#!/bin/sh

# The builtin grub.cfg generator. This script is called by
# ostree/src/libostree/ostree-bootloader-grub2.c whenever boot loader
# configuration file needs to be updated on systems which do not use
# grub2-mkconfig (and thus, the `ostree admin instutil grub2-generate` path).
#
# It can be used as a template for a custom grub.cfg generator. What to consider
# when writing a custom grub.cfg generator:
#
#   - The populate_menu() function converts boot loader entries as defined by
#   https://www.freedesktop.org/wiki/Specifications/BootLoaderSpec/ into GRUB2
#   menuentry sections. This is the core logic that is required by OSTree
#   based system.
#
#   - Embedded systems: Be aware that this script is executed not only on a host machine by OS
#   installer, but also on a target device, thus think about shell portability. A target device
#   for example might be using busybox with a limited shell.
#
# Feel free to edit this script to fit your requirements.

set -e

script=$(basename ${0})
# Atomically safe location where to generete grub.cfg when executing system upgrade.
new_grub2_cfg=${2}
entries_path=$(dirname $new_grub2_cfg)/entries
custom_scripts="/etc/ostree.d"

read_config()
{
    config_file=${1}
    title=""
    initrd=""
    options=""
    linux=""
    devicetree=""

    while read -r line
    do
        record=$(echo ${line} | cut -f 1 -d ' ')
        value=$(echo ${line} | cut -s -f2- -d ' ')
        case "${record}" in
            "title")
                title=${value}
                ;;
            "initrd")
                initrd=${value}
                ;;
            "linux")
                linux=${value}
                ;;
            "devicetree")
                devicetree=${value}
                ;;
            "options")
                options=${value}
                ;;
        esac
    done < ${config_file}

    if [ -z "${title}" ]; then
        title="(Untitled)"
    fi
}

populate_menu()
{
    # Default to /boot if OSTREE_BOOT_PARTITION is not set and /boot is on the same device as /ostree/repo
    if [ -z ${OSTREE_BOOT_PARTITION+x} ] && [ -d /boot/ostree ] && [ -d /ostree/repo ] && [ $(stat -c '%d' /boot/ostree) -eq $(stat -c '%d' /ostree/repo) ]; then
        boot_prefix="/boot"
    else
        boot_prefix="${OSTREE_BOOT_PARTITION}"
    fi
    for config in $(ls -v -r $entries_path/*.conf); do
        read_config ${config}
        menu="${menu}menuentry '${title}' {\n"
        menu="${menu}\t linux ${boot_prefix}${linux} ${options}\n"
        if [ -n "${initrd}" ] ; then
            menu="${menu}\t initrd ${boot_prefix}${initrd}\n"
        fi
        if [ -n "${devicetree}" ] ; then
            menu="${menu}\t devicetree ${boot_prefix}${devicetree}\n"
        fi
        menu="${menu}}\n\n"
    done
    # The printf command seems to be more reliable across shells for special character (\n, \t) evaluation
    printf "$menu" >> ${new_grub2_cfg}
}

populate_warning()
{
cat >> ${new_grub2_cfg} <<EOF
# This file was generated by ${script}. Do not modify the generated file - all changes will
# be lost the next time file is regenerated. For more details refer to the ${script} script.
EOF
}

populate_header()
{
cat >> ${new_grub2_cfg} <<EOF
serial --unit=0 --speed=115200 --word=8 --parity=no --stop=1
default=boot
timeout=10

EOF
}

populate_custom_section()
{
if [ -d "$custom_scripts" ]; then
    for script in $(ls -v $custom_scripts/*); do
        echo -e "\n### BEGIN ${script} ###" >> ${new_grub2_cfg} 
        cat ${script} >> ${new_grub2_cfg}
        echo -e "\n### END ${script} ###\n" >> ${new_grub2_cfg}
    done
fi
}

generate_grub2_cfg()
{
    populate_warning
    populate_header
    populate_custom_section
    populate_menu
}

generate_grub2_cfg
