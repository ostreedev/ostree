<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository xmlns="http://www.gtk.org/introspection/core/1.0" xmlns:c="http://www.gtk.org/introspection/c/1.0" xmlns:glib="http://www.gtk.org/introspection/glib/1.0" version="1.2">
  <include name="GObject" version="2.0"/>
  <package name="gio-2.0"/>
  <package name="gio-unix-2.0"/>
  <c:include name="gio/gdesktopappinfo.h"/>
  <c:include name="gio/gfiledescriptorbased.h"/>
  <c:include name="gio/gio.h"/>
  <c:include name="gio/gunixconnection.h"/>
  <c:include name="gio/gunixcredentialsmessage.h"/>
  <c:include name="gio/gunixfdlist.h"/>
  <c:include name="gio/gunixfdmessage.h"/>
  <c:include name="gio/gunixinputstream.h"/>
  <c:include name="gio/gunixmounts.h"/>
  <c:include name="gio/gunixoutputstream.h"/>
  <c:include name="gio/gunixsocketaddress.h"/>
  <namespace name="Gio" version="2.0" shared-library="libgio-2.0.so.0" c:identifier-prefixes="G" c:symbol-prefixes="g">
    <interface name="Action" c:symbol-prefix="action" c:type="GAction" glib:type-name="GAction" glib:get-type="g_action_get_type" glib:type-struct="ActionInterface">
      <doc xml:space="preserve">#GAction represents a single named action.

The main interface to an action is that it can be activated with
g_action_activate().  This results in the 'activate' signal being
emitted.  An activation has a #GVariant parameter (which may be
%NULL).  The correct type for the parameter is determined by a static
parameter type (which is given at construction time).

An action may optionally have a state, in which case the state may be
set with g_action_change_state().  This call takes a #GVariant.  The
correct type for the state is determined by a static state type
(which is given at construction time).

The state may have a hint associated with it, specifying its valid
range.

#GAction is merely the interface to the concept of an action, as
described above.  Various implementations of actions exist, including
#GSimpleAction.

In all cases, the implementing class is responsible for storing the
name of the action, the parameter type, the enabled state, the
optional state type and the state and emitting the appropriate
signals when these change.  The implementor is responsible for filtering
calls to g_action_activate() and g_action_change_state() for type
safety and for the state being enabled.

Probably the only useful thing to do with a #GAction is to put it
inside of a #GSimpleActionGroup.</doc>
      <function name="name_is_valid" c:identifier="g_action_name_is_valid" version="2.38">
        <doc xml:space="preserve">Checks if @action_name is valid.

@action_name is valid if it consists only of alphanumeric characters,
plus '-' and '.'.  The empty string is not a valid action name.

It is an error to call this function with a non-utf8 @action_name.
@action_name must not be %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @action_name is valid</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">an potential action name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="parse_detailed_name" c:identifier="g_action_parse_detailed_name" version="2.38" throws="1">
        <doc xml:space="preserve">Parses a detailed action name into its separate name and target
components.

Detailed action names can have three formats.

The first format is used to represent an action name with no target
value and consists of just an action name containing no whitespace
nor the characters ':', '(' or ')'.  For example: "app.action".

The second format is used to represent an action with a target value
that is a non-empty string consisting only of alphanumerics, plus '-'
and '.'.  In that case, the action name and target value are
separated by a double colon ("::").  For example:
"app.action::target".

The third format is used to represent an action with any type of
target value, including strings.  The target value follows the action
name, surrounded in parens.  For example: "app.action(42)".  The
target value is parsed using g_variant_parse().  If a tuple-typed
value is desired, it must be specified in the same way, resulting in
two sets of parens, for example: "app.action((1,2,3))".  A string
target can be specified this way as well: "app.action('target')".
For strings, this third format must be used if * target value is
empty or contains characters other than alphanumerics, '-' and '.'.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if successful, else %FALSE with @error set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="detailed_name" transfer-ownership="none">
            <doc xml:space="preserve">a detailed action name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="action_name" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">the action name</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="target_value" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">the target value, or %NULL for no target</doc>
            <type name="GLib.Variant" c:type="GVariant**"/>
          </parameter>
        </parameters>
      </function>
      <function name="print_detailed_name" c:identifier="g_action_print_detailed_name" version="2.38">
        <doc xml:space="preserve">Formats a detailed action name from @action_name and @target_value.

It is an error to call this function with an invalid action name.

This function is the opposite of g_action_parse_detailed_name().
It will produce a string that can be parsed back to the @action_name
and @target_value by that function.

See that function for the types of strings that will be printed by
this function.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a detailed format string</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">a valid action name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="target_value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GVariant target value, or %NULL</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="activate" invoker="activate" version="2.28">
        <doc xml:space="preserve">Activates the action.

@parameter must be the correct type of parameter for the action (ie:
the parameter type given at construction time).  If the parameter
type was %NULL then @parameter must also be %NULL.

If the @parameter GVariant is floating, it is consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve">a #GAction</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
          <parameter name="parameter" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the parameter to the activation</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="change_state" invoker="change_state" version="2.30">
        <doc xml:space="preserve">Request for the state of @action to be changed to @value.

The action must be stateful and @value must be of the correct type.
See g_action_get_state_type().

This call merely requests a change.  The action may refuse to change
its state or may change its state to something other than @value.
See g_action_get_state_hint().

If the @value GVariant is floating, it is consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve">a #GAction</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the new state</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_enabled" invoker="get_enabled" version="2.28">
        <doc xml:space="preserve">Checks if @action is currently enabled.

An action must be enabled in order to be activated or in order to
have its state changed from outside callers.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the action is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve">a #GAction</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_name" invoker="get_name" version="2.28">
        <doc xml:space="preserve">Queries the name of @action.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of the action</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve">a #GAction</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_parameter_type" invoker="get_parameter_type" version="2.28">
        <doc xml:space="preserve">Queries the type of the parameter that must be given when activating
@action.

When activating the action using g_action_activate(), the #GVariant
given to that function must be of the type returned by this function.

In the case that this function returns %NULL, you must not give any
#GVariant, but %NULL instead.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the parameter type</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve">a #GAction</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_state" invoker="get_state" version="2.28">
        <doc xml:space="preserve">Queries the current state of @action.

If the action is not stateful then %NULL will be returned.  If the
action is stateful then the type of the return value is the type
given by g_action_get_state_type().

The return value (if non-%NULL) should be freed with
g_variant_unref() when it is no longer required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the current state of the action</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve">a #GAction</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_state_hint" invoker="get_state_hint" version="2.28">
        <doc xml:space="preserve">Requests a hint about the valid range of values for the state of
@action.

If %NULL is returned it either means that the action is not stateful
or that there is no hint about the valid range of values for the
state of the action.

If a #GVariant array is returned then each item in the array is a
possible value for the state.  If a #GVariant pair (ie: two-tuple) is
returned then the tuple specifies the inclusive lower and upper bound
of valid values for the state.

In any case, the information is merely a hint.  It may be possible to
have a state value outside of the hinted range and setting a value
within the range may fail.

The return value (if non-%NULL) should be freed with
g_variant_unref() when it is no longer required.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the state range hint</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve">a #GAction</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_state_type" invoker="get_state_type" version="2.28">
        <doc xml:space="preserve">Queries the type of the state of @action.

If the action is stateful (e.g. created with
g_simple_action_new_stateful()) then this function returns the
#GVariantType of the state.  This is the type of the initial value
given as the state. All calls to g_action_change_state() must give a
#GVariant of this type and g_action_get_state() will return a
#GVariant of the same type.

If the action is not stateful (e.g. created with g_simple_action_new())
then this function will return %NULL. In that case, g_action_get_state()
will return %NULL and you must not call g_action_change_state().</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the state type, if the action is stateful</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve">a #GAction</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="activate" c:identifier="g_action_activate" version="2.28">
        <doc xml:space="preserve">Activates the action.

@parameter must be the correct type of parameter for the action (ie:
the parameter type given at construction time).  If the parameter
type was %NULL then @parameter must also be %NULL.

If the @parameter GVariant is floating, it is consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve">a #GAction</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
          <parameter name="parameter" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the parameter to the activation</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="change_state" c:identifier="g_action_change_state" version="2.30">
        <doc xml:space="preserve">Request for the state of @action to be changed to @value.

The action must be stateful and @value must be of the correct type.
See g_action_get_state_type().

This call merely requests a change.  The action may refuse to change
its state or may change its state to something other than @value.
See g_action_get_state_hint().

If the @value GVariant is floating, it is consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve">a #GAction</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the new state</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_enabled" c:identifier="g_action_get_enabled" version="2.28">
        <doc xml:space="preserve">Checks if @action is currently enabled.

An action must be enabled in order to be activated or in order to
have its state changed from outside callers.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the action is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve">a #GAction</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="g_action_get_name" version="2.28">
        <doc xml:space="preserve">Queries the name of @action.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of the action</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve">a #GAction</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parameter_type" c:identifier="g_action_get_parameter_type" version="2.28">
        <doc xml:space="preserve">Queries the type of the parameter that must be given when activating
@action.

When activating the action using g_action_activate(), the #GVariant
given to that function must be of the type returned by this function.

In the case that this function returns %NULL, you must not give any
#GVariant, but %NULL instead.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the parameter type</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve">a #GAction</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_state" c:identifier="g_action_get_state" version="2.28">
        <doc xml:space="preserve">Queries the current state of @action.

If the action is not stateful then %NULL will be returned.  If the
action is stateful then the type of the return value is the type
given by g_action_get_state_type().

The return value (if non-%NULL) should be freed with
g_variant_unref() when it is no longer required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the current state of the action</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve">a #GAction</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_state_hint" c:identifier="g_action_get_state_hint" version="2.28">
        <doc xml:space="preserve">Requests a hint about the valid range of values for the state of
@action.

If %NULL is returned it either means that the action is not stateful
or that there is no hint about the valid range of values for the
state of the action.

If a #GVariant array is returned then each item in the array is a
possible value for the state.  If a #GVariant pair (ie: two-tuple) is
returned then the tuple specifies the inclusive lower and upper bound
of valid values for the state.

In any case, the information is merely a hint.  It may be possible to
have a state value outside of the hinted range and setting a value
within the range may fail.

The return value (if non-%NULL) should be freed with
g_variant_unref() when it is no longer required.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the state range hint</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve">a #GAction</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_state_type" c:identifier="g_action_get_state_type" version="2.28">
        <doc xml:space="preserve">Queries the type of the state of @action.

If the action is stateful (e.g. created with
g_simple_action_new_stateful()) then this function returns the
#GVariantType of the state.  This is the type of the initial value
given as the state. All calls to g_action_change_state() must give a
#GVariant of this type and g_action_get_state() will return a
#GVariant of the same type.

If the action is not stateful (e.g. created with g_simple_action_new())
then this function will return %NULL. In that case, g_action_get_state()
will return %NULL and you must not call g_action_change_state().</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the state type, if the action is stateful</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve">a #GAction</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="enabled" version="2.28" transfer-ownership="none">
        <doc xml:space="preserve">If @action is currently enabled.

If the action is disabled then calls to g_action_activate() and
g_action_change_state() have no effect.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="name" version="2.28" transfer-ownership="none">
        <doc xml:space="preserve">The name of the action.  This is mostly meaningful for identifying
the action once it has been added to a #GActionGroup. It is immutable.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="parameter-type" version="2.28" transfer-ownership="none">
        <doc xml:space="preserve">The type of the parameter that must be given when activating the
action. This is immutable, and may be %NULL if no parameter is needed when
activating the action.</doc>
        <type name="GLib.VariantType"/>
      </property>
      <property name="state" version="2.28" transfer-ownership="none">
        <doc xml:space="preserve">The state of the action, or %NULL if the action is stateless.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="state-type" version="2.28" transfer-ownership="none">
        <doc xml:space="preserve">The #GVariantType of the state that the action has, or %NULL if the
action is stateless. This is immutable.</doc>
        <type name="GLib.VariantType"/>
      </property>
    </interface>
    <record name="ActionEntry" c:type="GActionEntry">
      <doc xml:space="preserve">This struct defines a single action.  It is for use with
g_action_map_add_action_entries().

The order of the items in the structure are intended to reflect
frequency of use.  It is permissible to use an incomplete initialiser
in order to leave some of the later values as %NULL.  All values
after @name are optional.  Additional optional fields may be added in
the future.

See g_action_map_add_action_entries() for an example.</doc>
      <field name="name" writable="1">
        <doc xml:space="preserve">the name of the action</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="activate">
        <callback name="activate">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <type name="SimpleAction" c:type="GSimpleAction*"/>
            </parameter>
            <parameter name="parameter" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="parameter_type" writable="1">
        <doc xml:space="preserve">the type of the parameter that must be passed to the
                 activate function for this action, given as a single
                 GVariant type string (or %NULL for no parameter)</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="state" writable="1">
        <doc xml:space="preserve">the initial state for this action, given in
        [GVariant text format][gvariant-text].  The state is parsed
        with no extra type information, so type tags must be added to
        the string if they are necessary.  Stateless actions should
        give %NULL here.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="change_state">
        <callback name="change_state">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <type name="SimpleAction" c:type="GSimpleAction*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gsize" fixed-size="3">
          <type name="gsize" c:type="gsize"/>
        </array>
      </field>
    </record>
    <interface name="ActionGroup" c:symbol-prefix="action_group" c:type="GActionGroup" glib:type-name="GActionGroup" glib:get-type="g_action_group_get_type" glib:type-struct="ActionGroupInterface">
      <doc xml:space="preserve">#GActionGroup represents a group of actions. Actions can be used to
expose functionality in a structured way, either from one part of a
program to another, or to the outside world. Action groups are often
used together with a #GMenuModel that provides additional
representation data for displaying the actions to the user, e.g. in
a menu.

The main way to interact with the actions in a GActionGroup is to
activate them with g_action_group_activate_action(). Activating an
action may require a #GVariant parameter. The required type of the
parameter can be inquired with g_action_group_get_action_parameter_type().
Actions may be disabled, see g_action_group_get_action_enabled().
Activating a disabled action has no effect.

Actions may optionally have a state in the form of a #GVariant. The
current state of an action can be inquired with
g_action_group_get_action_state(). Activating a stateful action may
change its state, but it is also possible to set the state by calling
g_action_group_change_action_state().

As typical example, consider a text editing application which has an
option to change the current font to 'bold'. A good way to represent
this would be a stateful action, with a boolean state. Activating the
action would toggle the state.

Each action in the group has a unique name (which is a string).  All
method calls, except g_action_group_list_actions() take the name of
an action as an argument.

The #GActionGroup API is meant to be the 'public' API to the action
group.  The calls here are exactly the interaction that 'external
forces' (eg: UI, incoming D-Bus messages, etc.) are supposed to have
with actions.  'Internal' APIs (ie: ones meant only to be accessed by
the action group implementation) are found on subclasses.  This is
why you will find - for example - g_action_group_get_action_enabled()
but not an equivalent set() call.

Signals are emitted on the action group in response to state changes
on individual actions.

Implementations of #GActionGroup should provide implementations for
the virtual functions g_action_group_list_actions() and
g_action_group_query_action().  The other virtual functions should
not be implemented - their "wrappers" are actually implemented with
calls to g_action_group_query_action().</doc>
      <virtual-method name="action_added" invoker="action_added" version="2.28">
        <doc xml:space="preserve">Emits the #GActionGroup::action-added signal on @action_group.

This function should only be called by #GActionGroup implementations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="action_enabled_changed" invoker="action_enabled_changed" version="2.28">
        <doc xml:space="preserve">Emits the #GActionGroup::action-enabled-changed signal on @action_group.

This function should only be called by #GActionGroup implementations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">whether or not the action is now enabled</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="action_removed" invoker="action_removed" version="2.28">
        <doc xml:space="preserve">Emits the #GActionGroup::action-removed signal on @action_group.

This function should only be called by #GActionGroup implementations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="action_state_changed" invoker="action_state_changed" version="2.28">
        <doc xml:space="preserve">Emits the #GActionGroup::action-state-changed signal on @action_group.

This function should only be called by #GActionGroup implementations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve">the new state of the named action</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="activate_action" invoker="activate_action" version="2.28">
        <doc xml:space="preserve">Activate the named action within @action_group.

If the action is expecting a parameter, then the correct type of
parameter must be given as @parameter.  If the action is expecting no
parameters then @parameter must be %NULL.  See
g_action_group_get_action_parameter_type().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action to activate</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="parameter" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">parameters to the activation</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="change_action_state" invoker="change_action_state" version="2.28">
        <doc xml:space="preserve">Request for the state of the named action within @action_group to be
changed to @value.

The action must be stateful and @value must be of the correct type.
See g_action_group_get_action_state_type().

This call merely requests a change.  The action may refuse to change
its state or may change its state to something other than @value.
See g_action_group_get_action_state_hint().

If the @value GVariant is floating, it is consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action to request the change on</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the new state</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_action_enabled" invoker="get_action_enabled" version="2.28">
        <doc xml:space="preserve">Checks if the named action within @action_group is currently enabled.

An action must be enabled in order to be activated or in order to
have its state changed from outside callers.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether or not the action is currently enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_action_parameter_type" invoker="get_action_parameter_type" version="2.28">
        <doc xml:space="preserve">Queries the type of the parameter that must be given when activating
the named action within @action_group.

When activating the action using g_action_group_activate_action(),
the #GVariant given to that function must be of the type returned
by this function.

In the case that this function returns %NULL, you must not give any
#GVariant, but %NULL instead.

The parameter type of a particular action will never change but it is
possible for an action to be removed and for a new action to be added
with the same name but a different parameter type.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the parameter type</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_action_state" invoker="get_action_state" version="2.28">
        <doc xml:space="preserve">Queries the current state of the named action within @action_group.

If the action is not stateful then %NULL will be returned.  If the
action is stateful then the type of the return value is the type
given by g_action_group_get_action_state_type().

The return value (if non-%NULL) should be freed with
g_variant_unref() when it is no longer required.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the current state of the action</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_action_state_hint" invoker="get_action_state_hint" version="2.28">
        <doc xml:space="preserve">Requests a hint about the valid range of values for the state of the
named action within @action_group.

If %NULL is returned it either means that the action is not stateful
or that there is no hint about the valid range of values for the
state of the action.

If a #GVariant array is returned then each item in the array is a
possible value for the state.  If a #GVariant pair (ie: two-tuple) is
returned then the tuple specifies the inclusive lower and upper bound
of valid values for the state.

In any case, the information is merely a hint.  It may be possible to
have a state value outside of the hinted range and setting a value
within the range may fail.

The return value (if non-%NULL) should be freed with
g_variant_unref() when it is no longer required.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the state range hint</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_action_state_type" invoker="get_action_state_type" version="2.28">
        <doc xml:space="preserve">Queries the type of the state of the named action within
@action_group.

If the action is stateful then this function returns the
#GVariantType of the state.  All calls to
g_action_group_change_action_state() must give a #GVariant of this
type and g_action_group_get_action_state() will return a #GVariant
of the same type.

If the action is not stateful then this function will return %NULL.
In that case, g_action_group_get_action_state() will return %NULL
and you must not call g_action_group_change_action_state().

The state type of a particular action will never change but it is
possible for an action to be removed and for a new action to be added
with the same name but a different state type.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the state type, if the action is stateful</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="has_action" invoker="has_action" version="2.28">
        <doc xml:space="preserve">Checks if the named action exists within @action_group.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the named action exists</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action to check for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="list_actions" invoker="list_actions" version="2.28">
        <doc xml:space="preserve">Lists the actions contained within @action_group.

The caller is responsible for freeing the list with g_strfreev() when
it is no longer required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a %NULL-terminated array of the names of the
actions in the group</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_action" invoker="query_action" version="2.32">
        <doc xml:space="preserve">Queries all aspects of the named action within an @action_group.

This function acquires the information available from
g_action_group_has_action(), g_action_group_get_action_enabled(),
g_action_group_get_action_parameter_type(),
g_action_group_get_action_state_type(),
g_action_group_get_action_state_hint() and
g_action_group_get_action_state() with a single function call.

This provides two main benefits.

The first is the improvement in efficiency that comes with not having
to perform repeated lookups of the action in order to discover
different things about it.  The second is that implementing
#GActionGroup can now be done by only overriding this one virtual
function.

The interface provides a default implementation of this function that
calls the individual functions, as required, to fetch the
information.  The interface also provides default implementations of
those functions that call this function.  All implementations,
therefore, must override either this function or all of the others.

If the action exists, %TRUE is returned and any of the requested
fields (as indicated by having a non-%NULL reference passed in) are
filled.  If the action doesn't exist, %FALSE is returned and the
fields may or may not have been modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the action exists, else %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="enabled" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">if the action is presently enabled</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="parameter_type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the parameter type, or %NULL if none needed</doc>
            <type name="GLib.VariantType" c:type="const GVariantType**"/>
          </parameter>
          <parameter name="state_type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the state type, or %NULL if stateless</doc>
            <type name="GLib.VariantType" c:type="const GVariantType**"/>
          </parameter>
          <parameter name="state_hint" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the state hint, or %NULL if none</doc>
            <type name="GLib.Variant" c:type="GVariant**"/>
          </parameter>
          <parameter name="state" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the current state, or %NULL if stateless</doc>
            <type name="GLib.Variant" c:type="GVariant**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="action_added" c:identifier="g_action_group_action_added" version="2.28">
        <doc xml:space="preserve">Emits the #GActionGroup::action-added signal on @action_group.

This function should only be called by #GActionGroup implementations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="action_enabled_changed" c:identifier="g_action_group_action_enabled_changed" version="2.28">
        <doc xml:space="preserve">Emits the #GActionGroup::action-enabled-changed signal on @action_group.

This function should only be called by #GActionGroup implementations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">whether or not the action is now enabled</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="action_removed" c:identifier="g_action_group_action_removed" version="2.28">
        <doc xml:space="preserve">Emits the #GActionGroup::action-removed signal on @action_group.

This function should only be called by #GActionGroup implementations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="action_state_changed" c:identifier="g_action_group_action_state_changed" version="2.28">
        <doc xml:space="preserve">Emits the #GActionGroup::action-state-changed signal on @action_group.

This function should only be called by #GActionGroup implementations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve">the new state of the named action</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="activate_action" c:identifier="g_action_group_activate_action" version="2.28">
        <doc xml:space="preserve">Activate the named action within @action_group.

If the action is expecting a parameter, then the correct type of
parameter must be given as @parameter.  If the action is expecting no
parameters then @parameter must be %NULL.  See
g_action_group_get_action_parameter_type().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action to activate</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="parameter" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">parameters to the activation</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="change_action_state" c:identifier="g_action_group_change_action_state" version="2.28">
        <doc xml:space="preserve">Request for the state of the named action within @action_group to be
changed to @value.

The action must be stateful and @value must be of the correct type.
See g_action_group_get_action_state_type().

This call merely requests a change.  The action may refuse to change
its state or may change its state to something other than @value.
See g_action_group_get_action_state_hint().

If the @value GVariant is floating, it is consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action to request the change on</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the new state</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_action_enabled" c:identifier="g_action_group_get_action_enabled" version="2.28">
        <doc xml:space="preserve">Checks if the named action within @action_group is currently enabled.

An action must be enabled in order to be activated or in order to
have its state changed from outside callers.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether or not the action is currently enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_action_parameter_type" c:identifier="g_action_group_get_action_parameter_type" version="2.28">
        <doc xml:space="preserve">Queries the type of the parameter that must be given when activating
the named action within @action_group.

When activating the action using g_action_group_activate_action(),
the #GVariant given to that function must be of the type returned
by this function.

In the case that this function returns %NULL, you must not give any
#GVariant, but %NULL instead.

The parameter type of a particular action will never change but it is
possible for an action to be removed and for a new action to be added
with the same name but a different parameter type.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the parameter type</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_action_state" c:identifier="g_action_group_get_action_state" version="2.28">
        <doc xml:space="preserve">Queries the current state of the named action within @action_group.

If the action is not stateful then %NULL will be returned.  If the
action is stateful then the type of the return value is the type
given by g_action_group_get_action_state_type().

The return value (if non-%NULL) should be freed with
g_variant_unref() when it is no longer required.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the current state of the action</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_action_state_hint" c:identifier="g_action_group_get_action_state_hint" version="2.28">
        <doc xml:space="preserve">Requests a hint about the valid range of values for the state of the
named action within @action_group.

If %NULL is returned it either means that the action is not stateful
or that there is no hint about the valid range of values for the
state of the action.

If a #GVariant array is returned then each item in the array is a
possible value for the state.  If a #GVariant pair (ie: two-tuple) is
returned then the tuple specifies the inclusive lower and upper bound
of valid values for the state.

In any case, the information is merely a hint.  It may be possible to
have a state value outside of the hinted range and setting a value
within the range may fail.

The return value (if non-%NULL) should be freed with
g_variant_unref() when it is no longer required.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the state range hint</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_action_state_type" c:identifier="g_action_group_get_action_state_type" version="2.28">
        <doc xml:space="preserve">Queries the type of the state of the named action within
@action_group.

If the action is stateful then this function returns the
#GVariantType of the state.  All calls to
g_action_group_change_action_state() must give a #GVariant of this
type and g_action_group_get_action_state() will return a #GVariant
of the same type.

If the action is not stateful then this function will return %NULL.
In that case, g_action_group_get_action_state() will return %NULL
and you must not call g_action_group_change_action_state().

The state type of a particular action will never change but it is
possible for an action to be removed and for a new action to be added
with the same name but a different state type.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the state type, if the action is stateful</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_action" c:identifier="g_action_group_has_action" version="2.28">
        <doc xml:space="preserve">Checks if the named action exists within @action_group.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the named action exists</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action to check for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_actions" c:identifier="g_action_group_list_actions" version="2.28">
        <doc xml:space="preserve">Lists the actions contained within @action_group.

The caller is responsible for freeing the list with g_strfreev() when
it is no longer required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a %NULL-terminated array of the names of the
actions in the group</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="query_action" c:identifier="g_action_group_query_action" version="2.32">
        <doc xml:space="preserve">Queries all aspects of the named action within an @action_group.

This function acquires the information available from
g_action_group_has_action(), g_action_group_get_action_enabled(),
g_action_group_get_action_parameter_type(),
g_action_group_get_action_state_type(),
g_action_group_get_action_state_hint() and
g_action_group_get_action_state() with a single function call.

This provides two main benefits.

The first is the improvement in efficiency that comes with not having
to perform repeated lookups of the action in order to discover
different things about it.  The second is that implementing
#GActionGroup can now be done by only overriding this one virtual
function.

The interface provides a default implementation of this function that
calls the individual functions, as required, to fetch the
information.  The interface also provides default implementations of
those functions that call this function.  All implementations,
therefore, must override either this function or all of the others.

If the action exists, %TRUE is returned and any of the requested
fields (as indicated by having a non-%NULL reference passed in) are
filled.  If the action doesn't exist, %FALSE is returned and the
fields may or may not have been modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the action exists, else %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="enabled" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">if the action is presently enabled</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="parameter_type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the parameter type, or %NULL if none needed</doc>
            <type name="GLib.VariantType" c:type="const GVariantType**"/>
          </parameter>
          <parameter name="state_type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the state type, or %NULL if stateless</doc>
            <type name="GLib.VariantType" c:type="const GVariantType**"/>
          </parameter>
          <parameter name="state_hint" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the state hint, or %NULL if none</doc>
            <type name="GLib.Variant" c:type="GVariant**"/>
          </parameter>
          <parameter name="state" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the current state, or %NULL if stateless</doc>
            <type name="GLib.Variant" c:type="GVariant**"/>
          </parameter>
        </parameters>
      </method>
      <glib:signal name="action-added" when="last" detailed="1" version="2.28">
        <doc xml:space="preserve">Signals that a new action was just added to the group.
This signal is emitted after the action has been added
and is now visible.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action in @action_group</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="action-enabled-changed" when="last" detailed="1" version="2.28">
        <doc xml:space="preserve">Signals that the enabled status of the named action has changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action in @action_group</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">whether the action is enabled or not</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="action-removed" when="last" detailed="1" version="2.28">
        <doc xml:space="preserve">Signals that an action is just about to be removed from the group.
This signal is emitted before the action is removed, so the action
is still visible and can be queried from the signal handler.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action in @action_group</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="action-state-changed" when="last" detailed="1" version="2.28">
        <doc xml:space="preserve">Signals that the state of the named action has changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action in @action_group</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the new value of the state</doc>
            <type name="GLib.Variant"/>
          </parameter>
        </parameters>
      </glib:signal>
    </interface>
    <record name="ActionGroupInterface" c:type="GActionGroupInterface" glib:is-gtype-struct-for="ActionGroup" version="2.28">
      <doc xml:space="preserve">The virtual function table for #GActionGroup.</doc>
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="has_action">
        <callback name="has_action">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">whether the named action exists</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve">the name of the action to check for</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="list_actions">
        <callback name="list_actions">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a %NULL-terminated array of the names of the
actions in the group</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_action_enabled">
        <callback name="get_action_enabled">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">whether or not the action is currently enabled</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve">the name of the action to query</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_action_parameter_type">
        <callback name="get_action_parameter_type">
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve">the parameter type</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve">the name of the action to query</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_action_state_type">
        <callback name="get_action_state_type">
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve">the state type, if the action is stateful</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve">the name of the action to query</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_action_state_hint">
        <callback name="get_action_state_hint">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">the state range hint</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve">the name of the action to query</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_action_state">
        <callback name="get_action_state">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">the current state of the action</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve">the name of the action to query</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="change_action_state">
        <callback name="change_action_state">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve">the name of the action to request the change on</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <doc xml:space="preserve">the new state</doc>
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="activate_action">
        <callback name="activate_action">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve">the name of the action to activate</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="parameter" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">parameters to the activation</doc>
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="action_added">
        <callback name="action_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve">the name of an action in the group</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="action_removed">
        <callback name="action_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve">the name of an action in the group</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="action_enabled_changed">
        <callback name="action_enabled_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve">the name of an action in the group</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="enabled" transfer-ownership="none">
              <doc xml:space="preserve">whether or not the action is now enabled</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="action_state_changed">
        <callback name="action_state_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve">the name of an action in the group</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="state" transfer-ownership="none">
              <doc xml:space="preserve">the new state of the named action</doc>
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_action">
        <callback name="query_action">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the action exists, else %FALSE</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve">the name of an action in the group</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="enabled" direction="out" caller-allocates="0" transfer-ownership="full">
              <doc xml:space="preserve">if the action is presently enabled</doc>
              <type name="gboolean" c:type="gboolean*"/>
            </parameter>
            <parameter name="parameter_type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
              <doc xml:space="preserve">the parameter type, or %NULL if none needed</doc>
              <type name="GLib.VariantType" c:type="const GVariantType**"/>
            </parameter>
            <parameter name="state_type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
              <doc xml:space="preserve">the state type, or %NULL if stateless</doc>
              <type name="GLib.VariantType" c:type="const GVariantType**"/>
            </parameter>
            <parameter name="state_hint" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
              <doc xml:space="preserve">the state hint, or %NULL if none</doc>
              <type name="GLib.Variant" c:type="GVariant**"/>
            </parameter>
            <parameter name="state" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
              <doc xml:space="preserve">the current state, or %NULL if stateless</doc>
              <type name="GLib.Variant" c:type="GVariant**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="ActionInterface" c:type="GActionInterface" glib:is-gtype-struct-for="Action" version="2.28">
      <doc xml:space="preserve">The virtual function table for #GAction.</doc>
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_name">
        <callback name="get_name">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the name of the action</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <doc xml:space="preserve">a #GAction</doc>
              <type name="Action" c:type="GAction*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_parameter_type">
        <callback name="get_parameter_type">
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve">the parameter type</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <doc xml:space="preserve">a #GAction</doc>
              <type name="Action" c:type="GAction*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_state_type">
        <callback name="get_state_type">
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve">the state type, if the action is stateful</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <doc xml:space="preserve">a #GAction</doc>
              <type name="Action" c:type="GAction*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_state_hint">
        <callback name="get_state_hint">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">the state range hint</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <doc xml:space="preserve">a #GAction</doc>
              <type name="Action" c:type="GAction*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_enabled">
        <callback name="get_enabled">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">whether the action is enabled</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <doc xml:space="preserve">a #GAction</doc>
              <type name="Action" c:type="GAction*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_state">
        <callback name="get_state">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the current state of the action</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <doc xml:space="preserve">a #GAction</doc>
              <type name="Action" c:type="GAction*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="change_state">
        <callback name="change_state">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <doc xml:space="preserve">a #GAction</doc>
              <type name="Action" c:type="GAction*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <doc xml:space="preserve">the new state</doc>
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="activate">
        <callback name="activate">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <doc xml:space="preserve">a #GAction</doc>
              <type name="Action" c:type="GAction*"/>
            </parameter>
            <parameter name="parameter" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">the parameter to the activation</doc>
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <interface name="ActionMap" c:symbol-prefix="action_map" c:type="GActionMap" glib:type-name="GActionMap" glib:get-type="g_action_map_get_type" glib:type-struct="ActionMapInterface">
      <doc xml:space="preserve">The GActionMap interface is implemented by #GActionGroup
implementations that operate by containing a number of
named #GAction instances, such as #GSimpleActionGroup.

One useful application of this interface is to map the
names of actions from various action groups to unique,
prefixed names (e.g. by prepending "app." or "win.").
This is the motivation for the 'Map' part of the interface
name.</doc>
      <virtual-method name="add_action" invoker="add_action" version="2.32">
        <doc xml:space="preserve">Adds an action to the @action_map.

If the action map already contains an action with the same name
as @action then the old action is dropped from the action map.

The action map takes its own reference on @action.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_map" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionMap</doc>
            <type name="ActionMap" c:type="GActionMap*"/>
          </instance-parameter>
          <parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve">a #GAction</doc>
            <type name="Action" c:type="GAction*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_action" invoker="lookup_action" version="2.32">
        <doc xml:space="preserve">Looks up the action with the name @action_name in @action_map.

If no such action exists, returns %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GAction, or %NULL</doc>
          <type name="Action" c:type="GAction*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_map" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionMap</doc>
            <type name="ActionMap" c:type="GActionMap*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of an action</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_action" invoker="remove_action" version="2.32">
        <doc xml:space="preserve">Removes the named action from the action map.

If no action of this name is in the map then nothing happens.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_map" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionMap</doc>
            <type name="ActionMap" c:type="GActionMap*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_action" c:identifier="g_action_map_add_action" version="2.32">
        <doc xml:space="preserve">Adds an action to the @action_map.

If the action map already contains an action with the same name
as @action then the old action is dropped from the action map.

The action map takes its own reference on @action.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_map" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionMap</doc>
            <type name="ActionMap" c:type="GActionMap*"/>
          </instance-parameter>
          <parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve">a #GAction</doc>
            <type name="Action" c:type="GAction*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_action_entries" c:identifier="g_action_map_add_action_entries" version="2.32">
        <doc xml:space="preserve">A convenience function for creating multiple #GSimpleAction instances
and adding them to a #GActionMap.

Each action is constructed as per one #GActionEntry.

|[&lt;!-- language="C" --&gt;
static void
activate_quit (GSimpleAction *simple,
               GVariant      *parameter,
               gpointer       user_data)
{
  exit (0);
}

static void
activate_print_string (GSimpleAction *simple,
                       GVariant      *parameter,
                       gpointer       user_data)
{
  g_print ("%s\n", g_variant_get_string (parameter, NULL));
}

static GActionGroup *
create_action_group (void)
{
  const GActionEntry entries[] = {
    { "quit",         activate_quit              },
    { "print-string", activate_print_string, "s" }
  };
  GSimpleActionGroup *group;

  group = g_simple_action_group_new ();
  g_action_map_add_action_entries (G_ACTION_MAP (group), entries, G_N_ELEMENTS (entries), NULL);

  return G_ACTION_GROUP (group);
}
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_map" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionMap</doc>
            <type name="ActionMap" c:type="GActionMap*"/>
          </instance-parameter>
          <parameter name="entries" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to
          the first item in an array of #GActionEntry structs</doc>
            <array length="1" zero-terminated="0" c:type="const GActionEntry*">
              <type name="ActionEntry"/>
            </array>
          </parameter>
          <parameter name="n_entries" transfer-ownership="none">
            <doc xml:space="preserve">the length of @entries, or -1 if @entries is %NULL-terminated</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the user data for signal connections</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_action" c:identifier="g_action_map_lookup_action" version="2.32">
        <doc xml:space="preserve">Looks up the action with the name @action_name in @action_map.

If no such action exists, returns %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GAction, or %NULL</doc>
          <type name="Action" c:type="GAction*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_map" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionMap</doc>
            <type name="ActionMap" c:type="GActionMap*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of an action</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_action" c:identifier="g_action_map_remove_action" version="2.32">
        <doc xml:space="preserve">Removes the named action from the action map.

If no action of this name is in the map then nothing happens.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_map" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionMap</doc>
            <type name="ActionMap" c:type="GActionMap*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="ActionMapInterface" c:type="GActionMapInterface" glib:is-gtype-struct-for="ActionMap" version="2.32">
      <doc xml:space="preserve">The virtual function table for #GActionMap.</doc>
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="lookup_action">
        <callback name="lookup_action">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">a #GAction, or %NULL</doc>
            <type name="Action" c:type="GAction*"/>
          </return-value>
          <parameters>
            <parameter name="action_map" transfer-ownership="none">
              <doc xml:space="preserve">a #GActionMap</doc>
              <type name="ActionMap" c:type="GActionMap*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve">the name of an action</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_action">
        <callback name="add_action">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action_map" transfer-ownership="none">
              <doc xml:space="preserve">a #GActionMap</doc>
              <type name="ActionMap" c:type="GActionMap*"/>
            </parameter>
            <parameter name="action" transfer-ownership="none">
              <doc xml:space="preserve">a #GAction</doc>
              <type name="Action" c:type="GAction*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_action">
        <callback name="remove_action">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action_map" transfer-ownership="none">
              <doc xml:space="preserve">a #GActionMap</doc>
              <type name="ActionMap" c:type="GActionMap*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve">the name of the action</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <interface name="AppInfo" c:symbol-prefix="app_info" c:type="GAppInfo" glib:type-name="GAppInfo" glib:get-type="g_app_info_get_type" glib:type-struct="AppInfoIface">
      <doc xml:space="preserve">#GAppInfo and #GAppLaunchContext are used for describing and launching
applications installed on the system.

As of GLib 2.20, URIs will always be converted to POSIX paths
(using g_file_get_path()) when using g_app_info_launch() even if
the application requested an URI and not a POSIX path. For example
for an desktop-file based application with Exec key `totem
%U` and a single URI, `sftp://foo/file.avi`, then
`/home/user/.gvfs/sftp on foo/file.avi` will be passed. This will
only work if a set of suitable GIO extensions (such as gvfs 2.26
compiled with FUSE support), is available and operational; if this
is not the case, the URI will be passed unmodified to the application.
Some URIs, such as `mailto:`, of course cannot be mapped to a POSIX
path (in gvfs there's no FUSE mount for it); such URIs will be
passed unmodified to the application.

Specifically for gvfs 2.26 and later, the POSIX URI will be mapped
back to the GIO URI in the #GFile constructors (since gvfs
implements the #GVfs extension point). As such, if the application
needs to examine the URI, it needs to use g_file_get_uri() or
similar on #GFile. In other words, an application cannot assume
that the URI passed to e.g. g_file_new_for_commandline_arg() is
equal to the result of g_file_get_uri(). The following snippet
illustrates this:

|[
GFile *f;
char *uri;

file = g_file_new_for_commandline_arg (uri_from_commandline);

uri = g_file_get_uri (file);
strcmp (uri, uri_from_commandline) == 0;
g_free (uri);

if (g_file_has_uri_scheme (file, "cdda"))
  {
    // do something special with uri
  }
g_object_unref (file);
]|

This code will work when both `cdda://sr0/Track 1.wav` and
`/home/user/.gvfs/cdda on sr0/Track 1.wav` is passed to the
application. It should be noted that it's generally not safe
for applications to rely on the format of a particular URIs.
Different launcher applications (e.g. file managers) may have
different ideas of what a given URI means.</doc>
      <function name="create_from_commandline" c:identifier="g_app_info_create_from_commandline" throws="1">
        <doc xml:space="preserve">Creates a new #GAppInfo from the given information.

Note that for @commandline, the quoting rules of the Exec key of the
[freedesktop.org Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec)
are applied. For example, if the @commandline contains
percent-encoded URIs, the percent-character must be doubled in order to prevent it from
being swallowed by Exec key unquoting. See the specification for exact quoting rules.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">new #GAppInfo for given command.</doc>
          <type name="AppInfo" c:type="GAppInfo*"/>
        </return-value>
        <parameters>
          <parameter name="commandline" transfer-ownership="none">
            <doc xml:space="preserve">the commandline to use</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
          <parameter name="application_name" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the application name, or %NULL to use @commandline</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags that can specify details of the created #GAppInfo</doc>
            <type name="AppInfoCreateFlags" c:type="GAppInfoCreateFlags"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_all" c:identifier="g_app_info_get_all">
        <doc xml:space="preserve">Gets a list of all of the applications currently registered
on this system.

For desktop files, this includes applications that have
`NoDisplay=true` set or are excluded from display by means
of `OnlyShowIn` or `NotShowIn`. See g_app_info_should_show().
The returned list does not include applications which have
the `Hidden` key set.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #GList of references to #GAppInfos.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="AppInfo"/>
          </type>
        </return-value>
      </function>
      <function name="get_all_for_type" c:identifier="g_app_info_get_all_for_type">
        <doc xml:space="preserve">Gets a list of all #GAppInfos for a given content type,
including the recommended and fallback #GAppInfos. See
g_app_info_get_recommended_for_type() and
g_app_info_get_fallback_for_type().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GList of #GAppInfos
    for given @content_type or %NULL on error.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="AppInfo"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve">the content type to find a #GAppInfo for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_default_for_type" c:identifier="g_app_info_get_default_for_type">
        <doc xml:space="preserve">Gets the default #GAppInfo for a given content type.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GAppInfo for given @content_type or
    %NULL on error.</doc>
          <type name="AppInfo" c:type="GAppInfo*"/>
        </return-value>
        <parameters>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve">the content type to find a #GAppInfo for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="must_support_uris" transfer-ownership="none">
            <doc xml:space="preserve">if %TRUE, the #GAppInfo is expected to
    support URIs</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_default_for_uri_scheme" c:identifier="g_app_info_get_default_for_uri_scheme">
        <doc xml:space="preserve">Gets the default application for handling URIs with
the given URI scheme. A URI scheme is the initial part
of the URI, up to but not including the ':', e.g. "http",
"ftp" or "sip".</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GAppInfo for given @uri_scheme or %NULL on error.</doc>
          <type name="AppInfo" c:type="GAppInfo*"/>
        </return-value>
        <parameters>
          <parameter name="uri_scheme" transfer-ownership="none">
            <doc xml:space="preserve">a string containing a URI scheme.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_fallback_for_type" c:identifier="g_app_info_get_fallback_for_type" version="2.28">
        <doc xml:space="preserve">Gets a list of fallback #GAppInfos for a given content type, i.e.
those applications which claim to support the given content type
by MIME type subclassing and not directly.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GList of #GAppInfos
    for given @content_type or %NULL on error.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="AppInfo"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve">the content type to find a #GAppInfo for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_recommended_for_type" c:identifier="g_app_info_get_recommended_for_type" version="2.28">
        <doc xml:space="preserve">Gets a list of recommended #GAppInfos for a given content type, i.e.
those applications which claim to support the given content type exactly,
and not by MIME type subclassing.
Note that the first application of the list is the last used one, i.e.
the last one for which g_app_info_set_as_last_used_for_type() has been
called.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GList of #GAppInfos
    for given @content_type or %NULL on error.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="AppInfo"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve">the content type to find a #GAppInfo for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="launch_default_for_uri" c:identifier="g_app_info_launch_default_for_uri" throws="1">
        <doc xml:space="preserve">Utility function that launches the default application
registered to handle the specified uri. Synchronous I/O
is done on the uri to detect the type of the file if
required.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">the uri to show</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an optional #GAppLaunchContext</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </parameter>
        </parameters>
      </function>
      <function name="launch_default_for_uri_async" c:identifier="g_app_info_launch_default_for_uri_async" version="2.50">
        <doc xml:space="preserve">Async version of g_app_info_launch_default_for_uri().

This version is useful if you are interested in receiving
error information in the case where the application is
sandboxed and the portal may present an application chooser
dialog to the user.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">the uri to show</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an optional #GAppLaunchContext</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GASyncReadyCallback to call when the request is done</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="launch_default_for_uri_finish" c:identifier="g_app_info_launch_default_for_uri_finish" version="2.50" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous launch-default-for-uri operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the launch was successful, %FALSE if @error is set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </function>
      <function name="reset_type_associations" c:identifier="g_app_info_reset_type_associations" version="2.20">
        <doc xml:space="preserve">Removes all changes to the type associations done by
g_app_info_set_as_default_for_type(),
g_app_info_set_as_default_for_extension(),
g_app_info_add_supports_type() or
g_app_info_remove_supports_type().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve">a content type</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="add_supports_type" invoker="add_supports_type" throws="1">
        <doc xml:space="preserve">Adds a content type to the application information to indicate the
application is capable of opening files with the given content type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve">a string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="can_delete" invoker="can_delete" version="2.20">
        <doc xml:space="preserve">Obtains the information whether the #GAppInfo can be deleted.
See g_app_info_delete().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @appinfo can be deleted</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="can_remove_supports_type" invoker="can_remove_supports_type">
        <doc xml:space="preserve">Checks if a supported content type can be removed from an application.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if it is possible to remove supported
    content types from a given @appinfo, %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="do_delete" invoker="delete" version="2.20">
        <doc xml:space="preserve">Tries to delete a #GAppInfo.

On some platforms, there may be a difference between user-defined
#GAppInfos which can be deleted, and system-wide ones which cannot.
See g_app_info_can_delete().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @appinfo has been deleted</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dup" invoker="dup">
        <doc xml:space="preserve">Creates a duplicate of a #GAppInfo.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a duplicate of @appinfo.</doc>
          <type name="AppInfo" c:type="GAppInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="equal" invoker="equal">
        <doc xml:space="preserve">Checks if two #GAppInfos are equal.

Note that the check &lt;emphasis&gt;may not&lt;/emphasis&gt; compare each individual
field, and only does an identity check. In case detecting changes in the
contents is needed, program code must additionally compare relevant fields.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @appinfo1 is equal to @appinfo2. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo1" transfer-ownership="none">
            <doc xml:space="preserve">the first #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="appinfo2" transfer-ownership="none">
            <doc xml:space="preserve">the second #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_commandline">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_description" invoker="get_description">
        <doc xml:space="preserve">Gets a human-readable description of an installed application.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string containing a description of the
application @appinfo, or %NULL if none.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_display_name" invoker="get_display_name" version="2.24">
        <doc xml:space="preserve">Gets the display name of the application. The display name is often more
descriptive to the user than the name itself.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the display name of the application for @appinfo, or the name if
no display name is available.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_executable">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_icon" invoker="get_icon">
        <doc xml:space="preserve">Gets the icon for the application.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the default #GIcon for @appinfo or %NULL
if there is no default icon.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_id" invoker="get_id">
        <doc xml:space="preserve">Gets the ID of an application. An id is a string that
identifies the application. The exact format of the id is
platform dependent. For instance, on Unix this is the
desktop file id from the xdg menu specification.

Note that the returned ID may be %NULL, depending on how
the @appinfo has been constructed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string containing the application's ID.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_name" invoker="get_name">
        <doc xml:space="preserve">Gets the installed name of the application.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of the application for @appinfo.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_supported_types" invoker="get_supported_types" version="2.34">
        <doc xml:space="preserve">Retrieves the list of content types that @app_info claims to support.
If this information is not provided by the environment, this function
will return %NULL.
This function does not take in consideration associations added with
g_app_info_add_supports_type(), but only those exported directly by
the application.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">
   a list of content types.</doc>
          <array c:type="const char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo that can handle files</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="launch" invoker="launch" throws="1">
        <doc xml:space="preserve">Launches the application. Passes @files to the launched application
as arguments, using the optional @context to get information
about the details of the launcher (like what screen it is on).
On error, @error will be set accordingly.

To launch the application without arguments pass a %NULL @files list.

Note that even if the launch is successful the application launched
can fail to start if it runs into problems during startup. There is
no way to detect this.

Some URIs can be changed when passed through a GFile (for instance
unsupported URIs with strange formats like mailto:), so if you have
a textual URI you want to pass in as argument, consider using
g_app_info_launch_uris() instead.

The launched application inherits the environment of the launching
process, but it can be modified with g_app_launch_context_setenv()
and g_app_launch_context_unsetenv().

On UNIX, this function sets the `GIO_LAUNCHED_DESKTOP_FILE`
environment variable with the path of the launched desktop file and
`GIO_LAUNCHED_DESKTOP_FILE_PID` to the process id of the launched
process. This can be used to ignore `GIO_LAUNCHED_DESKTOP_FILE`,
should it be inherited by further processes. The `DISPLAY` and
`DESKTOP_STARTUP_ID` environment variables are also set, based
on information provided in @context.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on successful launch, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="files" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GList of #GFile objects</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="File"/>
            </type>
          </parameter>
          <parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GAppLaunchContext or %NULL</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="launch_uris" invoker="launch_uris" throws="1">
        <doc xml:space="preserve">Launches the application. This passes the @uris to the launched application
as arguments, using the optional @context to get information
about the details of the launcher (like what screen it is on).
On error, @error will be set accordingly.

To launch the application without arguments pass a %NULL @uris list.

Note that even if the launch is successful the application launched
can fail to start if it runs into problems during startup. There is
no way to detect this.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on successful launch, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="uris" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GList containing URIs to launch.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GAppLaunchContext or %NULL</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_supports_type" invoker="remove_supports_type" throws="1">
        <doc xml:space="preserve">Removes a supported type from an application, if possible.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve">a string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_as_default_for_extension" invoker="set_as_default_for_extension" throws="1">
        <doc xml:space="preserve">Sets the application as the default handler for the given file extension.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="extension" transfer-ownership="none">
            <doc xml:space="preserve">a string containing the file extension
    (without the dot).</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_as_default_for_type" invoker="set_as_default_for_type" throws="1">
        <doc xml:space="preserve">Sets the application as the default handler for a given type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve">the content type.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_as_last_used_for_type" invoker="set_as_last_used_for_type" throws="1">
        <doc xml:space="preserve">Sets the application as the last used application for a given type.
This will make the application appear as first in the list returned
by g_app_info_get_recommended_for_type(), regardless of the default
application for that content type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve">the content type.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="should_show" invoker="should_show">
        <doc xml:space="preserve">Checks if the application info should be shown in menus that
list available applications.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @appinfo should be shown, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="supports_files" invoker="supports_files">
        <doc xml:space="preserve">Checks if the application accepts files as arguments.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @appinfo supports files.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="supports_uris" invoker="supports_uris">
        <doc xml:space="preserve">Checks if the application supports reading files and directories from URIs.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @appinfo supports URIs.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="add_supports_type" c:identifier="g_app_info_add_supports_type" throws="1">
        <doc xml:space="preserve">Adds a content type to the application information to indicate the
application is capable of opening files with the given content type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve">a string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_delete" c:identifier="g_app_info_can_delete" version="2.20">
        <doc xml:space="preserve">Obtains the information whether the #GAppInfo can be deleted.
See g_app_info_delete().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @appinfo can be deleted</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="can_remove_supports_type" c:identifier="g_app_info_can_remove_supports_type">
        <doc xml:space="preserve">Checks if a supported content type can be removed from an application.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if it is possible to remove supported
    content types from a given @appinfo, %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="delete" c:identifier="g_app_info_delete" version="2.20">
        <doc xml:space="preserve">Tries to delete a #GAppInfo.

On some platforms, there may be a difference between user-defined
#GAppInfos which can be deleted, and system-wide ones which cannot.
See g_app_info_can_delete().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @appinfo has been deleted</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="g_app_info_dup">
        <doc xml:space="preserve">Creates a duplicate of a #GAppInfo.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a duplicate of @appinfo.</doc>
          <type name="AppInfo" c:type="GAppInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="g_app_info_equal">
        <doc xml:space="preserve">Checks if two #GAppInfos are equal.

Note that the check &lt;emphasis&gt;may not&lt;/emphasis&gt; compare each individual
field, and only does an identity check. In case detecting changes in the
contents is needed, program code must additionally compare relevant fields.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @appinfo1 is equal to @appinfo2. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo1" transfer-ownership="none">
            <doc xml:space="preserve">the first #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="appinfo2" transfer-ownership="none">
            <doc xml:space="preserve">the second #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_commandline" c:identifier="g_app_info_get_commandline" version="2.20">
        <doc xml:space="preserve">Gets the commandline with which the application will be
started.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string containing the @appinfo's commandline,
    or %NULL if this information is not available</doc>
          <type name="filename" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_description" c:identifier="g_app_info_get_description">
        <doc xml:space="preserve">Gets a human-readable description of an installed application.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string containing a description of the
application @appinfo, or %NULL if none.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_display_name" c:identifier="g_app_info_get_display_name" version="2.24">
        <doc xml:space="preserve">Gets the display name of the application. The display name is often more
descriptive to the user than the name itself.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the display name of the application for @appinfo, or the name if
no display name is available.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_executable" c:identifier="g_app_info_get_executable">
        <doc xml:space="preserve">Gets the executable's name for the installed application.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string containing the @appinfo's application
binaries name</doc>
          <type name="filename" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_icon" c:identifier="g_app_info_get_icon">
        <doc xml:space="preserve">Gets the icon for the application.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the default #GIcon for @appinfo or %NULL
if there is no default icon.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_id" c:identifier="g_app_info_get_id">
        <doc xml:space="preserve">Gets the ID of an application. An id is a string that
identifies the application. The exact format of the id is
platform dependent. For instance, on Unix this is the
desktop file id from the xdg menu specification.

Note that the returned ID may be %NULL, depending on how
the @appinfo has been constructed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string containing the application's ID.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="g_app_info_get_name">
        <doc xml:space="preserve">Gets the installed name of the application.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of the application for @appinfo.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_supported_types" c:identifier="g_app_info_get_supported_types" version="2.34">
        <doc xml:space="preserve">Retrieves the list of content types that @app_info claims to support.
If this information is not provided by the environment, this function
will return %NULL.
This function does not take in consideration associations added with
g_app_info_add_supports_type(), but only those exported directly by
the application.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">
   a list of content types.</doc>
          <array c:type="const char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo that can handle files</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="launch" c:identifier="g_app_info_launch" throws="1">
        <doc xml:space="preserve">Launches the application. Passes @files to the launched application
as arguments, using the optional @context to get information
about the details of the launcher (like what screen it is on).
On error, @error will be set accordingly.

To launch the application without arguments pass a %NULL @files list.

Note that even if the launch is successful the application launched
can fail to start if it runs into problems during startup. There is
no way to detect this.

Some URIs can be changed when passed through a GFile (for instance
unsupported URIs with strange formats like mailto:), so if you have
a textual URI you want to pass in as argument, consider using
g_app_info_launch_uris() instead.

The launched application inherits the environment of the launching
process, but it can be modified with g_app_launch_context_setenv()
and g_app_launch_context_unsetenv().

On UNIX, this function sets the `GIO_LAUNCHED_DESKTOP_FILE`
environment variable with the path of the launched desktop file and
`GIO_LAUNCHED_DESKTOP_FILE_PID` to the process id of the launched
process. This can be used to ignore `GIO_LAUNCHED_DESKTOP_FILE`,
should it be inherited by further processes. The `DISPLAY` and
`DESKTOP_STARTUP_ID` environment variables are also set, based
on information provided in @context.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on successful launch, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="files" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GList of #GFile objects</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="File"/>
            </type>
          </parameter>
          <parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GAppLaunchContext or %NULL</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </parameter>
        </parameters>
      </method>
      <method name="launch_uris" c:identifier="g_app_info_launch_uris" throws="1">
        <doc xml:space="preserve">Launches the application. This passes the @uris to the launched application
as arguments, using the optional @context to get information
about the details of the launcher (like what screen it is on).
On error, @error will be set accordingly.

To launch the application without arguments pass a %NULL @uris list.

Note that even if the launch is successful the application launched
can fail to start if it runs into problems during startup. There is
no way to detect this.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on successful launch, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="uris" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GList containing URIs to launch.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GAppLaunchContext or %NULL</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_supports_type" c:identifier="g_app_info_remove_supports_type" throws="1">
        <doc xml:space="preserve">Removes a supported type from an application, if possible.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve">a string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_as_default_for_extension" c:identifier="g_app_info_set_as_default_for_extension" throws="1">
        <doc xml:space="preserve">Sets the application as the default handler for the given file extension.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="extension" transfer-ownership="none">
            <doc xml:space="preserve">a string containing the file extension
    (without the dot).</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_as_default_for_type" c:identifier="g_app_info_set_as_default_for_type" throws="1">
        <doc xml:space="preserve">Sets the application as the default handler for a given type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve">the content type.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_as_last_used_for_type" c:identifier="g_app_info_set_as_last_used_for_type" throws="1">
        <doc xml:space="preserve">Sets the application as the last used application for a given type.
This will make the application appear as first in the list returned
by g_app_info_get_recommended_for_type(), regardless of the default
application for that content type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve">the content type.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="should_show" c:identifier="g_app_info_should_show">
        <doc xml:space="preserve">Checks if the application info should be shown in menus that
list available applications.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @appinfo should be shown, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="supports_files" c:identifier="g_app_info_supports_files">
        <doc xml:space="preserve">Checks if the application accepts files as arguments.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @appinfo supports files.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="supports_uris" c:identifier="g_app_info_supports_uris">
        <doc xml:space="preserve">Checks if the application supports reading files and directories from URIs.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @appinfo supports URIs.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </interface>
    <bitfield name="AppInfoCreateFlags" glib:type-name="GAppInfoCreateFlags" glib:get-type="g_app_info_create_flags_get_type" c:type="GAppInfoCreateFlags">
      <doc xml:space="preserve">Flags used when creating a #GAppInfo.</doc>
      <member name="none" value="0" c:identifier="G_APP_INFO_CREATE_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags.</doc>
      </member>
      <member name="needs_terminal" value="1" c:identifier="G_APP_INFO_CREATE_NEEDS_TERMINAL" glib:nick="needs-terminal">
        <doc xml:space="preserve">Application opens in a terminal window.</doc>
      </member>
      <member name="supports_uris" value="2" c:identifier="G_APP_INFO_CREATE_SUPPORTS_URIS" glib:nick="supports-uris">
        <doc xml:space="preserve">Application supports URI arguments.</doc>
      </member>
      <member name="supports_startup_notification" value="4" c:identifier="G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION" glib:nick="supports-startup-notification">
        <doc xml:space="preserve">Application supports startup notification. Since 2.26</doc>
      </member>
    </bitfield>
    <record name="AppInfoIface" c:type="GAppInfoIface" glib:is-gtype-struct-for="AppInfo">
      <doc xml:space="preserve">Application Information interface, for operating system portability.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="dup">
        <callback name="dup">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a duplicate of @appinfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve">a #GAppInfo.</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="equal">
        <callback name="equal">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @appinfo1 is equal to @appinfo2. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo1" transfer-ownership="none">
              <doc xml:space="preserve">the first #GAppInfo.</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="appinfo2" transfer-ownership="none">
              <doc xml:space="preserve">the second #GAppInfo.</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_id">
        <callback name="get_id">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">a string containing the application's ID.</doc>
            <type name="utf8" c:type="const char*"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve">a #GAppInfo.</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_name">
        <callback name="get_name">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the name of the application for @appinfo.</doc>
            <type name="utf8" c:type="const char*"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve">a #GAppInfo.</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_description">
        <callback name="get_description">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">a string containing a description of the
application @appinfo, or %NULL if none.</doc>
            <type name="utf8" c:type="const char*"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve">a #GAppInfo.</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_executable">
        <callback name="get_executable">
          <return-value transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_icon">
        <callback name="get_icon">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the default #GIcon for @appinfo or %NULL
if there is no default icon.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve">a #GAppInfo.</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="launch">
        <callback name="launch" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on successful launch, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve">a #GAppInfo</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="files" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GList of #GFile objects</doc>
              <type name="GLib.List" c:type="GList*">
                <type name="File"/>
              </type>
            </parameter>
            <parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GAppLaunchContext or %NULL</doc>
              <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="supports_uris">
        <callback name="supports_uris">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the @appinfo supports URIs.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve">a #GAppInfo.</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="supports_files">
        <callback name="supports_files">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the @appinfo supports files.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve">a #GAppInfo.</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="launch_uris">
        <callback name="launch_uris" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on successful launch, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve">a #GAppInfo</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="uris" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GList containing URIs to launch.</doc>
              <type name="GLib.List" c:type="GList*">
                <type name="utf8"/>
              </type>
            </parameter>
            <parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GAppLaunchContext or %NULL</doc>
              <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="should_show">
        <callback name="should_show">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the @appinfo should be shown, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve">a #GAppInfo.</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_as_default_for_type">
        <callback name="set_as_default_for_type" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve">a #GAppInfo.</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="content_type" transfer-ownership="none">
              <doc xml:space="preserve">the content type.</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_as_default_for_extension">
        <callback name="set_as_default_for_extension" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve">a #GAppInfo.</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="extension" transfer-ownership="none">
              <doc xml:space="preserve">a string containing the file extension
    (without the dot).</doc>
              <type name="filename" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_supports_type">
        <callback name="add_supports_type" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve">a #GAppInfo.</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="content_type" transfer-ownership="none">
              <doc xml:space="preserve">a string.</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_remove_supports_type">
        <callback name="can_remove_supports_type">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if it is possible to remove supported
    content types from a given @appinfo, %FALSE if not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve">a #GAppInfo.</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_supports_type">
        <callback name="remove_supports_type" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve">a #GAppInfo.</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="content_type" transfer-ownership="none">
              <doc xml:space="preserve">a string.</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_delete">
        <callback name="can_delete">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @appinfo can be deleted</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve">a #GAppInfo</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="do_delete">
        <callback name="do_delete">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @appinfo has been deleted</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve">a #GAppInfo</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_commandline">
        <callback name="get_commandline">
          <return-value transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_display_name">
        <callback name="get_display_name">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the display name of the application for @appinfo, or the name if
no display name is available.</doc>
            <type name="utf8" c:type="const char*"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve">a #GAppInfo.</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_as_last_used_for_type">
        <callback name="set_as_last_used_for_type" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve">a #GAppInfo.</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="content_type" transfer-ownership="none">
              <doc xml:space="preserve">the content type.</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_supported_types">
        <callback name="get_supported_types">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">
   a list of content types.</doc>
            <array c:type="const char**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve">a #GAppInfo that can handle files</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="AppInfoMonitor" c:symbol-prefix="app_info_monitor" c:type="GAppInfoMonitor" version="2.40" parent="GObject.Object" glib:type-name="GAppInfoMonitor" glib:get-type="g_app_info_monitor_get_type">
      <doc xml:space="preserve">#GAppInfoMonitor is a very simple object used for monitoring the app
info database for changes (ie: newly installed or removed
applications).

Call g_app_info_monitor_get() to get a #GAppInfoMonitor and connect
to the "changed" signal.

In the usual case, applications should try to make note of the change
(doing things like invalidating caches) but not act on it.  In
particular, applications should avoid making calls to #GAppInfo APIs
in response to the change signal, deferring these until the time that
the data is actually required.  The exception to this case is when
application information is actually being displayed on the screen
(eg: during a search or when the list of all applications is shown).
The reason for this is that changes to the list of installed
applications often come in groups (like during system updates) and
rescanning the list on every change is pointless and expensive.</doc>
      <function name="get" c:identifier="g_app_info_monitor_get" version="2.40">
        <doc xml:space="preserve">Gets the #GAppInfoMonitor for the current thread-default main
context.

The #GAppInfoMonitor will emit a "changed" signal in the
thread-default main context whenever the list of installed
applications (as reported by g_app_info_get_all()) may have changed.

You must only call g_object_unref() on the return value from under
the same main context as you created it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a reference to a #GAppInfoMonitor</doc>
          <type name="AppInfoMonitor" c:type="GAppInfoMonitor*"/>
        </return-value>
      </function>
      <glib:signal name="changed" when="first">
        <doc xml:space="preserve">Signal emitted when the app info database for changes (ie: newly installed
or removed applications).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <class name="AppLaunchContext" c:symbol-prefix="app_launch_context" c:type="GAppLaunchContext" parent="GObject.Object" glib:type-name="GAppLaunchContext" glib:get-type="g_app_launch_context_get_type" glib:type-struct="AppLaunchContextClass">
      <doc xml:space="preserve">Integrating the launch with the launching application. This is used to
handle for instance startup notification and launching the new application
on the same screen as the launching window.</doc>
      <constructor name="new" c:identifier="g_app_launch_context_new">
        <doc xml:space="preserve">Creates a new application launch context. This is not normally used,
instead you instantiate a subclass of this, such as #GdkAppLaunchContext.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GAppLaunchContext.</doc>
          <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
        </return-value>
      </constructor>
      <virtual-method name="get_display" invoker="get_display">
        <doc xml:space="preserve">Gets the display string for the @context. This is used to ensure new
applications are started on the same display as the launching
application, by setting the `DISPLAY` environment variable.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a display string for the display.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppLaunchContext</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </parameter>
          <parameter name="files" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of #GFile objects</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="File"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_startup_notify_id" invoker="get_startup_notify_id">
        <doc xml:space="preserve">Initiates startup notification for the application and returns the
`DESKTOP_STARTUP_ID` for the launched operation, if supported.

Startup notification IDs are defined in the
[FreeDesktop.Org Startup Notifications standard](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt").</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a startup notification ID for the application, or %NULL if
    not supported.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppLaunchContext</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </parameter>
          <parameter name="files" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of of #GFile objects</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="File"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="launch_failed" invoker="launch_failed">
        <doc xml:space="preserve">Called when an application has failed to launch, so that it can cancel
the application startup notification started in g_app_launch_context_get_startup_notify_id().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppLaunchContext.</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </instance-parameter>
          <parameter name="startup_notify_id" transfer-ownership="none">
            <doc xml:space="preserve">the startup notification id that was returned by g_app_launch_context_get_startup_notify_id().</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="launched">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="AppInfo" c:type="GAppInfo*"/>
          </parameter>
          <parameter name="platform_data" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_display" c:identifier="g_app_launch_context_get_display">
        <doc xml:space="preserve">Gets the display string for the @context. This is used to ensure new
applications are started on the same display as the launching
application, by setting the `DISPLAY` environment variable.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a display string for the display.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppLaunchContext</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </parameter>
          <parameter name="files" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of #GFile objects</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="File"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_environment" c:identifier="g_app_launch_context_get_environment" version="2.32">
        <doc xml:space="preserve">Gets the complete environment variable list to be passed to
the child process when @context is used to launch an application.
This is a %NULL-terminated array of strings, where each string has
the form `KEY=VALUE`.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">
    the child's environment</doc>
          <array c:type="char**">
            <type name="filename"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppLaunchContext</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_startup_notify_id" c:identifier="g_app_launch_context_get_startup_notify_id">
        <doc xml:space="preserve">Initiates startup notification for the application and returns the
`DESKTOP_STARTUP_ID` for the launched operation, if supported.

Startup notification IDs are defined in the
[FreeDesktop.Org Startup Notifications standard](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt").</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a startup notification ID for the application, or %NULL if
    not supported.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppLaunchContext</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppInfo</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </parameter>
          <parameter name="files" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of of #GFile objects</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="File"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="launch_failed" c:identifier="g_app_launch_context_launch_failed">
        <doc xml:space="preserve">Called when an application has failed to launch, so that it can cancel
the application startup notification started in g_app_launch_context_get_startup_notify_id().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppLaunchContext.</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </instance-parameter>
          <parameter name="startup_notify_id" transfer-ownership="none">
            <doc xml:space="preserve">the startup notification id that was returned by g_app_launch_context_get_startup_notify_id().</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="setenv" c:identifier="g_app_launch_context_setenv" version="2.32">
        <doc xml:space="preserve">Arranges for @variable to be set to @value in the child's
environment when @context is used to launch an application.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppLaunchContext</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </instance-parameter>
          <parameter name="variable" transfer-ownership="none">
            <doc xml:space="preserve">the environment variable to set</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value for to set the variable to.</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unsetenv" c:identifier="g_app_launch_context_unsetenv" version="2.32">
        <doc xml:space="preserve">Arranges for @variable to be unset in the child's environment
when @context is used to launch an application.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GAppLaunchContext</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </instance-parameter>
          <parameter name="variable" transfer-ownership="none">
            <doc xml:space="preserve">the environment variable to remove</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AppLaunchContextPrivate" c:type="GAppLaunchContextPrivate*"/>
      </field>
      <glib:signal name="launch-failed" when="last" version="2.36">
        <doc xml:space="preserve">The ::launch-failed signal is emitted when a #GAppInfo launch
fails. The startup notification id is provided, so that the launcher
can cancel the startup notification.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="startup_notify_id" transfer-ownership="none">
            <doc xml:space="preserve">the startup notification id for the failed launch</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="launched" when="last" version="2.36">
        <doc xml:space="preserve">The ::launched signal is emitted when a #GAppInfo is successfully
launched. The @platform_data is an GVariant dictionary mapping
strings to variants (ie a{sv}), which contains additional,
platform-specific data about this launch. On UNIX, at least the
"pid" and "startup-notification-id" keys will be present.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">the #GAppInfo that was just launched</doc>
            <type name="AppInfo"/>
          </parameter>
          <parameter name="platform_data" transfer-ownership="none">
            <doc xml:space="preserve">additional platform-specific data for this launch</doc>
            <type name="GLib.Variant"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="AppLaunchContextClass" c:type="GAppLaunchContextClass" glib:is-gtype-struct-for="AppLaunchContext">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="get_display">
        <callback name="get_display">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a display string for the display.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <doc xml:space="preserve">a #GAppLaunchContext</doc>
              <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <doc xml:space="preserve">a #GAppInfo</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="files" transfer-ownership="none">
              <doc xml:space="preserve">a #GList of #GFile objects</doc>
              <type name="GLib.List" c:type="GList*">
                <type name="File"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_startup_notify_id">
        <callback name="get_startup_notify_id">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a startup notification ID for the application, or %NULL if
    not supported.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <doc xml:space="preserve">a #GAppLaunchContext</doc>
              <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <doc xml:space="preserve">a #GAppInfo</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="files" transfer-ownership="none">
              <doc xml:space="preserve">a #GList of of #GFile objects</doc>
              <type name="GLib.List" c:type="GList*">
                <type name="File"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="launch_failed">
        <callback name="launch_failed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <doc xml:space="preserve">a #GAppLaunchContext.</doc>
              <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
            </parameter>
            <parameter name="startup_notify_id" transfer-ownership="none">
              <doc xml:space="preserve">the startup notification id that was returned by g_app_launch_context_get_startup_notify_id().</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="launched">
        <callback name="launched">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="platform_data" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="AppLaunchContextPrivate" c:type="GAppLaunchContextPrivate" disguised="1">
    </record>
    <class name="Application" c:symbol-prefix="application" c:type="GApplication" version="2.28" parent="GObject.Object" glib:type-name="GApplication" glib:get-type="g_application_get_type" glib:type-struct="ApplicationClass">
      <doc xml:space="preserve">A #GApplication is the foundation of an application.  It wraps some
low-level platform-specific services and is intended to act as the
foundation for higher-level application classes such as
#GtkApplication or #MxApplication.  In general, you should not use
this class outside of a higher level framework.

GApplication provides convenient life cycle management by maintaining
a "use count" for the primary application instance. The use count can
be changed using g_application_hold() and g_application_release(). If
it drops to zero, the application exits. Higher-level classes such as
#GtkApplication employ the use count to ensure that the application
stays alive as long as it has any opened windows.

Another feature that GApplication (optionally) provides is process
uniqueness. Applications can make use of this functionality by
providing a unique application ID. If given, only one application
with this ID can be running at a time per session. The session
concept is platform-dependent, but corresponds roughly to a graphical
desktop login. When your application is launched again, its
arguments are passed through platform communication to the already
running program. The already running instance of the program is
called the "primary instance"; for non-unique applications this is
the always the current instance. On Linux, the D-Bus session bus
is used for communication.

The use of #GApplication differs from some other commonly-used
uniqueness libraries (such as libunique) in important ways. The
application is not expected to manually register itself and check
if it is the primary instance. Instead, the main() function of a
#GApplication should do very little more than instantiating the
application instance, possibly connecting signal handlers, then
calling g_application_run(). All checks for uniqueness are done
internally. If the application is the primary instance then the
startup signal is emitted and the mainloop runs. If the application
is not the primary instance then a signal is sent to the primary
instance and g_application_run() promptly returns. See the code
examples below.

If used, the expected form of an application identifier is the same as
that of of a
[D-Bus well-known bus name](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
Examples include: `com.example.MyApp`, `org.example.internal_apps.Calculator`,
`org._7_zip.Archiver`.
For details on valid application identifiers, see g_application_id_is_valid().

On Linux, the application identifier is claimed as a well-known bus name
on the user's session bus.  This means that the uniqueness of your
application is scoped to the current session.  It also means that your
application may provide additional services (through registration of other
object paths) at that bus name.  The registration of these object paths
should be done with the shared GDBus session bus.  Note that due to the
internal architecture of GDBus, method calls can be dispatched at any time
(even if a main loop is not running).  For this reason, you must ensure that
any object paths that you wish to register are registered before #GApplication
attempts to acquire the bus name of your application (which happens in
g_application_register()).  Unfortunately, this means that you cannot use
g_application_get_is_remote() to decide if you want to register object paths.

GApplication also implements the #GActionGroup and #GActionMap
interfaces and lets you easily export actions by adding them with
g_action_map_add_action(). When invoking an action by calling
g_action_group_activate_action() on the application, it is always
invoked in the primary instance. The actions are also exported on
the session bus, and GIO provides the #GDBusActionGroup wrapper to
conveniently access them remotely. GIO provides a #GDBusMenuModel wrapper
for remote access to exported #GMenuModels.

There is a number of different entry points into a GApplication:

- via 'Activate' (i.e. just starting the application)

- via 'Open' (i.e. opening some files)

- by handling a command-line

- via activating an action

The #GApplication::startup signal lets you handle the application
initialization for all of these in a single place.

Regardless of which of these entry points is used to start the
application, GApplication passes some "platform data from the
launching instance to the primary instance, in the form of a
#GVariant dictionary mapping strings to variants. To use platform
data, override the @before_emit or @after_emit virtual functions
in your #GApplication subclass. When dealing with
#GApplicationCommandLine objects, the platform data is
directly available via g_application_command_line_get_cwd(),
g_application_command_line_get_environ() and
g_application_command_line_get_platform_data().

As the name indicates, the platform data may vary depending on the
operating system, but it always includes the current directory (key
"cwd"), and optionally the environment (ie the set of environment
variables and their values) of the calling process (key "environ").
The environment is only added to the platform data if the
%G_APPLICATION_SEND_ENVIRONMENT flag is set. #GApplication subclasses
can add their own platform data by overriding the @add_platform_data
virtual function. For instance, #GtkApplication adds startup notification
data in this way.

To parse commandline arguments you may handle the
#GApplication::command-line signal or override the local_command_line()
vfunc, to parse them in either the primary instance or the local instance,
respectively.

For an example of opening files with a GApplication, see
[gapplication-example-open.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-open.c).

For an example of using actions with GApplication, see
[gapplication-example-actions.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-actions.c).

For an example of using extra D-Bus hooks with GApplication, see
[gapplication-example-dbushooks.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-dbushooks.c).</doc>
      <implements name="ActionGroup"/>
      <implements name="ActionMap"/>
      <constructor name="new" c:identifier="g_application_new">
        <doc xml:space="preserve">Creates a new #GApplication instance.

If non-%NULL, the application id must be valid.  See
g_application_id_is_valid().

If no application ID is given then some features of #GApplication
(most notably application uniqueness) will be disabled.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GApplication instance</doc>
          <type name="Application" c:type="GApplication*"/>
        </return-value>
        <parameters>
          <parameter name="application_id" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the application id</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">the application flags</doc>
            <type name="ApplicationFlags" c:type="GApplicationFlags"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_default" c:identifier="g_application_get_default" version="2.32">
        <doc xml:space="preserve">Returns the default #GApplication instance for this process.

Normally there is only one #GApplication per process and it becomes
the default when it is created.  You can exercise more control over
this by using g_application_set_default().

If there is no default application then %NULL is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the default application for this process, or %NULL</doc>
          <type name="Application" c:type="GApplication*"/>
        </return-value>
      </function>
      <function name="id_is_valid" c:identifier="g_application_id_is_valid">
        <doc xml:space="preserve">Checks if @application_id is a valid application identifier.

A valid ID is required for calls to g_application_new() and
g_application_set_application_id().

Application identifiers follow the same format as
[D-Bus well-known bus names](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
For convenience, the restrictions on application identifiers are
reproduced here:

- Application identifiers are composed of 1 or more elements separated by a
  period (`.`) character. All elements must contain at least one character.

- Each element must only contain the ASCII characters `[A-Z][a-z][0-9]_-`,
  with `-` discouraged in new application identifiers. Each element must not
  begin with a digit.

- Application identifiers must contain at least one `.` (period) character
  (and thus at least two elements).

- Application identifiers must not begin with a `.` (period) character.

- Application identifiers must not exceed 255 characters.

Note that the hyphen (`-`) character is allowed in application identifiers,
but is problematic or not allowed in various specifications and APIs that
refer to D-Bus, such as
[Flatpak application IDs](http://docs.flatpak.org/en/latest/introduction.html#identifiers),
the
[`DBusActivatable` interface in the Desktop Entry Specification](https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#dbus),
and the convention that an application's "main" interface and object path
resemble its application identifier and bus name. To avoid situations that
require special-case handling, it is recommended that new application
identifiers consistently replace hyphens with underscores.

Like D-Bus interface names, application identifiers should start with the
reversed DNS domain name of the author of the interface (in lower-case), and
it is conventional for the rest of the application identifier to consist of
words run together, with initial capital letters.

As with D-Bus interface names, if the author's DNS domain name contains
hyphen/minus characters they should be replaced by underscores, and if it
contains leading digits they should be escaped by prepending an underscore.
For example, if the owner of 7-zip.org used an application identifier for an
archiving application, it might be named `org._7_zip.Archiver`.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @application_id is valid</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="application_id" transfer-ownership="none">
            <doc xml:space="preserve">a potential application identifier</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="activate" invoker="activate" version="2.28">
        <doc xml:space="preserve">Activates the application.

In essence, this results in the #GApplication::activate signal being
emitted in the primary instance.

The application must be registered before calling this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="add_platform_data">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="builder" transfer-ownership="none">
            <type name="GLib.VariantBuilder" c:type="GVariantBuilder*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="after_emit">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="platform_data" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="before_emit">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="platform_data" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="command_line">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="command_line" transfer-ownership="none">
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dbus_register" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dbus_unregister">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="handle_local_options">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="options" transfer-ownership="none">
            <type name="GLib.VariantDict" c:type="GVariantDict*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="local_command_line">
        <doc xml:space="preserve">This virtual function is always invoked in the local instance. It
gets passed a pointer to a %NULL-terminated copy of @argv and is
expected to remove arguments that it handled (shifting up remaining
arguments).

The last argument to local_command_line() is a pointer to the @status
variable which can used to set the exit status that is returned from
g_application_run().

See g_application_run() for more details on #GApplication startup.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the commandline has been completely handled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="arguments" direction="inout" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">array of command line arguments</doc>
            <array c:type="gchar***">
              <type name="utf8" c:type="gchar**"/>
            </array>
          </parameter>
          <parameter name="exit_status" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">exit status to fill after processing the command line.</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="open" invoker="open" version="2.28">
        <doc xml:space="preserve">Opens the given files.

In essence, this results in the #GApplication::open signal being emitted
in the primary instance.

@n_files must be greater than zero.

@hint is simply passed through to the ::open signal.  It is
intended to be used by applications that have multiple modes for
opening files (eg: "view" vs "edit", etc).  Unless you have a need
for this functionality, you should use "".

The application must be registered before calling this function
and it must have the %G_APPLICATION_HANDLES_OPEN flag set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="files" transfer-ownership="none">
            <doc xml:space="preserve">an array of #GFiles to open</doc>
            <array length="1" zero-terminated="0" c:type="GFile**">
              <type name="File" c:type="GFile*"/>
            </array>
          </parameter>
          <parameter name="n_files" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @files array</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="hint" transfer-ownership="none">
            <doc xml:space="preserve">a hint (or ""), but never %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="quit_mainloop">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="run_mainloop">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="shutdown">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="startup">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="activate" c:identifier="g_application_activate" version="2.28">
        <doc xml:space="preserve">Activates the application.

In essence, this results in the #GApplication::activate signal being
emitted in the primary instance.

The application must be registered before calling this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="add_main_option" c:identifier="g_application_add_main_option" version="2.42">
        <doc xml:space="preserve">Add an option to be handled by @application.

Calling this function is the equivalent of calling
g_application_add_main_option_entries() with a single #GOptionEntry
that has its arg_data member set to %NULL.

The parsed arguments will be packed into a #GVariantDict which
is passed to #GApplication::handle-local-options. If
%G_APPLICATION_HANDLES_COMMAND_LINE is set, then it will also
be sent to the primary instance. See
g_application_add_main_option_entries() for more details.

See #GOptionEntry for more documentation of the arguments.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">the #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="long_name" transfer-ownership="none">
            <doc xml:space="preserve">the long name of an option used to specify it in a commandline</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="short_name" transfer-ownership="none">
            <doc xml:space="preserve">the short name of an option</doc>
            <type name="gchar" c:type="char"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags from #GOptionFlags</doc>
            <type name="GLib.OptionFlags" c:type="GOptionFlags"/>
          </parameter>
          <parameter name="arg" transfer-ownership="none">
            <doc xml:space="preserve">the type of the option, as a #GOptionArg</doc>
            <type name="GLib.OptionArg" c:type="GOptionArg"/>
          </parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:space="preserve">the description for the option in `--help` output</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="arg_description" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the placeholder to use for the extra argument
   parsed by the option in `--help` output</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_main_option_entries" c:identifier="g_application_add_main_option_entries" version="2.40">
        <doc xml:space="preserve">Adds main option entries to be handled by @application.

This function is comparable to g_option_context_add_main_entries().

After the commandline arguments are parsed, the
#GApplication::handle-local-options signal will be emitted.  At this
point, the application can inspect the values pointed to by @arg_data
in the given #GOptionEntrys.

Unlike #GOptionContext, #GApplication supports giving a %NULL
@arg_data for a non-callback #GOptionEntry.  This results in the
argument in question being packed into a #GVariantDict which is also
passed to #GApplication::handle-local-options, where it can be
inspected and modified.  If %G_APPLICATION_HANDLES_COMMAND_LINE is
set, then the resulting dictionary is sent to the primary instance,
where g_application_command_line_get_options_dict() will return it.
This "packing" is done according to the type of the argument --
booleans for normal flags, strings for strings, bytestrings for
filenames, etc.  The packing only occurs if the flag is given (ie: we
do not pack a "false" #GVariant in the case that a flag is missing).

In general, it is recommended that all commandline arguments are
parsed locally.  The options dictionary should then be used to
transmit the result of the parsing to the primary instance, where
g_variant_dict_lookup() can be used.  For local options, it is
possible to either use @arg_data in the usual way, or to consult (and
potentially remove) the option from the options dictionary.

This function is new in GLib 2.40.  Before then, the only real choice
was to send all of the commandline arguments (options and all) to the
primary instance for handling.  #GApplication ignored them completely
on the local side.  Calling this function "opts in" to the new
behaviour, and in particular, means that unrecognised options will be
treated as errors.  Unrecognised options have never been ignored when
%G_APPLICATION_HANDLES_COMMAND_LINE is unset.

If #GApplication::handle-local-options needs to see the list of
filenames, then the use of %G_OPTION_REMAINING is recommended.  If
@arg_data is %NULL then %G_OPTION_REMAINING can be used as a key into
the options dictionary.  If you do use %G_OPTION_REMAINING then you
need to handle these arguments for yourself because once they are
consumed, they will no longer be visible to the default handling
(which treats them as filenames to be opened).

It is important to use the proper GVariant format when retrieving
the options with g_variant_dict_lookup():
- for %G_OPTION_ARG_NONE, use b
- for %G_OPTION_ARG_STRING, use &amp;s
- for %G_OPTION_ARG_INT, use i
- for %G_OPTION_ARG_INT64, use x
- for %G_OPTION_ARG_DOUBLE, use d
- for %G_OPTION_ARG_FILENAME, use ^ay
- for %G_OPTION_ARG_STRING_ARRAY, use &amp;as
- for %G_OPTION_ARG_FILENAME_ARRAY, use ^aay</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="entries" transfer-ownership="none">
            <doc xml:space="preserve">a
          %NULL-terminated list of #GOptionEntrys</doc>
            <array c:type="const GOptionEntry*">
              <type name="GLib.OptionEntry"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="add_option_group" c:identifier="g_application_add_option_group" version="2.40">
        <doc xml:space="preserve">Adds a #GOptionGroup to the commandline handling of @application.

This function is comparable to g_option_context_add_group().

Unlike g_application_add_main_option_entries(), this function does
not deal with %NULL @arg_data and never transmits options to the
primary instance.

The reason for that is because, by the time the options arrive at the
primary instance, it is typically too late to do anything with them.
Taking the GTK option group as an example: GTK will already have been
initialised by the time the #GApplication::command-line handler runs.
In the case that this is not the first-running instance of the
application, the existing instance may already have been running for
a very long time.

This means that the options from #GOptionGroup are only really usable
in the case that the instance of the application being run is the
first instance.  Passing options like `--display=` or `--gdk-debug=`
on future runs will have no effect on the existing primary instance.

Calling this function will cause the options in the supplied option
group to be parsed, but it does not cause you to be "opted in" to the
new functionality whereby unrecognised options are rejected even if
%G_APPLICATION_HANDLES_COMMAND_LINE was given.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">the #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="full">
            <doc xml:space="preserve">a #GOptionGroup</doc>
            <type name="GLib.OptionGroup" c:type="GOptionGroup*"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind_busy_property" c:identifier="g_application_bind_busy_property" version="2.44">
        <doc xml:space="preserve">Marks @application as busy (see g_application_mark_busy()) while
@property on @object is %TRUE.

The binding holds a reference to @application while it is active, but
not to @object. Instead, the binding is destroyed when @object is
finalized.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
          <parameter name="property" transfer-ownership="none">
            <doc xml:space="preserve">the name of a boolean property of @object</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_application_id" c:identifier="g_application_get_application_id" version="2.28">
        <doc xml:space="preserve">Gets the unique identifier for @application.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the identifier for @application, owned by @application</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dbus_connection" c:identifier="g_application_get_dbus_connection" version="2.34">
        <doc xml:space="preserve">Gets the #GDBusConnection being used by the application, or %NULL.

If #GApplication is using its D-Bus backend then this function will
return the #GDBusConnection being used for uniqueness and
communication with the desktop environment and other instances of the
application.

If #GApplication is not using D-Bus then this function will return
%NULL.  This includes the situation where the D-Bus backend would
normally be in use but we were unable to connect to the bus.

This function must not be called before the application has been
registered.  See g_application_get_is_registered().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GDBusConnection, or %NULL</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dbus_object_path" c:identifier="g_application_get_dbus_object_path" version="2.34">
        <doc xml:space="preserve">Gets the D-Bus object path being used by the application, or %NULL.

If #GApplication is using its D-Bus backend then this function will
return the D-Bus object path that #GApplication is using.  If the
application is the primary instance then there is an object published
at this path.  If the application is not the primary instance then
the result of this function is undefined.

If #GApplication is not using D-Bus then this function will return
%NULL.  This includes the situation where the D-Bus backend would
normally be in use but we were unable to connect to the bus.

This function must not be called before the application has been
registered.  See g_application_get_is_registered().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the object path, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="g_application_get_flags" version="2.28">
        <doc xml:space="preserve">Gets the flags for @application.

See #GApplicationFlags.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the flags for @application</doc>
          <type name="ApplicationFlags" c:type="GApplicationFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_inactivity_timeout" c:identifier="g_application_get_inactivity_timeout" version="2.28">
        <doc xml:space="preserve">Gets the current inactivity timeout for the application.

This is the amount of time (in milliseconds) after the last call to
g_application_release() before the application stops running.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the timeout, in milliseconds</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_busy" c:identifier="g_application_get_is_busy" version="2.44">
        <doc xml:space="preserve">Gets the application's current busy state, as set through
g_application_mark_busy() or g_application_bind_busy_property().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @application is currenty marked as busy</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_registered" c:identifier="g_application_get_is_registered" version="2.28">
        <doc xml:space="preserve">Checks if @application is registered.

An application is registered if g_application_register() has been
successfully called.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @application is registered</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_remote" c:identifier="g_application_get_is_remote" version="2.28">
        <doc xml:space="preserve">Checks if @application is remote.

If @application is remote then it means that another instance of
application already exists (the 'primary' instance).  Calls to
perform actions on @application will result in the actions being
performed by the primary instance.

The value of this property cannot be accessed before
g_application_register() has been called.  See
g_application_get_is_registered().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @application is remote</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_resource_base_path" c:identifier="g_application_get_resource_base_path" version="2.42">
        <doc xml:space="preserve">Gets the resource base path of @application.

See g_application_set_resource_base_path() for more information.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the base resource path, if one is set</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="hold" c:identifier="g_application_hold">
        <doc xml:space="preserve">Increases the use count of @application.

Use this function to indicate that the application has a reason to
continue to run.  For example, g_application_hold() is called by GTK+
when a toplevel window is on the screen.

To cancel the hold, call g_application_release().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="mark_busy" c:identifier="g_application_mark_busy" version="2.38">
        <doc xml:space="preserve">Increases the busy count of @application.

Use this function to indicate that the application is busy, for instance
while a long running operation is pending.

The busy state will be exposed to other processes, so a session shell will
use that information to indicate the state to the user (e.g. with a
spinner).

To cancel the busy indication, use g_application_unmark_busy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="open" c:identifier="g_application_open" version="2.28">
        <doc xml:space="preserve">Opens the given files.

In essence, this results in the #GApplication::open signal being emitted
in the primary instance.

@n_files must be greater than zero.

@hint is simply passed through to the ::open signal.  It is
intended to be used by applications that have multiple modes for
opening files (eg: "view" vs "edit", etc).  Unless you have a need
for this functionality, you should use "".

The application must be registered before calling this function
and it must have the %G_APPLICATION_HANDLES_OPEN flag set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="files" transfer-ownership="none">
            <doc xml:space="preserve">an array of #GFiles to open</doc>
            <array length="1" zero-terminated="0" c:type="GFile**">
              <type name="File" c:type="GFile*"/>
            </array>
          </parameter>
          <parameter name="n_files" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @files array</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="hint" transfer-ownership="none">
            <doc xml:space="preserve">a hint (or ""), but never %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="quit" c:identifier="g_application_quit" version="2.32">
        <doc xml:space="preserve">Immediately quits the application.

Upon return to the mainloop, g_application_run() will return,
calling only the 'shutdown' function before doing so.

The hold count is ignored.
Take care if your code has called g_application_hold() on the application and
is therefore still expecting it to exist.
(Note that you may have called g_application_hold() indirectly, for example
through gtk_application_add_window().)

The result of calling g_application_run() again after it returns is
unspecified.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="register" c:identifier="g_application_register" version="2.28" throws="1">
        <doc xml:space="preserve">Attempts registration of the application.

This is the point at which the application discovers if it is the
primary instance or merely acting as a remote for an already-existing
primary instance.  This is implemented by attempting to acquire the
application identifier as a unique bus name on the session bus using
GDBus.

If there is no application ID or if %G_APPLICATION_NON_UNIQUE was
given, then this process will always become the primary instance.

Due to the internal architecture of GDBus, method calls can be
dispatched at any time (even if a main loop is not running).  For
this reason, you must ensure that any object paths that you wish to
register are registered before calling this function.

If the application has already been registered then %TRUE is
returned with no work performed.

The #GApplication::startup signal is emitted if registration succeeds
and @application is the primary instance (including the non-unique
case).

In the event of an error (such as @cancellable being cancelled, or a
failure to connect to the session bus), %FALSE is returned and @error
is set appropriately.

Note: the return value of this function is not an indicator that this
instance is or is not the primary instance of the application.  See
g_application_get_is_remote() for that.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if registration succeeded</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="release" c:identifier="g_application_release">
        <doc xml:space="preserve">Decrease the use count of @application.

When the use count reaches zero, the application will stop running.

Never call this function except to cancel the effect of a previous
call to g_application_hold().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="run" c:identifier="g_application_run" version="2.28">
        <doc xml:space="preserve">Runs the application.

This function is intended to be run from main() and its return value
is intended to be returned by main(). Although you are expected to pass
the @argc, @argv parameters from main() to this function, it is possible
to pass %NULL if @argv is not available or commandline handling is not
required.  Note that on Windows, @argc and @argv are ignored, and
g_win32_get_command_line() is called internally (for proper support
of Unicode commandline arguments).

#GApplication will attempt to parse the commandline arguments.  You
can add commandline flags to the list of recognised options by way of
g_application_add_main_option_entries().  After this, the
#GApplication::handle-local-options signal is emitted, from which the
application can inspect the values of its #GOptionEntrys.

#GApplication::handle-local-options is a good place to handle options
such as `--version`, where an immediate reply from the local process is
desired (instead of communicating with an already-running instance).
A #GApplication::handle-local-options handler can stop further processing
by returning a non-negative value, which then becomes the exit status of
the process.

What happens next depends on the flags: if
%G_APPLICATION_HANDLES_COMMAND_LINE was specified then the remaining
commandline arguments are sent to the primary instance, where a
#GApplication::command-line signal is emitted.  Otherwise, the
remaining commandline arguments are assumed to be a list of files.
If there are no files listed, the application is activated via the
#GApplication::activate signal.  If there are one or more files, and
%G_APPLICATION_HANDLES_OPEN was specified then the files are opened
via the #GApplication::open signal.

If you are interested in doing more complicated local handling of the
commandline then you should implement your own #GApplication subclass
and override local_command_line(). In this case, you most likely want
to return %TRUE from your local_command_line() implementation to
suppress the default handling. See
[gapplication-example-cmdline2.c][gapplication-example-cmdline2]
for an example.

If, after the above is done, the use count of the application is zero
then the exit status is returned immediately.  If the use count is
non-zero then the default main context is iterated until the use count
falls to zero, at which point 0 is returned.

If the %G_APPLICATION_IS_SERVICE flag is set, then the service will
run for as much as 10 seconds with a use count of zero while waiting
for the message that caused the activation to arrive.  After that,
if the use count falls to zero the application will exit immediately,
except in the case that g_application_set_inactivity_timeout() is in
use.

This function sets the prgname (g_set_prgname()), if not already set,
to the basename of argv[0].

Much like g_main_loop_run(), this function will acquire the main context
for the duration that the application is running.

Since 2.40, applications that are not explicitly flagged as services
or launchers (ie: neither %G_APPLICATION_IS_SERVICE or
%G_APPLICATION_IS_LAUNCHER are given as flags) will check (from the
default handler for local_command_line) if "--gapplication-service"
was given in the command line.  If this flag is present then normal
commandline processing is interrupted and the
%G_APPLICATION_IS_SERVICE flag is set.  This provides a "compromise"
solution whereby running an application directly from the commandline
will invoke it in the normal way (which can be useful for debugging)
while still allowing applications to be D-Bus activated in service
mode.  The D-Bus service file should invoke the executable with
"--gapplication-service" as the sole commandline argument.  This
approach is suitable for use by most graphical applications but
should not be used from applications like editors that need precise
control over when processes invoked via the commandline will exit and
what their exit status will be.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the exit status</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="argc" transfer-ownership="none">
            <doc xml:space="preserve">the argc from main() (or 0 if @argv is %NULL)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="argv" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">
    the argv from main(), or %NULL</doc>
            <array length="0" zero-terminated="0" c:type="char**">
              <type name="filename"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="send_notification" c:identifier="g_application_send_notification" version="2.40">
        <doc xml:space="preserve">Sends a notification on behalf of @application to the desktop shell.
There is no guarantee that the notification is displayed immediately,
or even at all.

Notifications may persist after the application exits. It will be
D-Bus-activated when the notification or one of its actions is
activated.

Modifying @notification after this call has no effect. However, the
object can be reused for a later call to this function.

@id may be any string that uniquely identifies the event for the
application. It does not need to be in any special format. For
example, "new-message" might be appropriate for a notification about
new messages.

If a previous notification was sent with the same @id, it will be
replaced with @notification and shown again as if it was a new
notification. This works even for notifications sent from a previous
execution of the application, as long as @id is the same string.

@id may be %NULL, but it is impossible to replace or withdraw
notifications without an id.

If @notification is no longer relevant, it can be withdrawn with
g_application_withdraw_notification().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">id of the notification, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="notification" transfer-ownership="none">
            <doc xml:space="preserve">the #GNotification to send</doc>
            <type name="Notification" c:type="GNotification*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_action_group" c:identifier="g_application_set_action_group" version="2.28" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">This used to be how actions were associated with a #GApplication.
Now there is #GActionMap for that.</doc>
        <doc-deprecated xml:space="preserve">Use the #GActionMap interface instead.  Never ever
mix use of this API with use of #GActionMap on the same @application
or things will go very badly wrong.  This function is known to
introduce buggy behaviour (ie: signals not emitted on changes to the
action group), so you should really use #GActionMap instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="action_group" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GActionGroup, or %NULL</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_application_id" c:identifier="g_application_set_application_id" version="2.28">
        <doc xml:space="preserve">Sets the unique identifier for @application.

The application id can only be modified if @application has not yet
been registered.

If non-%NULL, the application id must be valid.  See
g_application_id_is_valid().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="application_id" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the identifier for @application</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_default" c:identifier="g_application_set_default" version="2.32">
        <doc xml:space="preserve">Sets or unsets the default application for the process, as returned
by g_application_get_default().

This function does not take its own reference on @application.  If
@application is destroyed then the default application will revert
back to %NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the application to set as default, or %NULL</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_flags" c:identifier="g_application_set_flags" version="2.28">
        <doc xml:space="preserve">Sets the flags for @application.

The flags can only be modified if @application has not yet been
registered.

See #GApplicationFlags.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">the flags for @application</doc>
            <type name="ApplicationFlags" c:type="GApplicationFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_inactivity_timeout" c:identifier="g_application_set_inactivity_timeout" version="2.28">
        <doc xml:space="preserve">Sets the current inactivity timeout for the application.

This is the amount of time (in milliseconds) after the last call to
g_application_release() before the application stops running.

This call has no side effects of its own.  The value set here is only
used for next time g_application_release() drops the use count to
zero.  Any timeouts currently in progress are not impacted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="inactivity_timeout" transfer-ownership="none">
            <doc xml:space="preserve">the timeout, in milliseconds</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_option_context_description" c:identifier="g_application_set_option_context_description" version="2.56">
        <doc xml:space="preserve">Adds a description to the @application option context.

See g_option_context_set_description() for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">the #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="description" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a string to be shown in `--help` output
 after the list of options, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_option_context_parameter_string" c:identifier="g_application_set_option_context_parameter_string" version="2.56">
        <doc xml:space="preserve">Sets the parameter string to be used by the commandline handling of @application.

This function registers the argument to be passed to g_option_context_new()
when the internal #GOptionContext of @application is created.

See g_option_context_new() for more information about @parameter_string.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">the #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="parameter_string" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a string which is displayed
  in the first line of `--help` output, after the usage summary `programname [OPTION...]`.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_option_context_summary" c:identifier="g_application_set_option_context_summary" version="2.56">
        <doc xml:space="preserve">Adds a summary to the @application option context.

See g_option_context_set_summary() for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">the #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="summary" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a string to be shown in `--help` output
 before the list of options, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_resource_base_path" c:identifier="g_application_set_resource_base_path" version="2.42">
        <doc xml:space="preserve">Sets (or unsets) the base resource path of @application.

The path is used to automatically load various [application
resources][gresource] such as menu layouts and action descriptions.
The various types of resources will be found at fixed names relative
to the given base path.

By default, the resource base path is determined from the application
ID by prefixing '/' and replacing each '.' with '/'.  This is done at
the time that the #GApplication object is constructed.  Changes to
the application ID after that point will not have an impact on the
resource base path.

As an example, if the application has an ID of "org.example.app" then
the default resource base path will be "/org/example/app".  If this
is a #GtkApplication (and you have not manually changed the path)
then Gtk will then search for the menus of the application at
"/org/example/app/gtk/menus.ui".

See #GResource for more information about adding resources to your
application.

You can disable automatic resource loading functionality by setting
the path to %NULL.

Changing the resource base path once the application is running is
not recommended.  The point at which the resource path is consulted
for forming paths for various purposes is unspecified.  When writing
a sub-class of #GApplication you should either set the
#GApplication:resource-base-path property at construction time, or call
this function during the instance initialization. Alternatively, you
can call this function in the #GApplicationClass.startup virtual function,
before chaining up to the parent implementation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="resource_path" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the resource path to use</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unbind_busy_property" c:identifier="g_application_unbind_busy_property" version="2.44">
        <doc xml:space="preserve">Destroys a binding between @property and the busy state of
@application that was previously created with
g_application_bind_busy_property().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
          <parameter name="property" transfer-ownership="none">
            <doc xml:space="preserve">the name of a boolean property of @object</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unmark_busy" c:identifier="g_application_unmark_busy" version="2.38">
        <doc xml:space="preserve">Decreases the busy count of @application.

When the busy count reaches zero, the new state will be propagated
to other processes.

This function must only be called to cancel the effect of a previous
call to g_application_mark_busy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="withdraw_notification" c:identifier="g_application_withdraw_notification" version="2.40">
        <doc xml:space="preserve">Withdraws a notification that was sent with
g_application_send_notification().

This call does nothing if a notification with @id doesn't exist or
the notification was never sent.

This function works even for notifications sent in previous
executions of this application, as long @id is the same as it was for
the sent notification.

Note that notifications are dismissed when the user clicks on one
of the buttons in a notification or triggers its default action, so
there is no need to explicitly withdraw the notification in that case.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">id of a previously sent notification</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="action-group" readable="0" writable="1" transfer-ownership="none">
        <type name="ActionGroup"/>
      </property>
      <property name="application-id" writable="1" construct="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="flags" writable="1" transfer-ownership="none">
        <type name="ApplicationFlags"/>
      </property>
      <property name="inactivity-timeout" writable="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="is-busy" version="2.44" transfer-ownership="none">
        <doc xml:space="preserve">Whether the application is currently marked as busy through
g_application_mark_busy() or g_application_bind_busy_property().</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="is-registered" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="is-remote" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="resource-base-path" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ApplicationPrivate" c:type="GApplicationPrivate*"/>
      </field>
      <glib:signal name="activate" when="last">
        <doc xml:space="preserve">The ::activate signal is emitted on the primary instance when an
activation occurs. See g_application_activate().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="command-line" when="last">
        <doc xml:space="preserve">The ::command-line signal is emitted on the primary instance when
a commandline is not handled locally. See g_application_run() and
the #GApplicationCommandLine documentation for more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">An integer that is set as the exit status for the calling
  process. See g_application_command_line_set_exit_status().</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="command_line" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplicationCommandLine representing the
    passed commandline</doc>
            <type name="ApplicationCommandLine"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="handle-local-options" when="last" version="2.40">
        <doc xml:space="preserve">The ::handle-local-options signal is emitted on the local instance
after the parsing of the commandline options has occurred.

You can add options to be recognised during commandline option
parsing using g_application_add_main_option_entries() and
g_application_add_option_group().

Signal handlers can inspect @options (along with values pointed to
from the @arg_data of an installed #GOptionEntrys) in order to
decide to perform certain actions, including direct local handling
(which may be useful for options like --version).

In the event that the application is marked
%G_APPLICATION_HANDLES_COMMAND_LINE the "normal processing" will
send the @options dictionary to the primary instance where it can be
read with g_application_command_line_get_options_dict().  The signal
handler can modify the dictionary before returning, and the
modified dictionary will be sent.

In the event that %G_APPLICATION_HANDLES_COMMAND_LINE is not set,
"normal processing" will treat the remaining uncollected command
line arguments as filenames or URIs.  If there are no arguments,
the application is activated by g_application_activate().  One or
more arguments results in a call to g_application_open().

If you want to handle the local commandline arguments for yourself
by converting them to calls to g_application_open() or
g_action_group_activate_action() then you must be sure to register
the application first.  You should probably not call
g_application_activate() for yourself, however: just return -1 and
allow the default handler to do it for you.  This will ensure that
the `--gapplication-service` switch works properly (i.e. no activation
in that case).

Note that this signal is emitted from the default implementation of
local_command_line().  If you override that function and don't
chain up then this signal will never be emitted.

You can override local_command_line() if you need more powerful
capabilities than what is provided here, but this should not
normally be required.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an exit code. If you have handled your options and want
to exit the process, return a non-negative option, 0 for success,
and a positive value for failure. To continue, return -1 to let
the default option processing continue.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve">the options dictionary</doc>
            <type name="GLib.VariantDict"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="open" when="last">
        <doc xml:space="preserve">The ::open signal is emitted on the primary instance when there are
files to open. See g_application_open() for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="files" transfer-ownership="none">
            <doc xml:space="preserve">an array of #GFiles</doc>
            <array length="1" zero-terminated="0" c:type="gpointer">
              <type name="File"/>
            </array>
          </parameter>
          <parameter name="n_files" transfer-ownership="none">
            <doc xml:space="preserve">the length of @files</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="hint" transfer-ownership="none">
            <doc xml:space="preserve">a hint provided by the calling instance</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="shutdown" when="last">
        <doc xml:space="preserve">The ::shutdown signal is emitted only on the registered primary instance
immediately after the main loop terminates.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="startup" when="first">
        <doc xml:space="preserve">The ::startup signal is emitted on the primary instance immediately
after registration. See g_application_register().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="ApplicationClass" c:type="GApplicationClass" glib:is-gtype-struct-for="Application" version="2.28">
      <doc xml:space="preserve">Virtual function table for #GApplication.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="startup">
        <callback name="startup">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="activate">
        <callback name="activate">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <doc xml:space="preserve">a #GApplication</doc>
              <type name="Application" c:type="GApplication*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="open">
        <callback name="open">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <doc xml:space="preserve">a #GApplication</doc>
              <type name="Application" c:type="GApplication*"/>
            </parameter>
            <parameter name="files" transfer-ownership="none">
              <doc xml:space="preserve">an array of #GFiles to open</doc>
              <array length="2" zero-terminated="0" c:type="GFile**">
                <type name="File" c:type="GFile*"/>
              </array>
            </parameter>
            <parameter name="n_files" transfer-ownership="none">
              <doc xml:space="preserve">the length of the @files array</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="hint" transfer-ownership="none">
              <doc xml:space="preserve">a hint (or ""), but never %NULL</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="command_line">
        <callback name="command_line">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
            <parameter name="command_line" transfer-ownership="none">
              <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="local_command_line">
        <callback name="local_command_line">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the commandline has been completely handled</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <doc xml:space="preserve">a #GApplication</doc>
              <type name="Application" c:type="GApplication*"/>
            </parameter>
            <parameter name="arguments" direction="inout" caller-allocates="0" transfer-ownership="full">
              <doc xml:space="preserve">array of command line arguments</doc>
              <array c:type="gchar***">
                <type name="utf8" c:type="gchar**"/>
              </array>
            </parameter>
            <parameter name="exit_status" direction="out" caller-allocates="0" transfer-ownership="full">
              <doc xml:space="preserve">exit status to fill after processing the command line.</doc>
              <type name="gint" c:type="int*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="before_emit">
        <callback name="before_emit">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
            <parameter name="platform_data" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="after_emit">
        <callback name="after_emit">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
            <parameter name="platform_data" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_platform_data">
        <callback name="add_platform_data">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
            <parameter name="builder" transfer-ownership="none">
              <type name="GLib.VariantBuilder" c:type="GVariantBuilder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="quit_mainloop">
        <callback name="quit_mainloop">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="run_mainloop">
        <callback name="run_mainloop">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="shutdown">
        <callback name="shutdown">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dbus_register">
        <callback name="dbus_register" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="DBusConnection" c:type="GDBusConnection*"/>
            </parameter>
            <parameter name="object_path" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dbus_unregister">
        <callback name="dbus_unregister">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="DBusConnection" c:type="GDBusConnection*"/>
            </parameter>
            <parameter name="object_path" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="handle_local_options">
        <callback name="handle_local_options">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
            <parameter name="options" transfer-ownership="none">
              <type name="GLib.VariantDict" c:type="GVariantDict*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="ApplicationCommandLine" c:symbol-prefix="application_command_line" c:type="GApplicationCommandLine" parent="GObject.Object" glib:type-name="GApplicationCommandLine" glib:get-type="g_application_command_line_get_type" glib:type-struct="ApplicationCommandLineClass">
      <doc xml:space="preserve">#GApplicationCommandLine represents a command-line invocation of
an application.  It is created by #GApplication and emitted
in the #GApplication::command-line signal and virtual function.

The class contains the list of arguments that the program was invoked
with.  It is also possible to query if the commandline invocation was
local (ie: the current process is running in direct response to the
invocation) or remote (ie: some other process forwarded the
commandline to this process).

The GApplicationCommandLine object can provide the @argc and @argv
parameters for use with the #GOptionContext command-line parsing API,
with the g_application_command_line_get_arguments() function. See
[gapplication-example-cmdline3.c][gapplication-example-cmdline3]
for an example.

The exit status of the originally-invoked process may be set and
messages can be printed to stdout or stderr of that process.  The
lifecycle of the originally-invoked process is tied to the lifecycle
of this object (ie: the process exits when the last reference is
dropped).

The main use for #GApplicationCommandLine (and the
#GApplication::command-line signal) is 'Emacs server' like use cases:
You can set the `EDITOR` environment variable to have e.g. git use
your favourite editor to edit commit messages, and if you already
have an instance of the editor running, the editing will happen
in the running instance, instead of opening a new one. An important
aspect of this use case is that the process that gets started by git
does not return until the editing is done.

Normally, the commandline is completely handled in the
#GApplication::command-line handler. The launching instance exits
once the signal handler in the primary instance has returned, and
the return value of the signal handler becomes the exit status
of the launching instance.
|[&lt;!-- language="C" --&gt;
static int
command_line (GApplication            *application,
              GApplicationCommandLine *cmdline)
{
  gchar **argv;
  gint argc;
  gint i;

  argv = g_application_command_line_get_arguments (cmdline, &amp;argc);

  g_application_command_line_print (cmdline,
                                    "This text is written back\n"
                                    "to stdout of the caller\n");

  for (i = 0; i &lt; argc; i++)
    g_print ("argument %d: %s\n", i, argv[i]);

  g_strfreev (argv);

  return 0;
}
]|
The complete example can be found here:
[gapplication-example-cmdline.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-cmdline.c)

In more complicated cases, the handling of the comandline can be
split between the launcher and the primary instance.
|[&lt;!-- language="C" --&gt;
static gboolean
 test_local_cmdline (GApplication   *application,
                     gchar        ***arguments,
                     gint           *exit_status)
{
  gint i, j;
  gchar **argv;

  argv = *arguments;

  i = 1;
  while (argv[i])
    {
      if (g_str_has_prefix (argv[i], "--local-"))
        {
          g_print ("handling argument %s locally\n", argv[i]);
          g_free (argv[i]);
          for (j = i; argv[j]; j++)
            argv[j] = argv[j + 1];
        }
      else
        {
          g_print ("not handling argument %s locally\n", argv[i]);
          i++;
        }
    }

  *exit_status = 0;

  return FALSE;
}

static void
test_application_class_init (TestApplicationClass *class)
{
  G_APPLICATION_CLASS (class)-&gt;local_command_line = test_local_cmdline;

  ...
}
]|
In this example of split commandline handling, options that start
with `--local-` are handled locally, all other options are passed
to the #GApplication::command-line handler which runs in the primary
instance.

The complete example can be found here:
[gapplication-example-cmdline2.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-cmdline2.c)

If handling the commandline requires a lot of work, it may
be better to defer it.
|[&lt;!-- language="C" --&gt;
static gboolean
my_cmdline_handler (gpointer data)
{
  GApplicationCommandLine *cmdline = data;

  // do the heavy lifting in an idle

  g_application_command_line_set_exit_status (cmdline, 0);
  g_object_unref (cmdline); // this releases the application

  return G_SOURCE_REMOVE;
}

static int
command_line (GApplication            *application,
              GApplicationCommandLine *cmdline)
{
  // keep the application running until we are done with this commandline
  g_application_hold (application);

  g_object_set_data_full (G_OBJECT (cmdline),
                          "application", application,
                          (GDestroyNotify)g_application_release);

  g_object_ref (cmdline);
  g_idle_add (my_cmdline_handler, cmdline);

  return 0;
}
]|
In this example the commandline is not completely handled before
the #GApplication::command-line handler returns. Instead, we keep
a reference to the #GApplicationCommandLine object and handle it
later (in this example, in an idle). Note that it is necessary to
hold the application until you are done with the commandline.

The complete example can be found here:
[gapplication-example-cmdline3.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-cmdline3.c)</doc>
      <virtual-method name="get_stdin" invoker="get_stdin" version="2.34">
        <doc xml:space="preserve">Gets the stdin of the invoking process.

The #GInputStream can be used to read data passed to the standard
input of the invoking process.
This doesn't work on all platforms.  Presently, it is only available
on UNIX when using a DBus daemon capable of passing file descriptors.
If stdin is not available then %NULL will be returned.  In the
future, support may be expanded to other platforms.

You must only call this function once per commandline invocation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GInputStream for stdin</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="print_literal">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="printerr_literal">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="create_file_for_arg" c:identifier="g_application_command_line_create_file_for_arg" version="2.36">
        <doc xml:space="preserve">Creates a #GFile corresponding to a filename that was given as part
of the invocation of @cmdline.

This differs from g_file_new_for_commandline_arg() in that it
resolves relative pathnames using the current working directory of
the invoking process rather than the local process.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GFile</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*"/>
          </instance-parameter>
          <parameter name="arg" transfer-ownership="none">
            <doc xml:space="preserve">an argument from @cmdline</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_arguments" c:identifier="g_application_command_line_get_arguments" version="2.28">
        <doc xml:space="preserve">Gets the list of arguments that was passed on the command line.

The strings in the array may contain non-UTF-8 data on UNIX (such as
filenames or arguments given in the system locale) but are always in
UTF-8 on Windows.

If you wish to use the return value with #GOptionContext, you must
use g_option_context_parse_strv().

The return value is %NULL-terminated and should be freed using
g_strfreev().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">
     the string array containing the arguments (the argv)</doc>
          <array length="0" zero-terminated="0" c:type="gchar**">
            <type name="filename"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*"/>
          </instance-parameter>
          <parameter name="argc" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the length of the arguments array, or %NULL</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_cwd" c:identifier="g_application_command_line_get_cwd" version="2.28">
        <doc xml:space="preserve">Gets the working directory of the command line invocation.
The string may contain non-utf8 data.

It is possible that the remote application did not send a working
directory, so this may be %NULL.

The return value should not be modified or freed and is valid for as
long as @cmdline exists.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the current directory, or %NULL</doc>
          <type name="filename" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_environ" c:identifier="g_application_command_line_get_environ" version="2.28">
        <doc xml:space="preserve">Gets the contents of the 'environ' variable of the command line
invocation, as would be returned by g_get_environ(), ie as a
%NULL-terminated list of strings in the form 'NAME=VALUE'.
The strings may contain non-utf8 data.

The remote application usually does not send an environment.  Use
%G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
set it is possible that the environment is still not available (due
to invocation messages from other applications).

The return value should not be modified or freed and is valid for as
long as @cmdline exists.

See g_application_command_line_getenv() if you are only interested
in the value of a single environment variable.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">
    the environment strings, or %NULL if they were not sent</doc>
          <array c:type="const gchar* const*">
            <type name="filename"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_exit_status" c:identifier="g_application_command_line_get_exit_status" version="2.28">
        <doc xml:space="preserve">Gets the exit status of @cmdline.  See
g_application_command_line_set_exit_status() for more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the exit status</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_remote" c:identifier="g_application_command_line_get_is_remote" version="2.28">
        <doc xml:space="preserve">Determines if @cmdline represents a remote invocation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the invocation was remote</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_options_dict" c:identifier="g_application_command_line_get_options_dict" version="2.40">
        <doc xml:space="preserve">Gets the options there were passed to g_application_command_line().

If you did not override local_command_line() then these are the same
options that were parsed according to the #GOptionEntrys added to the
application with g_application_add_main_option_entries() and possibly
modified from your GApplication::handle-local-options handler.

If no options were sent then an empty dictionary is returned so that
you don't need to check for %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GVariantDict with the options</doc>
          <type name="GLib.VariantDict" c:type="GVariantDict*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_platform_data" c:identifier="g_application_command_line_get_platform_data" version="2.28">
        <doc xml:space="preserve">Gets the platform data associated with the invocation of @cmdline.

This is a #GVariant dictionary containing information about the
context in which the invocation occurred.  It typically contains
information like the current working directory and the startup
notification ID.

For local invocation, it will be %NULL.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the platform data, or %NULL</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve">#GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_stdin" c:identifier="g_application_command_line_get_stdin" version="2.34">
        <doc xml:space="preserve">Gets the stdin of the invoking process.

The #GInputStream can be used to read data passed to the standard
input of the invoking process.
This doesn't work on all platforms.  Presently, it is only available
on UNIX when using a DBus daemon capable of passing file descriptors.
If stdin is not available then %NULL will be returned.  In the
future, support may be expanded to other platforms.

You must only call this function once per commandline invocation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GInputStream for stdin</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="getenv" c:identifier="g_application_command_line_getenv" version="2.28">
        <doc xml:space="preserve">Gets the value of a particular environment variable of the command
line invocation, as would be returned by g_getenv().  The strings may
contain non-utf8 data.

The remote application usually does not send an environment.  Use
%G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
set it is possible that the environment is still not available (due
to invocation messages from other applications).

The return value should not be modified or freed and is valid for as
long as @cmdline exists.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the variable, or %NULL if unset or unsent</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the environment variable to get</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="print" c:identifier="g_application_command_line_print" version="2.28" introspectable="0">
        <doc xml:space="preserve">Formats a message and prints it using the stdout print handler in the
invoking process.

If @cmdline is a local invocation then this is exactly equivalent to
g_print().  If @cmdline is remote then this is equivalent to calling
g_print() in the invoking process.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">a printf-style format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">arguments, as per @format</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="printerr" c:identifier="g_application_command_line_printerr" version="2.28" introspectable="0">
        <doc xml:space="preserve">Formats a message and prints it using the stderr print handler in the
invoking process.

If @cmdline is a local invocation then this is exactly equivalent to
g_printerr().  If @cmdline is remote then this is equivalent to
calling g_printerr() in the invoking process.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">a printf-style format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">arguments, as per @format</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="set_exit_status" c:identifier="g_application_command_line_set_exit_status" version="2.28">
        <doc xml:space="preserve">Sets the exit status that will be used when the invoking process
exits.

The return value of the #GApplication::command-line signal is
passed to this function when the handler returns.  This is the usual
way of setting the exit status.

In the event that you want the remote invocation to continue running
and want to decide on the exit status in the future, you can use this
call.  For the case of a remote invocation, the remote process will
typically exit when the last reference is dropped on @cmdline.  The
exit status of the remote process will be equal to the last value
that was set with this function.

In the case that the commandline invocation is local, the situation
is slightly more complicated.  If the commandline invocation results
in the mainloop running (ie: because the use-count of the application
increased to a non-zero value) then the application is considered to
have been 'successful' in a certain sense, and the exit status is
always zero.  If the application use count is zero, though, the exit
status of the local #GApplicationCommandLine is used.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*"/>
          </instance-parameter>
          <parameter name="exit_status" transfer-ownership="none">
            <doc xml:space="preserve">the exit status</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <property name="arguments" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <type name="GLib.Variant"/>
      </property>
      <property name="is-remote" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="options" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <type name="GLib.Variant"/>
      </property>
      <property name="platform-data" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <type name="GLib.Variant"/>
      </property>
      <field name="parent_instance" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ApplicationCommandLinePrivate" c:type="GApplicationCommandLinePrivate*"/>
      </field>
    </class>
    <record name="ApplicationCommandLineClass" c:type="GApplicationCommandLineClass" glib:is-gtype-struct-for="ApplicationCommandLine" version="2.28">
      <doc xml:space="preserve">The #GApplicationCommandLineClass-struct
contains private data only.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="print_literal">
        <callback name="print_literal">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="cmdline" transfer-ownership="none">
              <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="printerr_literal">
        <callback name="printerr_literal">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="cmdline" transfer-ownership="none">
              <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_stdin">
        <callback name="get_stdin">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GInputStream for stdin</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </return-value>
          <parameters>
            <parameter name="cmdline" transfer-ownership="none">
              <doc xml:space="preserve">a #GApplicationCommandLine</doc>
              <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="11">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="ApplicationCommandLinePrivate" c:type="GApplicationCommandLinePrivate" disguised="1">
    </record>
    <bitfield name="ApplicationFlags" version="2.28" glib:type-name="GApplicationFlags" glib:get-type="g_application_flags_get_type" c:type="GApplicationFlags">
      <doc xml:space="preserve">Flags used to define the behaviour of a #GApplication.</doc>
      <member name="flags_none" value="0" c:identifier="G_APPLICATION_FLAGS_NONE" glib:nick="flags-none">
        <doc xml:space="preserve">Default</doc>
      </member>
      <member name="is_service" value="1" c:identifier="G_APPLICATION_IS_SERVICE" glib:nick="is-service">
        <doc xml:space="preserve">Run as a service. In this mode, registration
     fails if the service is already running, and the application
     will initially wait up to 10 seconds for an initial activation
     message to arrive.</doc>
      </member>
      <member name="is_launcher" value="2" c:identifier="G_APPLICATION_IS_LAUNCHER" glib:nick="is-launcher">
        <doc xml:space="preserve">Don't try to become the primary instance.</doc>
      </member>
      <member name="handles_open" value="4" c:identifier="G_APPLICATION_HANDLES_OPEN" glib:nick="handles-open">
        <doc xml:space="preserve">This application handles opening files (in
    the primary instance). Note that this flag only affects the default
    implementation of local_command_line(), and has no effect if
    %G_APPLICATION_HANDLES_COMMAND_LINE is given.
    See g_application_run() for details.</doc>
      </member>
      <member name="handles_command_line" value="8" c:identifier="G_APPLICATION_HANDLES_COMMAND_LINE" glib:nick="handles-command-line">
        <doc xml:space="preserve">This application handles command line
    arguments (in the primary instance). Note that this flag only affect
    the default implementation of local_command_line().
    See g_application_run() for details.</doc>
      </member>
      <member name="send_environment" value="16" c:identifier="G_APPLICATION_SEND_ENVIRONMENT" glib:nick="send-environment">
        <doc xml:space="preserve">Send the environment of the
    launching process to the primary instance. Set this flag if your
    application is expected to behave differently depending on certain
    environment variables. For instance, an editor might be expected
    to use the `GIT_COMMITTER_NAME` environment variable
    when editing a git commit message. The environment is available
    to the #GApplication::command-line signal handler, via
    g_application_command_line_getenv().</doc>
      </member>
      <member name="non_unique" value="32" c:identifier="G_APPLICATION_NON_UNIQUE" glib:nick="non-unique">
        <doc xml:space="preserve">Make no attempts to do any of the typical
    single-instance application negotiation, even if the application
    ID is given.  The application neither attempts to become the
    owner of the application ID nor does it check if an existing
    owner already exists.  Everything occurs in the local process.
    Since: 2.30.</doc>
      </member>
      <member name="can_override_app_id" value="64" c:identifier="G_APPLICATION_CAN_OVERRIDE_APP_ID" glib:nick="can-override-app-id">
        <doc xml:space="preserve">Allow users to override the
    application ID from the command line with `--gapplication-app-id`.
    Since: 2.48</doc>
      </member>
    </bitfield>
    <record name="ApplicationPrivate" c:type="GApplicationPrivate" disguised="1">
    </record>
    <bitfield name="AskPasswordFlags" glib:type-name="GAskPasswordFlags" glib:get-type="g_ask_password_flags_get_type" c:type="GAskPasswordFlags">
      <doc xml:space="preserve">#GAskPasswordFlags are used to request specific information from the
user, or to notify the user of their choices in an authentication
situation.</doc>
      <member name="need_password" value="1" c:identifier="G_ASK_PASSWORD_NEED_PASSWORD" glib:nick="need-password">
        <doc xml:space="preserve">operation requires a password.</doc>
      </member>
      <member name="need_username" value="2" c:identifier="G_ASK_PASSWORD_NEED_USERNAME" glib:nick="need-username">
        <doc xml:space="preserve">operation requires a username.</doc>
      </member>
      <member name="need_domain" value="4" c:identifier="G_ASK_PASSWORD_NEED_DOMAIN" glib:nick="need-domain">
        <doc xml:space="preserve">operation requires a domain.</doc>
      </member>
      <member name="saving_supported" value="8" c:identifier="G_ASK_PASSWORD_SAVING_SUPPORTED" glib:nick="saving-supported">
        <doc xml:space="preserve">operation supports saving settings.</doc>
      </member>
      <member name="anonymous_supported" value="16" c:identifier="G_ASK_PASSWORD_ANONYMOUS_SUPPORTED" glib:nick="anonymous-supported">
        <doc xml:space="preserve">operation supports anonymous users.</doc>
      </member>
      <member name="tcrypt" value="32" c:identifier="G_ASK_PASSWORD_TCRYPT" glib:nick="tcrypt">
        <doc xml:space="preserve">operation takes TCRYPT parameters (Since: 2.58)</doc>
      </member>
    </bitfield>
    <interface name="AsyncInitable" c:symbol-prefix="async_initable" c:type="GAsyncInitable" version="2.22" glib:type-name="GAsyncInitable" glib:get-type="g_async_initable_get_type" glib:type-struct="AsyncInitableIface">
      <doc xml:space="preserve">This is the asynchronous version of #GInitable; it behaves the same
in all ways except that initialization is asynchronous. For more details
see the descriptions on #GInitable.

A class may implement both the #GInitable and #GAsyncInitable interfaces.

Users of objects implementing this are not intended to use the interface
method directly; instead it will be used automatically in various ways.
For C applications you generally just call g_async_initable_new_async()
directly, or indirectly via a foo_thing_new_async() wrapper. This will call
g_async_initable_init_async() under the cover, calling back with %NULL and
a set %GError on failure.

A typical implementation might look something like this:

|[&lt;!-- language="C" --&gt;
enum {
   NOT_INITIALIZED,
   INITIALIZING,
   INITIALIZED
};

static void
_foo_ready_cb (Foo *self)
{
  GList *l;

  self-&gt;priv-&gt;state = INITIALIZED;

  for (l = self-&gt;priv-&gt;init_results; l != NULL; l = l-&gt;next)
    {
      GTask *task = l-&gt;data;

      if (self-&gt;priv-&gt;success)
        g_task_return_boolean (task, TRUE);
      else
        g_task_return_new_error (task, ...);
      g_object_unref (task);
    }

  g_list_free (self-&gt;priv-&gt;init_results);
  self-&gt;priv-&gt;init_results = NULL;
}

static void
foo_init_async (GAsyncInitable       *initable,
                int                   io_priority,
                GCancellable         *cancellable,
                GAsyncReadyCallback   callback,
                gpointer              user_data)
{
  Foo *self = FOO (initable);
  GTask *task;

  task = g_task_new (initable, cancellable, callback, user_data);

  switch (self-&gt;priv-&gt;state)
    {
      case NOT_INITIALIZED:
        _foo_get_ready (self);
        self-&gt;priv-&gt;init_results = g_list_append (self-&gt;priv-&gt;init_results,
                                                  task);
        self-&gt;priv-&gt;state = INITIALIZING;
        break;
      case INITIALIZING:
        self-&gt;priv-&gt;init_results = g_list_append (self-&gt;priv-&gt;init_results,
                                                  task);
        break;
      case INITIALIZED:
        if (!self-&gt;priv-&gt;success)
          g_task_return_new_error (task, ...);
        else
          g_task_return_boolean (task, TRUE);
        g_object_unref (task);
        break;
    }
}

static gboolean
foo_init_finish (GAsyncInitable       *initable,
                 GAsyncResult         *result,
                 GError              **error)
{
  g_return_val_if_fail (g_task_is_valid (result, initable), FALSE);

  return g_task_propagate_boolean (G_TASK (result), error);
}

static void
foo_async_initable_iface_init (gpointer g_iface,
                               gpointer data)
{
  GAsyncInitableIface *iface = g_iface;

  iface-&gt;init_async = foo_init_async;
  iface-&gt;init_finish = foo_init_finish;
}
]|</doc>
      <function name="new_async" c:identifier="g_async_initable_new_async" version="2.22" introspectable="0">
        <doc xml:space="preserve">Helper function for constructing #GAsyncInitable object. This is
similar to g_object_new() but also initializes the object asynchronously.

When the initialization is finished, @callback will be called. You can
then call g_async_initable_new_finish() to get the new object and check
for any errors.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object_type" transfer-ownership="none">
            <doc xml:space="preserve">a #GType supporting #GAsyncInitable.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the operation</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the initialization is
    finished</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="first_property_name" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the name of the first property, or %NULL if no
    properties</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the value of the first property, followed by other property
   value pairs, and ended by %NULL.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </function>
      <function name="new_valist_async" c:identifier="g_async_initable_new_valist_async" version="2.22" introspectable="0">
        <doc xml:space="preserve">Helper function for constructing #GAsyncInitable object. This is
similar to g_object_new_valist() but also initializes the object
asynchronously.

When the initialization is finished, @callback will be called. You can
then call g_async_initable_new_finish() to get the new object and check
for any errors.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object_type" transfer-ownership="none">
            <doc xml:space="preserve">a #GType supporting #GAsyncInitable.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the first property, followed by
the value, and other property value pairs, and ended by %NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:space="preserve">The var args list generated from @first_property_name.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the operation</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the initialization is
    finished</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="newv_async" c:identifier="g_async_initable_newv_async" version="2.22" deprecated="1" deprecated-version="2.54">
        <doc xml:space="preserve">Helper function for constructing #GAsyncInitable object. This is
similar to g_object_newv() but also initializes the object asynchronously.

When the initialization is finished, @callback will be called. You can
then call g_async_initable_new_finish() to get the new object and check
for any errors.</doc>
        <doc-deprecated xml:space="preserve">Use g_object_new_with_properties() and
g_async_initable_init_async() instead. See #GParameter for more information.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object_type" transfer-ownership="none">
            <doc xml:space="preserve">a #GType supporting #GAsyncInitable.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="n_parameters" transfer-ownership="none">
            <doc xml:space="preserve">the number of parameters in @parameters</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:space="preserve">the parameters to use to construct the object</doc>
            <type name="GObject.Parameter" c:type="GParameter*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the operation</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the initialization is
    finished</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="init_async" invoker="init_async" version="2.22">
        <doc xml:space="preserve">Starts asynchronous initialization of the object implementing the
interface. This must be done before any real use of the object after
initial construction. If the object also implements #GInitable you can
optionally call g_initable_init() instead.

This method is intended for language bindings. If writing in C,
g_async_initable_new_async() should typically be used instead.

When the initialization is finished, @callback will be called. You can
then call g_async_initable_init_finish() to get the result of the
initialization.

Implementations may also support cancellation. If @cancellable is not
%NULL, then initialization can be cancelled by triggering the cancellable
object from another thread. If the operation was cancelled, the error
%G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL, and
the object doesn't support cancellable initialization, the error
%G_IO_ERROR_NOT_SUPPORTED will be returned.

As with #GInitable, if the object is not initialized, or initialization
returns with an error, then all operations on the object except
g_object_ref() and g_object_unref() are considered to be invalid, and
have undefined behaviour. They will often fail with g_critical() or
g_warning(), but this must not be relied on.

Callers should not assume that a class which implements #GAsyncInitable can
be initialized multiple times; for more information, see g_initable_init().
If a class explicitly supports being initialized multiple times,
implementation requires yielding all subsequent calls to init_async() on the
results of the first call.

For classes that also support the #GInitable interface, the default
implementation of this method will run the g_initable_init() function
in a thread, so if you want to support asynchronous initialization via
threads, just implement the #GAsyncInitable interface without overriding
any interface methods.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="initable" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncInitable.</doc>
            <type name="AsyncInitable" c:type="GAsyncInitable*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the operation</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="init_finish" invoker="init_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes asynchronous initialization and returns the result.
See g_async_initable_init_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if successful. If an error has occurred, this function
will return %FALSE and set @error appropriately if present.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="initable" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncInitable.</doc>
            <type name="AsyncInitable" c:type="GAsyncInitable*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="init_async" c:identifier="g_async_initable_init_async" version="2.22">
        <doc xml:space="preserve">Starts asynchronous initialization of the object implementing the
interface. This must be done before any real use of the object after
initial construction. If the object also implements #GInitable you can
optionally call g_initable_init() instead.

This method is intended for language bindings. If writing in C,
g_async_initable_new_async() should typically be used instead.

When the initialization is finished, @callback will be called. You can
then call g_async_initable_init_finish() to get the result of the
initialization.

Implementations may also support cancellation. If @cancellable is not
%NULL, then initialization can be cancelled by triggering the cancellable
object from another thread. If the operation was cancelled, the error
%G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL, and
the object doesn't support cancellable initialization, the error
%G_IO_ERROR_NOT_SUPPORTED will be returned.

As with #GInitable, if the object is not initialized, or initialization
returns with an error, then all operations on the object except
g_object_ref() and g_object_unref() are considered to be invalid, and
have undefined behaviour. They will often fail with g_critical() or
g_warning(), but this must not be relied on.

Callers should not assume that a class which implements #GAsyncInitable can
be initialized multiple times; for more information, see g_initable_init().
If a class explicitly supports being initialized multiple times,
implementation requires yielding all subsequent calls to init_async() on the
results of the first call.

For classes that also support the #GInitable interface, the default
implementation of this method will run the g_initable_init() function
in a thread, so if you want to support asynchronous initialization via
threads, just implement the #GAsyncInitable interface without overriding
any interface methods.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="initable" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncInitable.</doc>
            <type name="AsyncInitable" c:type="GAsyncInitable*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the operation</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_finish" c:identifier="g_async_initable_init_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes asynchronous initialization and returns the result.
See g_async_initable_init_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if successful. If an error has occurred, this function
will return %FALSE and set @error appropriately if present.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="initable" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncInitable.</doc>
            <type name="AsyncInitable" c:type="GAsyncInitable*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="new_finish" c:identifier="g_async_initable_new_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes the async construction for the various g_async_initable_new
calls, returning the created object or %NULL on error.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly created #GObject,
     or %NULL on error. Free with g_object_unref().</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="initable" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncInitable from the callback</doc>
            <type name="AsyncInitable" c:type="GAsyncInitable*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult from the callback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="AsyncInitableIface" c:type="GAsyncInitableIface" glib:is-gtype-struct-for="AsyncInitable" version="2.22">
      <doc xml:space="preserve">Provides an interface for asynchronous initializing object such that
initialization may fail.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="init_async">
        <callback name="init_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="initable" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncInitable.</doc>
              <type name="AsyncInitable" c:type="GAsyncInitable*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the operation</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="init_finish">
        <callback name="init_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if successful. If an error has occurred, this function
will return %FALSE and set @error appropriately if present.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="initable" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncInitable.</doc>
              <type name="AsyncInitable" c:type="GAsyncInitable*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <callback name="AsyncReadyCallback" c:type="GAsyncReadyCallback">
      <doc xml:space="preserve">Type definition for a function that will be called back when an asynchronous
operation within GIO has been completed. #GAsyncReadyCallback
callbacks from #GTask are guaranteed to be invoked in a later
iteration of the
[thread-default main context][g-main-context-push-thread-default]
where the #GTask was created. All other users of
#GAsyncReadyCallback must likewise call it asynchronously in a
later iteration of the main context.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="source_object" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the object the asynchronous operation was started with.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="res" transfer-ownership="none">
          <doc xml:space="preserve">a #GAsyncResult.</doc>
          <type name="AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">user data passed to the callback.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <interface name="AsyncResult" c:symbol-prefix="async_result" c:type="GAsyncResult" glib:type-name="GAsyncResult" glib:get-type="g_async_result_get_type" glib:type-struct="AsyncResultIface">
      <doc xml:space="preserve">Provides a base class for implementing asynchronous function results.

Asynchronous operations are broken up into two separate operations
which are chained together by a #GAsyncReadyCallback. To begin
an asynchronous operation, provide a #GAsyncReadyCallback to the
asynchronous function. This callback will be triggered when the
operation has completed, and must be run in a later iteration of
the [thread-default main context][g-main-context-push-thread-default]
from where the operation was initiated. It will be passed a
#GAsyncResult instance filled with the details of the operation's
success or failure, the object the asynchronous function was
started for and any error codes returned. The asynchronous callback
function is then expected to call the corresponding "_finish()"
function, passing the object the function was called for, the
#GAsyncResult instance, and (optionally) an @error to grab any
error conditions that may have occurred.

The "_finish()" function for an operation takes the generic result
(of type #GAsyncResult) and returns the specific result that the
operation in question yields (e.g. a #GFileEnumerator for a
"enumerate children" operation). If the result or error status of the
operation is not needed, there is no need to call the "_finish()"
function; GIO will take care of cleaning up the result and error
information after the #GAsyncReadyCallback returns. You can pass
%NULL for the #GAsyncReadyCallback if you don't need to take any
action at all after the operation completes. Applications may also
take a reference to the #GAsyncResult and call "_finish()" later;
however, the "_finish()" function may be called at most once.

Example of a typical asynchronous operation flow:
|[&lt;!-- language="C" --&gt;
void _theoretical_frobnitz_async (Theoretical         *t,
                                  GCancellable        *c,
                                  GAsyncReadyCallback  cb,
                                  gpointer             u);

gboolean _theoretical_frobnitz_finish (Theoretical   *t,
                                       GAsyncResult  *res,
                                       GError       **e);

static void
frobnitz_result_func (GObject      *source_object,
		 GAsyncResult *res,
		 gpointer      user_data)
{
  gboolean success = FALSE;

  success = _theoretical_frobnitz_finish (source_object, res, NULL);

  if (success)
    g_printf ("Hurray!\n");
  else
    g_printf ("Uh oh!\n");

  ...

}

int main (int argc, void *argv[])
{
   ...

   _theoretical_frobnitz_async (theoretical_data,
                                NULL,
                                frobnitz_result_func,
                                NULL);

   ...
}
]|

The callback for an asynchronous operation is called only once, and is
always called, even in the case of a cancelled operation. On cancellation
the result is a %G_IO_ERROR_CANCELLED error.

## I/O Priority # {#io-priority}

Many I/O-related asynchronous operations have a priority parameter,
which is used in certain cases to determine the order in which
operations are executed. They are not used to determine system-wide
I/O scheduling. Priorities are integers, with lower numbers indicating
higher priority. It is recommended to choose priorities between
%G_PRIORITY_LOW and %G_PRIORITY_HIGH, with %G_PRIORITY_DEFAULT
as a default.</doc>
      <virtual-method name="get_source_object" invoker="get_source_object">
        <doc xml:space="preserve">Gets the source object from a #GAsyncResult.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new reference to the source
   object for the @res, or %NULL if there is none.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_user_data" invoker="get_user_data">
        <doc xml:space="preserve">Gets the user data from a #GAsyncResult.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the user data for @res.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_tagged" invoker="is_tagged" version="2.34">
        <doc xml:space="preserve">Checks if @res has the given @source_tag (generally a function
pointer indicating the function @res was created by).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @res has the indicated @source_tag, %FALSE if
  not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </instance-parameter>
          <parameter name="source_tag" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an application-defined tag</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_source_object" c:identifier="g_async_result_get_source_object">
        <doc xml:space="preserve">Gets the source object from a #GAsyncResult.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new reference to the source
   object for the @res, or %NULL if there is none.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_user_data" c:identifier="g_async_result_get_user_data">
        <doc xml:space="preserve">Gets the user data from a #GAsyncResult.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the user data for @res.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_tagged" c:identifier="g_async_result_is_tagged" version="2.34">
        <doc xml:space="preserve">Checks if @res has the given @source_tag (generally a function
pointer indicating the function @res was created by).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @res has the indicated @source_tag, %FALSE if
  not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </instance-parameter>
          <parameter name="source_tag" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an application-defined tag</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="legacy_propagate_error" c:identifier="g_async_result_legacy_propagate_error" version="2.34" throws="1">
        <doc xml:space="preserve">If @res is a #GSimpleAsyncResult, this is equivalent to
g_simple_async_result_propagate_error(). Otherwise it returns
%FALSE.

This can be used for legacy error handling in async *_finish()
wrapper functions that traditionally handled #GSimpleAsyncResult
error returns themselves rather than calling into the virtual method.
This should not be used in new code; #GAsyncResult errors that are
set by virtual methods should also be extracted by virtual methods,
to enable subclasses to chain up correctly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @error is has been filled in with an error from
  @res, %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </instance-parameter>
        </parameters>
      </method>
    </interface>
    <record name="AsyncResultIface" c:type="GAsyncResultIface" glib:is-gtype-struct-for="AsyncResult">
      <doc xml:space="preserve">Interface definition for #GAsyncResult.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_user_data">
        <callback name="get_user_data">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">the user data for @res.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </return-value>
          <parameters>
            <parameter name="res" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_source_object">
        <callback name="get_source_object">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">a new reference to the source
   object for the @res, or %NULL if there is none.</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </return-value>
          <parameters>
            <parameter name="res" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_tagged">
        <callback name="is_tagged">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @res has the indicated @source_tag, %FALSE if
  not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="res" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
            <parameter name="source_tag" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">an application-defined tag</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="BufferedInputStream" c:symbol-prefix="buffered_input_stream" c:type="GBufferedInputStream" parent="FilterInputStream" glib:type-name="GBufferedInputStream" glib:get-type="g_buffered_input_stream_get_type" glib:type-struct="BufferedInputStreamClass">
      <doc xml:space="preserve">Buffered input stream implements #GFilterInputStream and provides
for buffered reads.

By default, #GBufferedInputStream's buffer size is set at 4 kilobytes.

To create a buffered input stream, use g_buffered_input_stream_new(),
or g_buffered_input_stream_new_sized() to specify the buffer's size at
construction.

To get the size of a buffer within a buffered input stream, use
g_buffered_input_stream_get_buffer_size(). To change the size of a
buffered input stream's buffer, use
g_buffered_input_stream_set_buffer_size(). Note that the buffer's size
cannot be reduced below the size of the data within the buffer.</doc>
      <implements name="Seekable"/>
      <constructor name="new" c:identifier="g_buffered_input_stream_new">
        <doc xml:space="preserve">Creates a new #GInputStream from the given @base_stream, with
a buffer set to the default size (4 kilobytes).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GInputStream for the given @base_stream.</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="base_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_sized" c:identifier="g_buffered_input_stream_new_sized">
        <doc xml:space="preserve">Creates a new #GBufferedInputStream from the given @base_stream,
with a buffer set to @size.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GInputStream.</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="base_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">a #gsize</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="fill" invoker="fill" throws="1">
        <doc xml:space="preserve">Tries to read @count bytes from the stream into the buffer.
Will block during this read.

If @count is zero, returns zero and does nothing. A value of @count
larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.

On success, the number of bytes read into the buffer is returned.
It is not an error if this is not the same as the requested size, as it
can happen e.g. near the end of a file. Zero is returned on end of file
(or if @count is zero),  but never otherwise.

If @count is -1 then the attempted read size is equal to the number of
bytes that are required to fill the buffer.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.

On error -1 is returned and @error is set accordingly.

For the asynchronous, non-blocking, version of this function, see
g_buffered_input_stream_fill_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes read into @stream's buffer, up to @count,
    or -1 on error.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GBufferedInputStream</doc>
            <type name="BufferedInputStream" c:type="GBufferedInputStream*"/>
          </instance-parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes that will be read from the stream</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="fill_async" invoker="fill_async">
        <doc xml:space="preserve">Reads data into @stream's buffer asynchronously, up to @count size.
@io_priority can be used to prioritize reads. For the synchronous
version of this function, see g_buffered_input_stream_fill().

If @count is -1 then the attempted read size is equal to the number
of bytes that are required to fill the buffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GBufferedInputStream</doc>
            <type name="BufferedInputStream" c:type="GBufferedInputStream*"/>
          </instance-parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes that will be read from the stream</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">a #gpointer</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="fill_finish" invoker="fill_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous read.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #gssize of the read stream, or `-1` on an error.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GBufferedInputStream</doc>
            <type name="BufferedInputStream" c:type="GBufferedInputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="fill" c:identifier="g_buffered_input_stream_fill" throws="1">
        <doc xml:space="preserve">Tries to read @count bytes from the stream into the buffer.
Will block during this read.

If @count is zero, returns zero and does nothing. A value of @count
larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.

On success, the number of bytes read into the buffer is returned.
It is not an error if this is not the same as the requested size, as it
can happen e.g. near the end of a file. Zero is returned on end of file
(or if @count is zero),  but never otherwise.

If @count is -1 then the attempted read size is equal to the number of
bytes that are required to fill the buffer.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.

On error -1 is returned and @error is set accordingly.

For the asynchronous, non-blocking, version of this function, see
g_buffered_input_stream_fill_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes read into @stream's buffer, up to @count,
    or -1 on error.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GBufferedInputStream</doc>
            <type name="BufferedInputStream" c:type="GBufferedInputStream*"/>
          </instance-parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes that will be read from the stream</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="fill_async" c:identifier="g_buffered_input_stream_fill_async">
        <doc xml:space="preserve">Reads data into @stream's buffer asynchronously, up to @count size.
@io_priority can be used to prioritize reads. For the synchronous
version of this function, see g_buffered_input_stream_fill().

If @count is -1 then the attempted read size is equal to the number
of bytes that are required to fill the buffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GBufferedInputStream</doc>
            <type name="BufferedInputStream" c:type="GBufferedInputStream*"/>
          </instance-parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes that will be read from the stream</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #gpointer</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="fill_finish" c:identifier="g_buffered_input_stream_fill_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous read.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #gssize of the read stream, or `-1` on an error.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GBufferedInputStream</doc>
            <type name="BufferedInputStream" c:type="GBufferedInputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_available" c:identifier="g_buffered_input_stream_get_available">
        <doc xml:space="preserve">Gets the size of the available data within the stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">size of the available stream.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">#GBufferedInputStream</doc>
            <type name="BufferedInputStream" c:type="GBufferedInputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_buffer_size" c:identifier="g_buffered_input_stream_get_buffer_size">
        <doc xml:space="preserve">Gets the size of the input buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current buffer size.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GBufferedInputStream</doc>
            <type name="BufferedInputStream" c:type="GBufferedInputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek" c:identifier="g_buffered_input_stream_peek">
        <doc xml:space="preserve">Peeks in the buffer, copying data of size @count into @buffer,
offset @offset bytes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #gsize of the number of bytes peeked, or -1 on error.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GBufferedInputStream</doc>
            <type name="BufferedInputStream" c:type="GBufferedInputStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to
  an allocated chunk of memory</doc>
            <array length="2" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">a #gsize</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">a #gsize</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_buffer" c:identifier="g_buffered_input_stream_peek_buffer">
        <doc xml:space="preserve">Returns the buffer with the currently available bytes. The returned
buffer must not be modified and will become invalid when reading from
the stream or filling the buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">
         read-only buffer</doc>
          <array length="0" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GBufferedInputStream</doc>
            <type name="BufferedInputStream" c:type="GBufferedInputStream*"/>
          </instance-parameter>
          <parameter name="count" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">a #gsize to get the number of bytes available in the buffer</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_byte" c:identifier="g_buffered_input_stream_read_byte" throws="1">
        <doc xml:space="preserve">Tries to read a single byte from the stream or the buffer. Will block
during this read.

On success, the byte read from the stream is returned. On end of stream
-1 is returned but it's not an exceptional error and @error is not set.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.

On error -1 is returned and @error is set accordingly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the byte read from the @stream, or -1 on end of stream or error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GBufferedInputStream</doc>
            <type name="BufferedInputStream" c:type="GBufferedInputStream*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_buffer_size" c:identifier="g_buffered_input_stream_set_buffer_size">
        <doc xml:space="preserve">Sets the size of the internal buffer of @stream to @size, or to the
size of the contents of the buffer. The buffer can never be resized
smaller than its current contents.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GBufferedInputStream</doc>
            <type name="BufferedInputStream" c:type="GBufferedInputStream*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">a #gsize</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <property name="buffer-size" writable="1" construct="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent_instance">
        <type name="FilterInputStream" c:type="GFilterInputStream"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="BufferedInputStreamPrivate" c:type="GBufferedInputStreamPrivate*"/>
      </field>
    </class>
    <record name="BufferedInputStreamClass" c:type="GBufferedInputStreamClass" glib:is-gtype-struct-for="BufferedInputStream">
      <field name="parent_class">
        <type name="FilterInputStreamClass" c:type="GFilterInputStreamClass"/>
      </field>
      <field name="fill">
        <callback name="fill" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes read into @stream's buffer, up to @count,
    or -1 on error.</doc>
            <type name="gssize" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GBufferedInputStream</doc>
              <type name="BufferedInputStream" c:type="GBufferedInputStream*"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <doc xml:space="preserve">the number of bytes that will be read from the stream</doc>
              <type name="gssize" c:type="gssize"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="fill_async">
        <callback name="fill_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GBufferedInputStream</doc>
              <type name="BufferedInputStream" c:type="GBufferedInputStream*"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <doc xml:space="preserve">the number of bytes that will be read from the stream</doc>
              <type name="gssize" c:type="gssize"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">a #GAsyncReadyCallback</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">a #gpointer</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="fill_finish">
        <callback name="fill_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">a #gssize of the read stream, or `-1` on an error.</doc>
            <type name="gssize" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GBufferedInputStream</doc>
              <type name="BufferedInputStream" c:type="GBufferedInputStream*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="BufferedInputStreamPrivate" c:type="GBufferedInputStreamPrivate" disguised="1">
    </record>
    <class name="BufferedOutputStream" c:symbol-prefix="buffered_output_stream" c:type="GBufferedOutputStream" parent="FilterOutputStream" glib:type-name="GBufferedOutputStream" glib:get-type="g_buffered_output_stream_get_type" glib:type-struct="BufferedOutputStreamClass">
      <doc xml:space="preserve">Buffered output stream implements #GFilterOutputStream and provides
for buffered writes.

By default, #GBufferedOutputStream's buffer size is set at 4 kilobytes.

To create a buffered output stream, use g_buffered_output_stream_new(),
or g_buffered_output_stream_new_sized() to specify the buffer's size
at construction.

To get the size of a buffer within a buffered input stream, use
g_buffered_output_stream_get_buffer_size(). To change the size of a
buffered output stream's buffer, use
g_buffered_output_stream_set_buffer_size(). Note that the buffer's
size cannot be reduced below the size of the data within the buffer.</doc>
      <implements name="Seekable"/>
      <constructor name="new" c:identifier="g_buffered_output_stream_new">
        <doc xml:space="preserve">Creates a new buffered output stream for a base stream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GOutputStream for the given @base_stream.</doc>
          <type name="OutputStream" c:type="GOutputStream*"/>
        </return-value>
        <parameters>
          <parameter name="base_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_sized" c:identifier="g_buffered_output_stream_new_sized">
        <doc xml:space="preserve">Creates a new buffered output stream with a given buffer size.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GOutputStream with an internal buffer set to @size.</doc>
          <type name="OutputStream" c:type="GOutputStream*"/>
        </return-value>
        <parameters>
          <parameter name="base_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">a #gsize.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_auto_grow" c:identifier="g_buffered_output_stream_get_auto_grow">
        <doc xml:space="preserve">Checks if the buffer automatically grows as data is added.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @stream's buffer automatically grows,
%FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GBufferedOutputStream.</doc>
            <type name="BufferedOutputStream" c:type="GBufferedOutputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_buffer_size" c:identifier="g_buffered_output_stream_get_buffer_size">
        <doc xml:space="preserve">Gets the size of the buffer in the @stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current size of the buffer.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GBufferedOutputStream.</doc>
            <type name="BufferedOutputStream" c:type="GBufferedOutputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_auto_grow" c:identifier="g_buffered_output_stream_set_auto_grow">
        <doc xml:space="preserve">Sets whether or not the @stream's buffer should automatically grow.
If @auto_grow is true, then each write will just make the buffer
larger, and you must manually flush the buffer to actually write out
the data to the underlying stream.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GBufferedOutputStream.</doc>
            <type name="BufferedOutputStream" c:type="GBufferedOutputStream*"/>
          </instance-parameter>
          <parameter name="auto_grow" transfer-ownership="none">
            <doc xml:space="preserve">a #gboolean.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_buffer_size" c:identifier="g_buffered_output_stream_set_buffer_size">
        <doc xml:space="preserve">Sets the size of the internal buffer to @size.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GBufferedOutputStream.</doc>
            <type name="BufferedOutputStream" c:type="GBufferedOutputStream*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">a #gsize.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <property name="auto-grow" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="buffer-size" writable="1" construct="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent_instance">
        <type name="FilterOutputStream" c:type="GFilterOutputStream"/>
      </field>
      <field name="priv">
        <type name="BufferedOutputStreamPrivate" c:type="GBufferedOutputStreamPrivate*"/>
      </field>
    </class>
    <record name="BufferedOutputStreamClass" c:type="GBufferedOutputStreamClass" glib:is-gtype-struct-for="BufferedOutputStream">
      <field name="parent_class">
        <type name="FilterOutputStreamClass" c:type="GFilterOutputStreamClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="BufferedOutputStreamPrivate" c:type="GBufferedOutputStreamPrivate" disguised="1">
    </record>
    <callback name="BusAcquiredCallback" c:type="GBusAcquiredCallback" version="2.26">
      <doc xml:space="preserve">Invoked when a connection to a message bus has been obtained.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">The #GDBusConnection to a message bus.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">The name that is requested to be owned.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">User data passed to g_bus_own_name().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BusNameAcquiredCallback" c:type="GBusNameAcquiredCallback" version="2.26">
      <doc xml:space="preserve">Invoked when the name is acquired.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">The #GDBusConnection on which to acquired the name.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">The name being owned.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">User data passed to g_bus_own_name() or g_bus_own_name_on_connection().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BusNameAppearedCallback" c:type="GBusNameAppearedCallback" version="2.26">
      <doc xml:space="preserve">Invoked when the name being watched is known to have to have a owner.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">The #GDBusConnection the name is being watched on.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">The name being watched.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="name_owner" transfer-ownership="none">
          <doc xml:space="preserve">Unique name of the owner of the name being watched.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
          <doc xml:space="preserve">User data passed to g_bus_watch_name().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BusNameLostCallback" c:type="GBusNameLostCallback" version="2.26">
      <doc xml:space="preserve">Invoked when the name is lost or @connection has been closed.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">The #GDBusConnection on which to acquire the name or %NULL if
the connection was disconnected.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">The name being owned.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">User data passed to g_bus_own_name() or g_bus_own_name_on_connection().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="BusNameOwnerFlags" version="2.26" glib:type-name="GBusNameOwnerFlags" glib:get-type="g_bus_name_owner_flags_get_type" c:type="GBusNameOwnerFlags">
      <doc xml:space="preserve">Flags used in g_bus_own_name().</doc>
      <member name="none" value="0" c:identifier="G_BUS_NAME_OWNER_FLAGS_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
      <member name="allow_replacement" value="1" c:identifier="G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT" glib:nick="allow-replacement">
        <doc xml:space="preserve">Allow another message bus connection to claim the name.</doc>
      </member>
      <member name="replace" value="2" c:identifier="G_BUS_NAME_OWNER_FLAGS_REPLACE" glib:nick="replace">
        <doc xml:space="preserve">If another message bus connection owns the name and have
specified #G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, then take the name from the other connection.</doc>
      </member>
      <member name="do_not_queue" value="4" c:identifier="G_BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE" glib:nick="do-not-queue">
        <doc xml:space="preserve">If another message bus connection owns the name, immediately
return an error from g_bus_own_name() rather than entering the waiting queue for that name. (Since 2.54)</doc>
      </member>
    </bitfield>
    <callback name="BusNameVanishedCallback" c:type="GBusNameVanishedCallback" version="2.26">
      <doc xml:space="preserve">Invoked when the name being watched is known not to have to have a owner.

This is also invoked when the #GDBusConnection on which the watch was
established has been closed.  In that case, @connection will be
%NULL.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">The #GDBusConnection the name is being watched on, or
    %NULL.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">The name being watched.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">User data passed to g_bus_watch_name().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="BusNameWatcherFlags" version="2.26" glib:type-name="GBusNameWatcherFlags" glib:get-type="g_bus_name_watcher_flags_get_type" c:type="GBusNameWatcherFlags">
      <doc xml:space="preserve">Flags used in g_bus_watch_name().</doc>
      <member name="none" value="0" c:identifier="G_BUS_NAME_WATCHER_FLAGS_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
      <member name="auto_start" value="1" c:identifier="G_BUS_NAME_WATCHER_FLAGS_AUTO_START" glib:nick="auto-start">
        <doc xml:space="preserve">If no-one owns the name when
beginning to watch the name, ask the bus to launch an owner for the
name.</doc>
      </member>
    </bitfield>
    <enumeration name="BusType" version="2.26" glib:type-name="GBusType" glib:get-type="g_bus_type_get_type" c:type="GBusType">
      <doc xml:space="preserve">An enumeration for well-known message buses.</doc>
      <member name="starter" value="-1" c:identifier="G_BUS_TYPE_STARTER" glib:nick="starter">
        <doc xml:space="preserve">An alias for the message bus that activated the process, if any.</doc>
      </member>
      <member name="none" value="0" c:identifier="G_BUS_TYPE_NONE" glib:nick="none">
        <doc xml:space="preserve">Not a message bus.</doc>
      </member>
      <member name="system" value="1" c:identifier="G_BUS_TYPE_SYSTEM" glib:nick="system">
        <doc xml:space="preserve">The system-wide message bus.</doc>
      </member>
      <member name="session" value="2" c:identifier="G_BUS_TYPE_SESSION" glib:nick="session">
        <doc xml:space="preserve">The login session message bus.</doc>
      </member>
    </enumeration>
    <class name="BytesIcon" c:symbol-prefix="bytes_icon" c:type="GBytesIcon" parent="GObject.Object" glib:type-name="GBytesIcon" glib:get-type="g_bytes_icon_get_type">
      <doc xml:space="preserve">#GBytesIcon specifies an image held in memory in a common format (usually
png) to be used as icon.</doc>
      <implements name="Icon"/>
      <implements name="LoadableIcon"/>
      <constructor name="new" c:identifier="g_bytes_icon_new" version="2.38">
        <doc xml:space="preserve">Creates a new icon for a bytes.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GIcon for the given
  @bytes, or %NULL on error.</doc>
          <type name="BytesIcon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve">a #GBytes.</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_bytes" c:identifier="g_bytes_icon_get_bytes" version="2.38">
        <doc xml:space="preserve">Gets the #GBytes associated with the given @icon.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GBytes, or %NULL.</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">a #GIcon.</doc>
            <type name="BytesIcon" c:type="GBytesIcon*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="bytes" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The bytes containing the icon.</doc>
        <type name="GLib.Bytes"/>
      </property>
    </class>
    <class name="Cancellable" c:symbol-prefix="cancellable" c:type="GCancellable" parent="GObject.Object" glib:type-name="GCancellable" glib:get-type="g_cancellable_get_type" glib:type-struct="CancellableClass">
      <doc xml:space="preserve">GCancellable is a thread-safe operation cancellation stack used
throughout GIO to allow for cancellation of synchronous and
asynchronous operations.</doc>
      <constructor name="new" c:identifier="g_cancellable_new">
        <doc xml:space="preserve">Creates a new #GCancellable object.

Applications that want to start one or more operations
that should be cancellable should create a #GCancellable
and pass it to the operations.

One #GCancellable can be used in multiple consecutive
operations or in multiple concurrent operations.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GCancellable.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </return-value>
      </constructor>
      <function name="get_current" c:identifier="g_cancellable_get_current">
        <doc xml:space="preserve">Gets the top cancellable from the stack.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #GCancellable from the top
of the stack, or %NULL if the stack is empty.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </return-value>
      </function>
      <virtual-method name="cancelled">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="Cancellable" c:type="GCancellable*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="cancel" c:identifier="g_cancellable_cancel">
        <doc xml:space="preserve">Will set @cancellable to cancelled, and will emit the
#GCancellable::cancelled signal. (However, see the warning about
race conditions in the documentation for that signal if you are
planning to connect to it.)

This function is thread-safe. In other words, you can safely call
it from a thread other than the one running the operation that was
passed the @cancellable.

If @cancellable is %NULL, this function returns immediately for convenience.

The convention within GIO is that cancelling an asynchronous
operation causes it to complete asynchronously. That is, if you
cancel the operation from the same thread in which it is running,
then the operation's #GAsyncReadyCallback will not be invoked until
the application returns to the main loop.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable object.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="connect" c:identifier="g_cancellable_connect" version="2.22">
        <doc xml:space="preserve">Convenience function to connect to the #GCancellable::cancelled
signal. Also handles the race condition that may happen
if the cancellable is cancelled right before connecting.

@callback is called at most once, either directly at the
time of the connect if @cancellable is already cancelled,
or when @cancellable is cancelled in some thread.

@data_destroy_func will be called when the handler is
disconnected, or immediately if the cancellable is already
cancelled.

See #GCancellable::cancelled for details on how to use this.

Since GLib 2.40, the lock protecting @cancellable is not held when
@callback is invoked.  This lifts a restriction in place for
earlier GLib versions which now makes it easier to write cleanup
code that unconditionally invokes e.g. g_cancellable_cancel().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The id of the signal handler or 0 if @cancellable has already
         been cancelled.</doc>
          <type name="gulong" c:type="gulong"/>
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GCancellable.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </instance-parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="1" destroy="2">
            <doc xml:space="preserve">The #GCallback to connect.</doc>
            <type name="GObject.Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Data to pass to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="data_destroy_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">Free function for @data or %NULL.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="disconnect" c:identifier="g_cancellable_disconnect" version="2.22">
        <doc xml:space="preserve">Disconnects a handler from a cancellable instance similar to
g_signal_handler_disconnect().  Additionally, in the event that a
signal handler is currently running, this call will block until the
handler has finished.  Calling this function from a
#GCancellable::cancelled signal handler will therefore result in a
deadlock.

This avoids a race condition where a thread cancels at the
same time as the cancellable operation is finished and the
signal handler is removed. See #GCancellable::cancelled for
details on how to use this.

If @cancellable is %NULL or @handler_id is `0` this function does
nothing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </instance-parameter>
          <parameter name="handler_id" transfer-ownership="none">
            <doc xml:space="preserve">Handler id of the handler to be disconnected, or `0`.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_fd" c:identifier="g_cancellable_get_fd">
        <doc xml:space="preserve">Gets the file descriptor for a cancellable job. This can be used to
implement cancellable operations on Unix systems. The returned fd will
turn readable when @cancellable is cancelled.

You are not supposed to read from the fd yourself, just check for
readable status. Reading to unset the readable status is done
with g_cancellable_reset().

After a successful return from this function, you should use
g_cancellable_release_fd() to free up resources allocated for
the returned file descriptor.

See also g_cancellable_make_pollfd().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A valid file descriptor. %-1 if the file descriptor
is not supported, or on errors.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_cancelled" c:identifier="g_cancellable_is_cancelled">
        <doc xml:space="preserve">Checks if a cancellable job has been cancelled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @cancellable is cancelled,
FALSE if called with %NULL or if item is not cancelled.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="make_pollfd" c:identifier="g_cancellable_make_pollfd" version="2.22">
        <doc xml:space="preserve">Creates a #GPollFD corresponding to @cancellable; this can be passed
to g_poll() and used to poll for cancellation. This is useful both
for unix systems without a native poll and for portability to
windows.

When this function returns %TRUE, you should use
g_cancellable_release_fd() to free up resources allocated for the
@pollfd. After a %FALSE return, do not call g_cancellable_release_fd().

If this function returns %FALSE, either no @cancellable was given or
resource limits prevent this function from allocating the necessary
structures for polling. (On Linux, you will likely have reached
the maximum number of file descriptors.) The suggested way to handle
these cases is to ignore the @cancellable.

You are not supposed to read from the fd yourself, just check for
readable status. Reading to unset the readable status is done
with g_cancellable_reset().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @pollfd was successfully initialized, %FALSE on
         failure to prepare the cancellable.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </instance-parameter>
          <parameter name="pollfd" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to a #GPollFD</doc>
            <type name="GLib.PollFD" c:type="GPollFD*"/>
          </parameter>
        </parameters>
      </method>
      <method name="pop_current" c:identifier="g_cancellable_pop_current">
        <doc xml:space="preserve">Pops @cancellable off the cancellable stack (verifying that @cancellable
is on the top of the stack).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="push_current" c:identifier="g_cancellable_push_current">
        <doc xml:space="preserve">Pushes @cancellable onto the cancellable stack. The current
cancellable can then be received using g_cancellable_get_current().

This is useful when implementing cancellable operations in
code that does not allow you to pass down the cancellable object.

This is typically called automatically by e.g. #GFile operations,
so you rarely have to call this yourself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="release_fd" c:identifier="g_cancellable_release_fd" version="2.22">
        <doc xml:space="preserve">Releases a resources previously allocated by g_cancellable_get_fd()
or g_cancellable_make_pollfd().

For compatibility reasons with older releases, calling this function
is not strictly required, the resources will be automatically freed
when the @cancellable is finalized. However, the @cancellable will
block scarce file descriptors until it is finalized if this function
is not called. This can cause the application to run out of file
descriptors when many #GCancellables are used at the same time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reset" c:identifier="g_cancellable_reset">
        <doc xml:space="preserve">Resets @cancellable to its uncancelled state.

If cancellable is currently in use by any cancellable operation
then the behavior of this function is undefined.

Note that it is generally not a good idea to reuse an existing
cancellable for more operations after it has been cancelled once,
as this function might tempt you to do. The recommended practice
is to drop the reference to a cancellable after cancelling it,
and let it die with the outstanding async operations. You should
create a fresh cancellable for further async operations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable object.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_error_if_cancelled" c:identifier="g_cancellable_set_error_if_cancelled" throws="1">
        <doc xml:space="preserve">If the @cancellable is cancelled, sets the error to notify
that the operation was cancelled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @cancellable was cancelled, %FALSE if it was not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="source_new" c:identifier="g_cancellable_source_new" version="2.28" introspectable="0">
        <doc xml:space="preserve">Creates a source that triggers if @cancellable is cancelled and
calls its callback of type #GCancellableSourceFunc. This is
primarily useful for attaching to another (non-cancellable) source
with g_source_add_child_source() to add cancellability to it.

For convenience, you can call this with a %NULL #GCancellable,
in which case the source will never trigger.

The new #GSource will hold a reference to the #GCancellable.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #GSource.</doc>
          <type name="GLib.Source" c:type="GSource*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="CancellablePrivate" c:type="GCancellablePrivate*"/>
      </field>
      <glib:signal name="cancelled" when="last">
        <doc xml:space="preserve">Emitted when the operation has been cancelled.

Can be used by implementations of cancellable operations. If the
operation is cancelled from another thread, the signal will be
emitted in the thread that cancelled the operation, not the
thread that is running the operation.

Note that disconnecting from this signal (or any signal) in a
multi-threaded program is prone to race conditions. For instance
it is possible that a signal handler may be invoked even after
a call to g_signal_handler_disconnect() for that handler has
already returned.

There is also a problem when cancellation happens right before
connecting to the signal. If this happens the signal will
unexpectedly not be emitted, and checking before connecting to
the signal leaves a race condition where this is still happening.

In order to make it safe and easy to connect handlers there
are two helper functions: g_cancellable_connect() and
g_cancellable_disconnect() which protect against problems
like this.

An example of how to us this:
|[&lt;!-- language="C" --&gt;
    // Make sure we don't do unnecessary work if already cancelled
    if (g_cancellable_set_error_if_cancelled (cancellable, error))
      return;

    // Set up all the data needed to be able to handle cancellation
    // of the operation
    my_data = my_data_new (...);

    id = 0;
    if (cancellable)
      id = g_cancellable_connect (cancellable,
    			      G_CALLBACK (cancelled_handler)
    			      data, NULL);

    // cancellable operation here...

    g_cancellable_disconnect (cancellable, id);

    // cancelled_handler is never called after this, it is now safe
    // to free the data
    my_data_free (my_data);
]|

Note that the cancelled signal is emitted in the thread that
the user cancelled from, which may be the main thread. So, the
cancellable signal should not do something that can block.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="CancellableClass" c:type="GCancellableClass" glib:is-gtype-struct-for="Cancellable">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="cancelled">
        <callback name="cancelled">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="CancellablePrivate" c:type="GCancellablePrivate" disguised="1">
    </record>
    <callback name="CancellableSourceFunc" c:type="GCancellableSourceFunc" version="2.28">
      <doc xml:space="preserve">This is the function type of the callback used for the #GSource
returned by g_cancellable_source_new().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">it should return %FALSE if the source should be removed.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the #GCancellable</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="1">
          <doc xml:space="preserve">data passed in by the user.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="CharsetConverter" c:symbol-prefix="charset_converter" c:type="GCharsetConverter" parent="GObject.Object" glib:type-name="GCharsetConverter" glib:get-type="g_charset_converter_get_type" glib:type-struct="CharsetConverterClass">
      <doc xml:space="preserve">#GCharsetConverter is an implementation of #GConverter based on
GIConv.</doc>
      <implements name="Converter"/>
      <implements name="Initable"/>
      <constructor name="new" c:identifier="g_charset_converter_new" version="2.24" throws="1">
        <doc xml:space="preserve">Creates a new #GCharsetConverter.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GCharsetConverter or %NULL on error.</doc>
          <type name="CharsetConverter" c:type="GCharsetConverter*"/>
        </return-value>
        <parameters>
          <parameter name="to_charset" transfer-ownership="none">
            <doc xml:space="preserve">destination charset</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="from_charset" transfer-ownership="none">
            <doc xml:space="preserve">source charset</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_num_fallbacks" c:identifier="g_charset_converter_get_num_fallbacks" version="2.24">
        <doc xml:space="preserve">Gets the number of fallbacks that @converter has applied so far.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of fallbacks that @converter has applied</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="converter" transfer-ownership="none">
            <doc xml:space="preserve">a #GCharsetConverter</doc>
            <type name="CharsetConverter" c:type="GCharsetConverter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_use_fallback" c:identifier="g_charset_converter_get_use_fallback" version="2.24">
        <doc xml:space="preserve">Gets the #GCharsetConverter:use-fallback property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if fallbacks are used by @converter</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="converter" transfer-ownership="none">
            <doc xml:space="preserve">a #GCharsetConverter</doc>
            <type name="CharsetConverter" c:type="GCharsetConverter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_use_fallback" c:identifier="g_charset_converter_set_use_fallback" version="2.24">
        <doc xml:space="preserve">Sets the #GCharsetConverter:use-fallback property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="converter" transfer-ownership="none">
            <doc xml:space="preserve">a #GCharsetConverter</doc>
            <type name="CharsetConverter" c:type="GCharsetConverter*"/>
          </instance-parameter>
          <parameter name="use_fallback" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to use fallbacks</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="from-charset" writable="1" construct-only="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="to-charset" writable="1" construct-only="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="use-fallback" writable="1" construct="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
    </class>
    <record name="CharsetConverterClass" c:type="GCharsetConverterClass" glib:is-gtype-struct-for="CharsetConverter">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <interface name="Converter" c:symbol-prefix="converter" c:type="GConverter" version="2.24" glib:type-name="GConverter" glib:get-type="g_converter_get_type" glib:type-struct="ConverterIface">
      <doc xml:space="preserve">#GConverter is implemented by objects that convert
binary data in various ways. The conversion can be
stateful and may fail at any place.

Some example conversions are: character set conversion,
compression, decompression and regular expression
replace.</doc>
      <virtual-method name="convert" invoker="convert" version="2.24" throws="1">
        <doc xml:space="preserve">This is the main operation used when converting data. It is to be called
multiple times in a loop, and each time it will do some work, i.e.
producing some output (in @outbuf) or consuming some input (from @inbuf) or
both. If its not possible to do any work an error is returned.

Note that a single call may not consume all input (or any input at all).
Also a call may produce output even if given no input, due to state stored
in the converter producing output.

If any data was either produced or consumed, and then an error happens, then
only the successful conversion is reported and the error is returned on the
next call.

A full conversion loop involves calling this method repeatedly, each time
giving it new input and space output space. When there is no more input
data after the data in @inbuf, the flag %G_CONVERTER_INPUT_AT_END must be set.
The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
each time until all data is consumed and all output is produced, then
%G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
in a decompression converter where the end of data is detectable from the
data (and there might even be other data after the end of the compressed data).

When some data has successfully been converted @bytes_read and is set to
the number of bytes read from @inbuf, and @bytes_written is set to indicate
how many bytes was written to @outbuf. If there are more data to output
or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
%G_CONVERTER_CONVERTED is returned, and if no more data is to be output
then %G_CONVERTER_FINISHED is returned.

On error %G_CONVERTER_ERROR is returned and @error is set accordingly.
Some errors need special handling:

%G_IO_ERROR_NO_SPACE is returned if there is not enough space
to write the resulting converted data, the application should
call the function again with a larger @outbuf to continue.

%G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
input to fully determine what the conversion should produce,
and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
example with an incomplete multibyte sequence when converting text,
or when a regexp matches up to the end of the input (and may match
further input). It may also happen when @inbuf_size is zero and
there is no more data to produce.

When this happens the application should read more input and then
call the function again. If further input shows that there is no
more data call the function again with the same data but with
the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
to finish as e.g. in the regexp match case (or, to fail again with
%G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
input is actually partial).

After g_converter_convert() has returned %G_CONVERTER_FINISHED the
converter object is in an invalid state where its not allowed
to call g_converter_convert() anymore. At this time you can only
free the object or call g_converter_reset() to reset it to the
initial state.

If the flag %G_CONVERTER_FLUSH is set then conversion is modified
to try to write out all internal state to the output. The application
has to call the function multiple times with the flag set, and when
the available input has been consumed and all internal state has
been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
really at the end) is returned instead of %G_CONVERTER_CONVERTED.
This is somewhat similar to what happens at the end of the input stream,
but done in the middle of the data.

This has different meanings for different conversions. For instance
in a compression converter it would mean that we flush all the
compression state into output such that if you uncompress the
compressed data you get back all the input data. Doing this may
make the final file larger due to padding though. Another example
is a regexp conversion, where if you at the end of the flushed data
have a match, but there is also a potential longer match. In the
non-flushed case we would ask for more input, but when flushing we
treat this as the end of input and do the match.

Flushing is not always possible (like if a charset converter flushes
at a partial multibyte sequence). Converters are supposed to try
to produce as much output as possible and then return an error
(typically %G_IO_ERROR_PARTIAL_INPUT).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GConverterResult, %G_CONVERTER_ERROR on error.</doc>
          <type name="ConverterResult" c:type="GConverterResult"/>
        </return-value>
        <parameters>
          <instance-parameter name="converter" transfer-ownership="none">
            <doc xml:space="preserve">a #GConverter.</doc>
            <type name="Converter" c:type="GConverter*"/>
          </instance-parameter>
          <parameter name="inbuf" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the buffer
        containing the data to convert.</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="inbuf_size" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes in @inbuf</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="outbuf" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a buffer to write
   converted data in.</doc>
            <array length="3" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="outbuf_size" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes in @outbuf, must be at least one</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a #GConverterFlags controlling the conversion details</doc>
            <type name="ConverterFlags" c:type="GConverterFlags"/>
          </parameter>
          <parameter name="bytes_read" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">will be set to the number of bytes read from @inbuf on success</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">will be set to the number of bytes written to @outbuf on success</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="reset" invoker="reset" version="2.24">
        <doc xml:space="preserve">Resets all internal state in the converter, making it behave
as if it was just created. If the converter has any internal
state that would produce output then that output is lost.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="converter" transfer-ownership="none">
            <doc xml:space="preserve">a #GConverter.</doc>
            <type name="Converter" c:type="GConverter*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="convert" c:identifier="g_converter_convert" version="2.24" throws="1">
        <doc xml:space="preserve">This is the main operation used when converting data. It is to be called
multiple times in a loop, and each time it will do some work, i.e.
producing some output (in @outbuf) or consuming some input (from @inbuf) or
both. If its not possible to do any work an error is returned.

Note that a single call may not consume all input (or any input at all).
Also a call may produce output even if given no input, due to state stored
in the converter producing output.

If any data was either produced or consumed, and then an error happens, then
only the successful conversion is reported and the error is returned on the
next call.

A full conversion loop involves calling this method repeatedly, each time
giving it new input and space output space. When there is no more input
data after the data in @inbuf, the flag %G_CONVERTER_INPUT_AT_END must be set.
The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
each time until all data is consumed and all output is produced, then
%G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
in a decompression converter where the end of data is detectable from the
data (and there might even be other data after the end of the compressed data).

When some data has successfully been converted @bytes_read and is set to
the number of bytes read from @inbuf, and @bytes_written is set to indicate
how many bytes was written to @outbuf. If there are more data to output
or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
%G_CONVERTER_CONVERTED is returned, and if no more data is to be output
then %G_CONVERTER_FINISHED is returned.

On error %G_CONVERTER_ERROR is returned and @error is set accordingly.
Some errors need special handling:

%G_IO_ERROR_NO_SPACE is returned if there is not enough space
to write the resulting converted data, the application should
call the function again with a larger @outbuf to continue.

%G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
input to fully determine what the conversion should produce,
and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
example with an incomplete multibyte sequence when converting text,
or when a regexp matches up to the end of the input (and may match
further input). It may also happen when @inbuf_size is zero and
there is no more data to produce.

When this happens the application should read more input and then
call the function again. If further input shows that there is no
more data call the function again with the same data but with
the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
to finish as e.g. in the regexp match case (or, to fail again with
%G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
input is actually partial).

After g_converter_convert() has returned %G_CONVERTER_FINISHED the
converter object is in an invalid state where its not allowed
to call g_converter_convert() anymore. At this time you can only
free the object or call g_converter_reset() to reset it to the
initial state.

If the flag %G_CONVERTER_FLUSH is set then conversion is modified
to try to write out all internal state to the output. The application
has to call the function multiple times with the flag set, and when
the available input has been consumed and all internal state has
been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
really at the end) is returned instead of %G_CONVERTER_CONVERTED.
This is somewhat similar to what happens at the end of the input stream,
but done in the middle of the data.

This has different meanings for different conversions. For instance
in a compression converter it would mean that we flush all the
compression state into output such that if you uncompress the
compressed data you get back all the input data. Doing this may
make the final file larger due to padding though. Another example
is a regexp conversion, where if you at the end of the flushed data
have a match, but there is also a potential longer match. In the
non-flushed case we would ask for more input, but when flushing we
treat this as the end of input and do the match.

Flushing is not always possible (like if a charset converter flushes
at a partial multibyte sequence). Converters are supposed to try
to produce as much output as possible and then return an error
(typically %G_IO_ERROR_PARTIAL_INPUT).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GConverterResult, %G_CONVERTER_ERROR on error.</doc>
          <type name="ConverterResult" c:type="GConverterResult"/>
        </return-value>
        <parameters>
          <instance-parameter name="converter" transfer-ownership="none">
            <doc xml:space="preserve">a #GConverter.</doc>
            <type name="Converter" c:type="GConverter*"/>
          </instance-parameter>
          <parameter name="inbuf" transfer-ownership="none">
            <doc xml:space="preserve">the buffer
        containing the data to convert.</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="inbuf_size" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes in @inbuf</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="outbuf" transfer-ownership="none">
            <doc xml:space="preserve">a buffer to write
   converted data in.</doc>
            <array length="3" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="outbuf_size" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes in @outbuf, must be at least one</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a #GConverterFlags controlling the conversion details</doc>
            <type name="ConverterFlags" c:type="GConverterFlags"/>
          </parameter>
          <parameter name="bytes_read" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">will be set to the number of bytes read from @inbuf on success</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">will be set to the number of bytes written to @outbuf on success</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reset" c:identifier="g_converter_reset" version="2.24">
        <doc xml:space="preserve">Resets all internal state in the converter, making it behave
as if it was just created. If the converter has any internal
state that would produce output then that output is lost.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="converter" transfer-ownership="none">
            <doc xml:space="preserve">a #GConverter.</doc>
            <type name="Converter" c:type="GConverter*"/>
          </instance-parameter>
        </parameters>
      </method>
    </interface>
    <bitfield name="ConverterFlags" version="2.24" glib:type-name="GConverterFlags" glib:get-type="g_converter_flags_get_type" c:type="GConverterFlags">
      <doc xml:space="preserve">Flags used when calling a g_converter_convert().</doc>
      <member name="none" value="0" c:identifier="G_CONVERTER_NO_FLAGS" glib:nick="none">
        <doc xml:space="preserve">No flags.</doc>
      </member>
      <member name="input_at_end" value="1" c:identifier="G_CONVERTER_INPUT_AT_END" glib:nick="input-at-end">
        <doc xml:space="preserve">At end of input data</doc>
      </member>
      <member name="flush" value="2" c:identifier="G_CONVERTER_FLUSH" glib:nick="flush">
        <doc xml:space="preserve">Flush data</doc>
      </member>
    </bitfield>
    <record name="ConverterIface" c:type="GConverterIface" glib:is-gtype-struct-for="Converter" version="2.24">
      <doc xml:space="preserve">Provides an interface for converting data from one type
to another type. The conversion can be stateful
and may fail at any place.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="convert">
        <callback name="convert" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">a #GConverterResult, %G_CONVERTER_ERROR on error.</doc>
            <type name="ConverterResult" c:type="GConverterResult"/>
          </return-value>
          <parameters>
            <parameter name="converter" transfer-ownership="none">
              <doc xml:space="preserve">a #GConverter.</doc>
              <type name="Converter" c:type="GConverter*"/>
            </parameter>
            <parameter name="inbuf" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">the buffer
        containing the data to convert.</doc>
              <array length="2" zero-terminated="0" c:type="void*">
                <type name="guint8"/>
              </array>
            </parameter>
            <parameter name="inbuf_size" transfer-ownership="none">
              <doc xml:space="preserve">the number of bytes in @inbuf</doc>
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="outbuf" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a buffer to write
   converted data in.</doc>
              <array length="4" zero-terminated="0" c:type="void*">
                <type name="guint8"/>
              </array>
            </parameter>
            <parameter name="outbuf_size" transfer-ownership="none">
              <doc xml:space="preserve">the number of bytes in @outbuf, must be at least one</doc>
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">a #GConverterFlags controlling the conversion details</doc>
              <type name="ConverterFlags" c:type="GConverterFlags"/>
            </parameter>
            <parameter name="bytes_read" direction="out" caller-allocates="0" transfer-ownership="full">
              <doc xml:space="preserve">will be set to the number of bytes read from @inbuf on success</doc>
              <type name="gsize" c:type="gsize*"/>
            </parameter>
            <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full">
              <doc xml:space="preserve">will be set to the number of bytes written to @outbuf on success</doc>
              <type name="gsize" c:type="gsize*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reset">
        <callback name="reset">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="converter" transfer-ownership="none">
              <doc xml:space="preserve">a #GConverter.</doc>
              <type name="Converter" c:type="GConverter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="ConverterInputStream" c:symbol-prefix="converter_input_stream" c:type="GConverterInputStream" parent="FilterInputStream" glib:type-name="GConverterInputStream" glib:get-type="g_converter_input_stream_get_type" glib:type-struct="ConverterInputStreamClass">
      <doc xml:space="preserve">Converter input stream implements #GInputStream and allows
conversion of data of various types during reading.

As of GLib 2.34, #GConverterInputStream implements
#GPollableInputStream.</doc>
      <implements name="PollableInputStream"/>
      <constructor name="new" c:identifier="g_converter_input_stream_new">
        <doc xml:space="preserve">Creates a new converter input stream for the @base_stream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GInputStream.</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="base_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </parameter>
          <parameter name="converter" transfer-ownership="none">
            <doc xml:space="preserve">a #GConverter</doc>
            <type name="Converter" c:type="GConverter*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_converter" c:identifier="g_converter_input_stream_get_converter" version="2.24">
        <doc xml:space="preserve">Gets the #GConverter that is used by @converter_stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the converter of the converter input stream</doc>
          <type name="Converter" c:type="GConverter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="converter_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GConverterInputStream</doc>
            <type name="ConverterInputStream" c:type="GConverterInputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="converter" writable="1" construct-only="1" transfer-ownership="none">
        <type name="Converter"/>
      </property>
      <field name="parent_instance">
        <type name="FilterInputStream" c:type="GFilterInputStream"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ConverterInputStreamPrivate" c:type="GConverterInputStreamPrivate*"/>
      </field>
    </class>
    <record name="ConverterInputStreamClass" c:type="GConverterInputStreamClass" glib:is-gtype-struct-for="ConverterInputStream">
      <field name="parent_class">
        <type name="FilterInputStreamClass" c:type="GFilterInputStreamClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="ConverterInputStreamPrivate" c:type="GConverterInputStreamPrivate" disguised="1">
    </record>
    <class name="ConverterOutputStream" c:symbol-prefix="converter_output_stream" c:type="GConverterOutputStream" parent="FilterOutputStream" glib:type-name="GConverterOutputStream" glib:get-type="g_converter_output_stream_get_type" glib:type-struct="ConverterOutputStreamClass">
      <doc xml:space="preserve">Converter output stream implements #GOutputStream and allows
conversion of data of various types during reading.

As of GLib 2.34, #GConverterOutputStream implements
#GPollableOutputStream.</doc>
      <implements name="PollableOutputStream"/>
      <constructor name="new" c:identifier="g_converter_output_stream_new">
        <doc xml:space="preserve">Creates a new converter output stream for the @base_stream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GOutputStream.</doc>
          <type name="OutputStream" c:type="GOutputStream*"/>
        </return-value>
        <parameters>
          <parameter name="base_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </parameter>
          <parameter name="converter" transfer-ownership="none">
            <doc xml:space="preserve">a #GConverter</doc>
            <type name="Converter" c:type="GConverter*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_converter" c:identifier="g_converter_output_stream_get_converter" version="2.24">
        <doc xml:space="preserve">Gets the #GConverter that is used by @converter_stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the converter of the converter output stream</doc>
          <type name="Converter" c:type="GConverter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="converter_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GConverterOutputStream</doc>
            <type name="ConverterOutputStream" c:type="GConverterOutputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="converter" writable="1" construct-only="1" transfer-ownership="none">
        <type name="Converter"/>
      </property>
      <field name="parent_instance">
        <type name="FilterOutputStream" c:type="GFilterOutputStream"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ConverterOutputStreamPrivate" c:type="GConverterOutputStreamPrivate*"/>
      </field>
    </class>
    <record name="ConverterOutputStreamClass" c:type="GConverterOutputStreamClass" glib:is-gtype-struct-for="ConverterOutputStream">
      <field name="parent_class">
        <type name="FilterOutputStreamClass" c:type="GFilterOutputStreamClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="ConverterOutputStreamPrivate" c:type="GConverterOutputStreamPrivate" disguised="1">
    </record>
    <enumeration name="ConverterResult" version="2.24" glib:type-name="GConverterResult" glib:get-type="g_converter_result_get_type" c:type="GConverterResult">
      <doc xml:space="preserve">Results returned from g_converter_convert().</doc>
      <member name="error" value="0" c:identifier="G_CONVERTER_ERROR" glib:nick="error">
        <doc xml:space="preserve">There was an error during conversion.</doc>
      </member>
      <member name="converted" value="1" c:identifier="G_CONVERTER_CONVERTED" glib:nick="converted">
        <doc xml:space="preserve">Some data was consumed or produced</doc>
      </member>
      <member name="finished" value="2" c:identifier="G_CONVERTER_FINISHED" glib:nick="finished">
        <doc xml:space="preserve">The conversion is finished</doc>
      </member>
      <member name="flushed" value="3" c:identifier="G_CONVERTER_FLUSHED" glib:nick="flushed">
        <doc xml:space="preserve">Flushing is finished</doc>
      </member>
    </enumeration>
    <class name="Credentials" c:symbol-prefix="credentials" c:type="GCredentials" version="2.26" parent="GObject.Object" glib:type-name="GCredentials" glib:get-type="g_credentials_get_type" glib:type-struct="CredentialsClass">
      <doc xml:space="preserve">The #GCredentials type is a reference-counted wrapper for native
credentials. This information is typically used for identifying,
authenticating and authorizing other processes.

Some operating systems supports looking up the credentials of the
remote peer of a communication endpoint - see e.g.
g_socket_get_credentials().

Some operating systems supports securely sending and receiving
credentials over a Unix Domain Socket, see
#GUnixCredentialsMessage, g_unix_connection_send_credentials() and
g_unix_connection_receive_credentials() for details.

On Linux, the native credential type is a struct ucred - see the
unix(7) man page for details. This corresponds to
%G_CREDENTIALS_TYPE_LINUX_UCRED.

On FreeBSD, Debian GNU/kFreeBSD, and GNU/Hurd, the native
credential type is a struct cmsgcred. This corresponds
to %G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED.

On NetBSD, the native credential type is a struct unpcbid.
This corresponds to %G_CREDENTIALS_TYPE_NETBSD_UNPCBID.

On OpenBSD, the native credential type is a struct sockpeercred.
This corresponds to %G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED.

On Solaris (including OpenSolaris and its derivatives), the native
credential type is a ucred_t. This corresponds to
%G_CREDENTIALS_TYPE_SOLARIS_UCRED.</doc>
      <constructor name="new" c:identifier="g_credentials_new" version="2.26">
        <doc xml:space="preserve">Creates a new #GCredentials object with credentials matching the
the current process.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GCredentials. Free with g_object_unref().</doc>
          <type name="Credentials" c:type="GCredentials*"/>
        </return-value>
      </constructor>
      <method name="get_native" c:identifier="g_credentials_get_native" version="2.26" introspectable="0">
        <doc xml:space="preserve">Gets a pointer to native credentials of type @native_type from
@credentials.

It is a programming error (which will cause an warning to be
logged) to use this method if there is no #GCredentials support for
the OS or if @native_type isn't supported by the OS.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">The pointer to native credentials or %NULL if the
operation there is no #GCredentials support for the OS or if
@native_type isn't supported by the OS. Do not free the returned
data, it is owned by @credentials.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="credentials" transfer-ownership="none">
            <doc xml:space="preserve">A #GCredentials.</doc>
            <type name="Credentials" c:type="GCredentials*"/>
          </instance-parameter>
          <parameter name="native_type" transfer-ownership="none">
            <doc xml:space="preserve">The type of native credentials to get.</doc>
            <type name="CredentialsType" c:type="GCredentialsType"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_unix_pid" c:identifier="g_credentials_get_unix_pid" version="2.36" throws="1">
        <doc xml:space="preserve">Tries to get the UNIX process identifier from @credentials. This
method is only available on UNIX platforms.

This operation can fail if #GCredentials is not supported on the
OS or if the native credentials type does not contain information
about the UNIX process ID.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The UNIX process ID, or -1 if @error is set.</doc>
          <type name="gint" c:type="pid_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="credentials" transfer-ownership="none">
            <doc xml:space="preserve">A #GCredentials</doc>
            <type name="Credentials" c:type="GCredentials*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_unix_user" c:identifier="g_credentials_get_unix_user" version="2.26" throws="1">
        <doc xml:space="preserve">Tries to get the UNIX user identifier from @credentials. This
method is only available on UNIX platforms.

This operation can fail if #GCredentials is not supported on the
OS or if the native credentials type does not contain information
about the UNIX user.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The UNIX user identifier or -1 if @error is set.</doc>
          <type name="guint" c:type="uid_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="credentials" transfer-ownership="none">
            <doc xml:space="preserve">A #GCredentials</doc>
            <type name="Credentials" c:type="GCredentials*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_same_user" c:identifier="g_credentials_is_same_user" version="2.26" throws="1">
        <doc xml:space="preserve">Checks if @credentials and @other_credentials is the same user.

This operation can fail if #GCredentials is not supported on the
the OS.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @credentials and @other_credentials has the same
user, %FALSE otherwise or if @error is set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="credentials" transfer-ownership="none">
            <doc xml:space="preserve">A #GCredentials.</doc>
            <type name="Credentials" c:type="GCredentials*"/>
          </instance-parameter>
          <parameter name="other_credentials" transfer-ownership="none">
            <doc xml:space="preserve">A #GCredentials.</doc>
            <type name="Credentials" c:type="GCredentials*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_native" c:identifier="g_credentials_set_native" version="2.26">
        <doc xml:space="preserve">Copies the native credentials of type @native_type from @native
into @credentials.

It is a programming error (which will cause an warning to be
logged) to use this method if there is no #GCredentials support for
the OS or if @native_type isn't supported by the OS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="credentials" transfer-ownership="none">
            <doc xml:space="preserve">A #GCredentials.</doc>
            <type name="Credentials" c:type="GCredentials*"/>
          </instance-parameter>
          <parameter name="native_type" transfer-ownership="none">
            <doc xml:space="preserve">The type of native credentials to set.</doc>
            <type name="CredentialsType" c:type="GCredentialsType"/>
          </parameter>
          <parameter name="native" transfer-ownership="none">
            <doc xml:space="preserve">A pointer to native credentials.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_unix_user" c:identifier="g_credentials_set_unix_user" version="2.26" throws="1">
        <doc xml:space="preserve">Tries to set the UNIX user identifier on @credentials. This method
is only available on UNIX platforms.

This operation can fail if #GCredentials is not supported on the
OS or if the native credentials type does not contain information
about the UNIX user. It can also fail if the OS does not allow the
use of "spoofed" credentials.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @uid was set, %FALSE if error is set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="credentials" transfer-ownership="none">
            <doc xml:space="preserve">A #GCredentials.</doc>
            <type name="Credentials" c:type="GCredentials*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">The UNIX user identifier to set.</doc>
            <type name="guint" c:type="uid_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="g_credentials_to_string" version="2.26">
        <doc xml:space="preserve">Creates a human-readable textual representation of @credentials
that can be used in logging and debug messages. The format of the
returned string may change in future GLib release.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A string that should be freed with g_free().</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="credentials" transfer-ownership="none">
            <doc xml:space="preserve">A #GCredentials object.</doc>
            <type name="Credentials" c:type="GCredentials*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <record name="CredentialsClass" c:type="GCredentialsClass" disguised="1" glib:is-gtype-struct-for="Credentials" version="2.26">
      <doc xml:space="preserve">Class structure for #GCredentials.</doc>
    </record>
    <enumeration name="CredentialsType" version="2.26" glib:type-name="GCredentialsType" glib:get-type="g_credentials_type_get_type" c:type="GCredentialsType">
      <doc xml:space="preserve">Enumeration describing different kinds of native credential types.</doc>
      <member name="invalid" value="0" c:identifier="G_CREDENTIALS_TYPE_INVALID" glib:nick="invalid">
        <doc xml:space="preserve">Indicates an invalid native credential type.</doc>
      </member>
      <member name="linux_ucred" value="1" c:identifier="G_CREDENTIALS_TYPE_LINUX_UCRED" glib:nick="linux-ucred">
        <doc xml:space="preserve">The native credentials type is a struct ucred.</doc>
      </member>
      <member name="freebsd_cmsgcred" value="2" c:identifier="G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED" glib:nick="freebsd-cmsgcred">
        <doc xml:space="preserve">The native credentials type is a struct cmsgcred.</doc>
      </member>
      <member name="openbsd_sockpeercred" value="3" c:identifier="G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED" glib:nick="openbsd-sockpeercred">
        <doc xml:space="preserve">The native credentials type is a struct sockpeercred. Added in 2.30.</doc>
      </member>
      <member name="solaris_ucred" value="4" c:identifier="G_CREDENTIALS_TYPE_SOLARIS_UCRED" glib:nick="solaris-ucred">
        <doc xml:space="preserve">The native credentials type is a ucred_t. Added in 2.40.</doc>
      </member>
      <member name="netbsd_unpcbid" value="5" c:identifier="G_CREDENTIALS_TYPE_NETBSD_UNPCBID" glib:nick="netbsd-unpcbid">
        <doc xml:space="preserve">The native credentials type is a struct unpcbid.</doc>
      </member>
    </enumeration>
    <class name="DBusActionGroup" c:symbol-prefix="dbus_action_group" c:type="GDBusActionGroup" parent="GObject.Object" glib:type-name="GDBusActionGroup" glib:get-type="g_dbus_action_group_get_type">
      <doc xml:space="preserve">#GDBusActionGroup is an implementation of the #GActionGroup
interface that can be used as a proxy for an action group
that is exported over D-Bus with g_dbus_connection_export_action_group().</doc>
      <implements name="ActionGroup"/>
      <implements name="RemoteActionGroup"/>
      <function name="get" c:identifier="g_dbus_action_group_get" version="2.32">
        <doc xml:space="preserve">Obtains a #GDBusActionGroup for the action group which is exported at
the given @bus_name and @object_path.

The thread default main context is taken at the time of this call.
All signals on the menu model (and any linked models) are reported
with respect to this context.  All calls on the returned menu model
(and linked models) must also originate from this same context, with
the thread default main context unchanged.

This call is non-blocking.  The returned action group may or may not
already be filled in.  The correct thing to do is connect the signals
for the action group to monitor for changes and then to call
g_action_group_list_actions() to get the initial list.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GDBusActionGroup</doc>
          <type name="DBusActionGroup" c:type="GDBusActionGroup*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </parameter>
          <parameter name="bus_name" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the bus name which exports the action
    group or %NULL if @connection is not a message bus connection</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">the object path at which the action group is exported</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
    </class>
    <record name="DBusAnnotationInfo" c:type="GDBusAnnotationInfo" version="2.26" glib:type-name="GDBusAnnotationInfo" glib:get-type="g_dbus_annotation_info_get_type" c:symbol-prefix="dbus_annotation_info">
      <doc xml:space="preserve">Information about an annotation.</doc>
      <field name="ref_count" writable="1">
        <doc xml:space="preserve">The reference count or -1 if statically allocated.</doc>
        <type name="gint" c:type="volatile gint"/>
      </field>
      <field name="key" writable="1">
        <doc xml:space="preserve">The name of the annotation, e.g. "org.freedesktop.DBus.Deprecated".</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="value" writable="1">
        <doc xml:space="preserve">The value of the annotation.</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="annotations" writable="1">
        <doc xml:space="preserve">A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.</doc>
        <array c:type="GDBusAnnotationInfo**">
          <type name="DBusAnnotationInfo" c:type="GDBusAnnotationInfo*"/>
        </array>
      </field>
      <method name="ref" c:identifier="g_dbus_annotation_info_ref" version="2.26">
        <doc xml:space="preserve">If @info is statically allocated does nothing. Otherwise increases
the reference count.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The same @info.</doc>
          <type name="DBusAnnotationInfo" c:type="GDBusAnnotationInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusNodeInfo</doc>
            <type name="DBusAnnotationInfo" c:type="GDBusAnnotationInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_dbus_annotation_info_unref" version="2.26">
        <doc xml:space="preserve">If @info is statically allocated, does nothing. Otherwise decreases
the reference count of @info. When its reference count drops to 0,
the memory used is freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusAnnotationInfo.</doc>
            <type name="DBusAnnotationInfo" c:type="GDBusAnnotationInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="lookup" c:identifier="g_dbus_annotation_info_lookup" version="2.26">
        <doc xml:space="preserve">Looks up the value of an annotation.

The cost of this function is O(n) in number of annotations.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value or %NULL if not found. Do not free, it is owned by @annotations.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="annotations" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A %NULL-terminated array of annotations or %NULL.</doc>
            <array c:type="GDBusAnnotationInfo**">
              <type name="DBusAnnotationInfo" c:type="GDBusAnnotationInfo*"/>
            </array>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the annotation to look up.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="DBusArgInfo" c:type="GDBusArgInfo" version="2.26" glib:type-name="GDBusArgInfo" glib:get-type="g_dbus_arg_info_get_type" c:symbol-prefix="dbus_arg_info">
      <doc xml:space="preserve">Information about an argument for a method or a signal.</doc>
      <field name="ref_count" writable="1">
        <doc xml:space="preserve">The reference count or -1 if statically allocated.</doc>
        <type name="gint" c:type="volatile gint"/>
      </field>
      <field name="name" writable="1">
        <doc xml:space="preserve">Name of the argument, e.g. @unix_user_id.</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="signature" writable="1">
        <doc xml:space="preserve">D-Bus signature of the argument (a single complete type).</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="annotations" writable="1">
        <doc xml:space="preserve">A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.</doc>
        <array c:type="GDBusAnnotationInfo**">
          <type name="DBusAnnotationInfo" c:type="GDBusAnnotationInfo*"/>
        </array>
      </field>
      <method name="ref" c:identifier="g_dbus_arg_info_ref" version="2.26">
        <doc xml:space="preserve">If @info is statically allocated does nothing. Otherwise increases
the reference count.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The same @info.</doc>
          <type name="DBusArgInfo" c:type="GDBusArgInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusArgInfo</doc>
            <type name="DBusArgInfo" c:type="GDBusArgInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_dbus_arg_info_unref" version="2.26">
        <doc xml:space="preserve">If @info is statically allocated, does nothing. Otherwise decreases
the reference count of @info. When its reference count drops to 0,
the memory used is freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusArgInfo.</doc>
            <type name="DBusArgInfo" c:type="GDBusArgInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <class name="DBusAuthObserver" c:symbol-prefix="dbus_auth_observer" c:type="GDBusAuthObserver" version="2.26" parent="GObject.Object" glib:type-name="GDBusAuthObserver" glib:get-type="g_dbus_auth_observer_get_type">
      <doc xml:space="preserve">The #GDBusAuthObserver type provides a mechanism for participating
in how a #GDBusServer (or a #GDBusConnection) authenticates remote
peers. Simply instantiate a #GDBusAuthObserver and connect to the
signals you are interested in. Note that new signals may be added
in the future

## Controlling Authentication # {#auth-observer}

For example, if you only want to allow D-Bus connections from
processes owned by the same uid as the server, you would use a
signal handler like the following:

|[&lt;!-- language="C" --&gt;
static gboolean
on_authorize_authenticated_peer (GDBusAuthObserver *observer,
                                 GIOStream         *stream,
                                 GCredentials      *credentials,
                                 gpointer           user_data)
{
  gboolean authorized;

  authorized = FALSE;
  if (credentials != NULL)
    {
      GCredentials *own_credentials;
      own_credentials = g_credentials_new ();
      if (g_credentials_is_same_user (credentials, own_credentials, NULL))
        authorized = TRUE;
      g_object_unref (own_credentials);
    }

  return authorized;
}
]|</doc>
      <constructor name="new" c:identifier="g_dbus_auth_observer_new" version="2.26">
        <doc xml:space="preserve">Creates a new #GDBusAuthObserver object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GDBusAuthObserver. Free with g_object_unref().</doc>
          <type name="DBusAuthObserver" c:type="GDBusAuthObserver*"/>
        </return-value>
      </constructor>
      <method name="allow_mechanism" c:identifier="g_dbus_auth_observer_allow_mechanism" version="2.34">
        <doc xml:space="preserve">Emits the #GDBusAuthObserver::allow-mechanism signal on @observer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @mechanism can be used to authenticate the other peer, %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="observer" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusAuthObserver.</doc>
            <type name="DBusAuthObserver" c:type="GDBusAuthObserver*"/>
          </instance-parameter>
          <parameter name="mechanism" transfer-ownership="none">
            <doc xml:space="preserve">The name of the mechanism, e.g. `DBUS_COOKIE_SHA1`.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="authorize_authenticated_peer" c:identifier="g_dbus_auth_observer_authorize_authenticated_peer" version="2.26">
        <doc xml:space="preserve">Emits the #GDBusAuthObserver::authorize-authenticated-peer signal on @observer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the peer is authorized, %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="observer" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusAuthObserver.</doc>
            <type name="DBusAuthObserver" c:type="GDBusAuthObserver*"/>
          </instance-parameter>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">A #GIOStream for the #GDBusConnection.</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </parameter>
          <parameter name="credentials" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Credentials received from the peer or %NULL.</doc>
            <type name="Credentials" c:type="GCredentials*"/>
          </parameter>
        </parameters>
      </method>
      <glib:signal name="allow-mechanism" when="last" version="2.34">
        <doc xml:space="preserve">Emitted to check if @mechanism is allowed to be used.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @mechanism can be used to authenticate the other peer, %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="mechanism" transfer-ownership="none">
            <doc xml:space="preserve">The name of the mechanism, e.g. `DBUS_COOKIE_SHA1`.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="authorize-authenticated-peer" when="last" version="2.26">
        <doc xml:space="preserve">Emitted to check if a peer that is successfully authenticated
is authorized.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the peer is authorized, %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">A #GIOStream for the #GDBusConnection.</doc>
            <type name="IOStream"/>
          </parameter>
          <parameter name="credentials" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Credentials received from the peer or %NULL.</doc>
            <type name="Credentials"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <bitfield name="DBusCallFlags" version="2.26" glib:type-name="GDBusCallFlags" glib:get-type="g_dbus_call_flags_get_type" c:type="GDBusCallFlags">
      <doc xml:space="preserve">Flags used in g_dbus_connection_call() and similar APIs.</doc>
      <member name="none" value="0" c:identifier="G_DBUS_CALL_FLAGS_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
      <member name="no_auto_start" value="1" c:identifier="G_DBUS_CALL_FLAGS_NO_AUTO_START" glib:nick="no-auto-start">
        <doc xml:space="preserve">The bus must not launch
an owner for the destination name in response to this method
invocation.</doc>
      </member>
      <member name="allow_interactive_authorization" value="2" c:identifier="G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION" glib:nick="allow-interactive-authorization">
        <doc xml:space="preserve">the caller is prepared to
wait for interactive authorization. Since 2.46.</doc>
      </member>
    </bitfield>
    <bitfield name="DBusCapabilityFlags" version="2.26" glib:type-name="GDBusCapabilityFlags" glib:get-type="g_dbus_capability_flags_get_type" c:type="GDBusCapabilityFlags">
      <doc xml:space="preserve">Capabilities negotiated with the remote peer.</doc>
      <member name="none" value="0" c:identifier="G_DBUS_CAPABILITY_FLAGS_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
      <member name="unix_fd_passing" value="1" c:identifier="G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING" glib:nick="unix-fd-passing">
        <doc xml:space="preserve">The connection
supports exchanging UNIX file descriptors with the remote peer.</doc>
      </member>
    </bitfield>
    <class name="DBusConnection" c:symbol-prefix="dbus_connection" c:type="GDBusConnection" version="2.26" parent="GObject.Object" glib:type-name="GDBusConnection" glib:get-type="g_dbus_connection_get_type">
      <doc xml:space="preserve">The #GDBusConnection type is used for D-Bus connections to remote
peers such as a message buses. It is a low-level API that offers a
lot of flexibility. For instance, it lets you establish a connection
over any transport that can by represented as an #GIOStream.

This class is rarely used directly in D-Bus clients. If you are writing
a D-Bus client, it is often easier to use the g_bus_own_name(),
g_bus_watch_name() or g_dbus_proxy_new_for_bus() APIs.

As an exception to the usual GLib rule that a particular object must not
be used by two threads at the same time, #GDBusConnection's methods may be
called from any thread. This is so that g_bus_get() and g_bus_get_sync()
can safely return the same #GDBusConnection when called from any thread.

Most of the ways to obtain a #GDBusConnection automatically initialize it
(i.e. connect to D-Bus): for instance, g_dbus_connection_new() and
g_bus_get(), and the synchronous versions of those methods, give you an
initialized connection. Language bindings for GIO should use
g_initable_new() or g_async_initable_new_async(), which also initialize the
connection.

If you construct an uninitialized #GDBusConnection, such as via
g_object_new(), you must initialize it via g_initable_init() or
g_async_initable_init_async() before using its methods or properties.
Calling methods or accessing properties on a #GDBusConnection that has not
completed initialization successfully is considered to be invalid, and leads
to undefined behaviour. In particular, if initialization fails with a
#GError, the only valid thing you can do with that #GDBusConnection is to
free it with g_object_unref().

## An example D-Bus server # {#gdbus-server}

Here is an example for a D-Bus server:
[gdbus-example-server.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-server.c)

## An example for exporting a subtree # {#gdbus-subtree-server}

Here is an example for exporting a subtree:
[gdbus-example-subtree.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-subtree.c)

## An example for file descriptor passing # {#gdbus-unix-fd-client}

Here is an example for passing UNIX file descriptors:
[gdbus-unix-fd-client.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-unix-fd-client.c)

## An example for exporting a GObject # {#gdbus-export}

Here is an example for exporting a #GObject:
[gdbus-example-export.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-export.c)</doc>
      <implements name="AsyncInitable"/>
      <implements name="Initable"/>
      <constructor name="new_finish" c:identifier="g_dbus_connection_new_finish" version="2.26" throws="1">
        <doc xml:space="preserve">Finishes an operation started with g_dbus_connection_new().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GDBusConnection or %NULL if @error is set. Free
    with g_object_unref().</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult obtained from the #GAsyncReadyCallback
    passed to g_dbus_connection_new().</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_for_address_finish" c:identifier="g_dbus_connection_new_for_address_finish" version="2.26" throws="1">
        <doc xml:space="preserve">Finishes an operation started with g_dbus_connection_new_for_address().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GDBusConnection or %NULL if @error is set. Free with
    g_object_unref().</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult obtained from the #GAsyncReadyCallback passed
    to g_dbus_connection_new()</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_for_address_sync" c:identifier="g_dbus_connection_new_for_address_sync" version="2.26" throws="1">
        <doc xml:space="preserve">Synchronously connects and sets up a D-Bus client connection for
exchanging D-Bus messages with an endpoint specified by @address
which must be in the
[D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).

This constructor can only be used to initiate client-side
connections - use g_dbus_connection_new_sync() if you need to act
as the server. In particular, @flags cannot contain the
%G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER or
%G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS flags.

This is a synchronous failable constructor. See
g_dbus_connection_new_for_address() for the asynchronous version.

If @observer is not %NULL it may be used to control the
authentication process.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GDBusConnection or %NULL if @error is set. Free with
    g_object_unref().</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a D-Bus address</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags describing how to make the connection</doc>
            <type name="DBusConnectionFlags" c:type="GDBusConnectionFlags"/>
          </parameter>
          <parameter name="observer" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GDBusAuthObserver or %NULL</doc>
            <type name="DBusAuthObserver" c:type="GDBusAuthObserver*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_sync" c:identifier="g_dbus_connection_new_sync" version="2.26" throws="1">
        <doc xml:space="preserve">Synchronously sets up a D-Bus connection for exchanging D-Bus messages
with the end represented by @stream.

If @stream is a #GSocketConnection, then the corresponding #GSocket
will be put into non-blocking mode.

The D-Bus connection will interact with @stream from a worker thread.
As a result, the caller should not interact with @stream after this
method has been called, except by calling g_object_unref() on it.

If @observer is not %NULL it may be used to control the
authentication process.

This is a synchronous failable constructor. See
g_dbus_connection_new() for the asynchronous version.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GDBusConnection or %NULL if @error is set. Free with g_object_unref().</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </return-value>
        <parameters>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </parameter>
          <parameter name="guid" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the GUID to use if a authenticating as a server or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags describing how to make the connection</doc>
            <type name="DBusConnectionFlags" c:type="GDBusConnectionFlags"/>
          </parameter>
          <parameter name="observer" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GDBusAuthObserver or %NULL</doc>
            <type name="DBusAuthObserver" c:type="GDBusAuthObserver*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="new" c:identifier="g_dbus_connection_new" version="2.26">
        <doc xml:space="preserve">Asynchronously sets up a D-Bus connection for exchanging D-Bus messages
with the end represented by @stream.

If @stream is a #GSocketConnection, then the corresponding #GSocket
will be put into non-blocking mode.

The D-Bus connection will interact with @stream from a worker thread.
As a result, the caller should not interact with @stream after this
method has been called, except by calling g_object_unref() on it.

If @observer is not %NULL it may be used to control the
authentication process.

When the operation is finished, @callback will be invoked. You can
then call g_dbus_connection_new_finish() to get the result of the
operation.

This is a asynchronous failable constructor. See
g_dbus_connection_new_sync() for the synchronous
version.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </parameter>
          <parameter name="guid" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the GUID to use if a authenticating as a server or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags describing how to make the connection</doc>
            <type name="DBusConnectionFlags" c:type="GDBusConnectionFlags"/>
          </parameter>
          <parameter name="observer" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GDBusAuthObserver or %NULL</doc>
            <type name="DBusAuthObserver" c:type="GDBusAuthObserver*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_for_address" c:identifier="g_dbus_connection_new_for_address" version="2.26">
        <doc xml:space="preserve">Asynchronously connects and sets up a D-Bus client connection for
exchanging D-Bus messages with an endpoint specified by @address
which must be in the
[D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).

This constructor can only be used to initiate client-side
connections - use g_dbus_connection_new() if you need to act as the
server. In particular, @flags cannot contain the
%G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER or
%G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS flags.

When the operation is finished, @callback will be invoked. You can
then call g_dbus_connection_new_finish() to get the result of the
operation.

If @observer is not %NULL it may be used to control the
authentication process.

This is a asynchronous failable constructor. See
g_dbus_connection_new_for_address_sync() for the synchronous
version.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a D-Bus address</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags describing how to make the connection</doc>
            <type name="DBusConnectionFlags" c:type="GDBusConnectionFlags"/>
          </parameter>
          <parameter name="observer" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GDBusAuthObserver or %NULL</doc>
            <type name="DBusAuthObserver" c:type="GDBusAuthObserver*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <method name="add_filter" c:identifier="g_dbus_connection_add_filter" version="2.26">
        <doc xml:space="preserve">Adds a message filter. Filters are handlers that are run on all
incoming and outgoing messages, prior to standard dispatch. Filters
are run in the order that they were added.  The same handler can be
added as a filter more than once, in which case it will be run more
than once.  Filters added during a filter callback won't be run on
the message being processed. Filter functions are allowed to modify
and even drop messages.

Note that filters are run in a dedicated message handling thread so
they can't block and, generally, can't do anything but signal a
worker thread. Also note that filters are rarely needed - use API
such as g_dbus_connection_send_message_with_reply(),
g_dbus_connection_signal_subscribe() or g_dbus_connection_call() instead.

If a filter consumes an incoming message the message is not
dispatched anywhere else - not even the standard dispatch machinery
(that API such as g_dbus_connection_signal_subscribe() and
g_dbus_connection_send_message_with_reply() relies on) will see the
message. Similarly, if a filter consumes an outgoing message, the
message will not be sent to the other peer.

If @user_data_free_func is non-%NULL, it will be called (in the
thread-default main context of the thread you are calling this
method from) at some point after @user_data is no longer
needed. (It is not guaranteed to be called synchronously when the
filter is removed, and may be called after @connection has been
destroyed.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a filter identifier that can be used with
    g_dbus_connection_remove_filter()</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="filter_function" transfer-ownership="none" scope="notified" closure="1" destroy="2">
            <doc xml:space="preserve">a filter function</doc>
            <type name="DBusMessageFilterFunction" c:type="GDBusMessageFilterFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to @filter_function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="user_data_free_func" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">function to free @user_data with when filter
    is removed or %NULL</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="call" c:identifier="g_dbus_connection_call" version="2.26">
        <doc xml:space="preserve">Asynchronously invokes the @method_name method on the
@interface_name D-Bus interface on the remote object at
@object_path owned by @bus_name.

If @connection is closed then the operation will fail with
%G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will
fail with %G_IO_ERROR_CANCELLED. If @parameters contains a value
not compatible with the D-Bus protocol, the operation fails with
%G_IO_ERROR_INVALID_ARGUMENT.

If @reply_type is non-%NULL then the reply will be checked for having this type and an
error will be raised if it does not match.  Said another way, if you give a @reply_type
then any non-%NULL return value will be of this type. Unless it&#x2019;s
%G_VARIANT_TYPE_UNIT, the @reply_type will be a tuple containing one or more
values.

If the @parameters #GVariant is floating, it is consumed. This allows
convenient 'inline' use of g_variant_new(), e.g.:
|[&lt;!-- language="C" --&gt;
 g_dbus_connection_call (connection,
                         "org.freedesktop.StringThings",
                         "/org/freedesktop/StringThings",
                         "org.freedesktop.StringThings",
                         "TwoStrings",
                         g_variant_new ("(ss)",
                                        "Thing One",
                                        "Thing Two"),
                         NULL,
                         G_DBUS_CALL_FLAGS_NONE,
                         -1,
                         NULL,
                         (GAsyncReadyCallback) two_strings_done,
                         NULL);
]|

This is an asynchronous method. When the operation is finished,
@callback will be invoked in the
[thread-default main context][g-main-context-push-thread-default]
of the thread you are calling this method from. You can then call
g_dbus_connection_call_finish() to get the result of the operation.
See g_dbus_connection_call_sync() for the synchronous version of this
function.

If @callback is %NULL then the D-Bus method call message will be sent with
the %G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="bus_name" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a unique or well-known bus name or %NULL if
    @connection is not a message bus connection</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">path of remote object</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="interface_name" transfer-ownership="none">
            <doc xml:space="preserve">D-Bus interface to invoke method on</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="method_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the method to invoke</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GVariant tuple with parameters for the method
    or %NULL if not passing parameters</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="reply_type" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the expected type of the reply (which will be a
    tuple), or %NULL</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags from the #GDBusCallFlags enumeration</doc>
            <type name="DBusCallFlags" c:type="GDBusCallFlags"/>
          </parameter>
          <parameter name="timeout_msec" transfer-ownership="none">
            <doc xml:space="preserve">the timeout in milliseconds, -1 to use the default
    timeout or %G_MAXINT for no timeout</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="10">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request
    is satisfied or %NULL if you don't care about the result of the
    method invocation</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="call_finish" c:identifier="g_dbus_connection_call_finish" version="2.26" throws="1">
        <doc xml:space="preserve">Finishes an operation started with g_dbus_connection_call().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">%NULL if @error is set. Otherwise a #GVariant tuple with
    return values. Free with g_variant_unref().</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_connection_call()</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="call_sync" c:identifier="g_dbus_connection_call_sync" version="2.26" throws="1">
        <doc xml:space="preserve">Synchronously invokes the @method_name method on the
@interface_name D-Bus interface on the remote object at
@object_path owned by @bus_name.

If @connection is closed then the operation will fail with
%G_IO_ERROR_CLOSED. If @cancellable is canceled, the
operation will fail with %G_IO_ERROR_CANCELLED. If @parameters
contains a value not compatible with the D-Bus protocol, the operation
fails with %G_IO_ERROR_INVALID_ARGUMENT.

If @reply_type is non-%NULL then the reply will be checked for having
this type and an error will be raised if it does not match.  Said
another way, if you give a @reply_type then any non-%NULL return
value will be of this type.

If the @parameters #GVariant is floating, it is consumed.
This allows convenient 'inline' use of g_variant_new(), e.g.:
|[&lt;!-- language="C" --&gt;
 g_dbus_connection_call_sync (connection,
                              "org.freedesktop.StringThings",
                              "/org/freedesktop/StringThings",
                              "org.freedesktop.StringThings",
                              "TwoStrings",
                              g_variant_new ("(ss)",
                                             "Thing One",
                                             "Thing Two"),
                              NULL,
                              G_DBUS_CALL_FLAGS_NONE,
                              -1,
                              NULL,
                              &amp;error);
]|

The calling thread is blocked until a reply is received. See
g_dbus_connection_call() for the asynchronous version of
this method.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">%NULL if @error is set. Otherwise a #GVariant tuple with
    return values. Free with g_variant_unref().</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="bus_name" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a unique or well-known bus name or %NULL if
    @connection is not a message bus connection</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">path of remote object</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="interface_name" transfer-ownership="none">
            <doc xml:space="preserve">D-Bus interface to invoke method on</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="method_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the method to invoke</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GVariant tuple with parameters for the method
    or %NULL if not passing parameters</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="reply_type" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the expected type of the reply, or %NULL</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags from the #GDBusCallFlags enumeration</doc>
            <type name="DBusCallFlags" c:type="GDBusCallFlags"/>
          </parameter>
          <parameter name="timeout_msec" transfer-ownership="none">
            <doc xml:space="preserve">the timeout in milliseconds, -1 to use the default
    timeout or %G_MAXINT for no timeout</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="call_with_unix_fd_list" c:identifier="g_dbus_connection_call_with_unix_fd_list" version="2.30">
        <doc xml:space="preserve">Like g_dbus_connection_call() but also takes a #GUnixFDList object.

This method is only available on UNIX.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="bus_name" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a unique or well-known bus name or %NULL if
    @connection is not a message bus connection</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">path of remote object</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="interface_name" transfer-ownership="none">
            <doc xml:space="preserve">D-Bus interface to invoke method on</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="method_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the method to invoke</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GVariant tuple with parameters for the method
    or %NULL if not passing parameters</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="reply_type" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the expected type of the reply, or %NULL</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags from the #GDBusCallFlags enumeration</doc>
            <type name="DBusCallFlags" c:type="GDBusCallFlags"/>
          </parameter>
          <parameter name="timeout_msec" transfer-ownership="none">
            <doc xml:space="preserve">the timeout in milliseconds, -1 to use the default
    timeout or %G_MAXINT for no timeout</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="fd_list" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GUnixFDList or %NULL</doc>
            <type name="UnixFDList" c:type="GUnixFDList*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="11">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is
    satisfied or %NULL if you don't * care about the result of the
    method invocation</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The data to pass to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="call_with_unix_fd_list_finish" c:identifier="g_dbus_connection_call_with_unix_fd_list_finish" version="2.30" throws="1">
        <doc xml:space="preserve">Finishes an operation started with g_dbus_connection_call_with_unix_fd_list().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">%NULL if @error is set. Otherwise a #GVariant tuple with
    return values. Free with g_variant_unref().</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="out_fd_list" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for a #GUnixFDList or %NULL</doc>
            <type name="UnixFDList" c:type="GUnixFDList**"/>
          </parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult obtained from the #GAsyncReadyCallback passed to
    g_dbus_connection_call_with_unix_fd_list()</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="call_with_unix_fd_list_sync" c:identifier="g_dbus_connection_call_with_unix_fd_list_sync" version="2.30" throws="1">
        <doc xml:space="preserve">Like g_dbus_connection_call_sync() but also takes and returns #GUnixFDList objects.

This method is only available on UNIX.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">%NULL if @error is set. Otherwise a #GVariant tuple with
    return values. Free with g_variant_unref().</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="bus_name" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a unique or well-known bus name or %NULL
    if @connection is not a message bus connection</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">path of remote object</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="interface_name" transfer-ownership="none">
            <doc xml:space="preserve">D-Bus interface to invoke method on</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="method_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the method to invoke</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GVariant tuple with parameters for
    the method or %NULL if not passing parameters</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="reply_type" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the expected type of the reply, or %NULL</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags from the #GDBusCallFlags enumeration</doc>
            <type name="DBusCallFlags" c:type="GDBusCallFlags"/>
          </parameter>
          <parameter name="timeout_msec" transfer-ownership="none">
            <doc xml:space="preserve">the timeout in milliseconds, -1 to use the default
    timeout or %G_MAXINT for no timeout</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="fd_list" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GUnixFDList or %NULL</doc>
            <type name="UnixFDList" c:type="GUnixFDList*"/>
          </parameter>
          <parameter name="out_fd_list" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for a #GUnixFDList or %NULL</doc>
            <type name="UnixFDList" c:type="GUnixFDList**"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="close" c:identifier="g_dbus_connection_close" version="2.26">
        <doc xml:space="preserve">Closes @connection. Note that this never causes the process to
exit (this might only happen if the other end of a shared message
bus connection disconnects, see #GDBusConnection:exit-on-close).

Once the connection is closed, operations such as sending a message
will return with the error %G_IO_ERROR_CLOSED. Closing a connection
will not automatically flush the connection so queued messages may
be lost. Use g_dbus_connection_flush() if you need such guarantees.

If @connection is already closed, this method fails with
%G_IO_ERROR_CLOSED.

When @connection has been closed, the #GDBusConnection::closed
signal is emitted in the
[thread-default main context][g-main-context-push-thread-default]
of the thread that @connection was constructed in.

This is an asynchronous method. When the operation is finished,
@callback will be invoked in the
[thread-default main context][g-main-context-push-thread-default]
of the thread you are calling this method from. You can
then call g_dbus_connection_close_finish() to get the result of the
operation. See g_dbus_connection_close_sync() for the synchronous
version.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is
    satisfied or %NULL if you don't care about the result</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_finish" c:identifier="g_dbus_connection_close_finish" version="2.26" throws="1">
        <doc xml:space="preserve">Finishes an operation started with g_dbus_connection_close().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation succeeded, %FALSE if @error is set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult obtained from the #GAsyncReadyCallback passed
    to g_dbus_connection_close()</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_sync" c:identifier="g_dbus_connection_close_sync" version="2.26" throws="1">
        <doc xml:space="preserve">Synchronously closes @connection. The calling thread is blocked
until this is done. See g_dbus_connection_close() for the
asynchronous version of this method and more details about what it
does.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation succeeded, %FALSE if @error is set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="emit_signal" c:identifier="g_dbus_connection_emit_signal" version="2.26" throws="1">
        <doc xml:space="preserve">Emits a signal.

If the parameters GVariant is floating, it is consumed.

This can only fail if @parameters is not compatible with the D-Bus protocol
(%G_IO_ERROR_INVALID_ARGUMENT), or if @connection has been closed
(%G_IO_ERROR_CLOSED).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE unless @error is set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="destination_bus_name" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the unique bus name for the destination
    for the signal or %NULL to emit to all listeners</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">path of remote object</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="interface_name" transfer-ownership="none">
            <doc xml:space="preserve">D-Bus interface to emit a signal on</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="signal_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the signal to emit</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GVariant tuple with parameters for the signal
             or %NULL if not passing parameters</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="export_action_group" c:identifier="g_dbus_connection_export_action_group" version="2.32" throws="1">
        <doc xml:space="preserve">Exports @action_group on @connection at @object_path.

The implemented D-Bus API should be considered private.  It is
subject to change in the future.

A given object path can only have one action group exported on it.
If this constraint is violated, the export will fail and 0 will be
returned (with @error set accordingly).

You can unexport the action group using
g_dbus_connection_unexport_action_group() with the return value of
this function.

The thread default main context is taken at the time of this call.
All incoming action activations and state change requests are
reported from this context.  Any changes on the action group that
cause it to emit signals must also come from this same context.
Since incoming action activations and state change requests are
rather likely to cause changes on the action group, this effectively
limits a given action group to being exported from only one main
context.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the ID of the export (never zero), or 0 in case of failure</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">a D-Bus object path</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </parameter>
        </parameters>
      </method>
      <method name="export_menu_model" c:identifier="g_dbus_connection_export_menu_model" version="2.32" throws="1">
        <doc xml:space="preserve">Exports @menu on @connection at @object_path.

The implemented D-Bus API should be considered private.
It is subject to change in the future.

An object path can only have one menu model exported on it. If this
constraint is violated, the export will fail and 0 will be
returned (with @error set accordingly).

You can unexport the menu model using
g_dbus_connection_unexport_menu_model() with the return value of
this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the ID of the export (never zero), or 0 in case of failure</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">a D-Bus object path</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="menu" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuModel</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </parameter>
        </parameters>
      </method>
      <method name="flush" c:identifier="g_dbus_connection_flush" version="2.26">
        <doc xml:space="preserve">Asynchronously flushes @connection, that is, writes all queued
outgoing message to the transport and then flushes the transport
(using g_output_stream_flush_async()). This is useful in programs
that wants to emit a D-Bus signal and then exit immediately. Without
flushing the connection, there is no guaranteed that the message has
been sent to the networking buffers in the OS kernel.

This is an asynchronous method. When the operation is finished,
@callback will be invoked in the
[thread-default main context][g-main-context-push-thread-default]
of the thread you are calling this method from. You can
then call g_dbus_connection_flush_finish() to get the result of the
operation. See g_dbus_connection_flush_sync() for the synchronous
version.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the
    request is satisfied or %NULL if you don't care about the result</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="flush_finish" c:identifier="g_dbus_connection_flush_finish" version="2.26" throws="1">
        <doc xml:space="preserve">Finishes an operation started with g_dbus_connection_flush().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation succeeded, %FALSE if @error is set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult obtained from the #GAsyncReadyCallback passed
    to g_dbus_connection_flush()</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="flush_sync" c:identifier="g_dbus_connection_flush_sync" version="2.26" throws="1">
        <doc xml:space="preserve">Synchronously flushes @connection. The calling thread is blocked
until this is done. See g_dbus_connection_flush() for the
asynchronous version of this method and more details about what it
does.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation succeeded, %FALSE if @error is set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_capabilities" c:identifier="g_dbus_connection_get_capabilities" version="2.26">
        <doc xml:space="preserve">Gets the capabilities negotiated with the remote peer</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">zero or more flags from the #GDBusCapabilityFlags enumeration</doc>
          <type name="DBusCapabilityFlags" c:type="GDBusCapabilityFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_exit_on_close" c:identifier="g_dbus_connection_get_exit_on_close" version="2.26">
        <doc xml:space="preserve">Gets whether the process is terminated when @connection is
closed by the remote peer. See
#GDBusConnection:exit-on-close for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the process is terminated when @connection is
    closed by the remote peer</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_guid" c:identifier="g_dbus_connection_get_guid" version="2.26">
        <doc xml:space="preserve">The GUID of the peer performing the role of server when
authenticating. See #GDBusConnection:guid for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The GUID. Do not free this string, it is owned by
    @connection.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_last_serial" c:identifier="g_dbus_connection_get_last_serial" version="2.34">
        <doc xml:space="preserve">Retrieves the last serial number assigned to a #GDBusMessage on
the current thread. This includes messages sent via both low-level
API such as g_dbus_connection_send_message() as well as
high-level API such as g_dbus_connection_emit_signal(),
g_dbus_connection_call() or g_dbus_proxy_call().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the last used serial or zero when no message has been sent
    within the current thread</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_peer_credentials" c:identifier="g_dbus_connection_get_peer_credentials" version="2.26">
        <doc xml:space="preserve">Gets the credentials of the authenticated peer. This will always
return %NULL unless @connection acted as a server
(e.g. %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed)
when set up and the client passed credentials as part of the
authentication process.

In a message bus setup, the message bus is always the server and
each application is a client. So this method will always return
%NULL for message bus clients.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #GCredentials or %NULL if not
    available. Do not free this object, it is owned by @connection.</doc>
          <type name="Credentials" c:type="GCredentials*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_stream" c:identifier="g_dbus_connection_get_stream" version="2.26">
        <doc xml:space="preserve">Gets the underlying stream used for IO.

While the #GDBusConnection is active, it will interact with this
stream from a worker thread, so it is not safe to interact with
the stream directly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the stream used for IO</doc>
          <type name="IOStream" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_unique_name" c:identifier="g_dbus_connection_get_unique_name" version="2.26">
        <doc xml:space="preserve">Gets the unique name of @connection as assigned by the message
bus. This can also be used to figure out if @connection is a
message bus connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the unique name or %NULL if @connection is not a message
    bus connection. Do not free this string, it is owned by
    @connection.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_closed" c:identifier="g_dbus_connection_is_closed" version="2.26">
        <doc xml:space="preserve">Gets whether @connection is closed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection is closed, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="register_object" c:identifier="g_dbus_connection_register_object" shadowed-by="register_object_with_closures" version="2.26" throws="1">
        <doc xml:space="preserve">Registers callbacks for exported objects at @object_path with the
D-Bus interface that is described in @interface_info.

Calls to functions in @vtable (and @user_data_free_func) will happen
in the
[thread-default main context][g-main-context-push-thread-default]
of the thread you are calling this method from.

Note that all #GVariant values passed to functions in @vtable will match
the signature given in @interface_info - if a remote caller passes
incorrect values, the `org.freedesktop.DBus.Error.InvalidArgs`
is returned to the remote caller.

Additionally, if the remote caller attempts to invoke methods or
access properties not mentioned in @interface_info the
`org.freedesktop.DBus.Error.UnknownMethod` resp.
`org.freedesktop.DBus.Error.InvalidArgs` errors
are returned to the caller.

It is considered a programming error if the
#GDBusInterfaceGetPropertyFunc function in @vtable returns a
#GVariant of incorrect type.

If an existing callback is already registered at @object_path and
@interface_name, then @error is set to #G_IO_ERROR_EXISTS.

GDBus automatically implements the standard D-Bus interfaces
org.freedesktop.DBus.Properties, org.freedesktop.DBus.Introspectable
and org.freedesktop.Peer, so you don't have to implement those for the
objects you export. You can implement org.freedesktop.DBus.Properties
yourself, e.g. to handle getting and setting of properties asynchronously.

Note that the reference count on @interface_info will be
incremented by 1 (unless allocated statically, e.g. if the
reference count is -1, see g_dbus_interface_info_ref()) for as long
as the object is exported. Also note that @vtable will be copied.

See this [server][gdbus-server] for an example of how to use this method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 if @error is set, otherwise a registration id (never 0)
    that can be used with g_dbus_connection_unregister_object()</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">the object path to register at</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="interface_info" transfer-ownership="none">
            <doc xml:space="preserve">introspection data for the interface</doc>
            <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
          </parameter>
          <parameter name="vtable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GDBusInterfaceVTable to call into or %NULL</doc>
            <type name="DBusInterfaceVTable" c:type="const GDBusInterfaceVTable*"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to functions in @vtable</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="user_data_free_func" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">function to call when the object path is unregistered</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="register_object_with_closures" c:identifier="g_dbus_connection_register_object_with_closures" shadows="register_object" version="2.46" throws="1">
        <doc xml:space="preserve">Version of g_dbus_connection_register_object() using closures instead of a
#GDBusInterfaceVTable for easier binding in other languages.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 if @error is set, otherwise a registration id (never 0)
that can be used with g_dbus_connection_unregister_object() .</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusConnection.</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">The object path to register at.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="interface_info" transfer-ownership="none">
            <doc xml:space="preserve">Introspection data for the interface.</doc>
            <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
          </parameter>
          <parameter name="method_call_closure" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">#GClosure for handling incoming method calls.</doc>
            <type name="GObject.Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="get_property_closure" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">#GClosure for getting a property.</doc>
            <type name="GObject.Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="set_property_closure" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">#GClosure for setting a property.</doc>
            <type name="GObject.Closure" c:type="GClosure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="register_subtree" c:identifier="g_dbus_connection_register_subtree" version="2.26" throws="1">
        <doc xml:space="preserve">Registers a whole subtree of dynamic objects.

The @enumerate and @introspection functions in @vtable are used to
convey, to remote callers, what nodes exist in the subtree rooted
by @object_path.

When handling remote calls into any node in the subtree, first the
@enumerate function is used to check if the node exists. If the node exists
or the #G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is set
the @introspection function is used to check if the node supports the
requested method. If so, the @dispatch function is used to determine
where to dispatch the call. The collected #GDBusInterfaceVTable and
#gpointer will be used to call into the interface vtable for processing
the request.

All calls into user-provided code will be invoked in the
[thread-default main context][g-main-context-push-thread-default]
of the thread you are calling this method from.

If an existing subtree is already registered at @object_path or
then @error is set to #G_IO_ERROR_EXISTS.

Note that it is valid to register regular objects (using
g_dbus_connection_register_object()) in a subtree registered with
g_dbus_connection_register_subtree() - if so, the subtree handler
is tried as the last resort. One way to think about a subtree
handler is to consider it a fallback handler for object paths not
registered via g_dbus_connection_register_object() or other bindings.

Note that @vtable will be copied so you cannot change it after
registration.

See this [server][gdbus-subtree-server] for an example of how to use
this method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 if @error is set, otherwise a subtree registration id (never 0)
that can be used with g_dbus_connection_unregister_subtree() .</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">the object path to register the subtree at</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="vtable" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusSubtreeVTable to enumerate, introspect and
    dispatch nodes in the subtree</doc>
            <type name="DBusSubtreeVTable" c:type="const GDBusSubtreeVTable*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags used to fine tune the behavior of the subtree</doc>
            <type name="DBusSubtreeFlags" c:type="GDBusSubtreeFlags"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to functions in @vtable</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="user_data_free_func" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">function to call when the subtree is unregistered</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_filter" c:identifier="g_dbus_connection_remove_filter" version="2.26">
        <doc xml:space="preserve">Removes a filter.

Note that since filters run in a different thread, there is a race
condition where it is possible that the filter will be running even
after calling g_dbus_connection_remove_filter(), so you cannot just
free data that the filter might be using. Instead, you should pass
a #GDestroyNotify to g_dbus_connection_add_filter(), which will be
called when it is guaranteed that the data is no longer needed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="filter_id" transfer-ownership="none">
            <doc xml:space="preserve">an identifier obtained from g_dbus_connection_add_filter()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_message" c:identifier="g_dbus_connection_send_message" version="2.26" throws="1">
        <doc xml:space="preserve">Asynchronously sends @message to the peer represented by @connection.

Unless @flags contain the
%G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
will be assigned by @connection and set on @message via
g_dbus_message_set_serial(). If @out_serial is not %NULL, then the
serial number used will be written to this location prior to
submitting the message to the underlying transport.

If @connection is closed then the operation will fail with
%G_IO_ERROR_CLOSED. If @message is not well-formed,
the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.

See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
for an example of how to use this low-level API to send and receive
UNIX file descriptors.

Note that @message must be unlocked, unless @flags contain the
%G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the message was well-formed and queued for
    transmission, %FALSE if @error is set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusMessage</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting how the message is sent</doc>
            <type name="DBusSendMessageFlags" c:type="GDBusSendMessageFlags"/>
          </parameter>
          <parameter name="out_serial" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for serial number assigned
    to @message when sending it or %NULL</doc>
            <type name="guint32" c:type="volatile guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_message_with_reply" c:identifier="g_dbus_connection_send_message_with_reply" version="2.26">
        <doc xml:space="preserve">Asynchronously sends @message to the peer represented by @connection.

Unless @flags contain the
%G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
will be assigned by @connection and set on @message via
g_dbus_message_set_serial(). If @out_serial is not %NULL, then the
serial number used will be written to this location prior to
submitting the message to the underlying transport.

If @connection is closed then the operation will fail with
%G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will
fail with %G_IO_ERROR_CANCELLED. If @message is not well-formed,
the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.

This is an asynchronous method. When the operation is finished, @callback
will be invoked in the
[thread-default main context][g-main-context-push-thread-default]
of the thread you are calling this method from. You can then call
g_dbus_connection_send_message_with_reply_finish() to get the result of the operation.
See g_dbus_connection_send_message_with_reply_sync() for the synchronous version.

Note that @message must be unlocked, unless @flags contain the
%G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.

See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
for an example of how to use this low-level API to send and receive
UNIX file descriptors.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusMessage</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting how the message is sent</doc>
            <type name="DBusSendMessageFlags" c:type="GDBusSendMessageFlags"/>
          </parameter>
          <parameter name="timeout_msec" transfer-ownership="none">
            <doc xml:space="preserve">the timeout in milliseconds, -1 to use the default
    timeout or %G_MAXINT for no timeout</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="out_serial" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for serial number assigned
    to @message when sending it or %NULL</doc>
            <type name="guint32" c:type="volatile guint32*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request
    is satisfied or %NULL if you don't care about the result</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_message_with_reply_finish" c:identifier="g_dbus_connection_send_message_with_reply_finish" version="2.26" throws="1">
        <doc xml:space="preserve">Finishes an operation started with g_dbus_connection_send_message_with_reply().

Note that @error is only set if a local in-process error
occurred. That is to say that the returned #GDBusMessage object may
be of type %G_DBUS_MESSAGE_TYPE_ERROR. Use
g_dbus_message_to_gerror() to transcode this to a #GError.

See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
for an example of how to use this low-level API to send and receive
UNIX file descriptors.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a locked #GDBusMessage or %NULL if @error is set</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult obtained from the #GAsyncReadyCallback passed to
    g_dbus_connection_send_message_with_reply()</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_message_with_reply_sync" c:identifier="g_dbus_connection_send_message_with_reply_sync" version="2.26" throws="1">
        <doc xml:space="preserve">Synchronously sends @message to the peer represented by @connection
and blocks the calling thread until a reply is received or the
timeout is reached. See g_dbus_connection_send_message_with_reply()
for the asynchronous version of this method.

Unless @flags contain the
%G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
will be assigned by @connection and set on @message via
g_dbus_message_set_serial(). If @out_serial is not %NULL, then the
serial number used will be written to this location prior to
submitting the message to the underlying transport.

If @connection is closed then the operation will fail with
%G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will
fail with %G_IO_ERROR_CANCELLED. If @message is not well-formed,
the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.

Note that @error is only set if a local in-process error
occurred. That is to say that the returned #GDBusMessage object may
be of type %G_DBUS_MESSAGE_TYPE_ERROR. Use
g_dbus_message_to_gerror() to transcode this to a #GError.

See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
for an example of how to use this low-level API to send and receive
UNIX file descriptors.

Note that @message must be unlocked, unless @flags contain the
%G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a locked #GDBusMessage that is the reply
    to @message or %NULL if @error is set</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusMessage</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting how the message is sent.</doc>
            <type name="DBusSendMessageFlags" c:type="GDBusSendMessageFlags"/>
          </parameter>
          <parameter name="timeout_msec" transfer-ownership="none">
            <doc xml:space="preserve">the timeout in milliseconds, -1 to use the default
    timeout or %G_MAXINT for no timeout</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="out_serial" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for serial number
    assigned to @message when sending it or %NULL</doc>
            <type name="guint32" c:type="volatile guint32*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_exit_on_close" c:identifier="g_dbus_connection_set_exit_on_close" version="2.26">
        <doc xml:space="preserve">Sets whether the process should be terminated when @connection is
closed by the remote peer. See #GDBusConnection:exit-on-close for
more details.

Note that this function should be used with care. Most modern UNIX
desktops tie the notion of a user session the session bus, and expect
all of a users applications to quit when their bus connection goes away.
If you are setting @exit_on_close to %FALSE for the shared session
bus connection, you should make sure that your application exits
when the user session ends.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="exit_on_close" transfer-ownership="none">
            <doc xml:space="preserve">whether the process should be terminated
    when @connection is closed by the remote peer</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="signal_subscribe" c:identifier="g_dbus_connection_signal_subscribe" version="2.26">
        <doc xml:space="preserve">Subscribes to signals on @connection and invokes @callback with a whenever
the signal is received. Note that @callback will be invoked in the
[thread-default main context][g-main-context-push-thread-default]
of the thread you are calling this method from.

If @connection is not a message bus connection, @sender must be
%NULL.

If @sender is a well-known name note that @callback is invoked with
the unique name for the owner of @sender, not the well-known name
as one would expect. This is because the message bus rewrites the
name. As such, to avoid certain race conditions, users should be
tracking the name owner of the well-known name and use that when
processing the received signal.

If one of %G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE or
%G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH are given, @arg0 is
interpreted as part of a namespace or path.  The first argument
of a signal is matched against that part as specified by D-Bus.

If @user_data_free_func is non-%NULL, it will be called (in the
thread-default main context of the thread you are calling this
method from) at some point after @user_data is no longer
needed. (It is not guaranteed to be called synchronously when the
signal is unsubscribed from, and may be called after @connection
has been destroyed.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a subscription identifier that can be used with g_dbus_connection_signal_unsubscribe()</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="sender" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">sender name to match on (unique or well-known name)
    or %NULL to listen from all senders</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="interface_name" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">D-Bus interface name to match on or %NULL to
    match on all interfaces</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="member" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">D-Bus signal name to match on or %NULL to match on
    all signals</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">object path to match on or %NULL to match on
    all object paths</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="arg0" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">contents of first string argument to match on or %NULL
    to match on all kinds of arguments</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">#GDBusSignalFlags describing how arg0 is used in subscribing to the
    signal</doc>
            <type name="DBusSignalFlags" c:type="GDBusSignalFlags"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="7" destroy="8">
            <doc xml:space="preserve">callback to invoke when there is a signal matching the requested data</doc>
            <type name="DBusSignalCallback" c:type="GDBusSignalCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="user_data_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">function to free @user_data with when
    subscription is removed or %NULL</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="signal_unsubscribe" c:identifier="g_dbus_connection_signal_unsubscribe" version="2.26">
        <doc xml:space="preserve">Unsubscribes from signals.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="subscription_id" transfer-ownership="none">
            <doc xml:space="preserve">a subscription id obtained from
    g_dbus_connection_signal_subscribe()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="start_message_processing" c:identifier="g_dbus_connection_start_message_processing" version="2.26">
        <doc xml:space="preserve">If @connection was created with
%G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method
starts processing messages. Does nothing on if @connection wasn't
created with this flag or if the method has already been called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unexport_action_group" c:identifier="g_dbus_connection_unexport_action_group" version="2.32">
        <doc xml:space="preserve">Reverses the effect of a previous call to
g_dbus_connection_export_action_group().

It is an error to call this function with an ID that wasn't returned
from g_dbus_connection_export_action_group() or to call it with the
same ID more than once.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="export_id" transfer-ownership="none">
            <doc xml:space="preserve">the ID from g_dbus_connection_export_action_group()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="unexport_menu_model" c:identifier="g_dbus_connection_unexport_menu_model" version="2.32">
        <doc xml:space="preserve">Reverses the effect of a previous call to
g_dbus_connection_export_menu_model().

It is an error to call this function with an ID that wasn't returned
from g_dbus_connection_export_menu_model() or to call it with the
same ID more than once.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="export_id" transfer-ownership="none">
            <doc xml:space="preserve">the ID from g_dbus_connection_export_menu_model()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="unregister_object" c:identifier="g_dbus_connection_unregister_object" version="2.26">
        <doc xml:space="preserve">Unregisters an object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the object was unregistered, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="registration_id" transfer-ownership="none">
            <doc xml:space="preserve">a registration id obtained from
    g_dbus_connection_register_object()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="unregister_subtree" c:identifier="g_dbus_connection_unregister_subtree" version="2.26">
        <doc xml:space="preserve">Unregisters a subtree.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the subtree was unregistered, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </instance-parameter>
          <parameter name="registration_id" transfer-ownership="none">
            <doc xml:space="preserve">a subtree registration id obtained from
    g_dbus_connection_register_subtree()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <property name="address" version="2.26" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">A D-Bus address specifying potential endpoints that can be used
when establishing the connection.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="authentication-observer" version="2.26" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">A #GDBusAuthObserver object to assist in the authentication process or %NULL.</doc>
        <type name="DBusAuthObserver"/>
      </property>
      <property name="capabilities" version="2.26" transfer-ownership="none">
        <doc xml:space="preserve">Flags from the #GDBusCapabilityFlags enumeration
representing connection features negotiated with the other peer.</doc>
        <type name="DBusCapabilityFlags"/>
      </property>
      <property name="closed" version="2.26" transfer-ownership="none">
        <doc xml:space="preserve">A boolean specifying whether the connection has been closed.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="exit-on-close" version="2.26" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">A boolean specifying whether the process will be terminated (by
calling `raise(SIGTERM)`) if the connection is closed by the
remote peer.

Note that #GDBusConnection objects returned by g_bus_get_finish()
and g_bus_get_sync() will (usually) have this property set to %TRUE.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="flags" version="2.26" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">Flags from the #GDBusConnectionFlags enumeration.</doc>
        <type name="DBusConnectionFlags"/>
      </property>
      <property name="guid" version="2.26" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The GUID of the peer performing the role of server when
authenticating.

If you are constructing a #GDBusConnection and pass
%G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER in the
#GDBusConnection:flags property then you MUST also set this
property to a valid guid.

If you are constructing a #GDBusConnection and pass
%G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT in the
#GDBusConnection:flags property you will be able to read the GUID
of the other peer here after the connection has been successfully
initialized.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="stream" version="2.26" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The underlying #GIOStream used for I/O.

If this is passed on construction and is a #GSocketConnection,
then the corresponding #GSocket will be put into non-blocking mode.

While the #GDBusConnection is active, it will interact with this
stream from a worker thread, so it is not safe to interact with
the stream directly.</doc>
        <type name="IOStream"/>
      </property>
      <property name="unique-name" version="2.26" transfer-ownership="none">
        <doc xml:space="preserve">The unique name as assigned by the message bus or %NULL if the
connection is not open or not a message bus connection.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <glib:signal name="closed" when="last" version="2.26">
        <doc xml:space="preserve">Emitted when the connection is closed.

The cause of this event can be

- If g_dbus_connection_close() is called. In this case
  @remote_peer_vanished is set to %FALSE and @error is %NULL.

- If the remote peer closes the connection. In this case
  @remote_peer_vanished is set to %TRUE and @error is set.

- If the remote peer sends invalid or malformed data. In this
  case @remote_peer_vanished is set to %FALSE and @error is set.

Upon receiving this signal, you should give up your reference to
@connection. You are guaranteed that this signal is emitted only
once.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="remote_peer_vanished" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @connection is closed because the
    remote peer closed its end of the connection</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="error" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GError with more details about the event or %NULL</doc>
            <type name="GLib.Error"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <bitfield name="DBusConnectionFlags" version="2.26" glib:type-name="GDBusConnectionFlags" glib:get-type="g_dbus_connection_flags_get_type" c:type="GDBusConnectionFlags">
      <doc xml:space="preserve">Flags used when creating a new #GDBusConnection.</doc>
      <member name="none" value="0" c:identifier="G_DBUS_CONNECTION_FLAGS_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
      <member name="authentication_client" value="1" c:identifier="G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT" glib:nick="authentication-client">
        <doc xml:space="preserve">Perform authentication against server.</doc>
      </member>
      <member name="authentication_server" value="2" c:identifier="G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER" glib:nick="authentication-server">
        <doc xml:space="preserve">Perform authentication against client.</doc>
      </member>
      <member name="authentication_allow_anonymous" value="4" c:identifier="G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS" glib:nick="authentication-allow-anonymous">
        <doc xml:space="preserve">When
authenticating as a server, allow the anonymous authentication
method.</doc>
      </member>
      <member name="message_bus_connection" value="8" c:identifier="G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION" glib:nick="message-bus-connection">
        <doc xml:space="preserve">Pass this flag if connecting to a peer that is a
message bus. This means that the Hello() method will be invoked as part of the connection setup.</doc>
      </member>
      <member name="delay_message_processing" value="16" c:identifier="G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING" glib:nick="delay-message-processing">
        <doc xml:space="preserve">If set, processing of D-Bus messages is
delayed until g_dbus_connection_start_message_processing() is called.</doc>
      </member>
    </bitfield>
    <enumeration name="DBusError" version="2.26" glib:type-name="GDBusError" glib:get-type="g_dbus_error_get_type" c:type="GDBusError" glib:error-domain="g-dbus-error-quark">
      <doc xml:space="preserve">Error codes for the %G_DBUS_ERROR error domain.</doc>
      <member name="failed" value="0" c:identifier="G_DBUS_ERROR_FAILED" glib:nick="failed">
        <doc xml:space="preserve">A generic error; "something went wrong" - see the error message for
more.</doc>
      </member>
      <member name="no_memory" value="1" c:identifier="G_DBUS_ERROR_NO_MEMORY" glib:nick="no-memory">
        <doc xml:space="preserve">There was not enough memory to complete an operation.</doc>
      </member>
      <member name="service_unknown" value="2" c:identifier="G_DBUS_ERROR_SERVICE_UNKNOWN" glib:nick="service-unknown">
        <doc xml:space="preserve">The bus doesn't know how to launch a service to supply the bus name
you wanted.</doc>
      </member>
      <member name="name_has_no_owner" value="3" c:identifier="G_DBUS_ERROR_NAME_HAS_NO_OWNER" glib:nick="name-has-no-owner">
        <doc xml:space="preserve">The bus name you referenced doesn't exist (i.e. no application owns
it).</doc>
      </member>
      <member name="no_reply" value="4" c:identifier="G_DBUS_ERROR_NO_REPLY" glib:nick="no-reply">
        <doc xml:space="preserve">No reply to a message expecting one, usually means a timeout occurred.</doc>
      </member>
      <member name="io_error" value="5" c:identifier="G_DBUS_ERROR_IO_ERROR" glib:nick="io-error">
        <doc xml:space="preserve">Something went wrong reading or writing to a socket, for example.</doc>
      </member>
      <member name="bad_address" value="6" c:identifier="G_DBUS_ERROR_BAD_ADDRESS" glib:nick="bad-address">
        <doc xml:space="preserve">A D-Bus bus address was malformed.</doc>
      </member>
      <member name="not_supported" value="7" c:identifier="G_DBUS_ERROR_NOT_SUPPORTED" glib:nick="not-supported">
        <doc xml:space="preserve">Requested operation isn't supported (like ENOSYS on UNIX).</doc>
      </member>
      <member name="limits_exceeded" value="8" c:identifier="G_DBUS_ERROR_LIMITS_EXCEEDED" glib:nick="limits-exceeded">
        <doc xml:space="preserve">Some limited resource is exhausted.</doc>
      </member>
      <member name="access_denied" value="9" c:identifier="G_DBUS_ERROR_ACCESS_DENIED" glib:nick="access-denied">
        <doc xml:space="preserve">Security restrictions don't allow doing what you're trying to do.</doc>
      </member>
      <member name="auth_failed" value="10" c:identifier="G_DBUS_ERROR_AUTH_FAILED" glib:nick="auth-failed">
        <doc xml:space="preserve">Authentication didn't work.</doc>
      </member>
      <member name="no_server" value="11" c:identifier="G_DBUS_ERROR_NO_SERVER" glib:nick="no-server">
        <doc xml:space="preserve">Unable to connect to server (probably caused by ECONNREFUSED on a
socket).</doc>
      </member>
      <member name="timeout" value="12" c:identifier="G_DBUS_ERROR_TIMEOUT" glib:nick="timeout">
        <doc xml:space="preserve">Certain timeout errors, possibly ETIMEDOUT on a socket.  Note that
%G_DBUS_ERROR_NO_REPLY is used for message reply timeouts. Warning:
this is confusingly-named given that %G_DBUS_ERROR_TIMED_OUT also
exists. We can't fix it for compatibility reasons so just be
careful.</doc>
      </member>
      <member name="no_network" value="13" c:identifier="G_DBUS_ERROR_NO_NETWORK" glib:nick="no-network">
        <doc xml:space="preserve">No network access (probably ENETUNREACH on a socket).</doc>
      </member>
      <member name="address_in_use" value="14" c:identifier="G_DBUS_ERROR_ADDRESS_IN_USE" glib:nick="address-in-use">
        <doc xml:space="preserve">Can't bind a socket since its address is in use (i.e. EADDRINUSE).</doc>
      </member>
      <member name="disconnected" value="15" c:identifier="G_DBUS_ERROR_DISCONNECTED" glib:nick="disconnected">
        <doc xml:space="preserve">The connection is disconnected and you're trying to use it.</doc>
      </member>
      <member name="invalid_args" value="16" c:identifier="G_DBUS_ERROR_INVALID_ARGS" glib:nick="invalid-args">
        <doc xml:space="preserve">Invalid arguments passed to a method call.</doc>
      </member>
      <member name="file_not_found" value="17" c:identifier="G_DBUS_ERROR_FILE_NOT_FOUND" glib:nick="file-not-found">
        <doc xml:space="preserve">Missing file.</doc>
      </member>
      <member name="file_exists" value="18" c:identifier="G_DBUS_ERROR_FILE_EXISTS" glib:nick="file-exists">
        <doc xml:space="preserve">Existing file and the operation you're using does not silently overwrite.</doc>
      </member>
      <member name="unknown_method" value="19" c:identifier="G_DBUS_ERROR_UNKNOWN_METHOD" glib:nick="unknown-method">
        <doc xml:space="preserve">Method name you invoked isn't known by the object you invoked it on.</doc>
      </member>
      <member name="timed_out" value="20" c:identifier="G_DBUS_ERROR_TIMED_OUT" glib:nick="timed-out">
        <doc xml:space="preserve">Certain timeout errors, e.g. while starting a service. Warning: this is
confusingly-named given that %G_DBUS_ERROR_TIMEOUT also exists. We
can't fix it for compatibility reasons so just be careful.</doc>
      </member>
      <member name="match_rule_not_found" value="21" c:identifier="G_DBUS_ERROR_MATCH_RULE_NOT_FOUND" glib:nick="match-rule-not-found">
        <doc xml:space="preserve">Tried to remove or modify a match rule that didn't exist.</doc>
      </member>
      <member name="match_rule_invalid" value="22" c:identifier="G_DBUS_ERROR_MATCH_RULE_INVALID" glib:nick="match-rule-invalid">
        <doc xml:space="preserve">The match rule isn't syntactically valid.</doc>
      </member>
      <member name="spawn_exec_failed" value="23" c:identifier="G_DBUS_ERROR_SPAWN_EXEC_FAILED" glib:nick="spawn-exec-failed">
        <doc xml:space="preserve">While starting a new process, the exec() call failed.</doc>
      </member>
      <member name="spawn_fork_failed" value="24" c:identifier="G_DBUS_ERROR_SPAWN_FORK_FAILED" glib:nick="spawn-fork-failed">
        <doc xml:space="preserve">While starting a new process, the fork() call failed.</doc>
      </member>
      <member name="spawn_child_exited" value="25" c:identifier="G_DBUS_ERROR_SPAWN_CHILD_EXITED" glib:nick="spawn-child-exited">
        <doc xml:space="preserve">While starting a new process, the child exited with a status code.</doc>
      </member>
      <member name="spawn_child_signaled" value="26" c:identifier="G_DBUS_ERROR_SPAWN_CHILD_SIGNALED" glib:nick="spawn-child-signaled">
        <doc xml:space="preserve">While starting a new process, the child exited on a signal.</doc>
      </member>
      <member name="spawn_failed" value="27" c:identifier="G_DBUS_ERROR_SPAWN_FAILED" glib:nick="spawn-failed">
        <doc xml:space="preserve">While starting a new process, something went wrong.</doc>
      </member>
      <member name="spawn_setup_failed" value="28" c:identifier="G_DBUS_ERROR_SPAWN_SETUP_FAILED" glib:nick="spawn-setup-failed">
        <doc xml:space="preserve">We failed to setup the environment correctly.</doc>
      </member>
      <member name="spawn_config_invalid" value="29" c:identifier="G_DBUS_ERROR_SPAWN_CONFIG_INVALID" glib:nick="spawn-config-invalid">
        <doc xml:space="preserve">We failed to setup the config parser correctly.</doc>
      </member>
      <member name="spawn_service_invalid" value="30" c:identifier="G_DBUS_ERROR_SPAWN_SERVICE_INVALID" glib:nick="spawn-service-invalid">
        <doc xml:space="preserve">Bus name was not valid.</doc>
      </member>
      <member name="spawn_service_not_found" value="31" c:identifier="G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND" glib:nick="spawn-service-not-found">
        <doc xml:space="preserve">Service file not found in system-services directory.</doc>
      </member>
      <member name="spawn_permissions_invalid" value="32" c:identifier="G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID" glib:nick="spawn-permissions-invalid">
        <doc xml:space="preserve">Permissions are incorrect on the setuid helper.</doc>
      </member>
      <member name="spawn_file_invalid" value="33" c:identifier="G_DBUS_ERROR_SPAWN_FILE_INVALID" glib:nick="spawn-file-invalid">
        <doc xml:space="preserve">Service file invalid (Name, User or Exec missing).</doc>
      </member>
      <member name="spawn_no_memory" value="34" c:identifier="G_DBUS_ERROR_SPAWN_NO_MEMORY" glib:nick="spawn-no-memory">
        <doc xml:space="preserve">Tried to get a UNIX process ID and it wasn't available.</doc>
      </member>
      <member name="unix_process_id_unknown" value="35" c:identifier="G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN" glib:nick="unix-process-id-unknown">
        <doc xml:space="preserve">Tried to get a UNIX process ID and it wasn't available.</doc>
      </member>
      <member name="invalid_signature" value="36" c:identifier="G_DBUS_ERROR_INVALID_SIGNATURE" glib:nick="invalid-signature">
        <doc xml:space="preserve">A type signature is not valid.</doc>
      </member>
      <member name="invalid_file_content" value="37" c:identifier="G_DBUS_ERROR_INVALID_FILE_CONTENT" glib:nick="invalid-file-content">
        <doc xml:space="preserve">A file contains invalid syntax or is otherwise broken.</doc>
      </member>
      <member name="selinux_security_context_unknown" value="38" c:identifier="G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN" glib:nick="selinux-security-context-unknown">
        <doc xml:space="preserve">Asked for SELinux security context and it wasn't available.</doc>
      </member>
      <member name="adt_audit_data_unknown" value="39" c:identifier="G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN" glib:nick="adt-audit-data-unknown">
        <doc xml:space="preserve">Asked for ADT audit data and it wasn't available.</doc>
      </member>
      <member name="object_path_in_use" value="40" c:identifier="G_DBUS_ERROR_OBJECT_PATH_IN_USE" glib:nick="object-path-in-use">
        <doc xml:space="preserve">There's already an object with the requested object path.</doc>
      </member>
      <member name="unknown_object" value="41" c:identifier="G_DBUS_ERROR_UNKNOWN_OBJECT" glib:nick="unknown-object">
        <doc xml:space="preserve">Object you invoked a method on isn't known. Since 2.42</doc>
      </member>
      <member name="unknown_interface" value="42" c:identifier="G_DBUS_ERROR_UNKNOWN_INTERFACE" glib:nick="unknown-interface">
        <doc xml:space="preserve">Interface you invoked a method on isn't known by the object. Since 2.42</doc>
      </member>
      <member name="unknown_property" value="43" c:identifier="G_DBUS_ERROR_UNKNOWN_PROPERTY" glib:nick="unknown-property">
        <doc xml:space="preserve">Property you tried to access isn't known by the object. Since 2.42</doc>
      </member>
      <member name="property_read_only" value="44" c:identifier="G_DBUS_ERROR_PROPERTY_READ_ONLY" glib:nick="property-read-only">
        <doc xml:space="preserve">Property you tried to set is read-only. Since 2.42</doc>
      </member>
      <function name="encode_gerror" c:identifier="g_dbus_error_encode_gerror" version="2.26">
        <doc xml:space="preserve">Creates a D-Bus error name to use for @error. If @error matches
a registered error (cf. g_dbus_error_register_error()), the corresponding
D-Bus error name will be returned.

Otherwise the a name of the form
`org.gtk.GDBus.UnmappedGError.Quark._ESCAPED_QUARK_NAME.Code_ERROR_CODE`
will be used. This allows other GDBus applications to map the error
on the wire back to a #GError using g_dbus_error_new_for_dbus_error().

This function is typically only used in object mappings to put a
#GError on the wire. Regular applications should not use it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A D-Bus error name (never %NULL). Free with g_free().</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">A #GError.</doc>
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_remote_error" c:identifier="g_dbus_error_get_remote_error" version="2.26">
        <doc xml:space="preserve">Gets the D-Bus error name used for @error, if any.

This function is guaranteed to return a D-Bus error name for all
#GErrors returned from functions handling remote method calls
(e.g. g_dbus_connection_call_finish()) unless
g_dbus_error_strip_remote_error() has been used on @error.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an allocated string or %NULL if the D-Bus error name
    could not be found. Free with g_free().</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">a #GError</doc>
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </function>
      <function name="is_remote_error" c:identifier="g_dbus_error_is_remote_error" version="2.26">
        <doc xml:space="preserve">Checks if @error represents an error received via D-Bus from a remote peer. If so,
use g_dbus_error_get_remote_error() to get the name of the error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @error represents an error from a remote peer,
%FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">A #GError.</doc>
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_for_dbus_error" c:identifier="g_dbus_error_new_for_dbus_error" version="2.26">
        <doc xml:space="preserve">Creates a #GError based on the contents of @dbus_error_name and
@dbus_error_message.

Errors registered with g_dbus_error_register_error() will be looked
up using @dbus_error_name and if a match is found, the error domain
and code is used. Applications can use g_dbus_error_get_remote_error()
to recover @dbus_error_name.

If a match against a registered error is not found and the D-Bus
error name is in a form as returned by g_dbus_error_encode_gerror()
the error domain and code encoded in the name is used to
create the #GError. Also, @dbus_error_name is added to the error message
such that it can be recovered with g_dbus_error_get_remote_error().

Otherwise, a #GError with the error code %G_IO_ERROR_DBUS_ERROR
in the #G_IO_ERROR error domain is returned. Also, @dbus_error_name is
added to the error message such that it can be recovered with
g_dbus_error_get_remote_error().

In all three cases, @dbus_error_name can always be recovered from the
returned #GError using the g_dbus_error_get_remote_error() function
(unless g_dbus_error_strip_remote_error() hasn't been used on the returned error).

This function is typically only used in object mappings to prepare
#GError instances for applications. Regular applications should not use
it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">An allocated #GError. Free with g_error_free().</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </return-value>
        <parameters>
          <parameter name="dbus_error_name" transfer-ownership="none">
            <doc xml:space="preserve">D-Bus error name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="dbus_error_message" transfer-ownership="none">
            <doc xml:space="preserve">D-Bus error message.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="quark" c:identifier="g_dbus_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="register_error" c:identifier="g_dbus_error_register_error" version="2.26">
        <doc xml:space="preserve">Creates an association to map between @dbus_error_name and
#GErrors specified by @error_domain and @error_code.

This is typically done in the routine that returns the #GQuark for
an error domain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the association was created, %FALSE if it already
exists.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="error_domain" transfer-ownership="none">
            <doc xml:space="preserve">A #GQuark for a error domain.</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="error_code" transfer-ownership="none">
            <doc xml:space="preserve">An error code.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="dbus_error_name" transfer-ownership="none">
            <doc xml:space="preserve">A D-Bus error name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="register_error_domain" c:identifier="g_dbus_error_register_error_domain" version="2.26">
        <doc xml:space="preserve">Helper function for associating a #GError error domain with D-Bus error names.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error_domain_quark_name" transfer-ownership="none">
            <doc xml:space="preserve">The error domain name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="quark_volatile" transfer-ownership="none">
            <doc xml:space="preserve">A pointer where to store the #GQuark.</doc>
            <type name="gsize" c:type="volatile gsize*"/>
          </parameter>
          <parameter name="entries" transfer-ownership="none">
            <doc xml:space="preserve">A pointer to @num_entries #GDBusErrorEntry struct items.</doc>
            <array length="3" zero-terminated="0" c:type="const GDBusErrorEntry*">
              <type name="DBusErrorEntry" c:type="GDBusErrorEntry"/>
            </array>
          </parameter>
          <parameter name="num_entries" transfer-ownership="none">
            <doc xml:space="preserve">Number of items to register.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="set_dbus_error" c:identifier="g_dbus_error_set_dbus_error" version="2.26" introspectable="0">
        <doc xml:space="preserve">Does nothing if @error is %NULL. Otherwise sets *@error to
a new #GError created with g_dbus_error_new_for_dbus_error()
with @dbus_error_message prepend with @format (unless %NULL).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">A pointer to a #GError or %NULL.</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="dbus_error_name" transfer-ownership="none">
            <doc xml:space="preserve">D-Bus error name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="dbus_error_message" transfer-ownership="none">
            <doc xml:space="preserve">D-Bus error message.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">printf()-style format to prepend to @dbus_error_message or %NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">Arguments for @format.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </function>
      <function name="set_dbus_error_valist" c:identifier="g_dbus_error_set_dbus_error_valist" version="2.26" introspectable="0">
        <doc xml:space="preserve">Like g_dbus_error_set_dbus_error() but intended for language bindings.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">A pointer to a #GError or %NULL.</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="dbus_error_name" transfer-ownership="none">
            <doc xml:space="preserve">D-Bus error name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="dbus_error_message" transfer-ownership="none">
            <doc xml:space="preserve">D-Bus error message.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">printf()-style format to prepend to @dbus_error_message or %NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:space="preserve">Arguments for @format.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </function>
      <function name="strip_remote_error" c:identifier="g_dbus_error_strip_remote_error" version="2.26">
        <doc xml:space="preserve">Looks for extra information in the error message used to recover
the D-Bus error name and strips it if found. If stripped, the
message field in @error will correspond exactly to what was
received on the wire.

This is typically used when presenting errors to the end user.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if information was stripped, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">A #GError.</doc>
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
        </parameters>
      </function>
      <function name="unregister_error" c:identifier="g_dbus_error_unregister_error" version="2.26">
        <doc xml:space="preserve">Destroys an association previously set up with g_dbus_error_register_error().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the association was destroyed, %FALSE if it wasn't found.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="error_domain" transfer-ownership="none">
            <doc xml:space="preserve">A #GQuark for a error domain.</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="error_code" transfer-ownership="none">
            <doc xml:space="preserve">An error code.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="dbus_error_name" transfer-ownership="none">
            <doc xml:space="preserve">A D-Bus error name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
    </enumeration>
    <record name="DBusErrorEntry" c:type="GDBusErrorEntry" version="2.26">
      <doc xml:space="preserve">Struct used in g_dbus_error_register_error_domain().</doc>
      <field name="error_code" writable="1">
        <doc xml:space="preserve">An error code.</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="dbus_error_name" writable="1">
        <doc xml:space="preserve">The D-Bus error name to associate with @error_code.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
    </record>
    <interface name="DBusInterface" c:symbol-prefix="dbus_interface" c:type="GDBusInterface" version="2.30" glib:type-name="GDBusInterface" glib:get-type="g_dbus_interface_get_type" glib:type-struct="DBusInterfaceIface">
      <doc xml:space="preserve">The #GDBusInterface type is the base type for D-Bus interfaces both
on the service side (see #GDBusInterfaceSkeleton) and client side
(see #GDBusProxy).</doc>
      <virtual-method name="dup_object" invoker="dup_object" version="2.32">
        <doc xml:space="preserve">Gets the #GDBusObject that @interface_ belongs to, if any.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GDBusObject or %NULL. The returned
reference should be freed with g_object_unref().</doc>
          <type name="DBusObject" c:type="GDBusObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">An exported D-Bus interface.</doc>
            <type name="DBusInterface" c:type="GDBusInterface*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_info" invoker="get_info" version="2.30">
        <doc xml:space="preserve">Gets D-Bus introspection information for the D-Bus interface
implemented by @interface_.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusInterfaceInfo. Do not free.</doc>
          <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">An exported D-Bus interface.</doc>
            <type name="DBusInterface" c:type="GDBusInterface*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_object" invoker="get_object" version="2.30" introspectable="0">
        <doc xml:space="preserve">Gets the #GDBusObject that @interface_ belongs to, if any.

It is not safe to use the returned object if @interface_ or
the returned object is being used from other threads. See
g_dbus_interface_dup_object() for a thread-safe alternative.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusObject or %NULL. The returned
    reference belongs to @interface_ and should not be freed.</doc>
          <type name="DBusObject" c:type="GDBusObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">An exported D-Bus interface</doc>
            <type name="DBusInterface" c:type="GDBusInterface*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_object" invoker="set_object" version="2.30">
        <doc xml:space="preserve">Sets the #GDBusObject for @interface_ to @object.

Note that @interface_ will hold a weak reference to @object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">An exported D-Bus interface.</doc>
            <type name="DBusInterface" c:type="GDBusInterface*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GDBusObject or %NULL.</doc>
            <type name="DBusObject" c:type="GDBusObject*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="dup_object" c:identifier="g_dbus_interface_dup_object" shadows="get_object" version="2.32">
        <doc xml:space="preserve">Gets the #GDBusObject that @interface_ belongs to, if any.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GDBusObject or %NULL. The returned
reference should be freed with g_object_unref().</doc>
          <type name="DBusObject" c:type="GDBusObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">An exported D-Bus interface.</doc>
            <type name="DBusInterface" c:type="GDBusInterface*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_info" c:identifier="g_dbus_interface_get_info" version="2.30">
        <doc xml:space="preserve">Gets D-Bus introspection information for the D-Bus interface
implemented by @interface_.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusInterfaceInfo. Do not free.</doc>
          <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">An exported D-Bus interface.</doc>
            <type name="DBusInterface" c:type="GDBusInterface*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_object" c:identifier="g_dbus_interface_get_object" shadowed-by="dup_object" version="2.30" introspectable="0">
        <doc xml:space="preserve">Gets the #GDBusObject that @interface_ belongs to, if any.

It is not safe to use the returned object if @interface_ or
the returned object is being used from other threads. See
g_dbus_interface_dup_object() for a thread-safe alternative.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusObject or %NULL. The returned
    reference belongs to @interface_ and should not be freed.</doc>
          <type name="DBusObject" c:type="GDBusObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">An exported D-Bus interface</doc>
            <type name="DBusInterface" c:type="GDBusInterface*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_object" c:identifier="g_dbus_interface_set_object" version="2.30">
        <doc xml:space="preserve">Sets the #GDBusObject for @interface_ to @object.

Note that @interface_ will hold a weak reference to @object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">An exported D-Bus interface.</doc>
            <type name="DBusInterface" c:type="GDBusInterface*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GDBusObject or %NULL.</doc>
            <type name="DBusObject" c:type="GDBusObject*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <callback name="DBusInterfaceGetPropertyFunc" c:type="GDBusInterfaceGetPropertyFunc" version="2.26">
      <doc xml:space="preserve">The type of the @get_property function in #GDBusInterfaceVTable.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A #GVariant with the value for @property_name or %NULL if
    @error is set. If the returned #GVariant is floating, it is
    consumed - otherwise its reference count is decreased by one.</doc>
        <type name="GLib.Variant" c:type="GVariant*"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusConnection.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="sender" transfer-ownership="none">
          <doc xml:space="preserve">The unique bus name of the remote caller.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="object_path" transfer-ownership="none">
          <doc xml:space="preserve">The object path that the method was invoked on.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:space="preserve">The D-Bus interface name for the property.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="property_name" transfer-ownership="none">
          <doc xml:space="preserve">The name of the property to get the value of.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">Return location for error.</doc>
          <type name="GLib.Error" c:type="GError**"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6">
          <doc xml:space="preserve">The @user_data #gpointer passed to g_dbus_connection_register_object().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="DBusInterfaceIface" c:type="GDBusInterfaceIface" glib:is-gtype-struct-for="DBusInterface" version="2.30">
      <doc xml:space="preserve">Base type for D-Bus interfaces.</doc>
      <field name="parent_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_info">
        <callback name="get_info">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceInfo. Do not free.</doc>
            <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
          </return-value>
          <parameters>
            <parameter name="interface_" transfer-ownership="none">
              <doc xml:space="preserve">An exported D-Bus interface.</doc>
              <type name="DBusInterface" c:type="GDBusInterface*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_object">
        <callback name="get_object">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObject or %NULL. The returned
    reference belongs to @interface_ and should not be freed.</doc>
            <type name="DBusObject" c:type="GDBusObject*"/>
          </return-value>
          <parameters>
            <parameter name="interface_" transfer-ownership="none">
              <doc xml:space="preserve">An exported D-Bus interface</doc>
              <type name="DBusInterface" c:type="GDBusInterface*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_object">
        <callback name="set_object">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="interface_" transfer-ownership="none">
              <doc xml:space="preserve">An exported D-Bus interface.</doc>
              <type name="DBusInterface" c:type="GDBusInterface*"/>
            </parameter>
            <parameter name="object" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">A #GDBusObject or %NULL.</doc>
              <type name="DBusObject" c:type="GDBusObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dup_object">
        <callback name="dup_object">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A #GDBusObject or %NULL. The returned
reference should be freed with g_object_unref().</doc>
            <type name="DBusObject" c:type="GDBusObject*"/>
          </return-value>
          <parameters>
            <parameter name="interface_" transfer-ownership="none">
              <doc xml:space="preserve">An exported D-Bus interface.</doc>
              <type name="DBusInterface" c:type="GDBusInterface*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo" version="2.26" glib:type-name="GDBusInterfaceInfo" glib:get-type="g_dbus_interface_info_get_type" c:symbol-prefix="dbus_interface_info">
      <doc xml:space="preserve">Information about a D-Bus interface.</doc>
      <field name="ref_count" writable="1">
        <doc xml:space="preserve">The reference count or -1 if statically allocated.</doc>
        <type name="gint" c:type="volatile gint"/>
      </field>
      <field name="name" writable="1">
        <doc xml:space="preserve">The name of the D-Bus interface, e.g. "org.freedesktop.DBus.Properties".</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="methods" writable="1">
        <doc xml:space="preserve">A pointer to a %NULL-terminated array of pointers to #GDBusMethodInfo structures or %NULL if there are no methods.</doc>
        <array c:type="GDBusMethodInfo**">
          <type name="DBusMethodInfo" c:type="GDBusMethodInfo*"/>
        </array>
      </field>
      <field name="signals" writable="1">
        <doc xml:space="preserve">A pointer to a %NULL-terminated array of pointers to #GDBusSignalInfo structures or %NULL if there are no signals.</doc>
        <array c:type="GDBusSignalInfo**">
          <type name="DBusSignalInfo" c:type="GDBusSignalInfo*"/>
        </array>
      </field>
      <field name="properties" writable="1">
        <doc xml:space="preserve">A pointer to a %NULL-terminated array of pointers to #GDBusPropertyInfo structures or %NULL if there are no properties.</doc>
        <array c:type="GDBusPropertyInfo**">
          <type name="DBusPropertyInfo" c:type="GDBusPropertyInfo*"/>
        </array>
      </field>
      <field name="annotations" writable="1">
        <doc xml:space="preserve">A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.</doc>
        <array c:type="GDBusAnnotationInfo**">
          <type name="DBusAnnotationInfo" c:type="GDBusAnnotationInfo*"/>
        </array>
      </field>
      <method name="cache_build" c:identifier="g_dbus_interface_info_cache_build" version="2.30">
        <doc xml:space="preserve">Builds a lookup-cache to speed up
g_dbus_interface_info_lookup_method(),
g_dbus_interface_info_lookup_signal() and
g_dbus_interface_info_lookup_property().

If this has already been called with @info, the existing cache is
used and its use count is increased.

Note that @info cannot be modified until
g_dbus_interface_info_cache_release() is called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceInfo.</doc>
            <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="cache_release" c:identifier="g_dbus_interface_info_cache_release" version="2.30">
        <doc xml:space="preserve">Decrements the usage count for the cache for @info built by
g_dbus_interface_info_cache_build() (if any) and frees the
resources used by the cache if the usage count drops to zero.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A GDBusInterfaceInfo</doc>
            <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="generate_xml" c:identifier="g_dbus_interface_info_generate_xml" version="2.26">
        <doc xml:space="preserve">Appends an XML representation of @info (and its children) to @string_builder.

This function is typically used for generating introspection XML
documents at run-time for handling the
`org.freedesktop.DBus.Introspectable.Introspect`
method.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusNodeInfo</doc>
            <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
          </instance-parameter>
          <parameter name="indent" transfer-ownership="none">
            <doc xml:space="preserve">Indentation level.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="string_builder" transfer-ownership="none">
            <doc xml:space="preserve">A #GString to to append XML data to.</doc>
            <type name="GLib.String" c:type="GString*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_method" c:identifier="g_dbus_interface_info_lookup_method" version="2.26">
        <doc xml:space="preserve">Looks up information about a method.

The cost of this function is O(n) in number of methods unless
g_dbus_interface_info_cache_build() has been used on @info.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusMethodInfo or %NULL if not found. Do not free, it is owned by @info.</doc>
          <type name="DBusMethodInfo" c:type="GDBusMethodInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceInfo.</doc>
            <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">A D-Bus method name (typically in CamelCase)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_property" c:identifier="g_dbus_interface_info_lookup_property" version="2.26">
        <doc xml:space="preserve">Looks up information about a property.

The cost of this function is O(n) in number of properties unless
g_dbus_interface_info_cache_build() has been used on @info.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusPropertyInfo or %NULL if not found. Do not free, it is owned by @info.</doc>
          <type name="DBusPropertyInfo" c:type="GDBusPropertyInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceInfo.</doc>
            <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">A D-Bus property name (typically in CamelCase).</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_signal" c:identifier="g_dbus_interface_info_lookup_signal" version="2.26">
        <doc xml:space="preserve">Looks up information about a signal.

The cost of this function is O(n) in number of signals unless
g_dbus_interface_info_cache_build() has been used on @info.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusSignalInfo or %NULL if not found. Do not free, it is owned by @info.</doc>
          <type name="DBusSignalInfo" c:type="GDBusSignalInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceInfo.</doc>
            <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">A D-Bus signal name (typically in CamelCase)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_dbus_interface_info_ref" version="2.26">
        <doc xml:space="preserve">If @info is statically allocated does nothing. Otherwise increases
the reference count.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The same @info.</doc>
          <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceInfo</doc>
            <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_dbus_interface_info_unref" version="2.26">
        <doc xml:space="preserve">If @info is statically allocated, does nothing. Otherwise decreases
the reference count of @info. When its reference count drops to 0,
the memory used is freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceInfo.</doc>
            <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <callback name="DBusInterfaceMethodCallFunc" c:type="GDBusInterfaceMethodCallFunc" version="2.26">
      <doc xml:space="preserve">The type of the @method_call function in #GDBusInterfaceVTable.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusConnection.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="sender" transfer-ownership="none">
          <doc xml:space="preserve">The unique bus name of the remote caller.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="object_path" transfer-ownership="none">
          <doc xml:space="preserve">The object path that the method was invoked on.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:space="preserve">The D-Bus interface name the method was invoked on.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="method_name" transfer-ownership="none">
          <doc xml:space="preserve">The name of the method that was invoked.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="parameters" transfer-ownership="none">
          <doc xml:space="preserve">A #GVariant tuple with parameters.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
        <parameter name="invocation" transfer-ownership="full">
          <doc xml:space="preserve">A #GDBusMethodInvocation object that must be used to return a value or error.</doc>
          <type name="DBusMethodInvocation" c:type="GDBusMethodInvocation*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="7">
          <doc xml:space="preserve">The @user_data #gpointer passed to g_dbus_connection_register_object().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="DBusInterfaceSetPropertyFunc" c:type="GDBusInterfaceSetPropertyFunc" version="2.26">
      <doc xml:space="preserve">The type of the @set_property function in #GDBusInterfaceVTable.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the property was set to @value, %FALSE if @error is set.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusConnection.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="sender" transfer-ownership="none">
          <doc xml:space="preserve">The unique bus name of the remote caller.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="object_path" transfer-ownership="none">
          <doc xml:space="preserve">The object path that the method was invoked on.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:space="preserve">The D-Bus interface name for the property.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="property_name" transfer-ownership="none">
          <doc xml:space="preserve">The name of the property to get the value of.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">The value to set the property to.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">Return location for error.</doc>
          <type name="GLib.Error" c:type="GError**"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="7">
          <doc xml:space="preserve">The @user_data #gpointer passed to g_dbus_connection_register_object().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="DBusInterfaceSkeleton" c:symbol-prefix="dbus_interface_skeleton" c:type="GDBusInterfaceSkeleton" version="2.30" parent="GObject.Object" abstract="1" glib:type-name="GDBusInterfaceSkeleton" glib:get-type="g_dbus_interface_skeleton_get_type" glib:type-struct="DBusInterfaceSkeletonClass">
      <doc xml:space="preserve">Abstract base class for D-Bus interfaces on the service side.</doc>
      <implements name="DBusInterface"/>
      <virtual-method name="flush" invoker="flush" version="2.30">
        <doc xml:space="preserve">If @interface_ has outstanding changes, request for these changes to be
emitted immediately.

For example, an exported D-Bus interface may queue up property
changes and emit the
`org.freedesktop.DBus.Properties.PropertiesChanged`
signal later (e.g. in an idle handler). This technique is useful
for collapsing multiple property changes into one.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceSkeleton.</doc>
            <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="g_authorize_method">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
          </instance-parameter>
          <parameter name="invocation" transfer-ownership="none">
            <type name="DBusMethodInvocation" c:type="GDBusMethodInvocation*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_info" invoker="get_info" version="2.30">
        <doc xml:space="preserve">Gets D-Bus introspection information for the D-Bus interface
implemented by @interface_.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusInterfaceInfo (never %NULL). Do not free.</doc>
          <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceSkeleton.</doc>
            <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_properties" invoker="get_properties" version="2.30">
        <doc xml:space="preserve">Gets all D-Bus properties for @interface_.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GVariant of type
['a{sv}'][G-VARIANT-TYPE-VARDICT:CAPS].
Free with g_variant_unref().</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceSkeleton.</doc>
            <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_vtable" invoker="get_vtable" version="2.30" introspectable="0">
        <doc xml:space="preserve">Gets the interface vtable for the D-Bus interface implemented by
@interface_. The returned function pointers should expect @interface_
itself to be passed as @user_data.</doc>
        <return-value>
          <doc xml:space="preserve">A #GDBusInterfaceVTable (never %NULL).</doc>
          <type name="DBusInterfaceVTable" c:type="GDBusInterfaceVTable*"/>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceSkeleton.</doc>
            <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="export" c:identifier="g_dbus_interface_skeleton_export" version="2.30" throws="1">
        <doc xml:space="preserve">Exports @interface_ at @object_path on @connection.

This can be called multiple times to export the same @interface_
onto multiple connections however the @object_path provided must be
the same for all connections.

Use g_dbus_interface_skeleton_unexport() to unexport the object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the interface was exported on @connection, otherwise %FALSE with
@error set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">The D-Bus interface to export.</doc>
            <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusConnection to export @interface_ on.</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">The path to export the interface at.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="flush" c:identifier="g_dbus_interface_skeleton_flush" version="2.30">
        <doc xml:space="preserve">If @interface_ has outstanding changes, request for these changes to be
emitted immediately.

For example, an exported D-Bus interface may queue up property
changes and emit the
`org.freedesktop.DBus.Properties.PropertiesChanged`
signal later (e.g. in an idle handler). This technique is useful
for collapsing multiple property changes into one.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceSkeleton.</doc>
            <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_connection" c:identifier="g_dbus_interface_skeleton_get_connection" version="2.30">
        <doc xml:space="preserve">Gets the first connection that @interface_ is exported on, if any.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusConnection or %NULL if @interface_ is
not exported anywhere. Do not free, the object belongs to @interface_.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceSkeleton.</doc>
            <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_connections" c:identifier="g_dbus_interface_skeleton_get_connections" version="2.32">
        <doc xml:space="preserve">Gets a list of the connections that @interface_ is exported on.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A list of
  all the connections that @interface_ is exported on. The returned
  list should be freed with g_list_free() after each element has
  been freed with g_object_unref().</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="DBusConnection"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceSkeleton.</doc>
            <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="g_dbus_interface_skeleton_get_flags" version="2.30">
        <doc xml:space="preserve">Gets the #GDBusInterfaceSkeletonFlags that describes what the behavior
of @interface_</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">One or more flags from the #GDBusInterfaceSkeletonFlags enumeration.</doc>
          <type name="DBusInterfaceSkeletonFlags" c:type="GDBusInterfaceSkeletonFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceSkeleton.</doc>
            <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_info" c:identifier="g_dbus_interface_skeleton_get_info" version="2.30">
        <doc xml:space="preserve">Gets D-Bus introspection information for the D-Bus interface
implemented by @interface_.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusInterfaceInfo (never %NULL). Do not free.</doc>
          <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceSkeleton.</doc>
            <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_object_path" c:identifier="g_dbus_interface_skeleton_get_object_path" version="2.30">
        <doc xml:space="preserve">Gets the object path that @interface_ is exported on, if any.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A string owned by @interface_ or %NULL if @interface_ is not exported
anywhere. Do not free, the string belongs to @interface_.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceSkeleton.</doc>
            <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_properties" c:identifier="g_dbus_interface_skeleton_get_properties" version="2.30">
        <doc xml:space="preserve">Gets all D-Bus properties for @interface_.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GVariant of type
['a{sv}'][G-VARIANT-TYPE-VARDICT:CAPS].
Free with g_variant_unref().</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceSkeleton.</doc>
            <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vtable" c:identifier="g_dbus_interface_skeleton_get_vtable" version="2.30" introspectable="0">
        <doc xml:space="preserve">Gets the interface vtable for the D-Bus interface implemented by
@interface_. The returned function pointers should expect @interface_
itself to be passed as @user_data.</doc>
        <return-value>
          <doc xml:space="preserve">A #GDBusInterfaceVTable (never %NULL).</doc>
          <type name="DBusInterfaceVTable" c:type="GDBusInterfaceVTable*"/>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceSkeleton.</doc>
            <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_connection" c:identifier="g_dbus_interface_skeleton_has_connection" version="2.32">
        <doc xml:space="preserve">Checks if @interface_ is exported on @connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @interface_ is exported on @connection, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceSkeleton.</doc>
            <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusConnection.</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flags" c:identifier="g_dbus_interface_skeleton_set_flags" version="2.30">
        <doc xml:space="preserve">Sets flags describing what the behavior of @skeleton should be.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceSkeleton.</doc>
            <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags from the #GDBusInterfaceSkeletonFlags enumeration.</doc>
            <type name="DBusInterfaceSkeletonFlags" c:type="GDBusInterfaceSkeletonFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="unexport" c:identifier="g_dbus_interface_skeleton_unexport" version="2.30">
        <doc xml:space="preserve">Stops exporting @interface_ on all connections it is exported on.

To unexport @interface_ from only a single connection, use
g_dbus_interface_skeleton_unexport_from_connection()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceSkeleton.</doc>
            <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unexport_from_connection" c:identifier="g_dbus_interface_skeleton_unexport_from_connection" version="2.32">
        <doc xml:space="preserve">Stops exporting @interface_ on @connection.

To stop exporting on all connections the interface is exported on,
use g_dbus_interface_skeleton_unexport().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceSkeleton.</doc>
            <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusConnection.</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </parameter>
        </parameters>
      </method>
      <property name="g-flags" version="2.30" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Flags from the #GDBusInterfaceSkeletonFlags enumeration.</doc>
        <type name="DBusInterfaceSkeletonFlags"/>
      </property>
      <field name="parent_instance" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="DBusInterfaceSkeletonPrivate" c:type="GDBusInterfaceSkeletonPrivate*"/>
      </field>
      <glib:signal name="g-authorize-method" when="last" version="2.30">
        <doc xml:space="preserve">Emitted when a method is invoked by a remote caller and used to
determine if the method call is authorized.

Note that this signal is emitted in a thread dedicated to
handling the method call so handlers are allowed to perform
blocking IO. This means that it is appropriate to call e.g.
[polkit_authority_check_authorization_sync()](http://hal.freedesktop.org/docs/polkit/PolkitAuthority.html#polkit-authority-check-authorization-sync)
with the
[POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION](http://hal.freedesktop.org/docs/polkit/PolkitAuthority.html#POLKIT-CHECK-AUTHORIZATION-FLAGS-ALLOW-USER-INTERACTION:CAPS)
flag set.

If %FALSE is returned then no further handlers are run and the
signal handler must take a reference to @invocation and finish
handling the call (e.g. return an error via
g_dbus_method_invocation_return_error()).

Otherwise, if %TRUE is returned, signal emission continues. If no
handlers return %FALSE, then the method is dispatched. If
@interface has an enclosing #GDBusObjectSkeleton, then the
#GDBusObjectSkeleton::authorize-method signal handlers run before
the handlers for this signal.

The default class handler just returns %TRUE.

Please note that the common case is optimized: if no signals
handlers are connected and the default class handler isn't
overridden (for both @interface and the enclosing
#GDBusObjectSkeleton, if any) and #GDBusInterfaceSkeleton:g-flags does
not have the
%G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD
flags set, no dedicated thread is ever used and the call will be
handled in the same thread as the object that @interface belongs
to was exported in.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the call is authorized, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="invocation" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMethodInvocation.</doc>
            <type name="DBusMethodInvocation"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="DBusInterfaceSkeletonClass" c:type="GDBusInterfaceSkeletonClass" glib:is-gtype-struct-for="DBusInterfaceSkeleton" version="2.30">
      <doc xml:space="preserve">Class structure for #GDBusInterfaceSkeleton.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">The parent class.</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="get_info">
        <callback name="get_info">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceInfo (never %NULL). Do not free.</doc>
            <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
          </return-value>
          <parameters>
            <parameter name="interface_" transfer-ownership="none">
              <doc xml:space="preserve">A #GDBusInterfaceSkeleton.</doc>
              <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_vtable" introspectable="0">
        <callback name="get_vtable" introspectable="0">
          <return-value>
            <doc xml:space="preserve">A #GDBusInterfaceVTable (never %NULL).</doc>
            <type name="DBusInterfaceVTable" c:type="GDBusInterfaceVTable*"/>
          </return-value>
          <parameters>
            <parameter name="interface_" transfer-ownership="none">
              <doc xml:space="preserve">A #GDBusInterfaceSkeleton.</doc>
              <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_properties">
        <callback name="get_properties">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A #GVariant of type
['a{sv}'][G-VARIANT-TYPE-VARDICT:CAPS].
Free with g_variant_unref().</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </return-value>
          <parameters>
            <parameter name="interface_" transfer-ownership="none">
              <doc xml:space="preserve">A #GDBusInterfaceSkeleton.</doc>
              <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="flush">
        <callback name="flush">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="interface_" transfer-ownership="none">
              <doc xml:space="preserve">A #GDBusInterfaceSkeleton.</doc>
              <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="vfunc_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <field name="g_authorize_method">
        <callback name="g_authorize_method">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="interface_" transfer-ownership="none">
              <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
            </parameter>
            <parameter name="invocation" transfer-ownership="none">
              <type name="DBusMethodInvocation" c:type="GDBusMethodInvocation*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="signal_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="DBusInterfaceSkeletonFlags" version="2.30" glib:type-name="GDBusInterfaceSkeletonFlags" glib:get-type="g_dbus_interface_skeleton_flags_get_type" c:type="GDBusInterfaceSkeletonFlags">
      <doc xml:space="preserve">Flags describing the behavior of a #GDBusInterfaceSkeleton instance.</doc>
      <member name="none" value="0" c:identifier="G_DBUS_INTERFACE_SKELETON_FLAGS_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
      <member name="handle_method_invocations_in_thread" value="1" c:identifier="G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD" glib:nick="handle-method-invocations-in-thread">
        <doc xml:space="preserve">Each method invocation is handled in
  a thread dedicated to the invocation. This means that the method implementation can use blocking IO
  without blocking any other part of the process. It also means that the method implementation must
  use locking to access data structures used by other threads.</doc>
      </member>
    </bitfield>
    <record name="DBusInterfaceSkeletonPrivate" c:type="GDBusInterfaceSkeletonPrivate" disguised="1">
    </record>
    <record name="DBusInterfaceVTable" c:type="GDBusInterfaceVTable" version="2.26">
      <doc xml:space="preserve">Virtual table for handling properties and method calls for a D-Bus
interface.

Since 2.38, if you want to handle getting/setting D-Bus properties
asynchronously, give %NULL as your get_property() or set_property()
function. The D-Bus call will be directed to your @method_call function,
with the provided @interface_name set to "org.freedesktop.DBus.Properties".

Ownership of the #GDBusMethodInvocation object passed to the
method_call() function is transferred to your handler; you must
call one of the methods of #GDBusMethodInvocation to return a reply
(possibly empty), or an error. These functions also take ownership
of the passed-in invocation object, so unless the invocation
object has otherwise been referenced, it will be then be freed.
Calling one of these functions may be done within your
method_call() implementation but it also can be done at a later
point to handle the method asynchronously.

The usual checks on the validity of the calls is performed. For
`Get` calls, an error is automatically returned if the property does
not exist or the permissions do not allow access. The same checks are
performed for `Set` calls, and the provided value is also checked for
being the correct type.

For both `Get` and `Set` calls, the #GDBusMethodInvocation
passed to the @method_call handler can be queried with
g_dbus_method_invocation_get_property_info() to get a pointer
to the #GDBusPropertyInfo of the property.

If you have readable properties specified in your interface info,
you must ensure that you either provide a non-%NULL @get_property()
function or provide implementations of both the `Get` and `GetAll`
methods on org.freedesktop.DBus.Properties interface in your @method_call
function. Note that the required return type of the `Get` call is
`(v)`, not the type of the property. `GetAll` expects a return value
of type `a{sv}`.

If you have writable properties specified in your interface info,
you must ensure that you either provide a non-%NULL @set_property()
function or provide an implementation of the `Set` call. If implementing
the call, you must return the value of type %G_VARIANT_TYPE_UNIT.</doc>
      <field name="method_call" writable="1">
        <doc xml:space="preserve">Function for handling incoming method calls.</doc>
        <type name="DBusInterfaceMethodCallFunc" c:type="GDBusInterfaceMethodCallFunc"/>
      </field>
      <field name="get_property" writable="1">
        <doc xml:space="preserve">Function for getting a property.</doc>
        <type name="DBusInterfaceGetPropertyFunc" c:type="GDBusInterfaceGetPropertyFunc"/>
      </field>
      <field name="set_property" writable="1">
        <doc xml:space="preserve">Function for setting a property.</doc>
        <type name="DBusInterfaceSetPropertyFunc" c:type="GDBusInterfaceSetPropertyFunc"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="DBusMenuModel" c:symbol-prefix="dbus_menu_model" c:type="GDBusMenuModel" parent="MenuModel" glib:type-name="GDBusMenuModel" glib:get-type="g_dbus_menu_model_get_type">
      <doc xml:space="preserve">#GDBusMenuModel is an implementation of #GMenuModel that can be used
as a proxy for a menu model that is exported over D-Bus with
g_dbus_connection_export_menu_model().</doc>
      <function name="get" c:identifier="g_dbus_menu_model_get" version="2.32">
        <doc xml:space="preserve">Obtains a #GDBusMenuModel for the menu model which is exported
at the given @bus_name and @object_path.

The thread default main context is taken at the time of this call.
All signals on the menu model (and any linked models) are reported
with respect to this context.  All calls on the returned menu model
(and linked models) must also originate from this same context, with
the thread default main context unchanged.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GDBusMenuModel object. Free with
    g_object_unref().</doc>
          <type name="DBusMenuModel" c:type="GDBusMenuModel*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </parameter>
          <parameter name="bus_name" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the bus name which exports the menu model
    or %NULL if @connection is not a message bus connection</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">the object path at which the menu model is exported</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
    </class>
    <class name="DBusMessage" c:symbol-prefix="dbus_message" c:type="GDBusMessage" version="2.26" parent="GObject.Object" glib:type-name="GDBusMessage" glib:get-type="g_dbus_message_get_type">
      <doc xml:space="preserve">A type for representing D-Bus messages that can be sent or received
on a #GDBusConnection.</doc>
      <constructor name="new" c:identifier="g_dbus_message_new" version="2.26">
        <doc xml:space="preserve">Creates a new empty #GDBusMessage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GDBusMessage. Free with g_object_unref().</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </return-value>
      </constructor>
      <constructor name="new_from_blob" c:identifier="g_dbus_message_new_from_blob" version="2.26" throws="1">
        <doc xml:space="preserve">Creates a new #GDBusMessage from the data stored at @blob. The byte
order that the message was in can be retrieved using
g_dbus_message_get_byte_order().

If the @blob cannot be parsed, contains invalid fields, or contains invalid
headers, %G_IO_ERROR_INVALID_ARGUMENT will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GDBusMessage or %NULL if @error is set. Free with
g_object_unref().</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </return-value>
        <parameters>
          <parameter name="blob" transfer-ownership="none">
            <doc xml:space="preserve">A blob representing a binary D-Bus message.</doc>
            <array length="1" zero-terminated="0" c:type="guchar*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="blob_len" transfer-ownership="none">
            <doc xml:space="preserve">The length of @blob.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="capabilities" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusCapabilityFlags describing what protocol features are supported.</doc>
            <type name="DBusCapabilityFlags" c:type="GDBusCapabilityFlags"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_method_call" c:identifier="g_dbus_message_new_method_call" version="2.26">
        <doc xml:space="preserve">Creates a new #GDBusMessage for a method call.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GDBusMessage. Free with g_object_unref().</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A valid D-Bus name or %NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">A valid object path.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="interface_" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A valid D-Bus interface name or %NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">A valid method name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_signal" c:identifier="g_dbus_message_new_signal" version="2.26">
        <doc xml:space="preserve">Creates a new #GDBusMessage for a signal emission.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GDBusMessage. Free with g_object_unref().</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">A valid object path.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">A valid D-Bus interface name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="signal" transfer-ownership="none">
            <doc xml:space="preserve">A valid signal name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="bytes_needed" c:identifier="g_dbus_message_bytes_needed" version="2.26" throws="1">
        <doc xml:space="preserve">Utility function to calculate how many bytes are needed to
completely deserialize the D-Bus message stored at @blob.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Number of bytes needed or -1 if @error is set (e.g. if
@blob contains invalid data or not enough data is available to
determine the size).</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="blob" transfer-ownership="none">
            <doc xml:space="preserve">A blob representing a binary D-Bus message.</doc>
            <array length="1" zero-terminated="0" c:type="guchar*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="blob_len" transfer-ownership="none">
            <doc xml:space="preserve">The length of @blob (must be at least 16).</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
      <method name="copy" c:identifier="g_dbus_message_copy" version="2.26" throws="1">
        <doc xml:space="preserve">Copies @message. The copy is a deep copy and the returned
#GDBusMessage is completely identical except that it is guaranteed
to not be locked.

This operation can fail if e.g. @message contains file descriptors
and the per-process or system-wide open files limit is reached.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GDBusMessage or %NULL if @error is set.
    Free with g_object_unref().</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_arg0" c:identifier="g_dbus_message_get_arg0" version="2.26">
        <doc xml:space="preserve">Convenience to get the first item in the body of @message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The string item or %NULL if the first item in the body of
@message is not a string.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_body" c:identifier="g_dbus_message_get_body" version="2.26">
        <doc xml:space="preserve">Gets the body of a message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GVariant or %NULL if the body is
empty. Do not free, it is owned by @message.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_byte_order" c:identifier="g_dbus_message_get_byte_order">
        <doc xml:space="preserve">Gets the byte order of @message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The byte order.</doc>
          <type name="DBusMessageByteOrder" c:type="GDBusMessageByteOrder"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_destination" c:identifier="g_dbus_message_get_destination" version="2.26">
        <doc xml:space="preserve">Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_error_name" c:identifier="g_dbus_message_get_error_name" version="2.26">
        <doc xml:space="preserve">Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="g_dbus_message_get_flags" version="2.26">
        <doc xml:space="preserve">Gets the flags for @message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Flags that are set (typically values from the #GDBusMessageFlags enumeration bitwise ORed together).</doc>
          <type name="DBusMessageFlags" c:type="GDBusMessageFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_header" c:identifier="g_dbus_message_get_header" version="2.26">
        <doc xml:space="preserve">Gets a header field on @message.

The caller is responsible for checking the type of the returned #GVariant
matches what is expected.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">A #GVariant with the value if the header was found, %NULL
otherwise. Do not free, it is owned by @message.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
          <parameter name="header_field" transfer-ownership="none">
            <doc xml:space="preserve">A 8-bit unsigned integer (typically a value from the #GDBusMessageHeaderField enumeration)</doc>
            <type name="DBusMessageHeaderField" c:type="GDBusMessageHeaderField"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_header_fields" c:identifier="g_dbus_message_get_header_fields" version="2.26">
        <doc xml:space="preserve">Gets an array of all header fields on @message that are set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">An array of header fields
terminated by %G_DBUS_MESSAGE_HEADER_FIELD_INVALID.  Each element
is a #guchar. Free with g_free().</doc>
          <array c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_interface" c:identifier="g_dbus_message_get_interface" version="2.26">
        <doc xml:space="preserve">Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_locked" c:identifier="g_dbus_message_get_locked" version="2.26">
        <doc xml:space="preserve">Checks whether @message is locked. To monitor changes to this
value, conncet to the #GObject::notify signal to listen for changes
on the #GDBusMessage:locked property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @message is locked, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_member" c:identifier="g_dbus_message_get_member" version="2.26">
        <doc xml:space="preserve">Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_MEMBER header field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_message_type" c:identifier="g_dbus_message_get_message_type" version="2.26">
        <doc xml:space="preserve">Gets the type of @message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A 8-bit unsigned integer (typically a value from the #GDBusMessageType enumeration).</doc>
          <type name="DBusMessageType" c:type="GDBusMessageType"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_unix_fds" c:identifier="g_dbus_message_get_num_unix_fds" version="2.26">
        <doc xml:space="preserve">Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_path" c:identifier="g_dbus_message_get_path" version="2.26">
        <doc xml:space="preserve">Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_PATH header field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_reply_serial" c:identifier="g_dbus_message_get_reply_serial" version="2.26">
        <doc xml:space="preserve">Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sender" c:identifier="g_dbus_message_get_sender" version="2.26">
        <doc xml:space="preserve">Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_SENDER header field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_serial" c:identifier="g_dbus_message_get_serial" version="2.26">
        <doc xml:space="preserve">Gets the serial for @message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #guint32.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_signature" c:identifier="g_dbus_message_get_signature" version="2.26">
        <doc xml:space="preserve">Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_unix_fd_list" c:identifier="g_dbus_message_get_unix_fd_list" version="2.26">
        <doc xml:space="preserve">Gets the UNIX file descriptors associated with @message, if any.

This method is only available on UNIX.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GUnixFDList or %NULL if no file descriptors are
associated. Do not free, this object is owned by @message.</doc>
          <type name="UnixFDList" c:type="GUnixFDList*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="lock" c:identifier="g_dbus_message_lock" version="2.26">
        <doc xml:space="preserve">If @message is locked, does nothing. Otherwise locks the message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="new_method_error" c:identifier="g_dbus_message_new_method_error" version="2.26" introspectable="0">
        <doc xml:space="preserve">Creates a new #GDBusMessage that is an error reply to @method_call_message.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GDBusMessage. Free with g_object_unref().</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="method_call_message" transfer-ownership="none">
            <doc xml:space="preserve">A message of type %G_DBUS_MESSAGE_TYPE_METHOD_CALL to
create a reply message to.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
          <parameter name="error_name" transfer-ownership="none">
            <doc xml:space="preserve">A valid D-Bus error name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="error_message_format" transfer-ownership="none">
            <doc xml:space="preserve">The D-Bus error message in a printf() format.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">Arguments for @error_message_format.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="new_method_error_literal" c:identifier="g_dbus_message_new_method_error_literal" version="2.26">
        <doc xml:space="preserve">Creates a new #GDBusMessage that is an error reply to @method_call_message.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GDBusMessage. Free with g_object_unref().</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="method_call_message" transfer-ownership="none">
            <doc xml:space="preserve">A message of type %G_DBUS_MESSAGE_TYPE_METHOD_CALL to
create a reply message to.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
          <parameter name="error_name" transfer-ownership="none">
            <doc xml:space="preserve">A valid D-Bus error name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="error_message" transfer-ownership="none">
            <doc xml:space="preserve">The D-Bus error message.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="new_method_error_valist" c:identifier="g_dbus_message_new_method_error_valist" version="2.26" introspectable="0">
        <doc xml:space="preserve">Like g_dbus_message_new_method_error() but intended for language bindings.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GDBusMessage. Free with g_object_unref().</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="method_call_message" transfer-ownership="none">
            <doc xml:space="preserve">A message of type %G_DBUS_MESSAGE_TYPE_METHOD_CALL to
create a reply message to.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
          <parameter name="error_name" transfer-ownership="none">
            <doc xml:space="preserve">A valid D-Bus error name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="error_message_format" transfer-ownership="none">
            <doc xml:space="preserve">The D-Bus error message in a printf() format.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:space="preserve">Arguments for @error_message_format.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="new_method_reply" c:identifier="g_dbus_message_new_method_reply" version="2.26">
        <doc xml:space="preserve">Creates a new #GDBusMessage that is a reply to @method_call_message.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GDBusMessage. Free with g_object_unref().</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="method_call_message" transfer-ownership="none">
            <doc xml:space="preserve">A message of type %G_DBUS_MESSAGE_TYPE_METHOD_CALL to
create a reply message to.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="print" c:identifier="g_dbus_message_print" version="2.26">
        <doc xml:space="preserve">Produces a human-readable multi-line description of @message.

The contents of the description has no ABI guarantees, the contents
and formatting is subject to change at any time. Typical output
looks something like this:
|[
Flags:   none
Version: 0
Serial:  4
Headers:
  path -&gt; objectpath '/org/gtk/GDBus/TestObject'
  interface -&gt; 'org.gtk.GDBus.TestInterface'
  member -&gt; 'GimmeStdout'
  destination -&gt; ':1.146'
Body: ()
UNIX File Descriptors:
  (none)
]|
or
|[
Flags:   no-reply-expected
Version: 0
Serial:  477
Headers:
  reply-serial -&gt; uint32 4
  destination -&gt; ':1.159'
  sender -&gt; ':1.146'
  num-unix-fds -&gt; uint32 1
Body: ()
UNIX File Descriptors:
  fd 12: dev=0:10,mode=020620,ino=5,uid=500,gid=5,rdev=136:2,size=0,atime=1273085037,mtime=1273085851,ctime=1272982635
]|</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A string that should be freed with g_free().</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
          <parameter name="indent" transfer-ownership="none">
            <doc xml:space="preserve">Indentation level.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_body" c:identifier="g_dbus_message_set_body" version="2.26">
        <doc xml:space="preserve">Sets the body @message. As a side-effect the
%G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field is set to the
type string of @body (or cleared if @body is %NULL).

If @body is floating, @message assumes ownership of @body.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
          <parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">Either %NULL or a #GVariant that is a tuple.</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_byte_order" c:identifier="g_dbus_message_set_byte_order">
        <doc xml:space="preserve">Sets the byte order of @message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
          <parameter name="byte_order" transfer-ownership="none">
            <doc xml:space="preserve">The byte order.</doc>
            <type name="DBusMessageByteOrder" c:type="GDBusMessageByteOrder"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_destination" c:identifier="g_dbus_message_set_destination" version="2.26">
        <doc xml:space="preserve">Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">The value to set.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_error_name" c:identifier="g_dbus_message_set_error_name" version="2.26">
        <doc xml:space="preserve">Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">The value to set.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flags" c:identifier="g_dbus_message_set_flags" version="2.26">
        <doc xml:space="preserve">Sets the flags to set on @message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags for @message that are set (typically values from the #GDBusMessageFlags
enumeration bitwise ORed together).</doc>
            <type name="DBusMessageFlags" c:type="GDBusMessageFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_header" c:identifier="g_dbus_message_set_header" version="2.26">
        <doc xml:space="preserve">Sets a header field on @message.

If @value is floating, @message assumes ownership of @value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
          <parameter name="header_field" transfer-ownership="none">
            <doc xml:space="preserve">A 8-bit unsigned integer (typically a value from the #GDBusMessageHeaderField enumeration)</doc>
            <type name="DBusMessageHeaderField" c:type="GDBusMessageHeaderField"/>
          </parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GVariant to set the header field or %NULL to clear the header field.</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_interface" c:identifier="g_dbus_message_set_interface" version="2.26">
        <doc xml:space="preserve">Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">The value to set.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_member" c:identifier="g_dbus_message_set_member" version="2.26">
        <doc xml:space="preserve">Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_MEMBER header field.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">The value to set.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_message_type" c:identifier="g_dbus_message_set_message_type" version="2.26">
        <doc xml:space="preserve">Sets @message to be of @type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">A 8-bit unsigned integer (typically a value from the #GDBusMessageType enumeration).</doc>
            <type name="DBusMessageType" c:type="GDBusMessageType"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_num_unix_fds" c:identifier="g_dbus_message_set_num_unix_fds" version="2.26">
        <doc xml:space="preserve">Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">The value to set.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_path" c:identifier="g_dbus_message_set_path" version="2.26">
        <doc xml:space="preserve">Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_PATH header field.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">The value to set.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_reply_serial" c:identifier="g_dbus_message_set_reply_serial" version="2.26">
        <doc xml:space="preserve">Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">The value to set.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sender" c:identifier="g_dbus_message_set_sender" version="2.26">
        <doc xml:space="preserve">Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_SENDER header field.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">The value to set.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_serial" c:identifier="g_dbus_message_set_serial" version="2.26">
        <doc xml:space="preserve">Sets the serial for @message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
          <parameter name="serial" transfer-ownership="none">
            <doc xml:space="preserve">A #guint32.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_signature" c:identifier="g_dbus_message_set_signature" version="2.26">
        <doc xml:space="preserve">Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">The value to set.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_unix_fd_list" c:identifier="g_dbus_message_set_unix_fd_list" version="2.26">
        <doc xml:space="preserve">Sets the UNIX file descriptors associated with @message. As a
side-effect the %G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header
field is set to the number of fds in @fd_list (or cleared if
@fd_list is %NULL).

This method is only available on UNIX.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
          <parameter name="fd_list" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GUnixFDList or %NULL.</doc>
            <type name="UnixFDList" c:type="GUnixFDList*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_blob" c:identifier="g_dbus_message_to_blob" version="2.26" throws="1">
        <doc xml:space="preserve">Serializes @message to a blob. The byte order returned by
g_dbus_message_get_byte_order() will be used.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A pointer to a
valid binary D-Bus message of @out_size bytes generated by @message
or %NULL if @error is set. Free with g_free().</doc>
          <array length="0" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
          <parameter name="out_size" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">Return location for size of generated blob.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="capabilities" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusCapabilityFlags describing what protocol features are supported.</doc>
            <type name="DBusCapabilityFlags" c:type="GDBusCapabilityFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_gerror" c:identifier="g_dbus_message_to_gerror" version="2.26" throws="1">
        <doc xml:space="preserve">If @message is not of type %G_DBUS_MESSAGE_TYPE_ERROR does
nothing and returns %FALSE.

Otherwise this method encodes the error in @message as a #GError
using g_dbus_error_set_dbus_error() using the information in the
%G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field of @message as
well as the first string item in @message's body.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @error was set, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="locked" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
    </class>
    <enumeration name="DBusMessageByteOrder" version="2.26" glib:type-name="GDBusMessageByteOrder" glib:get-type="g_dbus_message_byte_order_get_type" c:type="GDBusMessageByteOrder">
      <doc xml:space="preserve">Enumeration used to describe the byte order of a D-Bus message.</doc>
      <member name="big_endian" value="66" c:identifier="G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN" glib:nick="big-endian">
        <doc xml:space="preserve">The byte order is big endian.</doc>
      </member>
      <member name="little_endian" value="108" c:identifier="G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN" glib:nick="little-endian">
        <doc xml:space="preserve">The byte order is little endian.</doc>
      </member>
    </enumeration>
    <callback name="DBusMessageFilterFunction" c:type="GDBusMessageFilterFunction" version="2.26">
      <doc xml:space="preserve">Signature for function used in g_dbus_connection_add_filter().

A filter function is passed a #GDBusMessage and expected to return
a #GDBusMessage too. Passive filter functions that don't modify the
message can simply return the @message object:
|[
static GDBusMessage *
passive_filter (GDBusConnection *connection
                GDBusMessage    *message,
                gboolean         incoming,
                gpointer         user_data)
{
  // inspect @message
  return message;
}
]|
Filter functions that wants to drop a message can simply return %NULL:
|[
static GDBusMessage *
drop_filter (GDBusConnection *connection
             GDBusMessage    *message,
             gboolean         incoming,
             gpointer         user_data)
{
  if (should_drop_message)
    {
      g_object_unref (message);
      message = NULL;
    }
  return message;
}
]|
Finally, a filter function may modify a message by copying it:
|[
static GDBusMessage *
modifying_filter (GDBusConnection *connection
                  GDBusMessage    *message,
                  gboolean         incoming,
                  gpointer         user_data)
{
  GDBusMessage *copy;
  GError *error;

  error = NULL;
  copy = g_dbus_message_copy (message, &amp;error);
  // handle @error being set
  g_object_unref (message);

  // modify @copy

  return copy;
}
]|
If the returned #GDBusMessage is different from @message and cannot
be sent on @connection (it could use features, such as file
descriptors, not compatible with @connection), then a warning is
logged to standard error. Applications can
check this ahead of time using g_dbus_message_to_blob() passing a
#GDBusCapabilityFlags value obtained from @connection.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">A #GDBusMessage that will be freed with
g_object_unref() or %NULL to drop the message. Passive filter
functions can simply return the passed @message object.</doc>
        <type name="DBusMessage" c:type="GDBusMessage*"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusConnection.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="message" transfer-ownership="full">
          <doc xml:space="preserve">A locked #GDBusMessage that the filter function takes ownership of.</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </parameter>
        <parameter name="incoming" transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if it is a message received from the other peer, %FALSE if it is
a message to be sent to the other peer.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
          <doc xml:space="preserve">User data passed when adding the filter.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="DBusMessageFlags" version="2.26" glib:type-name="GDBusMessageFlags" glib:get-type="g_dbus_message_flags_get_type" c:type="GDBusMessageFlags">
      <doc xml:space="preserve">Message flags used in #GDBusMessage.</doc>
      <member name="none" value="0" c:identifier="G_DBUS_MESSAGE_FLAGS_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
      <member name="no_reply_expected" value="1" c:identifier="G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED" glib:nick="no-reply-expected">
        <doc xml:space="preserve">A reply is not expected.</doc>
      </member>
      <member name="no_auto_start" value="2" c:identifier="G_DBUS_MESSAGE_FLAGS_NO_AUTO_START" glib:nick="no-auto-start">
        <doc xml:space="preserve">The bus must not launch an
owner for the destination name in response to this message.</doc>
      </member>
      <member name="allow_interactive_authorization" value="4" c:identifier="G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION" glib:nick="allow-interactive-authorization">
        <doc xml:space="preserve">If set on a method
call, this flag means that the caller is prepared to wait for interactive
authorization. Since 2.46.</doc>
      </member>
    </bitfield>
    <enumeration name="DBusMessageHeaderField" version="2.26" glib:type-name="GDBusMessageHeaderField" glib:get-type="g_dbus_message_header_field_get_type" c:type="GDBusMessageHeaderField">
      <doc xml:space="preserve">Header fields used in #GDBusMessage.</doc>
      <member name="invalid" value="0" c:identifier="G_DBUS_MESSAGE_HEADER_FIELD_INVALID" glib:nick="invalid">
        <doc xml:space="preserve">Not a valid header field.</doc>
      </member>
      <member name="path" value="1" c:identifier="G_DBUS_MESSAGE_HEADER_FIELD_PATH" glib:nick="path">
        <doc xml:space="preserve">The object path.</doc>
      </member>
      <member name="interface" value="2" c:identifier="G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE" glib:nick="interface">
        <doc xml:space="preserve">The interface name.</doc>
      </member>
      <member name="member" value="3" c:identifier="G_DBUS_MESSAGE_HEADER_FIELD_MEMBER" glib:nick="member">
        <doc xml:space="preserve">The method or signal name.</doc>
      </member>
      <member name="error_name" value="4" c:identifier="G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME" glib:nick="error-name">
        <doc xml:space="preserve">The name of the error that occurred.</doc>
      </member>
      <member name="reply_serial" value="5" c:identifier="G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL" glib:nick="reply-serial">
        <doc xml:space="preserve">The serial number the message is a reply to.</doc>
      </member>
      <member name="destination" value="6" c:identifier="G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION" glib:nick="destination">
        <doc xml:space="preserve">The name the message is intended for.</doc>
      </member>
      <member name="sender" value="7" c:identifier="G_DBUS_MESSAGE_HEADER_FIELD_SENDER" glib:nick="sender">
        <doc xml:space="preserve">Unique name of the sender of the message (filled in by the bus).</doc>
      </member>
      <member name="signature" value="8" c:identifier="G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE" glib:nick="signature">
        <doc xml:space="preserve">The signature of the message body.</doc>
      </member>
      <member name="num_unix_fds" value="9" c:identifier="G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS" glib:nick="num-unix-fds">
        <doc xml:space="preserve">The number of UNIX file descriptors that accompany the message.</doc>
      </member>
    </enumeration>
    <enumeration name="DBusMessageType" version="2.26" glib:type-name="GDBusMessageType" glib:get-type="g_dbus_message_type_get_type" c:type="GDBusMessageType">
      <doc xml:space="preserve">Message types used in #GDBusMessage.</doc>
      <member name="invalid" value="0" c:identifier="G_DBUS_MESSAGE_TYPE_INVALID" glib:nick="invalid">
        <doc xml:space="preserve">Message is of invalid type.</doc>
      </member>
      <member name="method_call" value="1" c:identifier="G_DBUS_MESSAGE_TYPE_METHOD_CALL" glib:nick="method-call">
        <doc xml:space="preserve">Method call.</doc>
      </member>
      <member name="method_return" value="2" c:identifier="G_DBUS_MESSAGE_TYPE_METHOD_RETURN" glib:nick="method-return">
        <doc xml:space="preserve">Method reply.</doc>
      </member>
      <member name="error" value="3" c:identifier="G_DBUS_MESSAGE_TYPE_ERROR" glib:nick="error">
        <doc xml:space="preserve">Error reply.</doc>
      </member>
      <member name="signal" value="4" c:identifier="G_DBUS_MESSAGE_TYPE_SIGNAL" glib:nick="signal">
        <doc xml:space="preserve">Signal emission.</doc>
      </member>
    </enumeration>
    <record name="DBusMethodInfo" c:type="GDBusMethodInfo" version="2.26" glib:type-name="GDBusMethodInfo" glib:get-type="g_dbus_method_info_get_type" c:symbol-prefix="dbus_method_info">
      <doc xml:space="preserve">Information about a method on an D-Bus interface.</doc>
      <field name="ref_count" writable="1">
        <doc xml:space="preserve">The reference count or -1 if statically allocated.</doc>
        <type name="gint" c:type="volatile gint"/>
      </field>
      <field name="name" writable="1">
        <doc xml:space="preserve">The name of the D-Bus method, e.g. @RequestName.</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="in_args" writable="1">
        <doc xml:space="preserve">A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no in arguments.</doc>
        <array c:type="GDBusArgInfo**">
          <type name="DBusArgInfo" c:type="GDBusArgInfo*"/>
        </array>
      </field>
      <field name="out_args" writable="1">
        <doc xml:space="preserve">A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no out arguments.</doc>
        <array c:type="GDBusArgInfo**">
          <type name="DBusArgInfo" c:type="GDBusArgInfo*"/>
        </array>
      </field>
      <field name="annotations" writable="1">
        <doc xml:space="preserve">A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.</doc>
        <array c:type="GDBusAnnotationInfo**">
          <type name="DBusAnnotationInfo" c:type="GDBusAnnotationInfo*"/>
        </array>
      </field>
      <method name="ref" c:identifier="g_dbus_method_info_ref" version="2.26">
        <doc xml:space="preserve">If @info is statically allocated does nothing. Otherwise increases
the reference count.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The same @info.</doc>
          <type name="DBusMethodInfo" c:type="GDBusMethodInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMethodInfo</doc>
            <type name="DBusMethodInfo" c:type="GDBusMethodInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_dbus_method_info_unref" version="2.26">
        <doc xml:space="preserve">If @info is statically allocated, does nothing. Otherwise decreases
the reference count of @info. When its reference count drops to 0,
the memory used is freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMethodInfo.</doc>
            <type name="DBusMethodInfo" c:type="GDBusMethodInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <class name="DBusMethodInvocation" c:symbol-prefix="dbus_method_invocation" c:type="GDBusMethodInvocation" version="2.26" parent="GObject.Object" glib:type-name="GDBusMethodInvocation" glib:get-type="g_dbus_method_invocation_get_type">
      <doc xml:space="preserve">Instances of the #GDBusMethodInvocation class are used when
handling D-Bus method calls. It provides a way to asynchronously
return results and errors.

The normal way to obtain a #GDBusMethodInvocation object is to receive
it as an argument to the handle_method_call() function in a
#GDBusInterfaceVTable that was passed to g_dbus_connection_register_object().</doc>
      <method name="get_connection" c:identifier="g_dbus_method_invocation_get_connection" version="2.26">
        <doc xml:space="preserve">Gets the #GDBusConnection the method was invoked on.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusConnection. Do not free, it is owned by @invocation.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="invocation" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMethodInvocation.</doc>
            <type name="DBusMethodInvocation" c:type="GDBusMethodInvocation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_interface_name" c:identifier="g_dbus_method_invocation_get_interface_name" version="2.26">
        <doc xml:space="preserve">Gets the name of the D-Bus interface the method was invoked on.

If this method call is a property Get, Set or GetAll call that has
been redirected to the method call handler then
"org.freedesktop.DBus.Properties" will be returned.  See
#GDBusInterfaceVTable for more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A string. Do not free, it is owned by @invocation.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="invocation" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMethodInvocation.</doc>
            <type name="DBusMethodInvocation" c:type="GDBusMethodInvocation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_message" c:identifier="g_dbus_method_invocation_get_message" version="2.26">
        <doc xml:space="preserve">Gets the #GDBusMessage for the method invocation. This is useful if
you need to use low-level protocol features, such as UNIX file
descriptor passing, that cannot be properly expressed in the
#GVariant API.

See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
for an example of how to use this low-level API to send and receive
UNIX file descriptors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#GDBusMessage. Do not free, it is owned by @invocation.</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="invocation" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMethodInvocation.</doc>
            <type name="DBusMethodInvocation" c:type="GDBusMethodInvocation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_method_info" c:identifier="g_dbus_method_invocation_get_method_info" version="2.26">
        <doc xml:space="preserve">Gets information about the method call, if any.

If this method invocation is a property Get, Set or GetAll call that
has been redirected to the method call handler then %NULL will be
returned.  See g_dbus_method_invocation_get_property_info() and
#GDBusInterfaceVTable for more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusMethodInfo or %NULL. Do not free, it is owned by @invocation.</doc>
          <type name="DBusMethodInfo" c:type="const GDBusMethodInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="invocation" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMethodInvocation.</doc>
            <type name="DBusMethodInvocation" c:type="GDBusMethodInvocation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_method_name" c:identifier="g_dbus_method_invocation_get_method_name" version="2.26">
        <doc xml:space="preserve">Gets the name of the method that was invoked.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A string. Do not free, it is owned by @invocation.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="invocation" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMethodInvocation.</doc>
            <type name="DBusMethodInvocation" c:type="GDBusMethodInvocation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_object_path" c:identifier="g_dbus_method_invocation_get_object_path" version="2.26">
        <doc xml:space="preserve">Gets the object path the method was invoked on.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A string. Do not free, it is owned by @invocation.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="invocation" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMethodInvocation.</doc>
            <type name="DBusMethodInvocation" c:type="GDBusMethodInvocation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parameters" c:identifier="g_dbus_method_invocation_get_parameters" version="2.26">
        <doc xml:space="preserve">Gets the parameters of the method invocation. If there are no input
parameters then this will return a GVariant with 0 children rather than NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GVariant tuple. Do not unref this because it is owned by @invocation.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="invocation" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMethodInvocation.</doc>
            <type name="DBusMethodInvocation" c:type="GDBusMethodInvocation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_property_info" c:identifier="g_dbus_method_invocation_get_property_info" version="2.38">
        <doc xml:space="preserve">Gets information about the property that this method call is for, if
any.

This will only be set in the case of an invocation in response to a
property Get or Set call that has been directed to the method call
handler for an object on account of its property_get() or
property_set() vtable pointers being unset.

See #GDBusInterfaceVTable for more information.

If the call was GetAll, %NULL will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GDBusPropertyInfo or %NULL</doc>
          <type name="DBusPropertyInfo" c:type="const GDBusPropertyInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="invocation" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMethodInvocation</doc>
            <type name="DBusMethodInvocation" c:type="GDBusMethodInvocation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sender" c:identifier="g_dbus_method_invocation_get_sender" version="2.26">
        <doc xml:space="preserve">Gets the bus name that invoked the method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A string. Do not free, it is owned by @invocation.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="invocation" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMethodInvocation.</doc>
            <type name="DBusMethodInvocation" c:type="GDBusMethodInvocation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_user_data" c:identifier="g_dbus_method_invocation_get_user_data" version="2.26" introspectable="0">
        <doc xml:space="preserve">Gets the @user_data #gpointer passed to g_dbus_connection_register_object().</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">A #gpointer.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="invocation" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMethodInvocation.</doc>
            <type name="DBusMethodInvocation" c:type="GDBusMethodInvocation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="return_dbus_error" c:identifier="g_dbus_method_invocation_return_dbus_error" version="2.26">
        <doc xml:space="preserve">Finishes handling a D-Bus method call by returning an error.

This method will take ownership of @invocation. See
#GDBusInterfaceVTable for more information about the ownership of
@invocation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="invocation" transfer-ownership="full">
            <doc xml:space="preserve">A #GDBusMethodInvocation.</doc>
            <type name="DBusMethodInvocation" c:type="GDBusMethodInvocation*"/>
          </instance-parameter>
          <parameter name="error_name" transfer-ownership="none">
            <doc xml:space="preserve">A valid D-Bus error name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="error_message" transfer-ownership="none">
            <doc xml:space="preserve">A valid D-Bus error message.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="return_error" c:identifier="g_dbus_method_invocation_return_error" version="2.26" introspectable="0">
        <doc xml:space="preserve">Finishes handling a D-Bus method call by returning an error.

See g_dbus_error_encode_gerror() for details about what error name
will be returned on the wire. In a nutshell, if the given error is
registered using g_dbus_error_register_error() the name given
during registration is used. Otherwise, a name of the form
`org.gtk.GDBus.UnmappedGError.Quark...` is used. This provides
transparent mapping of #GError between applications using GDBus.

If you are writing an application intended to be portable,
always register errors with g_dbus_error_register_error()
or use g_dbus_method_invocation_return_dbus_error().

This method will take ownership of @invocation. See
#GDBusInterfaceVTable for more information about the ownership of
@invocation.

Since 2.48, if the method call requested for a reply not to be sent
then this call will free @invocation but otherwise do nothing (as per
the recommendations of the D-Bus specification).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="invocation" transfer-ownership="full">
            <doc xml:space="preserve">A #GDBusMethodInvocation.</doc>
            <type name="DBusMethodInvocation" c:type="GDBusMethodInvocation*"/>
          </instance-parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">A #GQuark for the #GError error domain.</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:space="preserve">The error code.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">printf()-style format.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">Parameters for @format.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="return_error_literal" c:identifier="g_dbus_method_invocation_return_error_literal" version="2.26">
        <doc xml:space="preserve">Like g_dbus_method_invocation_return_error() but without printf()-style formatting.

This method will take ownership of @invocation. See
#GDBusInterfaceVTable for more information about the ownership of
@invocation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="invocation" transfer-ownership="full">
            <doc xml:space="preserve">A #GDBusMethodInvocation.</doc>
            <type name="DBusMethodInvocation" c:type="GDBusMethodInvocation*"/>
          </instance-parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">A #GQuark for the #GError error domain.</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:space="preserve">The error code.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">The error message.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="return_error_valist" c:identifier="g_dbus_method_invocation_return_error_valist" version="2.26" introspectable="0">
        <doc xml:space="preserve">Like g_dbus_method_invocation_return_error() but intended for
language bindings.

This method will take ownership of @invocation. See
#GDBusInterfaceVTable for more information about the ownership of
@invocation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="invocation" transfer-ownership="full">
            <doc xml:space="preserve">A #GDBusMethodInvocation.</doc>
            <type name="DBusMethodInvocation" c:type="GDBusMethodInvocation*"/>
          </instance-parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">A #GQuark for the #GError error domain.</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:space="preserve">The error code.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">printf()-style format.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:space="preserve">#va_list of parameters for @format.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="return_gerror" c:identifier="g_dbus_method_invocation_return_gerror" version="2.26">
        <doc xml:space="preserve">Like g_dbus_method_invocation_return_error() but takes a #GError
instead of the error domain, error code and message.

This method will take ownership of @invocation. See
#GDBusInterfaceVTable for more information about the ownership of
@invocation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="invocation" transfer-ownership="full">
            <doc xml:space="preserve">A #GDBusMethodInvocation.</doc>
            <type name="DBusMethodInvocation" c:type="GDBusMethodInvocation*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">A #GError.</doc>
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </method>
      <method name="return_value" c:identifier="g_dbus_method_invocation_return_value" version="2.26">
        <doc xml:space="preserve">Finishes handling a D-Bus method call by returning @parameters.
If the @parameters GVariant is floating, it is consumed.

It is an error if @parameters is not of the right format: it must be a tuple
containing the out-parameters of the D-Bus method. Even if the method has a
single out-parameter, it must be contained in a tuple. If the method has no
out-parameters, @parameters may be %NULL or an empty tuple.

|[&lt;!-- language="C" --&gt;
GDBusMethodInvocation *invocation = some_invocation;
g_autofree gchar *result_string = NULL;
g_autoptr (GError) error = NULL;

result_string = calculate_result (&amp;error);

if (error != NULL)
  g_dbus_method_invocation_return_gerror (invocation, error);
else
  g_dbus_method_invocation_return_value (invocation,
                                         g_variant_new ("(s)", result_string));

// Do not free @invocation here; returning a value does that
]|

This method will take ownership of @invocation. See
#GDBusInterfaceVTable for more information about the ownership of
@invocation.

Since 2.48, if the method call requested for a reply not to be sent
then this call will sink @parameters and free @invocation, but
otherwise do nothing (as per the recommendations of the D-Bus
specification).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="invocation" transfer-ownership="full">
            <doc xml:space="preserve">A #GDBusMethodInvocation.</doc>
            <type name="DBusMethodInvocation" c:type="GDBusMethodInvocation*"/>
          </instance-parameter>
          <parameter name="parameters" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GVariant tuple with out parameters for the method or %NULL if not passing any parameters.</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="return_value_with_unix_fd_list" c:identifier="g_dbus_method_invocation_return_value_with_unix_fd_list" version="2.30">
        <doc xml:space="preserve">Like g_dbus_method_invocation_return_value() but also takes a #GUnixFDList.

This method is only available on UNIX.

This method will take ownership of @invocation. See
#GDBusInterfaceVTable for more information about the ownership of
@invocation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="invocation" transfer-ownership="full">
            <doc xml:space="preserve">A #GDBusMethodInvocation.</doc>
            <type name="DBusMethodInvocation" c:type="GDBusMethodInvocation*"/>
          </instance-parameter>
          <parameter name="parameters" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GVariant tuple with out parameters for the method or %NULL if not passing any parameters.</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="fd_list" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GUnixFDList or %NULL.</doc>
            <type name="UnixFDList" c:type="GUnixFDList*"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_error" c:identifier="g_dbus_method_invocation_take_error" version="2.30" introspectable="0">
        <doc xml:space="preserve">Like g_dbus_method_invocation_return_gerror() but takes ownership
of @error so the caller does not need to free it.

This method will take ownership of @invocation. See
#GDBusInterfaceVTable for more information about the ownership of
@invocation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="invocation" transfer-ownership="full">
            <doc xml:space="preserve">A #GDBusMethodInvocation.</doc>
            <type name="DBusMethodInvocation" c:type="GDBusMethodInvocation*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="full">
            <doc xml:space="preserve">A #GError.</doc>
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="DBusNodeInfo" c:type="GDBusNodeInfo" version="2.26" glib:type-name="GDBusNodeInfo" glib:get-type="g_dbus_node_info_get_type" c:symbol-prefix="dbus_node_info">
      <doc xml:space="preserve">Information about nodes in a remote object hierarchy.</doc>
      <field name="ref_count" writable="1">
        <doc xml:space="preserve">The reference count or -1 if statically allocated.</doc>
        <type name="gint" c:type="volatile gint"/>
      </field>
      <field name="path" writable="1">
        <doc xml:space="preserve">The path of the node or %NULL if omitted. Note that this may be a relative path. See the D-Bus specification for more details.</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="interfaces" writable="1">
        <doc xml:space="preserve">A pointer to a %NULL-terminated array of pointers to #GDBusInterfaceInfo structures or %NULL if there are no interfaces.</doc>
        <array c:type="GDBusInterfaceInfo**">
          <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
        </array>
      </field>
      <field name="nodes" writable="1">
        <doc xml:space="preserve">A pointer to a %NULL-terminated array of pointers to #GDBusNodeInfo structures or %NULL if there are no nodes.</doc>
        <array c:type="GDBusNodeInfo**">
          <type name="DBusNodeInfo" c:type="GDBusNodeInfo*"/>
        </array>
      </field>
      <field name="annotations" writable="1">
        <doc xml:space="preserve">A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.</doc>
        <array c:type="GDBusAnnotationInfo**">
          <type name="DBusAnnotationInfo" c:type="GDBusAnnotationInfo*"/>
        </array>
      </field>
      <constructor name="new_for_xml" c:identifier="g_dbus_node_info_new_for_xml" version="2.26" throws="1">
        <doc xml:space="preserve">Parses @xml_data and returns a #GDBusNodeInfo representing the data.

The introspection XML must contain exactly one top-level
&lt;node&gt; element.

Note that this routine is using a
[GMarkup][glib-Simple-XML-Subset-Parser.description]-based
parser that only accepts a subset of valid XML documents.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GDBusNodeInfo structure or %NULL if @error is set. Free
with g_dbus_node_info_unref().</doc>
          <type name="DBusNodeInfo" c:type="GDBusNodeInfo*"/>
        </return-value>
        <parameters>
          <parameter name="xml_data" transfer-ownership="none">
            <doc xml:space="preserve">Valid D-Bus introspection XML.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="generate_xml" c:identifier="g_dbus_node_info_generate_xml" version="2.26">
        <doc xml:space="preserve">Appends an XML representation of @info (and its children) to @string_builder.

This function is typically used for generating introspection XML documents at run-time for
handling the `org.freedesktop.DBus.Introspectable.Introspect`  method.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusNodeInfo.</doc>
            <type name="DBusNodeInfo" c:type="GDBusNodeInfo*"/>
          </instance-parameter>
          <parameter name="indent" transfer-ownership="none">
            <doc xml:space="preserve">Indentation level.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="string_builder" transfer-ownership="none">
            <doc xml:space="preserve">A #GString to to append XML data to.</doc>
            <type name="GLib.String" c:type="GString*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_interface" c:identifier="g_dbus_node_info_lookup_interface" version="2.26">
        <doc xml:space="preserve">Looks up information about an interface.

The cost of this function is O(n) in number of interfaces.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusInterfaceInfo or %NULL if not found. Do not free, it is owned by @info.</doc>
          <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusNodeInfo.</doc>
            <type name="DBusNodeInfo" c:type="GDBusNodeInfo*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">A D-Bus interface name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_dbus_node_info_ref" version="2.26">
        <doc xml:space="preserve">If @info is statically allocated does nothing. Otherwise increases
the reference count.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The same @info.</doc>
          <type name="DBusNodeInfo" c:type="GDBusNodeInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusNodeInfo</doc>
            <type name="DBusNodeInfo" c:type="GDBusNodeInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_dbus_node_info_unref" version="2.26">
        <doc xml:space="preserve">If @info is statically allocated, does nothing. Otherwise decreases
the reference count of @info. When its reference count drops to 0,
the memory used is freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusNodeInfo.</doc>
            <type name="DBusNodeInfo" c:type="GDBusNodeInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <interface name="DBusObject" c:symbol-prefix="dbus_object" c:type="GDBusObject" glib:type-name="GDBusObject" glib:get-type="g_dbus_object_get_type" glib:type-struct="DBusObjectIface">
      <doc xml:space="preserve">The #GDBusObject type is the base type for D-Bus objects on both
the service side (see #GDBusObjectSkeleton) and the client side
(see #GDBusObjectProxy). It is essentially just a container of
interfaces.</doc>
      <virtual-method name="get_interface" invoker="get_interface" version="2.30">
        <doc xml:space="preserve">Gets the D-Bus interface with name @interface_name associated with
@object, if any.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">%NULL if not found, otherwise a
  #GDBusInterface that must be freed with g_object_unref().</doc>
          <type name="DBusInterface" c:type="GDBusInterface*"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObject.</doc>
            <type name="DBusObject" c:type="GDBusObject*"/>
          </instance-parameter>
          <parameter name="interface_name" transfer-ownership="none">
            <doc xml:space="preserve">A D-Bus interface name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_interfaces" invoker="get_interfaces" version="2.30">
        <doc xml:space="preserve">Gets the D-Bus interfaces associated with @object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A list of #GDBusInterface instances.
  The returned list must be freed by g_list_free() after each element has been freed
  with g_object_unref().</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="DBusInterface"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObject.</doc>
            <type name="DBusObject" c:type="GDBusObject*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_object_path" invoker="get_object_path" version="2.30">
        <doc xml:space="preserve">Gets the object path for @object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A string owned by @object. Do not free.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObject.</doc>
            <type name="DBusObject" c:type="GDBusObject*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="interface_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="DBusObject" c:type="GDBusObject*"/>
          </instance-parameter>
          <parameter name="interface_" transfer-ownership="none">
            <type name="DBusInterface" c:type="GDBusInterface*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="interface_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="DBusObject" c:type="GDBusObject*"/>
          </instance-parameter>
          <parameter name="interface_" transfer-ownership="none">
            <type name="DBusInterface" c:type="GDBusInterface*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_interface" c:identifier="g_dbus_object_get_interface" version="2.30">
        <doc xml:space="preserve">Gets the D-Bus interface with name @interface_name associated with
@object, if any.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">%NULL if not found, otherwise a
  #GDBusInterface that must be freed with g_object_unref().</doc>
          <type name="DBusInterface" c:type="GDBusInterface*"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObject.</doc>
            <type name="DBusObject" c:type="GDBusObject*"/>
          </instance-parameter>
          <parameter name="interface_name" transfer-ownership="none">
            <doc xml:space="preserve">A D-Bus interface name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_interfaces" c:identifier="g_dbus_object_get_interfaces" version="2.30">
        <doc xml:space="preserve">Gets the D-Bus interfaces associated with @object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A list of #GDBusInterface instances.
  The returned list must be freed by g_list_free() after each element has been freed
  with g_object_unref().</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="DBusInterface"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObject.</doc>
            <type name="DBusObject" c:type="GDBusObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_object_path" c:identifier="g_dbus_object_get_object_path" version="2.30">
        <doc xml:space="preserve">Gets the object path for @object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A string owned by @object. Do not free.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObject.</doc>
            <type name="DBusObject" c:type="GDBusObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <glib:signal name="interface-added" when="last" version="2.30">
        <doc xml:space="preserve">Emitted when @interface is added to @object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="interface" transfer-ownership="none">
            <doc xml:space="preserve">The #GDBusInterface that was added.</doc>
            <type name="DBusInterface"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="interface-removed" when="last" version="2.30">
        <doc xml:space="preserve">Emitted when @interface is removed from @object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="interface" transfer-ownership="none">
            <doc xml:space="preserve">The #GDBusInterface that was removed.</doc>
            <type name="DBusInterface"/>
          </parameter>
        </parameters>
      </glib:signal>
    </interface>
    <record name="DBusObjectIface" c:type="GDBusObjectIface" glib:is-gtype-struct-for="DBusObject" version="2.30">
      <doc xml:space="preserve">Base object type for D-Bus objects.</doc>
      <field name="parent_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_object_path">
        <callback name="get_object_path">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A string owned by @object. Do not free.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <doc xml:space="preserve">A #GDBusObject.</doc>
              <type name="DBusObject" c:type="GDBusObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_interfaces">
        <callback name="get_interfaces">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A list of #GDBusInterface instances.
  The returned list must be freed by g_list_free() after each element has been freed
  with g_object_unref().</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="DBusInterface"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <doc xml:space="preserve">A #GDBusObject.</doc>
              <type name="DBusObject" c:type="GDBusObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_interface">
        <callback name="get_interface">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">%NULL if not found, otherwise a
  #GDBusInterface that must be freed with g_object_unref().</doc>
            <type name="DBusInterface" c:type="GDBusInterface*"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <doc xml:space="preserve">A #GDBusObject.</doc>
              <type name="DBusObject" c:type="GDBusObject*"/>
            </parameter>
            <parameter name="interface_name" transfer-ownership="none">
              <doc xml:space="preserve">A D-Bus interface name.</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="interface_added">
        <callback name="interface_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="DBusObject" c:type="GDBusObject*"/>
            </parameter>
            <parameter name="interface_" transfer-ownership="none">
              <type name="DBusInterface" c:type="GDBusInterface*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="interface_removed">
        <callback name="interface_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="DBusObject" c:type="GDBusObject*"/>
            </parameter>
            <parameter name="interface_" transfer-ownership="none">
              <type name="DBusInterface" c:type="GDBusInterface*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <interface name="DBusObjectManager" c:symbol-prefix="dbus_object_manager" c:type="GDBusObjectManager" glib:type-name="GDBusObjectManager" glib:get-type="g_dbus_object_manager_get_type" glib:type-struct="DBusObjectManagerIface">
      <doc xml:space="preserve">The #GDBusObjectManager type is the base type for service- and
client-side implementations of the standardized
[org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
interface.

See #GDBusObjectManagerClient for the client-side implementation
and #GDBusObjectManagerServer for the service-side implementation.</doc>
      <virtual-method name="get_interface" invoker="get_interface" version="2.30">
        <doc xml:space="preserve">Gets the interface proxy for @interface_name at @object_path, if
any.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GDBusInterface instance or %NULL. Free
  with g_object_unref().</doc>
          <type name="DBusInterface" c:type="GDBusInterface*"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObjectManager.</doc>
            <type name="DBusObjectManager" c:type="GDBusObjectManager*"/>
          </instance-parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">Object path to lookup.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="interface_name" transfer-ownership="none">
            <doc xml:space="preserve">D-Bus interface name to lookup.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_object" invoker="get_object" version="2.30">
        <doc xml:space="preserve">Gets the #GDBusObjectProxy at @object_path, if any.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GDBusObject or %NULL. Free with
  g_object_unref().</doc>
          <type name="DBusObject" c:type="GDBusObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObjectManager.</doc>
            <type name="DBusObjectManager" c:type="GDBusObjectManager*"/>
          </instance-parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">Object path to lookup.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_object_path" invoker="get_object_path" version="2.30">
        <doc xml:space="preserve">Gets the object path that @manager is for.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A string owned by @manager. Do not free.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObjectManager.</doc>
            <type name="DBusObjectManager" c:type="GDBusObjectManager*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_objects" invoker="get_objects" version="2.30">
        <doc xml:space="preserve">Gets all #GDBusObject objects known to @manager.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A list of
  #GDBusObject objects. The returned list should be freed with
  g_list_free() after each element has been freed with
  g_object_unref().</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="DBusObject"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObjectManager.</doc>
            <type name="DBusObjectManager" c:type="GDBusObjectManager*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="interface_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <type name="DBusObjectManager" c:type="GDBusObjectManager*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <type name="DBusObject" c:type="GDBusObject*"/>
          </parameter>
          <parameter name="interface_" transfer-ownership="none">
            <type name="DBusInterface" c:type="GDBusInterface*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="interface_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <type name="DBusObjectManager" c:type="GDBusObjectManager*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <type name="DBusObject" c:type="GDBusObject*"/>
          </parameter>
          <parameter name="interface_" transfer-ownership="none">
            <type name="DBusInterface" c:type="GDBusInterface*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="object_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <type name="DBusObjectManager" c:type="GDBusObjectManager*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <type name="DBusObject" c:type="GDBusObject*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="object_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <type name="DBusObjectManager" c:type="GDBusObjectManager*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <type name="DBusObject" c:type="GDBusObject*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_interface" c:identifier="g_dbus_object_manager_get_interface" version="2.30">
        <doc xml:space="preserve">Gets the interface proxy for @interface_name at @object_path, if
any.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GDBusInterface instance or %NULL. Free
  with g_object_unref().</doc>
          <type name="DBusInterface" c:type="GDBusInterface*"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObjectManager.</doc>
            <type name="DBusObjectManager" c:type="GDBusObjectManager*"/>
          </instance-parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">Object path to lookup.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="interface_name" transfer-ownership="none">
            <doc xml:space="preserve">D-Bus interface name to lookup.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_object" c:identifier="g_dbus_object_manager_get_object" version="2.30">
        <doc xml:space="preserve">Gets the #GDBusObjectProxy at @object_path, if any.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GDBusObject or %NULL. Free with
  g_object_unref().</doc>
          <type name="DBusObject" c:type="GDBusObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObjectManager.</doc>
            <type name="DBusObjectManager" c:type="GDBusObjectManager*"/>
          </instance-parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">Object path to lookup.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_object_path" c:identifier="g_dbus_object_manager_get_object_path" version="2.30">
        <doc xml:space="preserve">Gets the object path that @manager is for.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A string owned by @manager. Do not free.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObjectManager.</doc>
            <type name="DBusObjectManager" c:type="GDBusObjectManager*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_objects" c:identifier="g_dbus_object_manager_get_objects" version="2.30">
        <doc xml:space="preserve">Gets all #GDBusObject objects known to @manager.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A list of
  #GDBusObject objects. The returned list should be freed with
  g_list_free() after each element has been freed with
  g_object_unref().</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="DBusObject"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObjectManager.</doc>
            <type name="DBusObjectManager" c:type="GDBusObjectManager*"/>
          </instance-parameter>
        </parameters>
      </method>
      <glib:signal name="interface-added" when="last" version="2.30">
        <doc xml:space="preserve">Emitted when @interface is added to @object.

This signal exists purely as a convenience to avoid having to
connect signals to all objects managed by @manager.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">The #GDBusObject on which an interface was added.</doc>
            <type name="DBusObject"/>
          </parameter>
          <parameter name="interface" transfer-ownership="none">
            <doc xml:space="preserve">The #GDBusInterface that was added.</doc>
            <type name="DBusInterface"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="interface-removed" when="last" version="2.30">
        <doc xml:space="preserve">Emitted when @interface has been removed from @object.

This signal exists purely as a convenience to avoid having to
connect signals to all objects managed by @manager.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">The #GDBusObject on which an interface was removed.</doc>
            <type name="DBusObject"/>
          </parameter>
          <parameter name="interface" transfer-ownership="none">
            <doc xml:space="preserve">The #GDBusInterface that was removed.</doc>
            <type name="DBusInterface"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="object-added" when="last" version="2.30">
        <doc xml:space="preserve">Emitted when @object is added to @manager.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">The #GDBusObject that was added.</doc>
            <type name="DBusObject"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="object-removed" when="last" version="2.30">
        <doc xml:space="preserve">Emitted when @object is removed from @manager.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">The #GDBusObject that was removed.</doc>
            <type name="DBusObject"/>
          </parameter>
        </parameters>
      </glib:signal>
    </interface>
    <class name="DBusObjectManagerClient" c:symbol-prefix="dbus_object_manager_client" c:type="GDBusObjectManagerClient" version="2.30" parent="GObject.Object" glib:type-name="GDBusObjectManagerClient" glib:get-type="g_dbus_object_manager_client_get_type" glib:type-struct="DBusObjectManagerClientClass">
      <doc xml:space="preserve">#GDBusObjectManagerClient is used to create, monitor and delete object
proxies for remote objects exported by a #GDBusObjectManagerServer (or any
code implementing the
[org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
interface).

Once an instance of this type has been created, you can connect to
the #GDBusObjectManager::object-added and
#GDBusObjectManager::object-removed signals and inspect the
#GDBusObjectProxy objects returned by
g_dbus_object_manager_get_objects().

If the name for a #GDBusObjectManagerClient is not owned by anyone at
object construction time, the default behavior is to request the
message bus to launch an owner for the name. This behavior can be
disabled using the %G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START
flag. It's also worth noting that this only works if the name of
interest is activatable in the first place. E.g. in some cases it
is not possible to launch an owner for the requested name. In this
case, #GDBusObjectManagerClient object construction still succeeds but
there will be no object proxies
(e.g. g_dbus_object_manager_get_objects() returns the empty list) and
the #GDBusObjectManagerClient:name-owner property is %NULL.

The owner of the requested name can come and go (for example
consider a system service being restarted) &#x2013; #GDBusObjectManagerClient
handles this case too; simply connect to the #GObject::notify
signal to watch for changes on the #GDBusObjectManagerClient:name-owner
property. When the name owner vanishes, the behavior is that
#GDBusObjectManagerClient:name-owner is set to %NULL (this includes
emission of the #GObject::notify signal) and then
#GDBusObjectManager::object-removed signals are synthesized
for all currently existing object proxies. Since
#GDBusObjectManagerClient:name-owner is %NULL when this happens, you can
use this information to disambiguate a synthesized signal from a
genuine signal caused by object removal on the remote
#GDBusObjectManager. Similarly, when a new name owner appears,
#GDBusObjectManager::object-added signals are synthesized
while #GDBusObjectManagerClient:name-owner is still %NULL. Only when all
object proxies have been added, the #GDBusObjectManagerClient:name-owner
is set to the new name owner (this includes emission of the
#GObject::notify signal).  Furthermore, you are guaranteed that
#GDBusObjectManagerClient:name-owner will alternate between a name owner
(e.g. `:1.42`) and %NULL even in the case where
the name of interest is atomically replaced

Ultimately, #GDBusObjectManagerClient is used to obtain #GDBusProxy
instances. All signals (including the
org.freedesktop.DBus.Properties::PropertiesChanged signal)
delivered to #GDBusProxy instances are guaranteed to originate
from the name owner. This guarantee along with the behavior
described above, means that certain race conditions including the
"half the proxy is from the old owner and the other half is from
the new owner" problem cannot happen.

To avoid having the application connect to signals on the returned
#GDBusObjectProxy and #GDBusProxy objects, the
#GDBusObject::interface-added,
#GDBusObject::interface-removed,
#GDBusProxy::g-properties-changed and
#GDBusProxy::g-signal signals
are also emitted on the #GDBusObjectManagerClient instance managing these
objects. The signals emitted are
#GDBusObjectManager::interface-added,
#GDBusObjectManager::interface-removed,
#GDBusObjectManagerClient::interface-proxy-properties-changed and
#GDBusObjectManagerClient::interface-proxy-signal.

Note that all callbacks and signals are emitted in the
[thread-default main context][g-main-context-push-thread-default]
that the #GDBusObjectManagerClient object was constructed
in. Additionally, the #GDBusObjectProxy and #GDBusProxy objects
originating from the #GDBusObjectManagerClient object will be created in
the same context and, consequently, will deliver signals in the
same main loop.</doc>
      <implements name="AsyncInitable"/>
      <implements name="DBusObjectManager"/>
      <implements name="Initable"/>
      <constructor name="new_finish" c:identifier="g_dbus_object_manager_client_new_finish" version="2.30" throws="1">
        <doc xml:space="preserve">Finishes an operation started with g_dbus_object_manager_client_new().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A
  #GDBusObjectManagerClient object or %NULL if @error is set. Free
  with g_object_unref().</doc>
          <type name="DBusObjectManagerClient" c:type="GDBusObjectManager*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">A #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_object_manager_client_new().</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_for_bus_finish" c:identifier="g_dbus_object_manager_client_new_for_bus_finish" version="2.30" throws="1">
        <doc xml:space="preserve">Finishes an operation started with g_dbus_object_manager_client_new_for_bus().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A
  #GDBusObjectManagerClient object or %NULL if @error is set. Free
  with g_object_unref().</doc>
          <type name="DBusObjectManagerClient" c:type="GDBusObjectManager*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">A #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_object_manager_client_new_for_bus().</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_for_bus_sync" c:identifier="g_dbus_object_manager_client_new_for_bus_sync" version="2.30" throws="1">
        <doc xml:space="preserve">Like g_dbus_object_manager_client_new_sync() but takes a #GBusType instead
of a #GDBusConnection.

This is a synchronous failable constructor - the calling thread is
blocked until a reply is received. See g_dbus_object_manager_client_new_for_bus()
for the asynchronous version.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A
  #GDBusObjectManagerClient object or %NULL if @error is set. Free
  with g_object_unref().</doc>
          <type name="DBusObjectManagerClient" c:type="GDBusObjectManager*"/>
        </return-value>
        <parameters>
          <parameter name="bus_type" transfer-ownership="none">
            <doc xml:space="preserve">A #GBusType.</doc>
            <type name="BusType" c:type="GBusType"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.</doc>
            <type name="DBusObjectManagerClientFlags" c:type="GDBusObjectManagerClientFlags"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The owner of the control object (unique or well-known name).</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">The object path of the control object.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="get_proxy_type_func" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="5" destroy="6">
            <doc xml:space="preserve">A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.</doc>
            <type name="DBusProxyTypeFunc" c:type="GDBusProxyTypeFunc"/>
          </parameter>
          <parameter name="get_proxy_type_user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">User data to pass to @get_proxy_type_func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="get_proxy_type_destroy_notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">Free function for @get_proxy_type_user_data or %NULL.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_sync" c:identifier="g_dbus_object_manager_client_new_sync" version="2.30" throws="1">
        <doc xml:space="preserve">Creates a new #GDBusObjectManagerClient object.

This is a synchronous failable constructor - the calling thread is
blocked until a reply is received. See g_dbus_object_manager_client_new()
for the asynchronous version.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A
  #GDBusObjectManagerClient object or %NULL if @error is set. Free
  with g_object_unref().</doc>
          <type name="DBusObjectManagerClient" c:type="GDBusObjectManager*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusConnection.</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.</doc>
            <type name="DBusObjectManagerClientFlags" c:type="GDBusObjectManagerClientFlags"/>
          </parameter>
          <parameter name="name" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The owner of the control object (unique or well-known name), or %NULL when not using a message bus connection.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">The object path of the control object.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="get_proxy_type_func" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="5" destroy="6">
            <doc xml:space="preserve">A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.</doc>
            <type name="DBusProxyTypeFunc" c:type="GDBusProxyTypeFunc"/>
          </parameter>
          <parameter name="get_proxy_type_user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">User data to pass to @get_proxy_type_func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="get_proxy_type_destroy_notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">Free function for @get_proxy_type_user_data or %NULL.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="new" c:identifier="g_dbus_object_manager_client_new" version="2.30">
        <doc xml:space="preserve">Asynchronously creates a new #GDBusObjectManagerClient object.

This is an asynchronous failable constructor. When the result is
ready, @callback will be invoked in the
[thread-default main context][g-main-context-push-thread-default]
of the thread you are calling this method from. You can
then call g_dbus_object_manager_client_new_finish() to get the result. See
g_dbus_object_manager_client_new_sync() for the synchronous version.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusConnection.</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.</doc>
            <type name="DBusObjectManagerClientFlags" c:type="GDBusObjectManagerClientFlags"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The owner of the control object (unique or well-known name).</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">The object path of the control object.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="get_proxy_type_func" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="5" destroy="6">
            <doc xml:space="preserve">A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.</doc>
            <type name="DBusProxyTypeFunc" c:type="GDBusProxyTypeFunc"/>
          </parameter>
          <parameter name="get_proxy_type_user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">User data to pass to @get_proxy_type_func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="get_proxy_type_destroy_notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">Free function for @get_proxy_type_user_data or %NULL.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="9">
            <doc xml:space="preserve">A #GAsyncReadyCallback to call when the request is satisfied.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The data to pass to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_for_bus" c:identifier="g_dbus_object_manager_client_new_for_bus" version="2.30">
        <doc xml:space="preserve">Like g_dbus_object_manager_client_new() but takes a #GBusType instead of a
#GDBusConnection.

This is an asynchronous failable constructor. When the result is
ready, @callback will be invoked in the
[thread-default main loop][g-main-context-push-thread-default]
of the thread you are calling this method from. You can
then call g_dbus_object_manager_client_new_for_bus_finish() to get the result. See
g_dbus_object_manager_client_new_for_bus_sync() for the synchronous version.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="bus_type" transfer-ownership="none">
            <doc xml:space="preserve">A #GBusType.</doc>
            <type name="BusType" c:type="GBusType"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.</doc>
            <type name="DBusObjectManagerClientFlags" c:type="GDBusObjectManagerClientFlags"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The owner of the control object (unique or well-known name).</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">The object path of the control object.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="get_proxy_type_func" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="5" destroy="6">
            <doc xml:space="preserve">A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.</doc>
            <type name="DBusProxyTypeFunc" c:type="GDBusProxyTypeFunc"/>
          </parameter>
          <parameter name="get_proxy_type_user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">User data to pass to @get_proxy_type_func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="get_proxy_type_destroy_notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">Free function for @get_proxy_type_user_data or %NULL.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="9">
            <doc xml:space="preserve">A #GAsyncReadyCallback to call when the request is satisfied.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The data to pass to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="interface_proxy_properties_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <type name="DBusObjectManagerClient" c:type="GDBusObjectManagerClient*"/>
          </instance-parameter>
          <parameter name="object_proxy" transfer-ownership="none">
            <type name="DBusObjectProxy" c:type="GDBusObjectProxy*"/>
          </parameter>
          <parameter name="interface_proxy" transfer-ownership="none">
            <type name="DBusProxy" c:type="GDBusProxy*"/>
          </parameter>
          <parameter name="changed_properties" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="invalidated_properties" transfer-ownership="none">
            <type name="utf8" c:type="const gchar* const*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="interface_proxy_signal">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <type name="DBusObjectManagerClient" c:type="GDBusObjectManagerClient*"/>
          </instance-parameter>
          <parameter name="object_proxy" transfer-ownership="none">
            <type name="DBusObjectProxy" c:type="GDBusObjectProxy*"/>
          </parameter>
          <parameter name="interface_proxy" transfer-ownership="none">
            <type name="DBusProxy" c:type="GDBusProxy*"/>
          </parameter>
          <parameter name="sender_name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="signal_name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_connection" c:identifier="g_dbus_object_manager_client_get_connection" version="2.30">
        <doc xml:space="preserve">Gets the #GDBusConnection used by @manager.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusConnection object. Do not free,
  the object belongs to @manager.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObjectManagerClient</doc>
            <type name="DBusObjectManagerClient" c:type="GDBusObjectManagerClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="g_dbus_object_manager_client_get_flags" version="2.30">
        <doc xml:space="preserve">Gets the flags that @manager was constructed with.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Zero of more flags from the #GDBusObjectManagerClientFlags
enumeration.</doc>
          <type name="DBusObjectManagerClientFlags" c:type="GDBusObjectManagerClientFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObjectManagerClient</doc>
            <type name="DBusObjectManagerClient" c:type="GDBusObjectManagerClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="g_dbus_object_manager_client_get_name" version="2.30">
        <doc xml:space="preserve">Gets the name that @manager is for, or %NULL if not a message bus
connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A unique or well-known name. Do not free, the string
belongs to @manager.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObjectManagerClient</doc>
            <type name="DBusObjectManagerClient" c:type="GDBusObjectManagerClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name_owner" c:identifier="g_dbus_object_manager_client_get_name_owner" version="2.30">
        <doc xml:space="preserve">The unique name that owns the name that @manager is for or %NULL if
no-one currently owns that name. You can connect to the
#GObject::notify signal to track changes to the
#GDBusObjectManagerClient:name-owner property.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The name owner or %NULL if no name owner
exists. Free with g_free().</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObjectManagerClient.</doc>
            <type name="DBusObjectManagerClient" c:type="GDBusObjectManagerClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="bus-type" version="2.30" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">If this property is not %G_BUS_TYPE_NONE, then
#GDBusObjectManagerClient:connection must be %NULL and will be set to the
#GDBusConnection obtained by calling g_bus_get() with the value
of this property.</doc>
        <type name="BusType"/>
      </property>
      <property name="connection" version="2.30" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The #GDBusConnection to use.</doc>
        <type name="DBusConnection"/>
      </property>
      <property name="flags" version="2.30" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">Flags from the #GDBusObjectManagerClientFlags enumeration.</doc>
        <type name="DBusObjectManagerClientFlags"/>
      </property>
      <property name="get-proxy-type-destroy-notify" version="2.30" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">A #GDestroyNotify for the #gpointer user_data in #GDBusObjectManagerClient:get-proxy-type-user-data.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="get-proxy-type-func" version="2.30" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The #GDBusProxyTypeFunc to use when determining what #GType to
use for interface proxies or %NULL.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="get-proxy-type-user-data" version="2.30" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The #gpointer user_data to pass to #GDBusObjectManagerClient:get-proxy-type-func.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="name" version="2.30" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The well-known name or unique name that the manager is for.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="name-owner" version="2.30" transfer-ownership="none">
        <doc xml:space="preserve">The unique name that owns #GDBusObjectManagerClient:name or %NULL if
no-one is currently owning the name. Connect to the
#GObject::notify signal to track changes to this property.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="object-path" version="2.30" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The object path the manager is for.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="DBusObjectManagerClientPrivate" c:type="GDBusObjectManagerClientPrivate*"/>
      </field>
      <glib:signal name="interface-proxy-properties-changed" when="last" version="2.30">
        <doc xml:space="preserve">Emitted when one or more D-Bus properties on proxy changes. The
local cache has already been updated when this signal fires. Note
that both @changed_properties and @invalidated_properties are
guaranteed to never be %NULL (either may be empty though).

This signal exists purely as a convenience to avoid having to
connect signals to all interface proxies managed by @manager.

This signal is emitted in the
[thread-default main context][g-main-context-push-thread-default]
that @manager was constructed in.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object_proxy" transfer-ownership="none">
            <doc xml:space="preserve">The #GDBusObjectProxy on which an interface has properties that are changing.</doc>
            <type name="DBusObjectProxy"/>
          </parameter>
          <parameter name="interface_proxy" transfer-ownership="none">
            <doc xml:space="preserve">The #GDBusProxy that has properties that are changing.</doc>
            <type name="DBusProxy"/>
          </parameter>
          <parameter name="changed_properties" transfer-ownership="none">
            <doc xml:space="preserve">A #GVariant containing the properties that changed (type: `a{sv}`).</doc>
            <type name="GLib.Variant"/>
          </parameter>
          <parameter name="invalidated_properties" transfer-ownership="none">
            <doc xml:space="preserve">A %NULL terminated
  array of properties that were invalidated.</doc>
            <array>
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="interface-proxy-signal" when="last" version="2.30">
        <doc xml:space="preserve">Emitted when a D-Bus signal is received on @interface_proxy.

This signal exists purely as a convenience to avoid having to
connect signals to all interface proxies managed by @manager.

This signal is emitted in the
[thread-default main context][g-main-context-push-thread-default]
that @manager was constructed in.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object_proxy" transfer-ownership="none">
            <doc xml:space="preserve">The #GDBusObjectProxy on which an interface is emitting a D-Bus signal.</doc>
            <type name="DBusObjectProxy"/>
          </parameter>
          <parameter name="interface_proxy" transfer-ownership="none">
            <doc xml:space="preserve">The #GDBusProxy that is emitting a D-Bus signal.</doc>
            <type name="DBusProxy"/>
          </parameter>
          <parameter name="sender_name" transfer-ownership="none">
            <doc xml:space="preserve">The sender of the signal or NULL if the connection is not a bus connection.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="signal_name" transfer-ownership="none">
            <doc xml:space="preserve">The signal name.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:space="preserve">A #GVariant tuple with parameters for the signal.</doc>
            <type name="GLib.Variant"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="DBusObjectManagerClientClass" c:type="GDBusObjectManagerClientClass" glib:is-gtype-struct-for="DBusObjectManagerClient" version="2.30">
      <doc xml:space="preserve">Class structure for #GDBusObjectManagerClient.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">The parent class.</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="interface_proxy_signal">
        <callback name="interface_proxy_signal">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="manager" transfer-ownership="none">
              <type name="DBusObjectManagerClient" c:type="GDBusObjectManagerClient*"/>
            </parameter>
            <parameter name="object_proxy" transfer-ownership="none">
              <type name="DBusObjectProxy" c:type="GDBusObjectProxy*"/>
            </parameter>
            <parameter name="interface_proxy" transfer-ownership="none">
              <type name="DBusProxy" c:type="GDBusProxy*"/>
            </parameter>
            <parameter name="sender_name" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="signal_name" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="parameters" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="interface_proxy_properties_changed">
        <callback name="interface_proxy_properties_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="manager" transfer-ownership="none">
              <type name="DBusObjectManagerClient" c:type="GDBusObjectManagerClient*"/>
            </parameter>
            <parameter name="object_proxy" transfer-ownership="none">
              <type name="DBusObjectProxy" c:type="GDBusObjectProxy*"/>
            </parameter>
            <parameter name="interface_proxy" transfer-ownership="none">
              <type name="DBusProxy" c:type="GDBusProxy*"/>
            </parameter>
            <parameter name="changed_properties" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
            <parameter name="invalidated_properties" transfer-ownership="none">
              <type name="utf8" c:type="const gchar* const*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="DBusObjectManagerClientFlags" version="2.30" glib:type-name="GDBusObjectManagerClientFlags" glib:get-type="g_dbus_object_manager_client_flags_get_type" c:type="GDBusObjectManagerClientFlags">
      <doc xml:space="preserve">Flags used when constructing a #GDBusObjectManagerClient.</doc>
      <member name="none" value="0" c:identifier="G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
      <member name="do_not_auto_start" value="1" c:identifier="G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START" glib:nick="do-not-auto-start">
        <doc xml:space="preserve">If not set and the
  manager is for a well-known name, then request the bus to launch
  an owner for the name if no-one owns the name. This flag can only
  be used in managers for well-known names.</doc>
      </member>
    </bitfield>
    <record name="DBusObjectManagerClientPrivate" c:type="GDBusObjectManagerClientPrivate" disguised="1">
    </record>
    <record name="DBusObjectManagerIface" c:type="GDBusObjectManagerIface" glib:is-gtype-struct-for="DBusObjectManager" version="2.30">
      <doc xml:space="preserve">Base type for D-Bus object managers.</doc>
      <field name="parent_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_object_path">
        <callback name="get_object_path">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A string owned by @manager. Do not free.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="manager" transfer-ownership="none">
              <doc xml:space="preserve">A #GDBusObjectManager.</doc>
              <type name="DBusObjectManager" c:type="GDBusObjectManager*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_objects">
        <callback name="get_objects">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A list of
  #GDBusObject objects. The returned list should be freed with
  g_list_free() after each element has been freed with
  g_object_unref().</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="DBusObject"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="manager" transfer-ownership="none">
              <doc xml:space="preserve">A #GDBusObjectManager.</doc>
              <type name="DBusObjectManager" c:type="GDBusObjectManager*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_object">
        <callback name="get_object">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A #GDBusObject or %NULL. Free with
  g_object_unref().</doc>
            <type name="DBusObject" c:type="GDBusObject*"/>
          </return-value>
          <parameters>
            <parameter name="manager" transfer-ownership="none">
              <doc xml:space="preserve">A #GDBusObjectManager.</doc>
              <type name="DBusObjectManager" c:type="GDBusObjectManager*"/>
            </parameter>
            <parameter name="object_path" transfer-ownership="none">
              <doc xml:space="preserve">Object path to lookup.</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_interface">
        <callback name="get_interface">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A #GDBusInterface instance or %NULL. Free
  with g_object_unref().</doc>
            <type name="DBusInterface" c:type="GDBusInterface*"/>
          </return-value>
          <parameters>
            <parameter name="manager" transfer-ownership="none">
              <doc xml:space="preserve">A #GDBusObjectManager.</doc>
              <type name="DBusObjectManager" c:type="GDBusObjectManager*"/>
            </parameter>
            <parameter name="object_path" transfer-ownership="none">
              <doc xml:space="preserve">Object path to lookup.</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="interface_name" transfer-ownership="none">
              <doc xml:space="preserve">D-Bus interface name to lookup.</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="object_added">
        <callback name="object_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="manager" transfer-ownership="none">
              <type name="DBusObjectManager" c:type="GDBusObjectManager*"/>
            </parameter>
            <parameter name="object" transfer-ownership="none">
              <type name="DBusObject" c:type="GDBusObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="object_removed">
        <callback name="object_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="manager" transfer-ownership="none">
              <type name="DBusObjectManager" c:type="GDBusObjectManager*"/>
            </parameter>
            <parameter name="object" transfer-ownership="none">
              <type name="DBusObject" c:type="GDBusObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="interface_added">
        <callback name="interface_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="manager" transfer-ownership="none">
              <type name="DBusObjectManager" c:type="GDBusObjectManager*"/>
            </parameter>
            <parameter name="object" transfer-ownership="none">
              <type name="DBusObject" c:type="GDBusObject*"/>
            </parameter>
            <parameter name="interface_" transfer-ownership="none">
              <type name="DBusInterface" c:type="GDBusInterface*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="interface_removed">
        <callback name="interface_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="manager" transfer-ownership="none">
              <type name="DBusObjectManager" c:type="GDBusObjectManager*"/>
            </parameter>
            <parameter name="object" transfer-ownership="none">
              <type name="DBusObject" c:type="GDBusObject*"/>
            </parameter>
            <parameter name="interface_" transfer-ownership="none">
              <type name="DBusInterface" c:type="GDBusInterface*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="DBusObjectManagerServer" c:symbol-prefix="dbus_object_manager_server" c:type="GDBusObjectManagerServer" version="2.30" parent="GObject.Object" glib:type-name="GDBusObjectManagerServer" glib:get-type="g_dbus_object_manager_server_get_type" glib:type-struct="DBusObjectManagerServerClass">
      <doc xml:space="preserve">#GDBusObjectManagerServer is used to export #GDBusObject instances using
the standardized
[org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
interface. For example, remote D-Bus clients can get all objects
and properties in a single call. Additionally, any change in the
object hierarchy is broadcast using signals. This means that D-Bus
clients can keep caches up to date by only listening to D-Bus
signals.

The recommended path to export an object manager at is the path form of the
well-known name of a D-Bus service, or below. For example, if a D-Bus service
is available at the well-known name `net.example.ExampleService1`, the object
manager should typically be exported at `/net/example/ExampleService1`, or
below (to allow for multiple object managers in a service).

It is supported, but not recommended, to export an object manager at the root
path, `/`.

See #GDBusObjectManagerClient for the client-side code that is
intended to be used with #GDBusObjectManagerServer or any D-Bus
object implementing the org.freedesktop.DBus.ObjectManager
interface.</doc>
      <implements name="DBusObjectManager"/>
      <constructor name="new" c:identifier="g_dbus_object_manager_server_new" version="2.30">
        <doc xml:space="preserve">Creates a new #GDBusObjectManagerServer object.

The returned server isn't yet exported on any connection. To do so,
use g_dbus_object_manager_server_set_connection(). Normally you
want to export all of your objects before doing so to avoid
[InterfacesAdded](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
signals being emitted.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GDBusObjectManagerServer object. Free with g_object_unref().</doc>
          <type name="DBusObjectManagerServer" c:type="GDBusObjectManagerServer*"/>
        </return-value>
        <parameters>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">The object path to export the manager object at.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="export" c:identifier="g_dbus_object_manager_server_export" version="2.30">
        <doc xml:space="preserve">Exports @object on @manager.

If there is already a #GDBusObject exported at the object path,
then the old object is removed.

The object path for @object must be in the hierarchy rooted by the
object path for @manager.

Note that @manager will take a reference on @object for as long as
it is exported.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObjectManagerServer.</doc>
            <type name="DBusObjectManagerServer" c:type="GDBusObjectManagerServer*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObjectSkeleton.</doc>
            <type name="DBusObjectSkeleton" c:type="GDBusObjectSkeleton*"/>
          </parameter>
        </parameters>
      </method>
      <method name="export_uniquely" c:identifier="g_dbus_object_manager_server_export_uniquely" version="2.30">
        <doc xml:space="preserve">Like g_dbus_object_manager_server_export() but appends a string of
the form _N (with N being a natural number) to @object's object path
if an object with the given path already exists. As such, the
#GDBusObjectProxy:g-object-path property of @object may be modified.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObjectManagerServer.</doc>
            <type name="DBusObjectManagerServer" c:type="GDBusObjectManagerServer*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">An object.</doc>
            <type name="DBusObjectSkeleton" c:type="GDBusObjectSkeleton*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_connection" c:identifier="g_dbus_object_manager_server_get_connection" version="2.30">
        <doc xml:space="preserve">Gets the #GDBusConnection used by @manager.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GDBusConnection object or %NULL if
  @manager isn't exported on a connection. The returned object should
  be freed with g_object_unref().</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObjectManagerServer</doc>
            <type name="DBusObjectManagerServer" c:type="GDBusObjectManagerServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_exported" c:identifier="g_dbus_object_manager_server_is_exported" version="2.34">
        <doc xml:space="preserve">Returns whether @object is currently exported on @manager.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @object is exported</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObjectManagerServer.</doc>
            <type name="DBusObjectManagerServer" c:type="GDBusObjectManagerServer*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">An object.</doc>
            <type name="DBusObjectSkeleton" c:type="GDBusObjectSkeleton*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_connection" c:identifier="g_dbus_object_manager_server_set_connection">
        <doc xml:space="preserve">Exports all objects managed by @manager on @connection. If
@connection is %NULL, stops exporting objects.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObjectManagerServer.</doc>
            <type name="DBusObjectManagerServer" c:type="GDBusObjectManagerServer*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GDBusConnection or %NULL.</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unexport" c:identifier="g_dbus_object_manager_server_unexport" version="2.30">
        <doc xml:space="preserve">If @manager has an object at @path, removes the object. Otherwise
does nothing.

Note that @object_path must be in the hierarchy rooted by the
object path for @manager.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if object at @object_path was removed, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObjectManagerServer.</doc>
            <type name="DBusObjectManagerServer" c:type="GDBusObjectManagerServer*"/>
          </instance-parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">An object path.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="connection" version="2.30" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The #GDBusConnection to export objects on.</doc>
        <type name="DBusConnection"/>
      </property>
      <property name="object-path" version="2.30" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The object path to register the manager object at.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="DBusObjectManagerServerPrivate" c:type="GDBusObjectManagerServerPrivate*"/>
      </field>
    </class>
    <record name="DBusObjectManagerServerClass" c:type="GDBusObjectManagerServerClass" glib:is-gtype-struct-for="DBusObjectManagerServer" version="2.30">
      <doc xml:space="preserve">Class structure for #GDBusObjectManagerServer.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">The parent class.</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="DBusObjectManagerServerPrivate" c:type="GDBusObjectManagerServerPrivate" disguised="1">
    </record>
    <class name="DBusObjectProxy" c:symbol-prefix="dbus_object_proxy" c:type="GDBusObjectProxy" version="2.30" parent="GObject.Object" glib:type-name="GDBusObjectProxy" glib:get-type="g_dbus_object_proxy_get_type" glib:type-struct="DBusObjectProxyClass">
      <doc xml:space="preserve">A #GDBusObjectProxy is an object used to represent a remote object
with one or more D-Bus interfaces. Normally, you don't instantiate
a #GDBusObjectProxy yourself - typically #GDBusObjectManagerClient
is used to obtain it.</doc>
      <implements name="DBusObject"/>
      <constructor name="new" c:identifier="g_dbus_object_proxy_new" version="2.30">
        <doc xml:space="preserve">Creates a new #GDBusObjectProxy for the given connection and
object path.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GDBusObjectProxy</doc>
          <type name="DBusObjectProxy" c:type="GDBusObjectProxy*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusConnection</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">the object path</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_connection" c:identifier="g_dbus_object_proxy_get_connection" version="2.30">
        <doc xml:space="preserve">Gets the connection that @proxy is for.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusConnection. Do not free, the
  object is owned by @proxy.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusObjectProxy</doc>
            <type name="DBusObjectProxy" c:type="GDBusObjectProxy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="g-connection" version="2.30" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The connection of the proxy.</doc>
        <type name="DBusConnection"/>
      </property>
      <property name="g-object-path" version="2.30" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The object path of the proxy.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="DBusObjectProxyPrivate" c:type="GDBusObjectProxyPrivate*"/>
      </field>
    </class>
    <record name="DBusObjectProxyClass" c:type="GDBusObjectProxyClass" glib:is-gtype-struct-for="DBusObjectProxy" version="2.30">
      <doc xml:space="preserve">Class structure for #GDBusObjectProxy.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">The parent class.</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="DBusObjectProxyPrivate" c:type="GDBusObjectProxyPrivate" disguised="1">
    </record>
    <class name="DBusObjectSkeleton" c:symbol-prefix="dbus_object_skeleton" c:type="GDBusObjectSkeleton" version="2.30" parent="GObject.Object" glib:type-name="GDBusObjectSkeleton" glib:get-type="g_dbus_object_skeleton_get_type" glib:type-struct="DBusObjectSkeletonClass">
      <doc xml:space="preserve">A #GDBusObjectSkeleton instance is essentially a group of D-Bus
interfaces. The set of exported interfaces on the object may be
dynamic and change at runtime.

This type is intended to be used with #GDBusObjectManager.</doc>
      <implements name="DBusObject"/>
      <constructor name="new" c:identifier="g_dbus_object_skeleton_new" version="2.30">
        <doc xml:space="preserve">Creates a new #GDBusObjectSkeleton.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GDBusObjectSkeleton. Free with g_object_unref().</doc>
          <type name="DBusObjectSkeleton" c:type="GDBusObjectSkeleton*"/>
        </return-value>
        <parameters>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">An object path.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="authorize_method">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="DBusObjectSkeleton" c:type="GDBusObjectSkeleton*"/>
          </instance-parameter>
          <parameter name="interface_" transfer-ownership="none">
            <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
          </parameter>
          <parameter name="invocation" transfer-ownership="none">
            <type name="DBusMethodInvocation" c:type="GDBusMethodInvocation*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_interface" c:identifier="g_dbus_object_skeleton_add_interface" version="2.30">
        <doc xml:space="preserve">Adds @interface_ to @object.

If @object already contains a #GDBusInterfaceSkeleton with the same
interface name, it is removed before @interface_ is added.

Note that @object takes its own reference on @interface_ and holds
it until removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObjectSkeleton.</doc>
            <type name="DBusObjectSkeleton" c:type="GDBusObjectSkeleton*"/>
          </instance-parameter>
          <parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceSkeleton.</doc>
            <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
          </parameter>
        </parameters>
      </method>
      <method name="flush" c:identifier="g_dbus_object_skeleton_flush" version="2.30">
        <doc xml:space="preserve">This method simply calls g_dbus_interface_skeleton_flush() on all
interfaces belonging to @object. See that method for when flushing
is useful.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObjectSkeleton.</doc>
            <type name="DBusObjectSkeleton" c:type="GDBusObjectSkeleton*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_interface" c:identifier="g_dbus_object_skeleton_remove_interface" version="2.30">
        <doc xml:space="preserve">Removes @interface_ from @object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObjectSkeleton.</doc>
            <type name="DBusObjectSkeleton" c:type="GDBusObjectSkeleton*"/>
          </instance-parameter>
          <parameter name="interface_" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusInterfaceSkeleton.</doc>
            <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_interface_by_name" c:identifier="g_dbus_object_skeleton_remove_interface_by_name" version="2.30">
        <doc xml:space="preserve">Removes the #GDBusInterface with @interface_name from @object.

If no D-Bus interface of the given interface exists, this function
does nothing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObjectSkeleton.</doc>
            <type name="DBusObjectSkeleton" c:type="GDBusObjectSkeleton*"/>
          </instance-parameter>
          <parameter name="interface_name" transfer-ownership="none">
            <doc xml:space="preserve">A D-Bus interface name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_object_path" c:identifier="g_dbus_object_skeleton_set_object_path" version="2.30">
        <doc xml:space="preserve">Sets the object path for @object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusObjectSkeleton.</doc>
            <type name="DBusObjectSkeleton" c:type="GDBusObjectSkeleton*"/>
          </instance-parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">A valid D-Bus object path.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="g-object-path" version="2.30" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">The object path where the object is exported.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="DBusObjectSkeletonPrivate" c:type="GDBusObjectSkeletonPrivate*"/>
      </field>
      <glib:signal name="authorize-method" when="last" version="2.30">
        <doc xml:space="preserve">Emitted when a method is invoked by a remote caller and used to
determine if the method call is authorized.

This signal is like #GDBusInterfaceSkeleton's
#GDBusInterfaceSkeleton::g-authorize-method signal,
except that it is for the enclosing object.

The default class handler just returns %TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the call is authorized, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="interface" transfer-ownership="none">
            <doc xml:space="preserve">The #GDBusInterfaceSkeleton that @invocation is for.</doc>
            <type name="DBusInterfaceSkeleton"/>
          </parameter>
          <parameter name="invocation" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusMethodInvocation.</doc>
            <type name="DBusMethodInvocation"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="DBusObjectSkeletonClass" c:type="GDBusObjectSkeletonClass" glib:is-gtype-struct-for="DBusObjectSkeleton" version="2.30">
      <doc xml:space="preserve">Class structure for #GDBusObjectSkeleton.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">The parent class.</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="authorize_method">
        <callback name="authorize_method">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="DBusObjectSkeleton" c:type="GDBusObjectSkeleton*"/>
            </parameter>
            <parameter name="interface_" transfer-ownership="none">
              <type name="DBusInterfaceSkeleton" c:type="GDBusInterfaceSkeleton*"/>
            </parameter>
            <parameter name="invocation" transfer-ownership="none">
              <type name="DBusMethodInvocation" c:type="GDBusMethodInvocation*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="DBusObjectSkeletonPrivate" c:type="GDBusObjectSkeletonPrivate" disguised="1">
    </record>
    <record name="DBusPropertyInfo" c:type="GDBusPropertyInfo" version="2.26" glib:type-name="GDBusPropertyInfo" glib:get-type="g_dbus_property_info_get_type" c:symbol-prefix="dbus_property_info">
      <doc xml:space="preserve">Information about a D-Bus property on a D-Bus interface.</doc>
      <field name="ref_count" writable="1">
        <doc xml:space="preserve">The reference count or -1 if statically allocated.</doc>
        <type name="gint" c:type="volatile gint"/>
      </field>
      <field name="name" writable="1">
        <doc xml:space="preserve">The name of the D-Bus property, e.g. "SupportedFilesystems".</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="signature" writable="1">
        <doc xml:space="preserve">The D-Bus signature of the property (a single complete type).</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="flags" writable="1">
        <doc xml:space="preserve">Access control flags for the property.</doc>
        <type name="DBusPropertyInfoFlags" c:type="GDBusPropertyInfoFlags"/>
      </field>
      <field name="annotations" writable="1">
        <doc xml:space="preserve">A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.</doc>
        <array c:type="GDBusAnnotationInfo**">
          <type name="DBusAnnotationInfo" c:type="GDBusAnnotationInfo*"/>
        </array>
      </field>
      <method name="ref" c:identifier="g_dbus_property_info_ref" version="2.26">
        <doc xml:space="preserve">If @info is statically allocated does nothing. Otherwise increases
the reference count.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The same @info.</doc>
          <type name="DBusPropertyInfo" c:type="GDBusPropertyInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusPropertyInfo</doc>
            <type name="DBusPropertyInfo" c:type="GDBusPropertyInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_dbus_property_info_unref" version="2.26">
        <doc xml:space="preserve">If @info is statically allocated, does nothing. Otherwise decreases
the reference count of @info. When its reference count drops to 0,
the memory used is freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusPropertyInfo.</doc>
            <type name="DBusPropertyInfo" c:type="GDBusPropertyInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <bitfield name="DBusPropertyInfoFlags" version="2.26" glib:type-name="GDBusPropertyInfoFlags" glib:get-type="g_dbus_property_info_flags_get_type" c:type="GDBusPropertyInfoFlags">
      <doc xml:space="preserve">Flags describing the access control of a D-Bus property.</doc>
      <member name="none" value="0" c:identifier="G_DBUS_PROPERTY_INFO_FLAGS_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
      <member name="readable" value="1" c:identifier="G_DBUS_PROPERTY_INFO_FLAGS_READABLE" glib:nick="readable">
        <doc xml:space="preserve">Property is readable.</doc>
      </member>
      <member name="writable" value="2" c:identifier="G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE" glib:nick="writable">
        <doc xml:space="preserve">Property is writable.</doc>
      </member>
    </bitfield>
    <class name="DBusProxy" c:symbol-prefix="dbus_proxy" c:type="GDBusProxy" version="2.26" parent="GObject.Object" glib:type-name="GDBusProxy" glib:get-type="g_dbus_proxy_get_type" glib:type-struct="DBusProxyClass">
      <doc xml:space="preserve">#GDBusProxy is a base class used for proxies to access a D-Bus
interface on a remote object. A #GDBusProxy can be constructed for
both well-known and unique names.

By default, #GDBusProxy will cache all properties (and listen to
changes) of the remote object, and proxy all signals that get
emitted. This behaviour can be changed by passing suitable
#GDBusProxyFlags when the proxy is created. If the proxy is for a
well-known name, the property cache is flushed when the name owner
vanishes and reloaded when a name owner appears.

If a #GDBusProxy is used for a well-known name, the owner of the
name is tracked and can be read from
#GDBusProxy:g-name-owner. Connect to the #GObject::notify signal to
get notified of changes. Additionally, only signals and property
changes emitted from the current name owner are considered and
calls are always sent to the current name owner. This avoids a
number of race conditions when the name is lost by one owner and
claimed by another. However, if no name owner currently exists,
then calls will be sent to the well-known name which may result in
the message bus launching an owner (unless
%G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is set).

The generic #GDBusProxy::g-properties-changed and
#GDBusProxy::g-signal signals are not very convenient to work with.
Therefore, the recommended way of working with proxies is to subclass
#GDBusProxy, and have more natural properties and signals in your derived
class. This [example][gdbus-example-gdbus-codegen] shows how this can
easily be done using the [gdbus-codegen][gdbus-codegen] tool.

A #GDBusProxy instance can be used from multiple threads but note
that all signals (e.g. #GDBusProxy::g-signal, #GDBusProxy::g-properties-changed
and #GObject::notify) are emitted in the
[thread-default main context][g-main-context-push-thread-default]
of the thread where the instance was constructed.

An example using a proxy for a well-known name can be found in
[gdbus-example-watch-proxy.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-watch-proxy.c)</doc>
      <implements name="AsyncInitable"/>
      <implements name="DBusInterface"/>
      <implements name="Initable"/>
      <constructor name="new_finish" c:identifier="g_dbus_proxy_new_finish" version="2.26" throws="1">
        <doc xml:space="preserve">Finishes creating a #GDBusProxy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GDBusProxy or %NULL if @error is set.
   Free with g_object_unref().</doc>
          <type name="DBusProxy" c:type="GDBusProxy*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new().</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_for_bus_finish" c:identifier="g_dbus_proxy_new_for_bus_finish" version="2.26" throws="1">
        <doc xml:space="preserve">Finishes creating a #GDBusProxy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GDBusProxy or %NULL if @error is set.
   Free with g_object_unref().</doc>
          <type name="DBusProxy" c:type="GDBusProxy*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new_for_bus().</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_for_bus_sync" c:identifier="g_dbus_proxy_new_for_bus_sync" version="2.26" throws="1">
        <doc xml:space="preserve">Like g_dbus_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.

#GDBusProxy is used in this [example][gdbus-wellknown-proxy].</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GDBusProxy or %NULL if error is set.
   Free with g_object_unref().</doc>
          <type name="DBusProxy" c:type="GDBusProxy*"/>
        </return-value>
        <parameters>
          <parameter name="bus_type" transfer-ownership="none">
            <doc xml:space="preserve">A #GBusType.</doc>
            <type name="BusType" c:type="GBusType"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags used when constructing the proxy.</doc>
            <type name="DBusProxyFlags" c:type="GDBusProxyFlags"/>
          </parameter>
          <parameter name="info" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GDBusInterfaceInfo specifying the minimal interface
       that @proxy conforms to or %NULL.</doc>
            <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">A bus name (well-known or unique).</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">An object path.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="interface_name" transfer-ownership="none">
            <doc xml:space="preserve">A D-Bus interface name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_sync" c:identifier="g_dbus_proxy_new_sync" version="2.26" throws="1">
        <doc xml:space="preserve">Creates a proxy for accessing @interface_name on the remote object
at @object_path owned by @name at @connection and synchronously
loads D-Bus properties unless the
%G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.

If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
match rules for signals. Connect to the #GDBusProxy::g-signal signal
to handle signals from the remote object.

If @name is a well-known name and the
%G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
flags aren't set and no name owner currently exists, the message bus
will be requested to launch a name owner for the name.

This is a synchronous failable constructor. See g_dbus_proxy_new()
and g_dbus_proxy_new_finish() for the asynchronous version.

#GDBusProxy is used in this [example][gdbus-wellknown-proxy].</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GDBusProxy or %NULL if error is set.
   Free with g_object_unref().</doc>
          <type name="DBusProxy" c:type="GDBusProxy*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusConnection.</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags used when constructing the proxy.</doc>
            <type name="DBusProxyFlags" c:type="GDBusProxyFlags"/>
          </parameter>
          <parameter name="info" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GDBusInterfaceInfo specifying the minimal interface that @proxy conforms to or %NULL.</doc>
            <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">An object path.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="interface_name" transfer-ownership="none">
            <doc xml:space="preserve">A D-Bus interface name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="new" c:identifier="g_dbus_proxy_new" version="2.26">
        <doc xml:space="preserve">Creates a proxy for accessing @interface_name on the remote object
at @object_path owned by @name at @connection and asynchronously
loads D-Bus properties unless the
%G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
the #GDBusProxy::g-properties-changed signal to get notified about
property changes.

If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
match rules for signals. Connect to the #GDBusProxy::g-signal signal
to handle signals from the remote object.

If @name is a well-known name and the
%G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
flags aren't set and no name owner currently exists, the message bus
will be requested to launch a name owner for the name.

This is a failable asynchronous constructor - when the proxy is
ready, @callback will be invoked and you can use
g_dbus_proxy_new_finish() to get the result.

See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.

#GDBusProxy is used in this [example][gdbus-wellknown-proxy].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusConnection.</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags used when constructing the proxy.</doc>
            <type name="DBusProxyFlags" c:type="GDBusProxyFlags"/>
          </parameter>
          <parameter name="info" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GDBusInterfaceInfo specifying the minimal interface that @proxy conforms to or %NULL.</doc>
            <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">An object path.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="interface_name" transfer-ownership="none">
            <doc xml:space="preserve">A D-Bus interface name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="8">
            <doc xml:space="preserve">Callback function to invoke when the proxy is ready.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">User data to pass to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_for_bus" c:identifier="g_dbus_proxy_new_for_bus" version="2.26">
        <doc xml:space="preserve">Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.

#GDBusProxy is used in this [example][gdbus-wellknown-proxy].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="bus_type" transfer-ownership="none">
            <doc xml:space="preserve">A #GBusType.</doc>
            <type name="BusType" c:type="GBusType"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags used when constructing the proxy.</doc>
            <type name="DBusProxyFlags" c:type="GDBusProxyFlags"/>
          </parameter>
          <parameter name="info" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GDBusInterfaceInfo specifying the minimal interface that @proxy conforms to or %NULL.</doc>
            <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">A bus name (well-known or unique).</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">An object path.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="interface_name" transfer-ownership="none">
            <doc xml:space="preserve">A D-Bus interface name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="8">
            <doc xml:space="preserve">Callback function to invoke when the proxy is ready.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">User data to pass to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="g_properties_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <type name="DBusProxy" c:type="GDBusProxy*"/>
          </instance-parameter>
          <parameter name="changed_properties" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="invalidated_properties" transfer-ownership="none">
            <type name="utf8" c:type="const gchar* const*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="g_signal">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <type name="DBusProxy" c:type="GDBusProxy*"/>
          </instance-parameter>
          <parameter name="sender_name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="signal_name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="call" c:identifier="g_dbus_proxy_call" version="2.26">
        <doc xml:space="preserve">Asynchronously invokes the @method_name method on @proxy.

If @method_name contains any dots, then @name is split into interface and
method name parts. This allows using @proxy for invoking methods on
other interfaces.

If the #GDBusConnection associated with @proxy is closed then
the operation will fail with %G_IO_ERROR_CLOSED. If
@cancellable is canceled, the operation will fail with
%G_IO_ERROR_CANCELLED. If @parameters contains a value not
compatible with the D-Bus protocol, the operation fails with
%G_IO_ERROR_INVALID_ARGUMENT.

If the @parameters #GVariant is floating, it is consumed. This allows
convenient 'inline' use of g_variant_new(), e.g.:
|[&lt;!-- language="C" --&gt;
 g_dbus_proxy_call (proxy,
                    "TwoStrings",
                    g_variant_new ("(ss)",
                                   "Thing One",
                                   "Thing Two"),
                    G_DBUS_CALL_FLAGS_NONE,
                    -1,
                    NULL,
                    (GAsyncReadyCallback) two_strings_done,
                    &amp;data);
]|

If @proxy has an expected interface (see
#GDBusProxy:g-interface-info) and @method_name is referenced by it,
then the return value is checked against the return type.

This is an asynchronous method. When the operation is finished,
@callback will be invoked in the
[thread-default main context][g-main-context-push-thread-default]
of the thread you are calling this method from.
You can then call g_dbus_proxy_call_finish() to get the result of
the operation. See g_dbus_proxy_call_sync() for the synchronous
version of this method.

If @callback is %NULL then the D-Bus method call message will be sent with
the %G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusProxy.</doc>
            <type name="DBusProxy" c:type="GDBusProxy*"/>
          </instance-parameter>
          <parameter name="method_name" transfer-ownership="none">
            <doc xml:space="preserve">Name of method to invoke.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GVariant tuple with parameters for the signal or %NULL if not passing parameters.</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags from the #GDBusCallFlags enumeration.</doc>
            <type name="DBusCallFlags" c:type="GDBusCallFlags"/>
          </parameter>
          <parameter name="timeout_msec" transfer-ownership="none">
            <doc xml:space="preserve">The timeout in milliseconds (with %G_MAXINT meaning
               "infinite") or -1 to use the proxy default timeout.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
            <doc xml:space="preserve">A #GAsyncReadyCallback to call when the request is satisfied or %NULL if you don't
care about the result of the method invocation.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The data to pass to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="call_finish" c:identifier="g_dbus_proxy_call_finish" version="2.26" throws="1">
        <doc xml:space="preserve">Finishes an operation started with g_dbus_proxy_call().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">%NULL if @error is set. Otherwise a #GVariant tuple with
return values. Free with g_variant_unref().</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusProxy.</doc>
            <type name="DBusProxy" c:type="GDBusProxy*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">A #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_proxy_call().</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="call_sync" c:identifier="g_dbus_proxy_call_sync" version="2.26" throws="1">
        <doc xml:space="preserve">Synchronously invokes the @method_name method on @proxy.

If @method_name contains any dots, then @name is split into interface and
method name parts. This allows using @proxy for invoking methods on
other interfaces.

If the #GDBusConnection associated with @proxy is disconnected then
the operation will fail with %G_IO_ERROR_CLOSED. If
@cancellable is canceled, the operation will fail with
%G_IO_ERROR_CANCELLED. If @parameters contains a value not
compatible with the D-Bus protocol, the operation fails with
%G_IO_ERROR_INVALID_ARGUMENT.

If the @parameters #GVariant is floating, it is consumed. This allows
convenient 'inline' use of g_variant_new(), e.g.:
|[&lt;!-- language="C" --&gt;
 g_dbus_proxy_call_sync (proxy,
                         "TwoStrings",
                         g_variant_new ("(ss)",
                                        "Thing One",
                                        "Thing Two"),
                         G_DBUS_CALL_FLAGS_NONE,
                         -1,
                         NULL,
                         &amp;error);
]|

The calling thread is blocked until a reply is received. See
g_dbus_proxy_call() for the asynchronous version of this
method.

If @proxy has an expected interface (see
#GDBusProxy:g-interface-info) and @method_name is referenced by it,
then the return value is checked against the return type.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">%NULL if @error is set. Otherwise a #GVariant tuple with
return values. Free with g_variant_unref().</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusProxy.</doc>
            <type name="DBusProxy" c:type="GDBusProxy*"/>
          </instance-parameter>
          <parameter name="method_name" transfer-ownership="none">
            <doc xml:space="preserve">Name of method to invoke.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GVariant tuple with parameters for the signal
             or %NULL if not passing parameters.</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags from the #GDBusCallFlags enumeration.</doc>
            <type name="DBusCallFlags" c:type="GDBusCallFlags"/>
          </parameter>
          <parameter name="timeout_msec" transfer-ownership="none">
            <doc xml:space="preserve">The timeout in milliseconds (with %G_MAXINT meaning
               "infinite") or -1 to use the proxy default timeout.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="call_with_unix_fd_list" c:identifier="g_dbus_proxy_call_with_unix_fd_list" version="2.30">
        <doc xml:space="preserve">Like g_dbus_proxy_call() but also takes a #GUnixFDList object.

This method is only available on UNIX.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusProxy.</doc>
            <type name="DBusProxy" c:type="GDBusProxy*"/>
          </instance-parameter>
          <parameter name="method_name" transfer-ownership="none">
            <doc xml:space="preserve">Name of method to invoke.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GVariant tuple with parameters for the signal or %NULL if not passing parameters.</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags from the #GDBusCallFlags enumeration.</doc>
            <type name="DBusCallFlags" c:type="GDBusCallFlags"/>
          </parameter>
          <parameter name="timeout_msec" transfer-ownership="none">
            <doc xml:space="preserve">The timeout in milliseconds (with %G_MAXINT meaning
               "infinite") or -1 to use the proxy default timeout.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="fd_list" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GUnixFDList or %NULL.</doc>
            <type name="UnixFDList" c:type="GUnixFDList*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="7">
            <doc xml:space="preserve">A #GAsyncReadyCallback to call when the request is satisfied or %NULL if you don't
care about the result of the method invocation.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The data to pass to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="call_with_unix_fd_list_finish" c:identifier="g_dbus_proxy_call_with_unix_fd_list_finish" version="2.30" throws="1">
        <doc xml:space="preserve">Finishes an operation started with g_dbus_proxy_call_with_unix_fd_list().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">%NULL if @error is set. Otherwise a #GVariant tuple with
return values. Free with g_variant_unref().</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusProxy.</doc>
            <type name="DBusProxy" c:type="GDBusProxy*"/>
          </instance-parameter>
          <parameter name="out_fd_list" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">Return location for a #GUnixFDList or %NULL.</doc>
            <type name="UnixFDList" c:type="GUnixFDList**"/>
          </parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">A #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_proxy_call_with_unix_fd_list().</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="call_with_unix_fd_list_sync" c:identifier="g_dbus_proxy_call_with_unix_fd_list_sync" version="2.30" throws="1">
        <doc xml:space="preserve">Like g_dbus_proxy_call_sync() but also takes and returns #GUnixFDList objects.

This method is only available on UNIX.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">%NULL if @error is set. Otherwise a #GVariant tuple with
return values. Free with g_variant_unref().</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusProxy.</doc>
            <type name="DBusProxy" c:type="GDBusProxy*"/>
          </instance-parameter>
          <parameter name="method_name" transfer-ownership="none">
            <doc xml:space="preserve">Name of method to invoke.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GVariant tuple with parameters for the signal
             or %NULL if not passing parameters.</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags from the #GDBusCallFlags enumeration.</doc>
            <type name="DBusCallFlags" c:type="GDBusCallFlags"/>
          </parameter>
          <parameter name="timeout_msec" transfer-ownership="none">
            <doc xml:space="preserve">The timeout in milliseconds (with %G_MAXINT meaning
               "infinite") or -1 to use the proxy default timeout.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="fd_list" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GUnixFDList or %NULL.</doc>
            <type name="UnixFDList" c:type="GUnixFDList*"/>
          </parameter>
          <parameter name="out_fd_list" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">Return location for a #GUnixFDList or %NULL.</doc>
            <type name="UnixFDList" c:type="GUnixFDList**"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_cached_property" c:identifier="g_dbus_proxy_get_cached_property" version="2.26">
        <doc xml:space="preserve">Looks up the value for a property from the cache. This call does no
blocking IO.

If @proxy has an expected interface (see
#GDBusProxy:g-interface-info) and @property_name is referenced by
it, then @value is checked against the type of the property.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">A reference to the #GVariant instance
   that holds the value for @property_name or %NULL if the value is not in
   the cache. The returned reference must be freed with g_variant_unref().</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusProxy.</doc>
            <type name="DBusProxy" c:type="GDBusProxy*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">Property name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_cached_property_names" c:identifier="g_dbus_proxy_get_cached_property_names" version="2.26">
        <doc xml:space="preserve">Gets the names of all cached properties on @proxy.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">A
         %NULL-terminated array of strings or %NULL if
         @proxy has no cached properties. Free the returned array with
         g_strfreev().</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusProxy.</doc>
            <type name="DBusProxy" c:type="GDBusProxy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_connection" c:identifier="g_dbus_proxy_get_connection" version="2.26">
        <doc xml:space="preserve">Gets the connection @proxy is for.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusConnection owned by @proxy. Do not free.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusProxy.</doc>
            <type name="DBusProxy" c:type="GDBusProxy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_default_timeout" c:identifier="g_dbus_proxy_get_default_timeout" version="2.26">
        <doc xml:space="preserve">Gets the timeout to use if -1 (specifying default timeout) is
passed as @timeout_msec in the g_dbus_proxy_call() and
g_dbus_proxy_call_sync() functions.

See the #GDBusProxy:g-default-timeout property for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Timeout to use for @proxy.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusProxy.</doc>
            <type name="DBusProxy" c:type="GDBusProxy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="g_dbus_proxy_get_flags" version="2.26">
        <doc xml:space="preserve">Gets the flags that @proxy was constructed with.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Flags from the #GDBusProxyFlags enumeration.</doc>
          <type name="DBusProxyFlags" c:type="GDBusProxyFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusProxy.</doc>
            <type name="DBusProxy" c:type="GDBusProxy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_interface_info" c:identifier="g_dbus_proxy_get_interface_info" version="2.26">
        <doc xml:space="preserve">Returns the #GDBusInterfaceInfo, if any, specifying the interface
that @proxy conforms to. See the #GDBusProxy:g-interface-info
property for more details.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">A #GDBusInterfaceInfo or %NULL.
   Do not unref the returned object, it is owned by @proxy.</doc>
          <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusProxy</doc>
            <type name="DBusProxy" c:type="GDBusProxy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_interface_name" c:identifier="g_dbus_proxy_get_interface_name" version="2.26">
        <doc xml:space="preserve">Gets the D-Bus interface name @proxy is for.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A string owned by @proxy. Do not free.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusProxy.</doc>
            <type name="DBusProxy" c:type="GDBusProxy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="g_dbus_proxy_get_name" version="2.26">
        <doc xml:space="preserve">Gets the name that @proxy was constructed for.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A string owned by @proxy. Do not free.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusProxy.</doc>
            <type name="DBusProxy" c:type="GDBusProxy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name_owner" c:identifier="g_dbus_proxy_get_name_owner" version="2.26">
        <doc xml:space="preserve">The unique name that owns the name that @proxy is for or %NULL if
no-one currently owns that name. You may connect to the
#GObject::notify signal to track changes to the
#GDBusProxy:g-name-owner property.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The name owner or %NULL if no name
   owner exists. Free with g_free().</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusProxy.</doc>
            <type name="DBusProxy" c:type="GDBusProxy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_object_path" c:identifier="g_dbus_proxy_get_object_path" version="2.26">
        <doc xml:space="preserve">Gets the object path @proxy is for.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A string owned by @proxy. Do not free.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusProxy.</doc>
            <type name="DBusProxy" c:type="GDBusProxy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_cached_property" c:identifier="g_dbus_proxy_set_cached_property" version="2.26">
        <doc xml:space="preserve">If @value is not %NULL, sets the cached value for the property with
name @property_name to the value in @value.

If @value is %NULL, then the cached value is removed from the
property cache.

If @proxy has an expected interface (see
#GDBusProxy:g-interface-info) and @property_name is referenced by
it, then @value is checked against the type of the property.

If the @value #GVariant is floating, it is consumed. This allows
convenient 'inline' use of g_variant_new(), e.g.
|[&lt;!-- language="C" --&gt;
 g_dbus_proxy_set_cached_property (proxy,
                                   "SomeProperty",
                                   g_variant_new ("(si)",
                                                 "A String",
                                                 42));
]|

Normally you will not need to use this method since @proxy
is tracking changes using the
`org.freedesktop.DBus.Properties.PropertiesChanged`
D-Bus signal. However, for performance reasons an object may
decide to not use this signal for some properties and instead
use a proprietary out-of-band mechanism to transmit changes.

As a concrete example, consider an object with a property
`ChatroomParticipants` which is an array of strings. Instead of
transmitting the same (long) array every time the property changes,
it is more efficient to only transmit the delta using e.g. signals
`ChatroomParticipantJoined(String name)` and
`ChatroomParticipantParted(String name)`.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusProxy</doc>
            <type name="DBusProxy" c:type="GDBusProxy*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">Property name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Value for the property or %NULL to remove it from the cache.</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_default_timeout" c:identifier="g_dbus_proxy_set_default_timeout" version="2.26">
        <doc xml:space="preserve">Sets the timeout to use if -1 (specifying default timeout) is
passed as @timeout_msec in the g_dbus_proxy_call() and
g_dbus_proxy_call_sync() functions.

See the #GDBusProxy:g-default-timeout property for more details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusProxy.</doc>
            <type name="DBusProxy" c:type="GDBusProxy*"/>
          </instance-parameter>
          <parameter name="timeout_msec" transfer-ownership="none">
            <doc xml:space="preserve">Timeout in milliseconds.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_interface_info" c:identifier="g_dbus_proxy_set_interface_info" version="2.26">
        <doc xml:space="preserve">Ensure that interactions with @proxy conform to the given
interface. See the #GDBusProxy:g-interface-info property for more
details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusProxy</doc>
            <type name="DBusProxy" c:type="GDBusProxy*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Minimum interface this proxy conforms to
   or %NULL to unset.</doc>
            <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
          </parameter>
        </parameters>
      </method>
      <property name="g-bus-type" version="2.26" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">If this property is not %G_BUS_TYPE_NONE, then
#GDBusProxy:g-connection must be %NULL and will be set to the
#GDBusConnection obtained by calling g_bus_get() with the value
of this property.</doc>
        <type name="BusType"/>
      </property>
      <property name="g-connection" version="2.26" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The #GDBusConnection the proxy is for.</doc>
        <type name="DBusConnection"/>
      </property>
      <property name="g-default-timeout" version="2.26" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">The timeout to use if -1 (specifying default timeout) is passed
as @timeout_msec in the g_dbus_proxy_call() and
g_dbus_proxy_call_sync() functions.

This allows applications to set a proxy-wide timeout for all
remote method invocations on the proxy. If this property is -1,
the default timeout (typically 25 seconds) is used. If set to
%G_MAXINT, then no timeout is used.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="g-flags" version="2.26" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">Flags from the #GDBusProxyFlags enumeration.</doc>
        <type name="DBusProxyFlags"/>
      </property>
      <property name="g-interface-info" version="2.26" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Ensure that interactions with this proxy conform to the given
interface. This is mainly to ensure that malformed data received
from the other peer is ignored. The given #GDBusInterfaceInfo is
said to be the "expected interface".

The checks performed are:
- When completing a method call, if the type signature of
  the reply message isn't what's expected, the reply is
  discarded and the #GError is set to %G_IO_ERROR_INVALID_ARGUMENT.

- Received signals that have a type signature mismatch are dropped and
  a warning is logged via g_warning().

- Properties received via the initial `GetAll()` call or via the
  `::PropertiesChanged` signal (on the
  [org.freedesktop.DBus.Properties](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties)
  interface) or set using g_dbus_proxy_set_cached_property()
  with a type signature mismatch are ignored and a warning is
  logged via g_warning().

Note that these checks are never done on methods, signals and
properties that are not referenced in the given
#GDBusInterfaceInfo, since extending a D-Bus interface on the
service-side is not considered an ABI break.</doc>
        <type name="DBusInterfaceInfo"/>
      </property>
      <property name="g-interface-name" version="2.26" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The D-Bus interface name the proxy is for.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="g-name" version="2.26" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The well-known or unique name that the proxy is for.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="g-name-owner" version="2.26" transfer-ownership="none">
        <doc xml:space="preserve">The unique name that owns #GDBusProxy:g-name or %NULL if no-one
currently owns that name. You may connect to #GObject::notify signal to
track changes to this property.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="g-object-path" version="2.26" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The object path the proxy is for.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="DBusProxyPrivate" c:type="GDBusProxyPrivate*"/>
      </field>
      <glib:signal name="g-properties-changed" when="last" version="2.26">
        <doc xml:space="preserve">Emitted when one or more D-Bus properties on @proxy changes. The
local cache has already been updated when this signal fires. Note
that both @changed_properties and @invalidated_properties are
guaranteed to never be %NULL (either may be empty though).

If the proxy has the flag
%G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES set, then
@invalidated_properties will always be empty.

This signal corresponds to the
`PropertiesChanged` D-Bus signal on the
`org.freedesktop.DBus.Properties` interface.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="changed_properties" transfer-ownership="none">
            <doc xml:space="preserve">A #GVariant containing the properties that changed (type: `a{sv}`)</doc>
            <type name="GLib.Variant"/>
          </parameter>
          <parameter name="invalidated_properties" transfer-ownership="none">
            <doc xml:space="preserve">A %NULL terminated array of properties that was invalidated</doc>
            <array>
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="g-signal" when="last" version="2.26">
        <doc xml:space="preserve">Emitted when a signal from the remote object and interface that @proxy is for, has been received.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="sender_name" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The sender of the signal or %NULL if the connection is not a bus connection.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="signal_name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the signal.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:space="preserve">A #GVariant tuple with parameters for the signal.</doc>
            <type name="GLib.Variant"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="DBusProxyClass" c:type="GDBusProxyClass" glib:is-gtype-struct-for="DBusProxy" version="2.26">
      <doc xml:space="preserve">Class structure for #GDBusProxy.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="g_properties_changed">
        <callback name="g_properties_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="proxy" transfer-ownership="none">
              <type name="DBusProxy" c:type="GDBusProxy*"/>
            </parameter>
            <parameter name="changed_properties" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
            <parameter name="invalidated_properties" transfer-ownership="none">
              <type name="utf8" c:type="const gchar* const*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="g_signal">
        <callback name="g_signal">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="proxy" transfer-ownership="none">
              <type name="DBusProxy" c:type="GDBusProxy*"/>
            </parameter>
            <parameter name="sender_name" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="signal_name" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="parameters" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="32">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="DBusProxyFlags" version="2.26" glib:type-name="GDBusProxyFlags" glib:get-type="g_dbus_proxy_flags_get_type" c:type="GDBusProxyFlags">
      <doc xml:space="preserve">Flags used when constructing an instance of a #GDBusProxy derived class.</doc>
      <member name="none" value="0" c:identifier="G_DBUS_PROXY_FLAGS_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
      <member name="do_not_load_properties" value="1" c:identifier="G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES" glib:nick="do-not-load-properties">
        <doc xml:space="preserve">Don't load properties.</doc>
      </member>
      <member name="do_not_connect_signals" value="2" c:identifier="G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS" glib:nick="do-not-connect-signals">
        <doc xml:space="preserve">Don't connect to signals on the remote object.</doc>
      </member>
      <member name="do_not_auto_start" value="4" c:identifier="G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START" glib:nick="do-not-auto-start">
        <doc xml:space="preserve">If the proxy is for a well-known name,
do not ask the bus to launch an owner during proxy initialization or a method call.
This flag is only meaningful in proxies for well-known names.</doc>
      </member>
      <member name="get_invalidated_properties" value="8" c:identifier="G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES" glib:nick="get-invalidated-properties">
        <doc xml:space="preserve">If set, the property value for any __invalidated property__ will be (asynchronously) retrieved upon receiving the [`PropertiesChanged`](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties) D-Bus signal and the property will not cause emission of the #GDBusProxy::g-properties-changed signal. When the value is received the #GDBusProxy::g-properties-changed signal is emitted for the property along with the retrieved value. Since 2.32.</doc>
      </member>
      <member name="do_not_auto_start_at_construction" value="16" c:identifier="G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION" glib:nick="do-not-auto-start-at-construction">
        <doc xml:space="preserve">If the proxy is for a well-known name,
do not ask the bus to launch an owner during proxy initialization, but allow it to be
autostarted by a method call. This flag is only meaningful in proxies for well-known names,
and only if %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is not also specified.</doc>
      </member>
    </bitfield>
    <record name="DBusProxyPrivate" c:type="GDBusProxyPrivate" disguised="1">
    </record>
    <callback name="DBusProxyTypeFunc" c:type="GDBusProxyTypeFunc" version="2.30">
      <doc xml:space="preserve">Function signature for a function used to determine the #GType to
use for an interface proxy (if @interface_name is not %NULL) or
object proxy (if @interface_name is %NULL).

This function is called in the
[thread-default main loop][g-main-context-push-thread-default]
that @manager was constructed in.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">A #GType to use for the remote object. The returned type
  must be a #GDBusProxy or #GDBusObjectProxy -derived
  type.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="manager" transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusObjectManagerClient.</doc>
          <type name="DBusObjectManagerClient" c:type="GDBusObjectManagerClient*"/>
        </parameter>
        <parameter name="object_path" transfer-ownership="none">
          <doc xml:space="preserve">The object path of the remote object.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="interface_name" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The interface name of the remote object or %NULL if a #GDBusObjectProxy #GType is requested.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
          <doc xml:space="preserve">User data.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="DBusSendMessageFlags" version="2.26" glib:type-name="GDBusSendMessageFlags" glib:get-type="g_dbus_send_message_flags_get_type" c:type="GDBusSendMessageFlags">
      <doc xml:space="preserve">Flags used when sending #GDBusMessages on a #GDBusConnection.</doc>
      <member name="none" value="0" c:identifier="G_DBUS_SEND_MESSAGE_FLAGS_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
      <member name="preserve_serial" value="1" c:identifier="G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL" glib:nick="preserve-serial">
        <doc xml:space="preserve">Do not automatically
assign a serial number from the #GDBusConnection object when
sending a message.</doc>
      </member>
    </bitfield>
    <class name="DBusServer" c:symbol-prefix="dbus_server" c:type="GDBusServer" version="2.26" parent="GObject.Object" glib:type-name="GDBusServer" glib:get-type="g_dbus_server_get_type">
      <doc xml:space="preserve">#GDBusServer is a helper for listening to and accepting D-Bus
connections. This can be used to create a new D-Bus server, allowing two
peers to use the D-Bus protocol for their own specialized communication.
A server instance provided in this way will not perform message routing or
implement the org.freedesktop.DBus interface.

To just export an object on a well-known name on a message bus, such as the
session or system bus, you should instead use g_bus_own_name().

An example of peer-to-peer communication with G-DBus can be found
in [gdbus-example-peer.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-peer.c).</doc>
      <implements name="Initable"/>
      <constructor name="new_sync" c:identifier="g_dbus_server_new_sync" version="2.26" throws="1">
        <doc xml:space="preserve">Creates a new D-Bus server that listens on the first address in
@address that works.

Once constructed, you can use g_dbus_server_get_client_address() to
get a D-Bus address string that clients can use to connect.

Connect to the #GDBusServer::new-connection signal to handle
incoming connections.

The returned #GDBusServer isn't active - you have to start it with
g_dbus_server_start().

#GDBusServer is used in this [example][gdbus-peer-to-peer].

This is a synchronous failable constructor. See
g_dbus_server_new() for the asynchronous version.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GDBusServer or %NULL if @error is set. Free with
g_object_unref().</doc>
          <type name="DBusServer" c:type="GDBusServer*"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">A D-Bus address.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags from the #GDBusServerFlags enumeration.</doc>
            <type name="DBusServerFlags" c:type="GDBusServerFlags"/>
          </parameter>
          <parameter name="guid" transfer-ownership="none">
            <doc xml:space="preserve">A D-Bus GUID.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="observer" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GDBusAuthObserver or %NULL.</doc>
            <type name="DBusAuthObserver" c:type="GDBusAuthObserver*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_client_address" c:identifier="g_dbus_server_get_client_address" version="2.26">
        <doc xml:space="preserve">Gets a
[D-Bus address](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
string that can be used by clients to connect to @server.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A D-Bus address string. Do not free, the string is owned
by @server.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusServer.</doc>
            <type name="DBusServer" c:type="GDBusServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="g_dbus_server_get_flags" version="2.26">
        <doc xml:space="preserve">Gets the flags for @server.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A set of flags from the #GDBusServerFlags enumeration.</doc>
          <type name="DBusServerFlags" c:type="GDBusServerFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusServer.</doc>
            <type name="DBusServer" c:type="GDBusServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_guid" c:identifier="g_dbus_server_get_guid" version="2.26">
        <doc xml:space="preserve">Gets the GUID for @server.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A D-Bus GUID. Do not free this string, it is owned by @server.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusServer.</doc>
            <type name="DBusServer" c:type="GDBusServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_active" c:identifier="g_dbus_server_is_active" version="2.26">
        <doc xml:space="preserve">Gets whether @server is active.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if server is active, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusServer.</doc>
            <type name="DBusServer" c:type="GDBusServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="start" c:identifier="g_dbus_server_start" version="2.26">
        <doc xml:space="preserve">Starts @server.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusServer.</doc>
            <type name="DBusServer" c:type="GDBusServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="stop" c:identifier="g_dbus_server_stop" version="2.26">
        <doc xml:space="preserve">Stops @server.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusServer.</doc>
            <type name="DBusServer" c:type="GDBusServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="active" version="2.26" transfer-ownership="none">
        <doc xml:space="preserve">Whether the server is currently active.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="address" version="2.26" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The D-Bus address to listen on.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="authentication-observer" version="2.26" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">A #GDBusAuthObserver object to assist in the authentication process or %NULL.</doc>
        <type name="DBusAuthObserver"/>
      </property>
      <property name="client-address" version="2.26" transfer-ownership="none">
        <doc xml:space="preserve">The D-Bus address that clients can use.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="flags" version="2.26" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">Flags from the #GDBusServerFlags enumeration.</doc>
        <type name="DBusServerFlags"/>
      </property>
      <property name="guid" version="2.26" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The guid of the server.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <glib:signal name="new-connection" when="last" version="2.26">
        <doc xml:space="preserve">Emitted when a new authenticated connection has been made. Use
g_dbus_connection_get_peer_credentials() to figure out what
identity (if any), was authenticated.

If you want to accept the connection, take a reference to the
@connection object and return %TRUE. When you are done with the
connection call g_dbus_connection_close() and give up your
reference. Note that the other peer may disconnect at any time -
a typical thing to do when accepting a connection is to listen to
the #GDBusConnection::closed signal.

If #GDBusServer:flags contains %G_DBUS_SERVER_FLAGS_RUN_IN_THREAD
then the signal is emitted in a new thread dedicated to the
connection. Otherwise the signal is emitted in the
[thread-default main context][g-main-context-push-thread-default]
of the thread that @server was constructed in.

You are guaranteed that signal handlers for this signal runs
before incoming messages on @connection are processed. This means
that it's suitable to call g_dbus_connection_register_object() or
similar from the signal handler.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE to claim @connection, %FALSE to let other handlers
run.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusConnection for the new connection.</doc>
            <type name="DBusConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <bitfield name="DBusServerFlags" version="2.26" glib:type-name="GDBusServerFlags" glib:get-type="g_dbus_server_flags_get_type" c:type="GDBusServerFlags">
      <doc xml:space="preserve">Flags used when creating a #GDBusServer.</doc>
      <member name="none" value="0" c:identifier="G_DBUS_SERVER_FLAGS_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
      <member name="run_in_thread" value="1" c:identifier="G_DBUS_SERVER_FLAGS_RUN_IN_THREAD" glib:nick="run-in-thread">
        <doc xml:space="preserve">All #GDBusServer::new-connection
signals will run in separated dedicated threads (see signal for
details).</doc>
      </member>
      <member name="authentication_allow_anonymous" value="2" c:identifier="G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS" glib:nick="authentication-allow-anonymous">
        <doc xml:space="preserve">Allow the anonymous
authentication method.</doc>
      </member>
    </bitfield>
    <callback name="DBusSignalCallback" c:type="GDBusSignalCallback" version="2.26">
      <doc xml:space="preserve">Signature for callback function used in g_dbus_connection_signal_subscribe().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusConnection.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="sender_name" transfer-ownership="none">
          <doc xml:space="preserve">The unique bus name of the sender of the signal.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="object_path" transfer-ownership="none">
          <doc xml:space="preserve">The object path that the signal was emitted on.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:space="preserve">The name of the interface.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="signal_name" transfer-ownership="none">
          <doc xml:space="preserve">The name of the signal.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="parameters" transfer-ownership="none">
          <doc xml:space="preserve">A #GVariant tuple with parameters for the signal.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6">
          <doc xml:space="preserve">User data passed when subscribing to the signal.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="DBusSignalFlags" version="2.26" glib:type-name="GDBusSignalFlags" glib:get-type="g_dbus_signal_flags_get_type" c:type="GDBusSignalFlags">
      <doc xml:space="preserve">Flags used when subscribing to signals via g_dbus_connection_signal_subscribe().</doc>
      <member name="none" value="0" c:identifier="G_DBUS_SIGNAL_FLAGS_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
      <member name="no_match_rule" value="1" c:identifier="G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE" glib:nick="no-match-rule">
        <doc xml:space="preserve">Don't actually send the AddMatch
D-Bus call for this signal subscription.  This gives you more control
over which match rules you add (but you must add them manually).</doc>
      </member>
      <member name="match_arg0_namespace" value="2" c:identifier="G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE" glib:nick="match-arg0-namespace">
        <doc xml:space="preserve">Match first arguments that
contain a bus or interface name with the given namespace.</doc>
      </member>
      <member name="match_arg0_path" value="4" c:identifier="G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH" glib:nick="match-arg0-path">
        <doc xml:space="preserve">Match first arguments that
contain an object path that is either equivalent to the given path,
or one of the paths is a subpath of the other.</doc>
      </member>
    </bitfield>
    <record name="DBusSignalInfo" c:type="GDBusSignalInfo" version="2.26" glib:type-name="GDBusSignalInfo" glib:get-type="g_dbus_signal_info_get_type" c:symbol-prefix="dbus_signal_info">
      <doc xml:space="preserve">Information about a signal on a D-Bus interface.</doc>
      <field name="ref_count" writable="1">
        <doc xml:space="preserve">The reference count or -1 if statically allocated.</doc>
        <type name="gint" c:type="volatile gint"/>
      </field>
      <field name="name" writable="1">
        <doc xml:space="preserve">The name of the D-Bus signal, e.g. "NameOwnerChanged".</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="args" writable="1">
        <doc xml:space="preserve">A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no arguments.</doc>
        <array c:type="GDBusArgInfo**">
          <type name="DBusArgInfo" c:type="GDBusArgInfo*"/>
        </array>
      </field>
      <field name="annotations" writable="1">
        <doc xml:space="preserve">A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.</doc>
        <array c:type="GDBusAnnotationInfo**">
          <type name="DBusAnnotationInfo" c:type="GDBusAnnotationInfo*"/>
        </array>
      </field>
      <method name="ref" c:identifier="g_dbus_signal_info_ref" version="2.26">
        <doc xml:space="preserve">If @info is statically allocated does nothing. Otherwise increases
the reference count.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The same @info.</doc>
          <type name="DBusSignalInfo" c:type="GDBusSignalInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusSignalInfo</doc>
            <type name="DBusSignalInfo" c:type="GDBusSignalInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_dbus_signal_info_unref" version="2.26">
        <doc xml:space="preserve">If @info is statically allocated, does nothing. Otherwise decreases
the reference count of @info. When its reference count drops to 0,
the memory used is freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #GDBusSignalInfo.</doc>
            <type name="DBusSignalInfo" c:type="GDBusSignalInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <callback name="DBusSubtreeDispatchFunc" c:type="GDBusSubtreeDispatchFunc" version="2.26">
      <doc xml:space="preserve">The type of the @dispatch function in #GDBusSubtreeVTable.

Subtrees are flat.  @node, if non-%NULL, is always exactly one
segment of the object path (ie: it never contains a slash).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">A #GDBusInterfaceVTable or %NULL if you don't want to handle the methods.</doc>
        <type name="DBusInterfaceVTable" c:type="const GDBusInterfaceVTable*"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusConnection.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="sender" transfer-ownership="none">
          <doc xml:space="preserve">The unique bus name of the remote caller.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="object_path" transfer-ownership="none">
          <doc xml:space="preserve">The object path that was registered with g_dbus_connection_register_subtree().</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:space="preserve">The D-Bus interface name that the method call or property access is for.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">A node that is a child of @object_path (relative to @object_path) or %NULL for the root of the subtree.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="out_user_data" transfer-ownership="none">
          <doc xml:space="preserve">Return location for user data to pass to functions in the returned #GDBusInterfaceVTable (never %NULL).</doc>
          <type name="gpointer" c:type="gpointer*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6">
          <doc xml:space="preserve">The @user_data #gpointer passed to g_dbus_connection_register_subtree().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="DBusSubtreeEnumerateFunc" c:type="GDBusSubtreeEnumerateFunc" version="2.26" introspectable="0">
      <doc xml:space="preserve">The type of the @enumerate function in #GDBusSubtreeVTable.

This function is called when generating introspection data and also
when preparing to dispatch incoming messages in the event that the
%G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is not
specified (ie: to verify that the object path is valid).

Hierarchies are not supported; the items that you return should not
contain the '/' character.

The return value will be freed with g_strfreev().</doc>
      <return-value>
        <doc xml:space="preserve">A newly allocated array of strings for node names that are children of @object_path.</doc>
        <array c:type="gchar**">
          <type name="utf8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusConnection.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="sender" transfer-ownership="none">
          <doc xml:space="preserve">The unique bus name of the remote caller.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="object_path" transfer-ownership="none">
          <doc xml:space="preserve">The object path that was registered with g_dbus_connection_register_subtree().</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
          <doc xml:space="preserve">The @user_data #gpointer passed to g_dbus_connection_register_subtree().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="DBusSubtreeFlags" version="2.26" glib:type-name="GDBusSubtreeFlags" glib:get-type="g_dbus_subtree_flags_get_type" c:type="GDBusSubtreeFlags">
      <doc xml:space="preserve">Flags passed to g_dbus_connection_register_subtree().</doc>
      <member name="none" value="0" c:identifier="G_DBUS_SUBTREE_FLAGS_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
      <member name="dispatch_to_unenumerated_nodes" value="1" c:identifier="G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES" glib:nick="dispatch-to-unenumerated-nodes">
        <doc xml:space="preserve">Method calls to objects not in the enumerated range
                                                      will still be dispatched. This is useful if you want
                                                      to dynamically spawn objects in the subtree.</doc>
      </member>
    </bitfield>
    <callback name="DBusSubtreeIntrospectFunc" c:type="GDBusSubtreeIntrospectFunc" version="2.26">
      <doc xml:space="preserve">The type of the @introspect function in #GDBusSubtreeVTable.

Subtrees are flat.  @node, if non-%NULL, is always exactly one
segment of the object path (ie: it never contains a slash).

This function should return %NULL to indicate that there is no object
at this node.

If this function returns non-%NULL, the return value is expected to
be a %NULL-terminated array of pointers to #GDBusInterfaceInfo
structures describing the interfaces implemented by @node.  This
array will have g_dbus_interface_info_unref() called on each item
before being freed with g_free().

The difference between returning %NULL and an array containing zero
items is that the standard DBus interfaces will returned to the
remote introspector in the empty array case, but not in the %NULL
case.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A %NULL-terminated array of pointers to #GDBusInterfaceInfo, or %NULL.</doc>
        <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo**"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusConnection.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="sender" transfer-ownership="none">
          <doc xml:space="preserve">The unique bus name of the remote caller.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="object_path" transfer-ownership="none">
          <doc xml:space="preserve">The object path that was registered with g_dbus_connection_register_subtree().</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">A node that is a child of @object_path (relative to @object_path) or %NULL for the root of the subtree.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
          <doc xml:space="preserve">The @user_data #gpointer passed to g_dbus_connection_register_subtree().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="DBusSubtreeVTable" c:type="GDBusSubtreeVTable" version="2.26">
      <doc xml:space="preserve">Virtual table for handling subtrees registered with g_dbus_connection_register_subtree().</doc>
      <field name="enumerate" introspectable="0" writable="1">
        <doc xml:space="preserve">Function for enumerating child nodes.</doc>
        <type name="DBusSubtreeEnumerateFunc" c:type="GDBusSubtreeEnumerateFunc"/>
      </field>
      <field name="introspect" writable="1">
        <doc xml:space="preserve">Function for introspecting a child node.</doc>
        <type name="DBusSubtreeIntrospectFunc" c:type="GDBusSubtreeIntrospectFunc"/>
      </field>
      <field name="dispatch" writable="1">
        <doc xml:space="preserve">Function for dispatching a remote call on a child node.</doc>
        <type name="DBusSubtreeDispatchFunc" c:type="GDBusSubtreeDispatchFunc"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <constant name="DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME" value="gio-desktop-app-info-lookup" c:type="G_DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME">
      <doc xml:space="preserve">Extension point for default handler to URI association. See
[Extending GIO][extending-gio].</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DRIVE_IDENTIFIER_KIND_UNIX_DEVICE" value="unix-device" c:type="G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE" version="2.58">
      <doc xml:space="preserve">The string used to obtain a Unix device path with g_drive_get_identifier().</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="DataInputStream" c:symbol-prefix="data_input_stream" c:type="GDataInputStream" parent="BufferedInputStream" glib:type-name="GDataInputStream" glib:get-type="g_data_input_stream_get_type" glib:type-struct="DataInputStreamClass">
      <doc xml:space="preserve">Data input stream implements #GInputStream and includes functions for
reading structured data directly from a binary input stream.</doc>
      <implements name="Seekable"/>
      <constructor name="new" c:identifier="g_data_input_stream_new">
        <doc xml:space="preserve">Creates a new data input stream for the @base_stream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GDataInputStream.</doc>
          <type name="DataInputStream" c:type="GDataInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="base_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_byte_order" c:identifier="g_data_input_stream_get_byte_order">
        <doc xml:space="preserve">Gets the byte order for the data input stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the @stream's current #GDataStreamByteOrder.</doc>
          <type name="DataStreamByteOrder" c:type="GDataStreamByteOrder"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a given #GDataInputStream.</doc>
            <type name="DataInputStream" c:type="GDataInputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_newline_type" c:identifier="g_data_input_stream_get_newline_type">
        <doc xml:space="preserve">Gets the current newline type for the @stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#GDataStreamNewlineType for the given @stream.</doc>
          <type name="DataStreamNewlineType" c:type="GDataStreamNewlineType"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a given #GDataInputStream.</doc>
            <type name="DataInputStream" c:type="GDataInputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="read_byte" c:identifier="g_data_input_stream_read_byte" throws="1">
        <doc xml:space="preserve">Reads an unsigned 8-bit/1-byte value from @stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an unsigned 8-bit/1-byte value read from the @stream or %0
if an error occurred.</doc>
          <type name="guint8" c:type="guchar"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a given #GDataInputStream.</doc>
            <type name="DataInputStream" c:type="GDataInputStream*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_int16" c:identifier="g_data_input_stream_read_int16" throws="1">
        <doc xml:space="preserve">Reads a 16-bit/2-byte value from @stream.

In order to get the correct byte order for this read operation,
see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a signed 16-bit/2-byte value read from @stream or %0 if
an error occurred.</doc>
          <type name="gint16" c:type="gint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a given #GDataInputStream.</doc>
            <type name="DataInputStream" c:type="GDataInputStream*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_int32" c:identifier="g_data_input_stream_read_int32" throws="1">
        <doc xml:space="preserve">Reads a signed 32-bit/4-byte value from @stream.

In order to get the correct byte order for this read operation,
see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a signed 32-bit/4-byte value read from the @stream or %0 if
an error occurred.</doc>
          <type name="gint32" c:type="gint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a given #GDataInputStream.</doc>
            <type name="DataInputStream" c:type="GDataInputStream*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_int64" c:identifier="g_data_input_stream_read_int64" throws="1">
        <doc xml:space="preserve">Reads a 64-bit/8-byte value from @stream.

In order to get the correct byte order for this read operation,
see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a signed 64-bit/8-byte value read from @stream or %0 if
an error occurred.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a given #GDataInputStream.</doc>
            <type name="DataInputStream" c:type="GDataInputStream*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_line" c:identifier="g_data_input_stream_read_line" throws="1">
        <doc xml:space="preserve">Reads a line from the data input stream.  Note that no encoding
checks or conversion is performed; the input is not guaranteed to
be UTF-8, and may in fact have embedded NUL characters.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">
 a NUL terminated byte array with the line that was read in
 (without the newlines).  Set @length to a #gsize to get the length
 of the read line.  On an error, it will return %NULL and @error
 will be set. If there's no content to read, it will still return
 %NULL, but @error won't be set.</doc>
          <array c:type="char*">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a given #GDataInputStream.</doc>
            <type name="DataInputStream" c:type="GDataInputStream*"/>
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a #gsize to get the length of the data read in.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_line_async" c:identifier="g_data_input_stream_read_line_async" version="2.20">
        <doc xml:space="preserve">The asynchronous version of g_data_input_stream_read_line().  It is
an error to have two outstanding calls to this function.

When the operation is finished, @callback will be called. You
can then call g_data_input_stream_read_line_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a given #GDataInputStream.</doc>
            <type name="DataInputStream" c:type="GDataInputStream*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">callback to call when the request is satisfied.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_line_finish" c:identifier="g_data_input_stream_read_line_finish" version="2.20" throws="1">
        <doc xml:space="preserve">Finish an asynchronous call started by
g_data_input_stream_read_line_async().  Note the warning about
string encoding in g_data_input_stream_read_line() applies here as
well.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">
 a NUL-terminated byte array with the line that was read in
 (without the newlines).  Set @length to a #gsize to get the length
 of the read line.  On an error, it will return %NULL and @error
 will be set. If there's no content to read, it will still return
 %NULL, but @error won't be set.</doc>
          <array c:type="char*">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a given #GDataInputStream.</doc>
            <type name="DataInputStream" c:type="GDataInputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult that was provided to the callback.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a #gsize to get the length of the data read in.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_line_finish_utf8" c:identifier="g_data_input_stream_read_line_finish_utf8" version="2.30" throws="1">
        <doc xml:space="preserve">Finish an asynchronous call started by
g_data_input_stream_read_line_async().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a string with the line that
 was read in (without the newlines).  Set @length to a #gsize to
 get the length of the read line.  On an error, it will return
 %NULL and @error will be set. For UTF-8 conversion errors, the set
 error domain is %G_CONVERT_ERROR.  If there's no content to read,
 it will still return %NULL, but @error won't be set.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a given #GDataInputStream.</doc>
            <type name="DataInputStream" c:type="GDataInputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult that was provided to the callback.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a #gsize to get the length of the data read in.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_line_utf8" c:identifier="g_data_input_stream_read_line_utf8" version="2.30" throws="1">
        <doc xml:space="preserve">Reads a UTF-8 encoded line from the data input stream.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a NUL terminated UTF-8 string
 with the line that was read in (without the newlines).  Set
 @length to a #gsize to get the length of the read line.  On an
 error, it will return %NULL and @error will be set.  For UTF-8
 conversion errors, the set error domain is %G_CONVERT_ERROR.  If
 there's no content to read, it will still return %NULL, but @error
 won't be set.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a given #GDataInputStream.</doc>
            <type name="DataInputStream" c:type="GDataInputStream*"/>
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a #gsize to get the length of the data read in.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_uint16" c:identifier="g_data_input_stream_read_uint16" throws="1">
        <doc xml:space="preserve">Reads an unsigned 16-bit/2-byte value from @stream.

In order to get the correct byte order for this read operation,
see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an unsigned 16-bit/2-byte value read from the @stream or %0 if
an error occurred.</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a given #GDataInputStream.</doc>
            <type name="DataInputStream" c:type="GDataInputStream*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_uint32" c:identifier="g_data_input_stream_read_uint32" throws="1">
        <doc xml:space="preserve">Reads an unsigned 32-bit/4-byte value from @stream.

In order to get the correct byte order for this read operation,
see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an unsigned 32-bit/4-byte value read from the @stream or %0 if
an error occurred.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a given #GDataInputStream.</doc>
            <type name="DataInputStream" c:type="GDataInputStream*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_uint64" c:identifier="g_data_input_stream_read_uint64" throws="1">
        <doc xml:space="preserve">Reads an unsigned 64-bit/8-byte value from @stream.

In order to get the correct byte order for this read operation,
see g_data_input_stream_get_byte_order().

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an unsigned 64-bit/8-byte read from @stream or %0 if
an error occurred.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a given #GDataInputStream.</doc>
            <type name="DataInputStream" c:type="GDataInputStream*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_until" c:identifier="g_data_input_stream_read_until" deprecated="1" deprecated-version="2.56" throws="1">
        <doc xml:space="preserve">Reads a string from the data input stream, up to the first
occurrence of any of the stop characters.

Note that, in contrast to g_data_input_stream_read_until_async(),
this function consumes the stop character that it finds.

Don't use this function in new code.  Its functionality is
inconsistent with g_data_input_stream_read_until_async().  Both
functions will be marked as deprecated in a future release.  Use
g_data_input_stream_read_upto() instead, but note that that function
does not consume the stop character.</doc>
        <doc-deprecated xml:space="preserve">Use g_data_input_stream_read_upto() instead, which has more
    consistent behaviour regarding the stop character.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a string with the data that was read
    before encountering any of the stop characters. Set @length to
    a #gsize to get the length of the string. This function will
    return %NULL on an error.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a given #GDataInputStream.</doc>
            <type name="DataInputStream" c:type="GDataInputStream*"/>
          </instance-parameter>
          <parameter name="stop_chars" transfer-ownership="none">
            <doc xml:space="preserve">characters to terminate the read.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a #gsize to get the length of the data read in.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_until_async" c:identifier="g_data_input_stream_read_until_async" version="2.20" deprecated="1" deprecated-version="2.56">
        <doc xml:space="preserve">The asynchronous version of g_data_input_stream_read_until().
It is an error to have two outstanding calls to this function.

Note that, in contrast to g_data_input_stream_read_until(),
this function does not consume the stop character that it finds.  You
must read it for yourself.

When the operation is finished, @callback will be called. You
can then call g_data_input_stream_read_until_finish() to get
the result of the operation.

Don't use this function in new code.  Its functionality is
inconsistent with g_data_input_stream_read_until().  Both functions
will be marked as deprecated in a future release.  Use
g_data_input_stream_read_upto_async() instead.</doc>
        <doc-deprecated xml:space="preserve">Use g_data_input_stream_read_upto_async() instead, which
    has more consistent behaviour regarding the stop character.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a given #GDataInputStream.</doc>
            <type name="DataInputStream" c:type="GDataInputStream*"/>
          </instance-parameter>
          <parameter name="stop_chars" transfer-ownership="none">
            <doc xml:space="preserve">characters to terminate the read.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">callback to call when the request is satisfied.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_until_finish" c:identifier="g_data_input_stream_read_until_finish" version="2.20" deprecated="1" deprecated-version="2.56" throws="1">
        <doc xml:space="preserve">Finish an asynchronous call started by
g_data_input_stream_read_until_async().</doc>
        <doc-deprecated xml:space="preserve">Use g_data_input_stream_read_upto_finish() instead, which
    has more consistent behaviour regarding the stop character.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a string with the data that was read
    before encountering any of the stop characters. Set @length to
    a #gsize to get the length of the string. This function will
    return %NULL on an error.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a given #GDataInputStream.</doc>
            <type name="DataInputStream" c:type="GDataInputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult that was provided to the callback.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a #gsize to get the length of the data read in.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_upto" c:identifier="g_data_input_stream_read_upto" version="2.26" throws="1">
        <doc xml:space="preserve">Reads a string from the data input stream, up to the first
occurrence of any of the stop characters.

In contrast to g_data_input_stream_read_until(), this function
does not consume the stop character. You have to use
g_data_input_stream_read_byte() to get it before calling
g_data_input_stream_read_upto() again.

Note that @stop_chars may contain '\0' if @stop_chars_len is
specified.

The returned string will always be nul-terminated on success.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a string with the data that was read
    before encountering any of the stop characters. Set @length to
    a #gsize to get the length of the string. This function will
    return %NULL on an error</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GDataInputStream</doc>
            <type name="DataInputStream" c:type="GDataInputStream*"/>
          </instance-parameter>
          <parameter name="stop_chars" transfer-ownership="none">
            <doc xml:space="preserve">characters to terminate the read</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="stop_chars_len" transfer-ownership="none">
            <doc xml:space="preserve">length of @stop_chars. May be -1 if @stop_chars is
    nul-terminated</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a #gsize to get the length of the data read in</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_upto_async" c:identifier="g_data_input_stream_read_upto_async" version="2.26">
        <doc xml:space="preserve">The asynchronous version of g_data_input_stream_read_upto().
It is an error to have two outstanding calls to this function.

In contrast to g_data_input_stream_read_until(), this function
does not consume the stop character. You have to use
g_data_input_stream_read_byte() to get it before calling
g_data_input_stream_read_upto() again.

Note that @stop_chars may contain '\0' if @stop_chars_len is
specified.

When the operation is finished, @callback will be called. You
can then call g_data_input_stream_read_upto_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GDataInputStream</doc>
            <type name="DataInputStream" c:type="GDataInputStream*"/>
          </instance-parameter>
          <parameter name="stop_chars" transfer-ownership="none">
            <doc xml:space="preserve">characters to terminate the read</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="stop_chars_len" transfer-ownership="none">
            <doc xml:space="preserve">length of @stop_chars. May be -1 if @stop_chars is
    nul-terminated</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_upto_finish" c:identifier="g_data_input_stream_read_upto_finish" version="2.24" throws="1">
        <doc xml:space="preserve">Finish an asynchronous call started by
g_data_input_stream_read_upto_async().

Note that this function does not consume the stop character. You
have to use g_data_input_stream_read_byte() to get it before calling
g_data_input_stream_read_upto_async() again.

The returned string will always be nul-terminated on success.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a string with the data that was read
    before encountering any of the stop characters. Set @length to
    a #gsize to get the length of the string. This function will
    return %NULL on an error.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GDataInputStream</doc>
            <type name="DataInputStream" c:type="GDataInputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult that was provided to the callback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a #gsize to get the length of the data read in</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_byte_order" c:identifier="g_data_input_stream_set_byte_order">
        <doc xml:space="preserve">This function sets the byte order for the given @stream. All subsequent
reads from the @stream will be read in the given @order.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a given #GDataInputStream.</doc>
            <type name="DataInputStream" c:type="GDataInputStream*"/>
          </instance-parameter>
          <parameter name="order" transfer-ownership="none">
            <doc xml:space="preserve">a #GDataStreamByteOrder to set.</doc>
            <type name="DataStreamByteOrder" c:type="GDataStreamByteOrder"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_newline_type" c:identifier="g_data_input_stream_set_newline_type">
        <doc xml:space="preserve">Sets the newline type for the @stream.

Note that using G_DATA_STREAM_NEWLINE_TYPE_ANY is slightly unsafe. If a read
chunk ends in "CR" we must read an additional byte to know if this is "CR" or
"CR LF", and this might block if there is no more data available.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GDataInputStream.</doc>
            <type name="DataInputStream" c:type="GDataInputStream*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the type of new line return as #GDataStreamNewlineType.</doc>
            <type name="DataStreamNewlineType" c:type="GDataStreamNewlineType"/>
          </parameter>
        </parameters>
      </method>
      <property name="byte-order" writable="1" transfer-ownership="none">
        <type name="DataStreamByteOrder"/>
      </property>
      <property name="newline-type" writable="1" transfer-ownership="none">
        <type name="DataStreamNewlineType"/>
      </property>
      <field name="parent_instance">
        <type name="BufferedInputStream" c:type="GBufferedInputStream"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="DataInputStreamPrivate" c:type="GDataInputStreamPrivate*"/>
      </field>
    </class>
    <record name="DataInputStreamClass" c:type="GDataInputStreamClass" glib:is-gtype-struct-for="DataInputStream">
      <field name="parent_class">
        <type name="BufferedInputStreamClass" c:type="GBufferedInputStreamClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="DataInputStreamPrivate" c:type="GDataInputStreamPrivate" disguised="1">
    </record>
    <class name="DataOutputStream" c:symbol-prefix="data_output_stream" c:type="GDataOutputStream" parent="FilterOutputStream" glib:type-name="GDataOutputStream" glib:get-type="g_data_output_stream_get_type" glib:type-struct="DataOutputStreamClass">
      <doc xml:space="preserve">Data output stream implements #GOutputStream and includes functions for
writing data directly to an output stream.</doc>
      <implements name="Seekable"/>
      <constructor name="new" c:identifier="g_data_output_stream_new">
        <doc xml:space="preserve">Creates a new data output stream for @base_stream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GDataOutputStream.</doc>
          <type name="DataOutputStream" c:type="GDataOutputStream*"/>
        </return-value>
        <parameters>
          <parameter name="base_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_byte_order" c:identifier="g_data_output_stream_get_byte_order">
        <doc xml:space="preserve">Gets the byte order for the stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GDataStreamByteOrder for the @stream.</doc>
          <type name="DataStreamByteOrder" c:type="GDataStreamByteOrder"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GDataOutputStream.</doc>
            <type name="DataOutputStream" c:type="GDataOutputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="put_byte" c:identifier="g_data_output_stream_put_byte" throws="1">
        <doc xml:space="preserve">Puts a byte into the output stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @data was successfully added to the @stream.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GDataOutputStream.</doc>
            <type name="DataOutputStream" c:type="GDataOutputStream*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">a #guchar.</doc>
            <type name="guint8" c:type="guchar"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int16" c:identifier="g_data_output_stream_put_int16" throws="1">
        <doc xml:space="preserve">Puts a signed 16-bit integer into the output stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @data was successfully added to the @stream.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GDataOutputStream.</doc>
            <type name="DataOutputStream" c:type="GDataOutputStream*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">a #gint16.</doc>
            <type name="gint16" c:type="gint16"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int32" c:identifier="g_data_output_stream_put_int32" throws="1">
        <doc xml:space="preserve">Puts a signed 32-bit integer into the output stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @data was successfully added to the @stream.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GDataOutputStream.</doc>
            <type name="DataOutputStream" c:type="GDataOutputStream*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">a #gint32.</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int64" c:identifier="g_data_output_stream_put_int64" throws="1">
        <doc xml:space="preserve">Puts a signed 64-bit integer into the stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @data was successfully added to the @stream.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GDataOutputStream.</doc>
            <type name="DataOutputStream" c:type="GDataOutputStream*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">a #gint64.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_string" c:identifier="g_data_output_stream_put_string" throws="1">
        <doc xml:space="preserve">Puts a string into the output stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @string was successfully added to the @stream.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GDataOutputStream.</doc>
            <type name="DataOutputStream" c:type="GDataOutputStream*"/>
          </instance-parameter>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve">a string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint16" c:identifier="g_data_output_stream_put_uint16" throws="1">
        <doc xml:space="preserve">Puts an unsigned 16-bit integer into the output stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @data was successfully added to the @stream.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GDataOutputStream.</doc>
            <type name="DataOutputStream" c:type="GDataOutputStream*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">a #guint16.</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint32" c:identifier="g_data_output_stream_put_uint32" throws="1">
        <doc xml:space="preserve">Puts an unsigned 32-bit integer into the stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @data was successfully added to the @stream.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GDataOutputStream.</doc>
            <type name="DataOutputStream" c:type="GDataOutputStream*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">a #guint32.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint64" c:identifier="g_data_output_stream_put_uint64" throws="1">
        <doc xml:space="preserve">Puts an unsigned 64-bit integer into the stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @data was successfully added to the @stream.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GDataOutputStream.</doc>
            <type name="DataOutputStream" c:type="GDataOutputStream*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">a #guint64.</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_byte_order" c:identifier="g_data_output_stream_set_byte_order">
        <doc xml:space="preserve">Sets the byte order of the data output stream to @order.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GDataOutputStream.</doc>
            <type name="DataOutputStream" c:type="GDataOutputStream*"/>
          </instance-parameter>
          <parameter name="order" transfer-ownership="none">
            <doc xml:space="preserve">a %GDataStreamByteOrder.</doc>
            <type name="DataStreamByteOrder" c:type="GDataStreamByteOrder"/>
          </parameter>
        </parameters>
      </method>
      <property name="byte-order" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Determines the byte ordering that is used when writing
multi-byte entities (such as integers) to the stream.</doc>
        <type name="DataStreamByteOrder"/>
      </property>
      <field name="parent_instance">
        <type name="FilterOutputStream" c:type="GFilterOutputStream"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="DataOutputStreamPrivate" c:type="GDataOutputStreamPrivate*"/>
      </field>
    </class>
    <record name="DataOutputStreamClass" c:type="GDataOutputStreamClass" glib:is-gtype-struct-for="DataOutputStream">
      <field name="parent_class">
        <type name="FilterOutputStreamClass" c:type="GFilterOutputStreamClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="DataOutputStreamPrivate" c:type="GDataOutputStreamPrivate" disguised="1">
    </record>
    <enumeration name="DataStreamByteOrder" glib:type-name="GDataStreamByteOrder" glib:get-type="g_data_stream_byte_order_get_type" c:type="GDataStreamByteOrder">
      <doc xml:space="preserve">#GDataStreamByteOrder is used to ensure proper endianness of streaming data sources
across various machine architectures.</doc>
      <member name="big_endian" value="0" c:identifier="G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN" glib:nick="big-endian">
        <doc xml:space="preserve">Selects Big Endian byte order.</doc>
      </member>
      <member name="little_endian" value="1" c:identifier="G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN" glib:nick="little-endian">
        <doc xml:space="preserve">Selects Little Endian byte order.</doc>
      </member>
      <member name="host_endian" value="2" c:identifier="G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN" glib:nick="host-endian">
        <doc xml:space="preserve">Selects endianness based on host machine's architecture.</doc>
      </member>
    </enumeration>
    <enumeration name="DataStreamNewlineType" glib:type-name="GDataStreamNewlineType" glib:get-type="g_data_stream_newline_type_get_type" c:type="GDataStreamNewlineType">
      <doc xml:space="preserve">#GDataStreamNewlineType is used when checking for or setting the line endings for a given file.</doc>
      <member name="lf" value="0" c:identifier="G_DATA_STREAM_NEWLINE_TYPE_LF" glib:nick="lf">
        <doc xml:space="preserve">Selects "LF" line endings, common on most modern UNIX platforms.</doc>
      </member>
      <member name="cr" value="1" c:identifier="G_DATA_STREAM_NEWLINE_TYPE_CR" glib:nick="cr">
        <doc xml:space="preserve">Selects "CR" line endings.</doc>
      </member>
      <member name="cr_lf" value="2" c:identifier="G_DATA_STREAM_NEWLINE_TYPE_CR_LF" glib:nick="cr-lf">
        <doc xml:space="preserve">Selects "CR, LF" line ending, common on Microsoft Windows.</doc>
      </member>
      <member name="any" value="3" c:identifier="G_DATA_STREAM_NEWLINE_TYPE_ANY" glib:nick="any">
        <doc xml:space="preserve">Automatically try to handle any line ending type.</doc>
      </member>
    </enumeration>
    <interface name="DatagramBased" c:symbol-prefix="datagram_based" c:type="GDatagramBased" version="2.48" glib:type-name="GDatagramBased" glib:get-type="g_datagram_based_get_type" glib:type-struct="DatagramBasedInterface">
      <doc xml:space="preserve">A #GDatagramBased is a networking interface for representing datagram-based
communications. It is a more or less direct mapping of the core parts of the
BSD socket API in a portable GObject interface. It is implemented by
#GSocket, which wraps the UNIX socket API on UNIX and winsock2 on Windows.

#GDatagramBased is entirely platform independent, and is intended to be used
alongside higher-level networking APIs such as #GIOStream.

It uses vectored scatter/gather I/O by default, allowing for many messages
to be sent or received in a single call. Where possible, implementations of
the interface should take advantage of vectored I/O to minimise processing
or system calls. For example, #GSocket uses recvmmsg() and sendmmsg() where
possible. Callers should take advantage of scatter/gather I/O (the use of
multiple buffers per message) to avoid unnecessary copying of data to
assemble or disassemble a message.

Each #GDatagramBased operation has a timeout parameter which may be negative
for blocking behaviour, zero for non-blocking behaviour, or positive for
timeout behaviour. A blocking operation blocks until finished or there is an
error. A non-blocking operation will return immediately with a
%G_IO_ERROR_WOULD_BLOCK error if it cannot make progress. A timeout operation
will block until the operation is complete or the timeout expires; if the
timeout expires it will return what progress it made, or
%G_IO_ERROR_TIMED_OUT if no progress was made. To know when a call would
successfully run you can call g_datagram_based_condition_check() or
g_datagram_based_condition_wait(). You can also use
g_datagram_based_create_source() and attach it to a #GMainContext to get
callbacks when I/O is possible.

When running a non-blocking operation applications should always be able to
handle getting a %G_IO_ERROR_WOULD_BLOCK error even when some other function
said that I/O was possible. This can easily happen in case of a race
condition in the application, but it can also happen for other reasons. For
instance, on Windows a socket is always seen as writable until a write
returns %G_IO_ERROR_WOULD_BLOCK.

As with #GSocket, #GDatagramBaseds can be either connection oriented (for
example, SCTP) or connectionless (for example, UDP). #GDatagramBaseds must be
datagram-based, not stream-based. The interface does not cover connection
establishment &#x2014; use methods on the underlying type to establish a connection
before sending and receiving data through the #GDatagramBased API. For
connectionless socket types the target/source address is specified or
received in each I/O operation.

Like most other APIs in GLib, #GDatagramBased is not inherently thread safe.
To use a #GDatagramBased concurrently from multiple threads, you must
implement your own locking.</doc>
      <virtual-method name="condition_check" invoker="condition_check" version="2.48">
        <doc xml:space="preserve">Checks on the readiness of @datagram_based to perform operations. The
operations specified in @condition are checked for and masked against the
currently-satisfied conditions on @datagram_based. The result is returned.

%G_IO_IN will be set in the return value if data is available to read with
g_datagram_based_receive_messages(), or if the connection is closed remotely
(EOS); and if the datagram_based has not been closed locally using some
implementation-specific method (such as g_socket_close() or
g_socket_shutdown() with @shutdown_read set, if it&#x2019;s a #GSocket).

If the connection is shut down or closed (by calling g_socket_close() or
g_socket_shutdown() with @shutdown_read set, if it&#x2019;s a #GSocket, for
example), all calls to this function will return %G_IO_ERROR_CLOSED.

%G_IO_OUT will be set if it is expected that at least one byte can be sent
using g_datagram_based_send_messages() without blocking. It will not be set
if the datagram_based has been closed locally.

%G_IO_HUP will be set if the connection has been closed locally.

%G_IO_ERR will be set if there was an asynchronous error in transmitting data
previously enqueued using g_datagram_based_send_messages().

Note that on Windows, it is possible for an operation to return
%G_IO_ERROR_WOULD_BLOCK even immediately after
g_datagram_based_condition_check() has claimed that the #GDatagramBased is
ready for writing. Rather than calling g_datagram_based_condition_check() and
then writing to the #GDatagramBased if it succeeds, it is generally better to
simply try writing right away, and try again later if the initial attempt
returns %G_IO_ERROR_WOULD_BLOCK.

It is meaningless to specify %G_IO_ERR or %G_IO_HUP in @condition; these
conditions will always be set in the output if they are true. Apart from
these flags, the output is guaranteed to be masked by @condition.

This call never blocks.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GIOCondition mask of the current state</doc>
          <type name="GLib.IOCondition" c:type="GIOCondition"/>
        </return-value>
        <parameters>
          <instance-parameter name="datagram_based" transfer-ownership="none">
            <doc xml:space="preserve">a #GDatagramBased</doc>
            <type name="DatagramBased" c:type="GDatagramBased*"/>
          </instance-parameter>
          <parameter name="condition" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOCondition mask to check</doc>
            <type name="GLib.IOCondition" c:type="GIOCondition"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="condition_wait" invoker="condition_wait" version="2.48" throws="1">
        <doc xml:space="preserve">Waits for up to @timeout microseconds for condition to become true on
@datagram_based. If the condition is met, %TRUE is returned.

If @cancellable is cancelled before the condition is met, or if @timeout is
reached before the condition is met, then %FALSE is returned and @error is
set appropriately (%G_IO_ERROR_CANCELLED or %G_IO_ERROR_TIMED_OUT).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the condition was met, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="datagram_based" transfer-ownership="none">
            <doc xml:space="preserve">a #GDatagramBased</doc>
            <type name="DatagramBased" c:type="GDatagramBased*"/>
          </instance-parameter>
          <parameter name="condition" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOCondition mask to wait for</doc>
            <type name="GLib.IOCondition" c:type="GIOCondition"/>
          </parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:space="preserve">the maximum time (in microseconds) to wait, 0 to not block, or -1
  to block indefinitely</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_source" invoker="create_source" version="2.48">
        <doc xml:space="preserve">Creates a #GSource that can be attached to a #GMainContext to monitor for
the availability of the specified @condition on the #GDatagramBased. The
#GSource keeps a reference to the @datagram_based.

The callback on the source is of the #GDatagramBasedSourceFunc type.

It is meaningless to specify %G_IO_ERR or %G_IO_HUP in @condition; these
conditions will always be reported in the callback if they are true.

If non-%NULL, @cancellable can be used to cancel the source, which will
cause the source to trigger, reporting the current condition (which is
likely 0 unless cancellation happened at the same time as a condition
change). You can check for this in the callback using
g_cancellable_is_cancelled().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #GSource</doc>
          <type name="GLib.Source" c:type="GSource*"/>
        </return-value>
        <parameters>
          <instance-parameter name="datagram_based" transfer-ownership="none">
            <doc xml:space="preserve">a #GDatagramBased</doc>
            <type name="DatagramBased" c:type="GDatagramBased*"/>
          </instance-parameter>
          <parameter name="condition" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOCondition mask to monitor</doc>
            <type name="GLib.IOCondition" c:type="GIOCondition"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="receive_messages" invoker="receive_messages" version="2.48" throws="1">
        <doc xml:space="preserve">Receive one or more data messages from @datagram_based in one go.

@messages must point to an array of #GInputMessage structs and
@num_messages must be the length of this array. Each #GInputMessage
contains a pointer to an array of #GInputVector structs describing the
buffers that the data received in each message will be written to.

@flags modify how all messages are received. The commonly available
arguments for this are available in the #GSocketMsgFlags enum, but the
values there are the same as the system values, and the flags
are passed in as-is, so you can pass in system-specific flags too. These
flags affect the overall receive operation. Flags affecting individual
messages are returned in #GInputMessage.flags.

The other members of #GInputMessage are treated as described in its
documentation.

If @timeout is negative the call will block until @num_messages have been
received, the connection is closed remotely (EOS), @cancellable is cancelled,
or an error occurs.

If @timeout is 0 the call will return up to @num_messages without blocking,
or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the operating system
to be received.

If @timeout is positive the call will block on the same conditions as if
@timeout were negative. If the timeout is reached
before any messages are received, %G_IO_ERROR_TIMED_OUT is returned,
otherwise it will return the number of messages received before timing out.
(Note: This is effectively the behaviour of `MSG_WAITFORONE` with
recvmmsg().)

To be notified when messages are available, wait for the %G_IO_IN condition.
Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
g_datagram_based_receive_messages() even if you were previously notified of a
%G_IO_IN condition.

If the remote peer closes the connection, any messages queued in the
underlying receive buffer will be returned, and subsequent calls to
g_datagram_based_receive_messages() will return 0 (with no error set).

If the connection is shut down or closed (by calling g_socket_close() or
g_socket_shutdown() with @shutdown_read set, if it&#x2019;s a #GSocket, for
example), all calls to this function will return %G_IO_ERROR_CLOSED.

On error -1 is returned and @error is set accordingly. An error will only
be returned if zero messages could be received; otherwise the number of
messages successfully received before the error will be returned. If
@cancellable is cancelled, %G_IO_ERROR_CANCELLED is returned as with any
other error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">number of messages received, or -1 on error. Note that the number
    of messages received may be smaller than @num_messages if @timeout is
    zero or positive, if the peer closed the connection, or if @num_messages
    was larger than `UIO_MAXIOV` (1024), in which case the caller may re-try
    to receive the remaining messages.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="datagram_based" transfer-ownership="none">
            <doc xml:space="preserve">a #GDatagramBased</doc>
            <type name="DatagramBased" c:type="GDatagramBased*"/>
          </instance-parameter>
          <parameter name="messages" transfer-ownership="none">
            <doc xml:space="preserve">an array of #GInputMessage structs</doc>
            <array length="1" zero-terminated="0" c:type="GInputMessage*">
              <type name="InputMessage" c:type="GInputMessage"/>
            </array>
          </parameter>
          <parameter name="num_messages" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements in @messages</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">an int containing #GSocketMsgFlags flags for the overall operation</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:space="preserve">the maximum time (in microseconds) to wait, 0 to not block, or -1
  to block indefinitely</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a %GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="send_messages" invoker="send_messages" version="2.48" throws="1">
        <doc xml:space="preserve">Send one or more data messages from @datagram_based in one go.

@messages must point to an array of #GOutputMessage structs and
@num_messages must be the length of this array. Each #GOutputMessage
contains an address to send the data to, and a pointer to an array of
#GOutputVector structs to describe the buffers that the data to be sent
for each message will be gathered from.

@flags modify how the message is sent. The commonly available arguments
for this are available in the #GSocketMsgFlags enum, but the
values there are the same as the system values, and the flags
are passed in as-is, so you can pass in system-specific flags too.

The other members of #GOutputMessage are treated as described in its
documentation.

If @timeout is negative the call will block until @num_messages have been
sent, @cancellable is cancelled, or an error occurs.

If @timeout is 0 the call will send up to @num_messages without blocking,
or will return %G_IO_ERROR_WOULD_BLOCK if there is no space to send messages.

If @timeout is positive the call will block on the same conditions as if
@timeout were negative. If the timeout is reached before any messages are
sent, %G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the number
of messages sent before timing out.

To be notified when messages can be sent, wait for the %G_IO_OUT condition.
Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
g_datagram_based_send_messages() even if you were previously notified of a
%G_IO_OUT condition. (On Windows in particular, this is very common due to
the way the underlying APIs work.)

If the connection is shut down or closed (by calling g_socket_close() or
g_socket_shutdown() with @shutdown_write set, if it&#x2019;s a #GSocket, for
example), all calls to this function will return %G_IO_ERROR_CLOSED.

On error -1 is returned and @error is set accordingly. An error will only
be returned if zero messages could be sent; otherwise the number of messages
successfully sent before the error will be returned. If @cancellable is
cancelled, %G_IO_ERROR_CANCELLED is returned as with any other error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">number of messages sent, or -1 on error. Note that the number of
    messages sent may be smaller than @num_messages if @timeout is zero
    or positive, or if @num_messages was larger than `UIO_MAXIOV` (1024), in
    which case the caller may re-try to send the remaining messages.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="datagram_based" transfer-ownership="none">
            <doc xml:space="preserve">a #GDatagramBased</doc>
            <type name="DatagramBased" c:type="GDatagramBased*"/>
          </instance-parameter>
          <parameter name="messages" transfer-ownership="none">
            <doc xml:space="preserve">an array of #GOutputMessage structs</doc>
            <array length="1" zero-terminated="0" c:type="GOutputMessage*">
              <type name="OutputMessage" c:type="GOutputMessage"/>
            </array>
          </parameter>
          <parameter name="num_messages" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements in @messages</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">an int containing #GSocketMsgFlags flags</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:space="preserve">the maximum time (in microseconds) to wait, 0 to not block, or -1
  to block indefinitely</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a %GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="condition_check" c:identifier="g_datagram_based_condition_check" version="2.48">
        <doc xml:space="preserve">Checks on the readiness of @datagram_based to perform operations. The
operations specified in @condition are checked for and masked against the
currently-satisfied conditions on @datagram_based. The result is returned.

%G_IO_IN will be set in the return value if data is available to read with
g_datagram_based_receive_messages(), or if the connection is closed remotely
(EOS); and if the datagram_based has not been closed locally using some
implementation-specific method (such as g_socket_close() or
g_socket_shutdown() with @shutdown_read set, if it&#x2019;s a #GSocket).

If the connection is shut down or closed (by calling g_socket_close() or
g_socket_shutdown() with @shutdown_read set, if it&#x2019;s a #GSocket, for
example), all calls to this function will return %G_IO_ERROR_CLOSED.

%G_IO_OUT will be set if it is expected that at least one byte can be sent
using g_datagram_based_send_messages() without blocking. It will not be set
if the datagram_based has been closed locally.

%G_IO_HUP will be set if the connection has been closed locally.

%G_IO_ERR will be set if there was an asynchronous error in transmitting data
previously enqueued using g_datagram_based_send_messages().

Note that on Windows, it is possible for an operation to return
%G_IO_ERROR_WOULD_BLOCK even immediately after
g_datagram_based_condition_check() has claimed that the #GDatagramBased is
ready for writing. Rather than calling g_datagram_based_condition_check() and
then writing to the #GDatagramBased if it succeeds, it is generally better to
simply try writing right away, and try again later if the initial attempt
returns %G_IO_ERROR_WOULD_BLOCK.

It is meaningless to specify %G_IO_ERR or %G_IO_HUP in @condition; these
conditions will always be set in the output if they are true. Apart from
these flags, the output is guaranteed to be masked by @condition.

This call never blocks.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GIOCondition mask of the current state</doc>
          <type name="GLib.IOCondition" c:type="GIOCondition"/>
        </return-value>
        <parameters>
          <instance-parameter name="datagram_based" transfer-ownership="none">
            <doc xml:space="preserve">a #GDatagramBased</doc>
            <type name="DatagramBased" c:type="GDatagramBased*"/>
          </instance-parameter>
          <parameter name="condition" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOCondition mask to check</doc>
            <type name="GLib.IOCondition" c:type="GIOCondition"/>
          </parameter>
        </parameters>
      </method>
      <method name="condition_wait" c:identifier="g_datagram_based_condition_wait" version="2.48" throws="1">
        <doc xml:space="preserve">Waits for up to @timeout microseconds for condition to become true on
@datagram_based. If the condition is met, %TRUE is returned.

If @cancellable is cancelled before the condition is met, or if @timeout is
reached before the condition is met, then %FALSE is returned and @error is
set appropriately (%G_IO_ERROR_CANCELLED or %G_IO_ERROR_TIMED_OUT).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the condition was met, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="datagram_based" transfer-ownership="none">
            <doc xml:space="preserve">a #GDatagramBased</doc>
            <type name="DatagramBased" c:type="GDatagramBased*"/>
          </instance-parameter>
          <parameter name="condition" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOCondition mask to wait for</doc>
            <type name="GLib.IOCondition" c:type="GIOCondition"/>
          </parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:space="preserve">the maximum time (in microseconds) to wait, 0 to not block, or -1
  to block indefinitely</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_source" c:identifier="g_datagram_based_create_source" version="2.48">
        <doc xml:space="preserve">Creates a #GSource that can be attached to a #GMainContext to monitor for
the availability of the specified @condition on the #GDatagramBased. The
#GSource keeps a reference to the @datagram_based.

The callback on the source is of the #GDatagramBasedSourceFunc type.

It is meaningless to specify %G_IO_ERR or %G_IO_HUP in @condition; these
conditions will always be reported in the callback if they are true.

If non-%NULL, @cancellable can be used to cancel the source, which will
cause the source to trigger, reporting the current condition (which is
likely 0 unless cancellation happened at the same time as a condition
change). You can check for this in the callback using
g_cancellable_is_cancelled().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #GSource</doc>
          <type name="GLib.Source" c:type="GSource*"/>
        </return-value>
        <parameters>
          <instance-parameter name="datagram_based" transfer-ownership="none">
            <doc xml:space="preserve">a #GDatagramBased</doc>
            <type name="DatagramBased" c:type="GDatagramBased*"/>
          </instance-parameter>
          <parameter name="condition" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOCondition mask to monitor</doc>
            <type name="GLib.IOCondition" c:type="GIOCondition"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="receive_messages" c:identifier="g_datagram_based_receive_messages" version="2.48" throws="1">
        <doc xml:space="preserve">Receive one or more data messages from @datagram_based in one go.

@messages must point to an array of #GInputMessage structs and
@num_messages must be the length of this array. Each #GInputMessage
contains a pointer to an array of #GInputVector structs describing the
buffers that the data received in each message will be written to.

@flags modify how all messages are received. The commonly available
arguments for this are available in the #GSocketMsgFlags enum, but the
values there are the same as the system values, and the flags
are passed in as-is, so you can pass in system-specific flags too. These
flags affect the overall receive operation. Flags affecting individual
messages are returned in #GInputMessage.flags.

The other members of #GInputMessage are treated as described in its
documentation.

If @timeout is negative the call will block until @num_messages have been
received, the connection is closed remotely (EOS), @cancellable is cancelled,
or an error occurs.

If @timeout is 0 the call will return up to @num_messages without blocking,
or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the operating system
to be received.

If @timeout is positive the call will block on the same conditions as if
@timeout were negative. If the timeout is reached
before any messages are received, %G_IO_ERROR_TIMED_OUT is returned,
otherwise it will return the number of messages received before timing out.
(Note: This is effectively the behaviour of `MSG_WAITFORONE` with
recvmmsg().)

To be notified when messages are available, wait for the %G_IO_IN condition.
Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
g_datagram_based_receive_messages() even if you were previously notified of a
%G_IO_IN condition.

If the remote peer closes the connection, any messages queued in the
underlying receive buffer will be returned, and subsequent calls to
g_datagram_based_receive_messages() will return 0 (with no error set).

If the connection is shut down or closed (by calling g_socket_close() or
g_socket_shutdown() with @shutdown_read set, if it&#x2019;s a #GSocket, for
example), all calls to this function will return %G_IO_ERROR_CLOSED.

On error -1 is returned and @error is set accordingly. An error will only
be returned if zero messages could be received; otherwise the number of
messages successfully received before the error will be returned. If
@cancellable is cancelled, %G_IO_ERROR_CANCELLED is returned as with any
other error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">number of messages received, or -1 on error. Note that the number
    of messages received may be smaller than @num_messages if @timeout is
    zero or positive, if the peer closed the connection, or if @num_messages
    was larger than `UIO_MAXIOV` (1024), in which case the caller may re-try
    to receive the remaining messages.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="datagram_based" transfer-ownership="none">
            <doc xml:space="preserve">a #GDatagramBased</doc>
            <type name="DatagramBased" c:type="GDatagramBased*"/>
          </instance-parameter>
          <parameter name="messages" transfer-ownership="none">
            <doc xml:space="preserve">an array of #GInputMessage structs</doc>
            <array length="1" zero-terminated="0" c:type="GInputMessage*">
              <type name="InputMessage" c:type="GInputMessage"/>
            </array>
          </parameter>
          <parameter name="num_messages" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements in @messages</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">an int containing #GSocketMsgFlags flags for the overall operation</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:space="preserve">the maximum time (in microseconds) to wait, 0 to not block, or -1
  to block indefinitely</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a %GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_messages" c:identifier="g_datagram_based_send_messages" version="2.48" throws="1">
        <doc xml:space="preserve">Send one or more data messages from @datagram_based in one go.

@messages must point to an array of #GOutputMessage structs and
@num_messages must be the length of this array. Each #GOutputMessage
contains an address to send the data to, and a pointer to an array of
#GOutputVector structs to describe the buffers that the data to be sent
for each message will be gathered from.

@flags modify how the message is sent. The commonly available arguments
for this are available in the #GSocketMsgFlags enum, but the
values there are the same as the system values, and the flags
are passed in as-is, so you can pass in system-specific flags too.

The other members of #GOutputMessage are treated as described in its
documentation.

If @timeout is negative the call will block until @num_messages have been
sent, @cancellable is cancelled, or an error occurs.

If @timeout is 0 the call will send up to @num_messages without blocking,
or will return %G_IO_ERROR_WOULD_BLOCK if there is no space to send messages.

If @timeout is positive the call will block on the same conditions as if
@timeout were negative. If the timeout is reached before any messages are
sent, %G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the number
of messages sent before timing out.

To be notified when messages can be sent, wait for the %G_IO_OUT condition.
Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
g_datagram_based_send_messages() even if you were previously notified of a
%G_IO_OUT condition. (On Windows in particular, this is very common due to
the way the underlying APIs work.)

If the connection is shut down or closed (by calling g_socket_close() or
g_socket_shutdown() with @shutdown_write set, if it&#x2019;s a #GSocket, for
example), all calls to this function will return %G_IO_ERROR_CLOSED.

On error -1 is returned and @error is set accordingly. An error will only
be returned if zero messages could be sent; otherwise the number of messages
successfully sent before the error will be returned. If @cancellable is
cancelled, %G_IO_ERROR_CANCELLED is returned as with any other error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">number of messages sent, or -1 on error. Note that the number of
    messages sent may be smaller than @num_messages if @timeout is zero
    or positive, or if @num_messages was larger than `UIO_MAXIOV` (1024), in
    which case the caller may re-try to send the remaining messages.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="datagram_based" transfer-ownership="none">
            <doc xml:space="preserve">a #GDatagramBased</doc>
            <type name="DatagramBased" c:type="GDatagramBased*"/>
          </instance-parameter>
          <parameter name="messages" transfer-ownership="none">
            <doc xml:space="preserve">an array of #GOutputMessage structs</doc>
            <array length="1" zero-terminated="0" c:type="GOutputMessage*">
              <type name="OutputMessage" c:type="GOutputMessage"/>
            </array>
          </parameter>
          <parameter name="num_messages" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements in @messages</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">an int containing #GSocketMsgFlags flags</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:space="preserve">the maximum time (in microseconds) to wait, 0 to not block, or -1
  to block indefinitely</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a %GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="DatagramBasedInterface" c:type="GDatagramBasedInterface" glib:is-gtype-struct-for="DatagramBased" version="2.48">
      <doc xml:space="preserve">Provides an interface for socket-like objects which have datagram semantics,
following the Berkeley sockets API. The interface methods are thin wrappers
around the corresponding virtual methods, and no pre-processing of inputs is
implemented &#x2014; so implementations of this API must handle all functionality
documented in the interface methods.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="receive_messages">
        <callback name="receive_messages" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">number of messages received, or -1 on error. Note that the number
    of messages received may be smaller than @num_messages if @timeout is
    zero or positive, if the peer closed the connection, or if @num_messages
    was larger than `UIO_MAXIOV` (1024), in which case the caller may re-try
    to receive the remaining messages.</doc>
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="datagram_based" transfer-ownership="none">
              <doc xml:space="preserve">a #GDatagramBased</doc>
              <type name="DatagramBased" c:type="GDatagramBased*"/>
            </parameter>
            <parameter name="messages" transfer-ownership="none">
              <doc xml:space="preserve">an array of #GInputMessage structs</doc>
              <array length="2" zero-terminated="0" c:type="GInputMessage*">
                <type name="InputMessage" c:type="GInputMessage"/>
              </array>
            </parameter>
            <parameter name="num_messages" transfer-ownership="none">
              <doc xml:space="preserve">the number of elements in @messages</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">an int containing #GSocketMsgFlags flags for the overall operation</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="timeout" transfer-ownership="none">
              <doc xml:space="preserve">the maximum time (in microseconds) to wait, 0 to not block, or -1
  to block indefinitely</doc>
              <type name="gint64" c:type="gint64"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a %GCancellable</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="send_messages">
        <callback name="send_messages" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">number of messages sent, or -1 on error. Note that the number of
    messages sent may be smaller than @num_messages if @timeout is zero
    or positive, or if @num_messages was larger than `UIO_MAXIOV` (1024), in
    which case the caller may re-try to send the remaining messages.</doc>
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="datagram_based" transfer-ownership="none">
              <doc xml:space="preserve">a #GDatagramBased</doc>
              <type name="DatagramBased" c:type="GDatagramBased*"/>
            </parameter>
            <parameter name="messages" transfer-ownership="none">
              <doc xml:space="preserve">an array of #GOutputMessage structs</doc>
              <array length="2" zero-terminated="0" c:type="GOutputMessage*">
                <type name="OutputMessage" c:type="GOutputMessage"/>
              </array>
            </parameter>
            <parameter name="num_messages" transfer-ownership="none">
              <doc xml:space="preserve">the number of elements in @messages</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">an int containing #GSocketMsgFlags flags</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="timeout" transfer-ownership="none">
              <doc xml:space="preserve">the maximum time (in microseconds) to wait, 0 to not block, or -1
  to block indefinitely</doc>
              <type name="gint64" c:type="gint64"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a %GCancellable</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_source">
        <callback name="create_source">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a newly allocated #GSource</doc>
            <type name="GLib.Source" c:type="GSource*"/>
          </return-value>
          <parameters>
            <parameter name="datagram_based" transfer-ownership="none">
              <doc xml:space="preserve">a #GDatagramBased</doc>
              <type name="DatagramBased" c:type="GDatagramBased*"/>
            </parameter>
            <parameter name="condition" transfer-ownership="none">
              <doc xml:space="preserve">a #GIOCondition mask to monitor</doc>
              <type name="GLib.IOCondition" c:type="GIOCondition"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="condition_check">
        <callback name="condition_check">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the #GIOCondition mask of the current state</doc>
            <type name="GLib.IOCondition" c:type="GIOCondition"/>
          </return-value>
          <parameters>
            <parameter name="datagram_based" transfer-ownership="none">
              <doc xml:space="preserve">a #GDatagramBased</doc>
              <type name="DatagramBased" c:type="GDatagramBased*"/>
            </parameter>
            <parameter name="condition" transfer-ownership="none">
              <doc xml:space="preserve">a #GIOCondition mask to check</doc>
              <type name="GLib.IOCondition" c:type="GIOCondition"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="condition_wait">
        <callback name="condition_wait" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the condition was met, %FALSE otherwise</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="datagram_based" transfer-ownership="none">
              <doc xml:space="preserve">a #GDatagramBased</doc>
              <type name="DatagramBased" c:type="GDatagramBased*"/>
            </parameter>
            <parameter name="condition" transfer-ownership="none">
              <doc xml:space="preserve">a #GIOCondition mask to wait for</doc>
              <type name="GLib.IOCondition" c:type="GIOCondition"/>
            </parameter>
            <parameter name="timeout" transfer-ownership="none">
              <doc xml:space="preserve">the maximum time (in microseconds) to wait, 0 to not block, or -1
  to block indefinitely</doc>
              <type name="gint64" c:type="gint64"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <callback name="DatagramBasedSourceFunc" c:type="GDatagramBasedSourceFunc" version="2.48">
      <doc xml:space="preserve">This is the function type of the callback used for the #GSource
returned by g_datagram_based_create_source().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%G_SOURCE_REMOVE if the source should be removed,
  %G_SOURCE_CONTINUE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="datagram_based" transfer-ownership="none">
          <doc xml:space="preserve">the #GDatagramBased</doc>
          <type name="DatagramBased" c:type="GDatagramBased*"/>
        </parameter>
        <parameter name="condition" transfer-ownership="none">
          <doc xml:space="preserve">the current condition at the source fired</doc>
          <type name="GLib.IOCondition" c:type="GIOCondition"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">data passed in by the user</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="DesktopAppInfo" c:symbol-prefix="desktop_app_info" c:type="GDesktopAppInfo" parent="GObject.Object" glib:type-name="GDesktopAppInfo" glib:get-type="g_desktop_app_info_get_type" glib:type-struct="DesktopAppInfoClass">
      <doc xml:space="preserve">#GDesktopAppInfo is an implementation of #GAppInfo based on
desktop files.

Note that `&lt;gio/gdesktopappinfo.h&gt;` belongs to the UNIX-specific
GIO interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
file when using it.</doc>
      <implements name="AppInfo"/>
      <constructor name="new" c:identifier="g_desktop_app_info_new">
        <doc xml:space="preserve">Creates a new #GDesktopAppInfo based on a desktop file id.

A desktop file id is the basename of the desktop file, including the
.desktop extension. GIO is looking for a desktop file with this name
in the `applications` subdirectories of the XDG
data directories (i.e. the directories specified in the `XDG_DATA_HOME`
and `XDG_DATA_DIRS` environment variables). GIO also supports the
prefix-to-subdirectory mapping that is described in the
[Menu Spec](http://standards.freedesktop.org/menu-spec/latest/)
(i.e. a desktop id of kde-foo.desktop will match
`/usr/share/applications/kde/foo.desktop`).</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #GDesktopAppInfo, or %NULL if no desktop
    file with that id exists.</doc>
          <type name="DesktopAppInfo" c:type="GDesktopAppInfo*"/>
        </return-value>
        <parameters>
          <parameter name="desktop_id" transfer-ownership="none">
            <doc xml:space="preserve">the desktop file id</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_filename" c:identifier="g_desktop_app_info_new_from_filename">
        <doc xml:space="preserve">Creates a new #GDesktopAppInfo.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #GDesktopAppInfo or %NULL on error.</doc>
          <type name="DesktopAppInfo" c:type="GDesktopAppInfo*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">the path of a desktop file, in the GLib
     filename encoding</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_keyfile" c:identifier="g_desktop_app_info_new_from_keyfile" version="2.18">
        <doc xml:space="preserve">Creates a new #GDesktopAppInfo.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #GDesktopAppInfo or %NULL on error.</doc>
          <type name="DesktopAppInfo" c:type="GDesktopAppInfo*"/>
        </return-value>
        <parameters>
          <parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">an opened #GKeyFile</doc>
            <type name="GLib.KeyFile" c:type="GKeyFile*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_implementations" c:identifier="g_desktop_app_info_get_implementations" version="2.42">
        <doc xml:space="preserve">Gets all applications that implement @interface.

An application implements an interface if that interface is listed in
the Implements= line of the desktop file of the application.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a list of #GDesktopAppInfo
objects.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="DesktopAppInfo"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="interface" transfer-ownership="none">
            <doc xml:space="preserve">the name of the interface</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="search" c:identifier="g_desktop_app_info_search">
        <doc xml:space="preserve">Searches desktop files for ones that match @search_string.

The return value is an array of strvs.  Each strv contains a list of
applications that matched @search_string with an equal score.  The
outer list is sorted by score so that the first strv contains the
best-matching applications, and so on.
The algorithm for determining matches is undefined and may change at
any time.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a
  list of strvs.  Free each item with g_strfreev() and free the outer
  list with g_free().</doc>
          <array c:type="gchar***">
            <array>
              <type name="utf8"/>
            </array>
          </array>
        </return-value>
        <parameters>
          <parameter name="search_string" transfer-ownership="none">
            <doc xml:space="preserve">the search string to use</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="set_desktop_env" c:identifier="g_desktop_app_info_set_desktop_env" deprecated="1" deprecated-version="2.42">
        <doc xml:space="preserve">Sets the name of the desktop that the application is running in.
This is used by g_app_info_should_show() and
g_desktop_app_info_get_show_in() to evaluate the
`OnlyShowIn` and `NotShowIn`
desktop entry fields.

Should be called only once; subsequent calls are ignored.</doc>
        <doc-deprecated xml:space="preserve">do not use this API.  Since 2.42 the value of the
`XDG_CURRENT_DESKTOP` environment variable will be used.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="desktop_env" transfer-ownership="none">
            <doc xml:space="preserve">a string specifying what desktop this is</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_action_name" c:identifier="g_desktop_app_info_get_action_name" version="2.38">
        <doc xml:space="preserve">Gets the user-visible display name of the "additional application
action" specified by @action_name.

This corresponds to the "Name" key within the keyfile group for the
action.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the locale-specific action name</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GDesktopAppInfo</doc>
            <type name="DesktopAppInfo" c:type="GDesktopAppInfo*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action as from
  g_desktop_app_info_list_actions()</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_boolean" c:identifier="g_desktop_app_info_get_boolean" version="2.36">
        <doc xml:space="preserve">Looks up a boolean value in the keyfile backing @info.

The @key is looked up in the "Desktop Entry" group.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the boolean value, or %FALSE if the key
    is not found</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GDesktopAppInfo</doc>
            <type name="DesktopAppInfo" c:type="GDesktopAppInfo*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to look up</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_categories" c:identifier="g_desktop_app_info_get_categories">
        <doc xml:space="preserve">Gets the categories from the desktop file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The unparsed Categories key from the desktop file;
    i.e. no attempt is made to split it by ';' or validate it.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GDesktopAppInfo</doc>
            <type name="DesktopAppInfo" c:type="GDesktopAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_filename" c:identifier="g_desktop_app_info_get_filename" version="2.24">
        <doc xml:space="preserve">When @info was created from a known filename, return it.  In some
situations such as the #GDesktopAppInfo returned from
g_desktop_app_info_new_from_keyfile(), this function will return %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The full path to the file for @info,
    or %NULL if not known.</doc>
          <type name="filename" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GDesktopAppInfo</doc>
            <type name="DesktopAppInfo" c:type="GDesktopAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_generic_name" c:identifier="g_desktop_app_info_get_generic_name">
        <doc xml:space="preserve">Gets the generic name from the destkop file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value of the GenericName key</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GDesktopAppInfo</doc>
            <type name="DesktopAppInfo" c:type="GDesktopAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_hidden" c:identifier="g_desktop_app_info_get_is_hidden">
        <doc xml:space="preserve">A desktop file is hidden if the Hidden key in it is
set to True.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if hidden, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GDesktopAppInfo.</doc>
            <type name="DesktopAppInfo" c:type="GDesktopAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_keywords" c:identifier="g_desktop_app_info_get_keywords" version="2.32">
        <doc xml:space="preserve">Gets the keywords from the desktop file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value of the Keywords key</doc>
          <array c:type="const char* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GDesktopAppInfo</doc>
            <type name="DesktopAppInfo" c:type="GDesktopAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_locale_string" c:identifier="g_desktop_app_info_get_locale_string" version="2.56">
        <doc xml:space="preserve">Looks up a localized string value in the keyfile backing @info
translated to the current locale.

The @key is looked up in the "Desktop Entry" group.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a newly allocated string, or %NULL if the key
    is not found</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GDesktopAppInfo</doc>
            <type name="DesktopAppInfo" c:type="GDesktopAppInfo*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to look up</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_nodisplay" c:identifier="g_desktop_app_info_get_nodisplay" version="2.30">
        <doc xml:space="preserve">Gets the value of the NoDisplay key, which helps determine if the
application info should be shown in menus. See
#G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY and g_app_info_should_show().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value of the NoDisplay key</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GDesktopAppInfo</doc>
            <type name="DesktopAppInfo" c:type="GDesktopAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_show_in" c:identifier="g_desktop_app_info_get_show_in" version="2.30">
        <doc xml:space="preserve">Checks if the application info should be shown in menus that list available
applications for a specific name of the desktop, based on the
`OnlyShowIn` and `NotShowIn` keys.

@desktop_env should typically be given as %NULL, in which case the
`XDG_CURRENT_DESKTOP` environment variable is consulted.  If you want
to override the default mechanism then you may specify @desktop_env,
but this is not recommended.

Note that g_app_info_should_show() for @info will include this check (with
%NULL for @desktop_env) as well as additional checks.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @info should be shown in @desktop_env according to the
`OnlyShowIn` and `NotShowIn` keys, %FALSE
otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GDesktopAppInfo</doc>
            <type name="DesktopAppInfo" c:type="GDesktopAppInfo*"/>
          </instance-parameter>
          <parameter name="desktop_env" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a string specifying a desktop name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_startup_wm_class" c:identifier="g_desktop_app_info_get_startup_wm_class" version="2.34">
        <doc xml:space="preserve">Retrieves the StartupWMClass field from @info. This represents the
WM_CLASS property of the main window of the application, if launched
through @info.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the startup WM class, or %NULL if none is set
in the desktop file.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GDesktopAppInfo that supports startup notify</doc>
            <type name="DesktopAppInfo" c:type="GDesktopAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_string" c:identifier="g_desktop_app_info_get_string" version="2.36">
        <doc xml:space="preserve">Looks up a string value in the keyfile backing @info.

The @key is looked up in the "Desktop Entry" group.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string, or %NULL if the key
    is not found</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GDesktopAppInfo</doc>
            <type name="DesktopAppInfo" c:type="GDesktopAppInfo*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to look up</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_key" c:identifier="g_desktop_app_info_has_key" version="2.36">
        <doc xml:space="preserve">Returns whether @key exists in the "Desktop Entry" group
of the keyfile backing @info.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @key exists</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GDesktopAppInfo</doc>
            <type name="DesktopAppInfo" c:type="GDesktopAppInfo*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to look up</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="launch_action" c:identifier="g_desktop_app_info_launch_action" version="2.38">
        <doc xml:space="preserve">Activates the named application action.

You may only call this function on action names that were
returned from g_desktop_app_info_list_actions().

Note that if the main entry of the desktop file indicates that the
application supports startup notification, and @launch_context is
non-%NULL, then startup notification will be used when activating the
action (and as such, invocation of the action on the receiving side
must signal the end of startup notification when it is completed).
This is the expected behaviour of applications declaring additional
actions, as per the desktop file specification.

As with g_app_info_launch() there is no way to detect failures that
occur while using this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GDesktopAppInfo</doc>
            <type name="DesktopAppInfo" c:type="GDesktopAppInfo*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action as from
  g_desktop_app_info_list_actions()</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="launch_context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GAppLaunchContext</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </parameter>
        </parameters>
      </method>
      <method name="launch_uris_as_manager" c:identifier="g_desktop_app_info_launch_uris_as_manager" throws="1">
        <doc xml:space="preserve">This function performs the equivalent of g_app_info_launch_uris(),
but is intended primarily for operating system components that
launch applications.  Ordinary applications should use
g_app_info_launch_uris().

If the application is launched via GSpawn, then @spawn_flags, @user_setup
and @user_setup_data are used for the call to g_spawn_async().
Additionally, @pid_callback (with @pid_callback_data) will be called to
inform about the PID of the created process. See g_spawn_async_with_pipes()
for information on certain parameter conditions that can enable an
optimized posix_spawn() codepath to be used.

If application launching occurs via some other mechanism (eg: D-Bus
activation) then @spawn_flags, @user_setup, @user_setup_data,
@pid_callback and @pid_callback_data are ignored.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on successful launch, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GDesktopAppInfo</doc>
            <type name="DesktopAppInfo" c:type="GDesktopAppInfo*"/>
          </instance-parameter>
          <parameter name="uris" transfer-ownership="none">
            <doc xml:space="preserve">List of URIs</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="launch_context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GAppLaunchContext</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </parameter>
          <parameter name="spawn_flags" transfer-ownership="none">
            <doc xml:space="preserve">#GSpawnFlags, used for each process</doc>
            <type name="GLib.SpawnFlags" c:type="GSpawnFlags"/>
          </parameter>
          <parameter name="user_setup" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GSpawnChildSetupFunc, used once
    for each process.</doc>
            <type name="GLib.SpawnChildSetupFunc" c:type="GSpawnChildSetupFunc"/>
          </parameter>
          <parameter name="user_setup_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">User data for @user_setup</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="pid_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="6">
            <doc xml:space="preserve">Callback for child processes</doc>
            <type name="DesktopAppLaunchCallback" c:type="GDesktopAppLaunchCallback"/>
          </parameter>
          <parameter name="pid_callback_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
            <doc xml:space="preserve">User data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="launch_uris_as_manager_with_fds" c:identifier="g_desktop_app_info_launch_uris_as_manager_with_fds" version="2.58" throws="1">
        <doc xml:space="preserve">Equivalent to g_desktop_app_info_launch_uris_as_manager() but allows
you to pass in file descriptors for the stdin, stdout and stderr streams
of the launched process.

If application launching occurs via some non-spawn mechanism (e.g. D-Bus
activation) then @stdin_fd, @stdout_fd and @stderr_fd are ignored.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on successful launch, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GDesktopAppInfo</doc>
            <type name="DesktopAppInfo" c:type="GDesktopAppInfo*"/>
          </instance-parameter>
          <parameter name="uris" transfer-ownership="none">
            <doc xml:space="preserve">List of URIs</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="launch_context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GAppLaunchContext</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </parameter>
          <parameter name="spawn_flags" transfer-ownership="none">
            <doc xml:space="preserve">#GSpawnFlags, used for each process</doc>
            <type name="GLib.SpawnFlags" c:type="GSpawnFlags"/>
          </parameter>
          <parameter name="user_setup" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GSpawnChildSetupFunc, used once
    for each process.</doc>
            <type name="GLib.SpawnChildSetupFunc" c:type="GSpawnChildSetupFunc"/>
          </parameter>
          <parameter name="user_setup_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">User data for @user_setup</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="pid_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="6">
            <doc xml:space="preserve">Callback for child processes</doc>
            <type name="DesktopAppLaunchCallback" c:type="GDesktopAppLaunchCallback"/>
          </parameter>
          <parameter name="pid_callback_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
            <doc xml:space="preserve">User data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="stdin_fd" transfer-ownership="none">
            <doc xml:space="preserve">file descriptor to use for child's stdin, or -1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="stdout_fd" transfer-ownership="none">
            <doc xml:space="preserve">file descriptor to use for child's stdout, or -1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="stderr_fd" transfer-ownership="none">
            <doc xml:space="preserve">file descriptor to use for child's stderr, or -1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_actions" c:identifier="g_desktop_app_info_list_actions" version="2.38">
        <doc xml:space="preserve">Returns the list of "additional application actions" supported on the
desktop file, as per the desktop file specification.

As per the specification, this is the list of actions that are
explicitly listed in the "Actions" key of the [Desktop Entry] group.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a list of strings, always non-%NULL</doc>
          <array c:type="const gchar* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GDesktopAppInfo</doc>
            <type name="DesktopAppInfo" c:type="GDesktopAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="filename" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The origin filename of this #GDesktopAppInfo</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
    </class>
    <record name="DesktopAppInfoClass" c:type="GDesktopAppInfoClass" glib:is-gtype-struct-for="DesktopAppInfo">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <interface name="DesktopAppInfoLookup" c:symbol-prefix="desktop_app_info_lookup" c:type="GDesktopAppInfoLookup" glib:type-name="GDesktopAppInfoLookup" glib:get-type="g_desktop_app_info_lookup_get_type" glib:type-struct="DesktopAppInfoLookupIface">
      <doc xml:space="preserve">#GDesktopAppInfoLookup is an opaque data structure and can only be accessed
using the following functions.</doc>
      <virtual-method name="get_default_for_uri_scheme" invoker="get_default_for_uri_scheme" deprecated="1">
        <doc xml:space="preserve">Gets the default application for launching applications
using this URI scheme for a particular GDesktopAppInfoLookup
implementation.

The GDesktopAppInfoLookup interface and this function is used
to implement g_app_info_get_default_for_uri_scheme() backends
in a GIO module. There is no reason for applications to use it
directly. Applications should use g_app_info_get_default_for_uri_scheme().</doc>
        <doc-deprecated xml:space="preserve">The #GDesktopAppInfoLookup interface is deprecated and unused by gio.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GAppInfo for given @uri_scheme or %NULL on error.</doc>
          <type name="AppInfo" c:type="GAppInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="lookup" transfer-ownership="none">
            <doc xml:space="preserve">a #GDesktopAppInfoLookup</doc>
            <type name="DesktopAppInfoLookup" c:type="GDesktopAppInfoLookup*"/>
          </instance-parameter>
          <parameter name="uri_scheme" transfer-ownership="none">
            <doc xml:space="preserve">a string containing a URI scheme.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_default_for_uri_scheme" c:identifier="g_desktop_app_info_lookup_get_default_for_uri_scheme" deprecated="1">
        <doc xml:space="preserve">Gets the default application for launching applications
using this URI scheme for a particular GDesktopAppInfoLookup
implementation.

The GDesktopAppInfoLookup interface and this function is used
to implement g_app_info_get_default_for_uri_scheme() backends
in a GIO module. There is no reason for applications to use it
directly. Applications should use g_app_info_get_default_for_uri_scheme().</doc>
        <doc-deprecated xml:space="preserve">The #GDesktopAppInfoLookup interface is deprecated and unused by gio.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GAppInfo for given @uri_scheme or %NULL on error.</doc>
          <type name="AppInfo" c:type="GAppInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="lookup" transfer-ownership="none">
            <doc xml:space="preserve">a #GDesktopAppInfoLookup</doc>
            <type name="DesktopAppInfoLookup" c:type="GDesktopAppInfoLookup*"/>
          </instance-parameter>
          <parameter name="uri_scheme" transfer-ownership="none">
            <doc xml:space="preserve">a string containing a URI scheme.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="DesktopAppInfoLookupIface" c:type="GDesktopAppInfoLookupIface" glib:is-gtype-struct-for="DesktopAppInfoLookup">
      <doc xml:space="preserve">Interface that is used by backends to associate default
handlers with URI schemes.</doc>
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_default_for_uri_scheme">
        <callback name="get_default_for_uri_scheme">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">#GAppInfo for given @uri_scheme or %NULL on error.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </return-value>
          <parameters>
            <parameter name="lookup" transfer-ownership="none">
              <doc xml:space="preserve">a #GDesktopAppInfoLookup</doc>
              <type name="DesktopAppInfoLookup" c:type="GDesktopAppInfoLookup*"/>
            </parameter>
            <parameter name="uri_scheme" transfer-ownership="none">
              <doc xml:space="preserve">a string containing a URI scheme.</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <callback name="DesktopAppLaunchCallback" c:type="GDesktopAppLaunchCallback">
      <doc xml:space="preserve">During invocation, g_desktop_app_info_launch_uris_as_manager() may
create one or more child processes.  This callback is invoked once
for each, providing the process ID.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="appinfo" transfer-ownership="none">
          <doc xml:space="preserve">a #GDesktopAppInfo</doc>
          <type name="DesktopAppInfo" c:type="GDesktopAppInfo*"/>
        </parameter>
        <parameter name="pid" transfer-ownership="none">
          <doc xml:space="preserve">Process identifier</doc>
          <type name="GLib.Pid" c:type="GPid"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">User data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <interface name="Drive" c:symbol-prefix="drive" c:type="GDrive" glib:type-name="GDrive" glib:get-type="g_drive_get_type" glib:type-struct="DriveIface">
      <doc xml:space="preserve">#GDrive - this represent a piece of hardware connected to the machine.
It's generally only created for removable hardware or hardware with
removable media.

#GDrive is a container class for #GVolume objects that stem from
the same piece of media. As such, #GDrive abstracts a drive with
(or without) removable media and provides operations for querying
whether media is available, determining whether media change is
automatically detected and ejecting the media.

If the #GDrive reports that media isn't automatically detected, one
can poll for media; typically one should not do this periodically
as a poll for media operation is potententially expensive and may
spin up the drive creating noise.

#GDrive supports starting and stopping drives with authentication
support for the former. This can be used to support a diverse set
of use cases including connecting/disconnecting iSCSI devices,
powering down external disk enclosures and starting/stopping
multi-disk devices such as RAID devices. Note that the actual
semantics and side-effects of starting/stopping a #GDrive may vary
according to implementation. To choose the correct verbs in e.g. a
file manager, use g_drive_get_start_stop_type().

For porting from GnomeVFS note that there is no equivalent of
#GDrive in that API.</doc>
      <virtual-method name="can_eject" invoker="can_eject">
        <doc xml:space="preserve">Checks if a drive can be ejected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @drive can be ejected, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="can_poll_for_media" invoker="can_poll_for_media">
        <doc xml:space="preserve">Checks if a drive can be polled for media changes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @drive can be polled for media changes,
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="can_start" invoker="can_start" version="2.22">
        <doc xml:space="preserve">Checks if a drive can be started.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @drive can be started, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="can_start_degraded" invoker="can_start_degraded" version="2.22">
        <doc xml:space="preserve">Checks if a drive can be started degraded.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @drive can be started degraded, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="can_stop" invoker="can_stop" version="2.22">
        <doc xml:space="preserve">Checks if a drive can be stopped.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @drive can be stopped, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="disconnected">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject" invoker="eject" deprecated="1" deprecated-version="2.22">
        <doc xml:space="preserve">Asynchronously ejects a drive.

When the operation is finished, @callback will be called.
You can then call g_drive_eject_finish() to obtain the
result of the operation.</doc>
        <doc-deprecated xml:space="preserve">Use g_drive_eject_with_operation() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the unmount if required for eject</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_button">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_finish" invoker="eject_finish" deprecated="1" deprecated-version="2.22" throws="1">
        <doc xml:space="preserve">Finishes ejecting a drive.</doc>
        <doc-deprecated xml:space="preserve">Use g_drive_eject_with_operation_finish() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the drive has been ejected successfully,
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_with_operation" invoker="eject_with_operation" version="2.22">
        <doc xml:space="preserve">Ejects a drive. This is an asynchronous operation, and is
finished by calling g_drive_eject_with_operation_finish() with the @drive
and #GAsyncResult data returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the unmount if required for eject</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation or %NULL to avoid
    user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_with_operation_finish" invoker="eject_with_operation_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes ejecting a drive. If any errors occurred during the operation,
@error will be set to contain the errors and %FALSE will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the drive was successfully ejected. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="enumerate_identifiers" invoker="enumerate_identifiers">
        <doc xml:space="preserve">Gets the kinds of identifiers that @drive has.
Use g_drive_get_identifier() to obtain the identifiers
themselves.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a %NULL-terminated
    array of strings containing kinds of identifiers. Use g_strfreev()
    to free.</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_icon" invoker="get_icon">
        <doc xml:space="preserve">Gets the icon for @drive.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GIcon for the @drive.
   Free the returned object with g_object_unref().</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_identifier" invoker="get_identifier">
        <doc xml:space="preserve">Gets the identifier of the given kind for @drive. The only
identifier currently available is
#G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a newly allocated string containing the
    requested identifier, or %NULL if the #GDrive
    doesn't have this kind of identifier.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
          <parameter name="kind" transfer-ownership="none">
            <doc xml:space="preserve">the kind of identifier to return</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_name" invoker="get_name">
        <doc xml:space="preserve">Gets the name of @drive.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a string containing @drive's name. The returned
    string should be freed when no longer needed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_sort_key" invoker="get_sort_key" version="2.32">
        <doc xml:space="preserve">Gets the sort key for @drive, if any.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">Sorting key for @drive or %NULL if no such key is available.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">A #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_start_stop_type" invoker="get_start_stop_type" version="2.22">
        <doc xml:space="preserve">Gets a hint about how a drive can be started/stopped.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A value from the #GDriveStartStopType enumeration.</doc>
          <type name="DriveStartStopType" c:type="GDriveStartStopType"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_symbolic_icon" invoker="get_symbolic_icon" version="2.34">
        <doc xml:space="preserve">Gets the icon for @drive.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">symbolic #GIcon for the @drive.
   Free the returned object with g_object_unref().</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_volumes" invoker="get_volumes">
        <doc xml:space="preserve">Get a list of mountable volumes for @drive.

The returned list should be freed with g_list_free(), after
its elements have been unreffed with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GList containing any #GVolume objects on the given @drive.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Volume"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="has_media" invoker="has_media">
        <doc xml:space="preserve">Checks if the @drive has media. Note that the OS may not be polling
the drive for media changes; see g_drive_is_media_check_automatic()
for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @drive has media, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="has_volumes" invoker="has_volumes">
        <doc xml:space="preserve">Check if @drive has any mountable volumes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @drive contains volumes, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_media_check_automatic" invoker="is_media_check_automatic">
        <doc xml:space="preserve">Checks if @drive is capabable of automatically detecting media changes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @drive is capabable of automatically detecting
    media changes, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_media_removable" invoker="is_media_removable">
        <doc xml:space="preserve">Checks if the @drive supports removable media.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @drive supports removable media, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_removable" invoker="is_removable" version="2.50">
        <doc xml:space="preserve">Checks if the #GDrive and/or its media is considered removable by the user.
See g_drive_is_media_removable().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @drive and/or its media is considered removable, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="poll_for_media" invoker="poll_for_media">
        <doc xml:space="preserve">Asynchronously polls @drive to see if media has been inserted or removed.

When the operation is finished, @callback will be called.
You can then call g_drive_poll_for_media_finish() to obtain the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
            <doc xml:space="preserve">user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="poll_for_media_finish" invoker="poll_for_media_finish" throws="1">
        <doc xml:space="preserve">Finishes an operation started with g_drive_poll_for_media() on a drive.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the drive has been poll_for_mediaed successfully,
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start" invoker="start" version="2.22">
        <doc xml:space="preserve">Asynchronously starts a drive.

When the operation is finished, @callback will be called.
You can then call g_drive_start_finish() to obtain the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the start operation.</doc>
            <type name="DriveStartFlags" c:type="GDriveStartFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation or %NULL to avoid
    user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start_finish" invoker="start_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes starting a drive.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the drive has been started successfully,
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="stop" invoker="stop" version="2.22">
        <doc xml:space="preserve">Asynchronously stops a drive.

When the operation is finished, @callback will be called.
You can then call g_drive_stop_finish() to obtain the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the unmount if required for stopping.</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation or %NULL to avoid
    user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="stop_button">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="stop_finish" invoker="stop_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes stopping a drive.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the drive has been stopped successfully,
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="can_eject" c:identifier="g_drive_can_eject">
        <doc xml:space="preserve">Checks if a drive can be ejected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @drive can be ejected, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="can_poll_for_media" c:identifier="g_drive_can_poll_for_media">
        <doc xml:space="preserve">Checks if a drive can be polled for media changes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @drive can be polled for media changes,
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="can_start" c:identifier="g_drive_can_start" version="2.22">
        <doc xml:space="preserve">Checks if a drive can be started.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @drive can be started, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="can_start_degraded" c:identifier="g_drive_can_start_degraded" version="2.22">
        <doc xml:space="preserve">Checks if a drive can be started degraded.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @drive can be started degraded, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="can_stop" c:identifier="g_drive_can_stop" version="2.22">
        <doc xml:space="preserve">Checks if a drive can be stopped.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @drive can be stopped, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="eject" c:identifier="g_drive_eject" deprecated="1" deprecated-version="2.22">
        <doc xml:space="preserve">Asynchronously ejects a drive.

When the operation is finished, @callback will be called.
You can then call g_drive_eject_finish() to obtain the
result of the operation.</doc>
        <doc-deprecated xml:space="preserve">Use g_drive_eject_with_operation() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the unmount if required for eject</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="eject_finish" c:identifier="g_drive_eject_finish" deprecated="1" deprecated-version="2.22" throws="1">
        <doc xml:space="preserve">Finishes ejecting a drive.</doc>
        <doc-deprecated xml:space="preserve">Use g_drive_eject_with_operation_finish() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the drive has been ejected successfully,
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="eject_with_operation" c:identifier="g_drive_eject_with_operation" version="2.22">
        <doc xml:space="preserve">Ejects a drive. This is an asynchronous operation, and is
finished by calling g_drive_eject_with_operation_finish() with the @drive
and #GAsyncResult data returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the unmount if required for eject</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation or %NULL to avoid
    user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="eject_with_operation_finish" c:identifier="g_drive_eject_with_operation_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes ejecting a drive. If any errors occurred during the operation,
@error will be set to contain the errors and %FALSE will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the drive was successfully ejected. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="enumerate_identifiers" c:identifier="g_drive_enumerate_identifiers">
        <doc xml:space="preserve">Gets the kinds of identifiers that @drive has.
Use g_drive_get_identifier() to obtain the identifiers
themselves.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a %NULL-terminated
    array of strings containing kinds of identifiers. Use g_strfreev()
    to free.</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_icon" c:identifier="g_drive_get_icon">
        <doc xml:space="preserve">Gets the icon for @drive.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GIcon for the @drive.
   Free the returned object with g_object_unref().</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_identifier" c:identifier="g_drive_get_identifier">
        <doc xml:space="preserve">Gets the identifier of the given kind for @drive. The only
identifier currently available is
#G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a newly allocated string containing the
    requested identifier, or %NULL if the #GDrive
    doesn't have this kind of identifier.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
          <parameter name="kind" transfer-ownership="none">
            <doc xml:space="preserve">the kind of identifier to return</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="g_drive_get_name">
        <doc xml:space="preserve">Gets the name of @drive.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a string containing @drive's name. The returned
    string should be freed when no longer needed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sort_key" c:identifier="g_drive_get_sort_key" version="2.32">
        <doc xml:space="preserve">Gets the sort key for @drive, if any.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">Sorting key for @drive or %NULL if no such key is available.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">A #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_start_stop_type" c:identifier="g_drive_get_start_stop_type" version="2.22">
        <doc xml:space="preserve">Gets a hint about how a drive can be started/stopped.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A value from the #GDriveStartStopType enumeration.</doc>
          <type name="DriveStartStopType" c:type="GDriveStartStopType"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_symbolic_icon" c:identifier="g_drive_get_symbolic_icon" version="2.34">
        <doc xml:space="preserve">Gets the icon for @drive.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">symbolic #GIcon for the @drive.
   Free the returned object with g_object_unref().</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_volumes" c:identifier="g_drive_get_volumes">
        <doc xml:space="preserve">Get a list of mountable volumes for @drive.

The returned list should be freed with g_list_free(), after
its elements have been unreffed with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GList containing any #GVolume objects on the given @drive.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Volume"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_media" c:identifier="g_drive_has_media">
        <doc xml:space="preserve">Checks if the @drive has media. Note that the OS may not be polling
the drive for media changes; see g_drive_is_media_check_automatic()
for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @drive has media, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_volumes" c:identifier="g_drive_has_volumes">
        <doc xml:space="preserve">Check if @drive has any mountable volumes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @drive contains volumes, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_media_check_automatic" c:identifier="g_drive_is_media_check_automatic">
        <doc xml:space="preserve">Checks if @drive is capabable of automatically detecting media changes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @drive is capabable of automatically detecting
    media changes, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_media_removable" c:identifier="g_drive_is_media_removable">
        <doc xml:space="preserve">Checks if the @drive supports removable media.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @drive supports removable media, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_removable" c:identifier="g_drive_is_removable" version="2.50">
        <doc xml:space="preserve">Checks if the #GDrive and/or its media is considered removable by the user.
See g_drive_is_media_removable().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @drive and/or its media is considered removable, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="poll_for_media" c:identifier="g_drive_poll_for_media">
        <doc xml:space="preserve">Asynchronously polls @drive to see if media has been inserted or removed.

When the operation is finished, @callback will be called.
You can then call g_drive_poll_for_media_finish() to obtain the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="poll_for_media_finish" c:identifier="g_drive_poll_for_media_finish" throws="1">
        <doc xml:space="preserve">Finishes an operation started with g_drive_poll_for_media() on a drive.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the drive has been poll_for_mediaed successfully,
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="start" c:identifier="g_drive_start" version="2.22">
        <doc xml:space="preserve">Asynchronously starts a drive.

When the operation is finished, @callback will be called.
You can then call g_drive_start_finish() to obtain the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the start operation.</doc>
            <type name="DriveStartFlags" c:type="GDriveStartFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation or %NULL to avoid
    user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="start_finish" c:identifier="g_drive_start_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes starting a drive.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the drive has been started successfully,
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="stop" c:identifier="g_drive_stop" version="2.22">
        <doc xml:space="preserve">Asynchronously stops a drive.

When the operation is finished, @callback will be called.
You can then call g_drive_stop_finish() to obtain the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the unmount if required for stopping.</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation or %NULL to avoid
    user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="stop_finish" c:identifier="g_drive_stop_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes stopping a drive.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the drive has been stopped successfully,
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <glib:signal name="changed" when="last">
        <doc xml:space="preserve">Emitted when the drive's state has changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="disconnected" when="last">
        <doc xml:space="preserve">This signal is emitted when the #GDrive have been
disconnected. If the recipient is holding references to the
object they should release them so the object can be
finalized.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="eject-button" when="last">
        <doc xml:space="preserve">Emitted when the physical eject button (if any) of a drive has
been pressed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="stop-button" when="last" version="2.22">
        <doc xml:space="preserve">Emitted when the physical stop button (if any) of a drive has
been pressed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </interface>
    <record name="DriveIface" c:type="GDriveIface" glib:is-gtype-struct-for="Drive">
      <doc xml:space="preserve">Interface for creating #GDrive implementations.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="changed">
        <callback name="changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="disconnected">
        <callback name="disconnected">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_button">
        <callback name="eject_button">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_name">
        <callback name="get_name">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a string containing @drive's name. The returned
    string should be freed when no longer needed.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_icon">
        <callback name="get_icon">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">#GIcon for the @drive.
   Free the returned object with g_object_unref().</doc>
            <type name="Icon" c:type="GIcon*"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="has_volumes">
        <callback name="has_volumes">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the @drive contains volumes, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_volumes">
        <callback name="get_volumes">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">#GList containing any #GVolume objects on the given @drive.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Volume"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_media_removable">
        <callback name="is_media_removable">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @drive supports removable media, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="has_media">
        <callback name="has_media">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @drive has media, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_media_check_automatic">
        <callback name="is_media_check_automatic">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the @drive is capabable of automatically detecting
    media changes, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_eject">
        <callback name="can_eject">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the @drive can be ejected, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_poll_for_media">
        <callback name="can_poll_for_media">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the @drive can be polled for media changes,
    %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject">
        <callback name="eject">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags affecting the unmount if required for eject</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">user data to pass to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_finish">
        <callback name="eject_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the drive has been ejected successfully,
    %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="poll_for_media">
        <callback name="poll_for_media">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
              <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
              <doc xml:space="preserve">user data to pass to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="poll_for_media_finish">
        <callback name="poll_for_media_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the drive has been poll_for_mediaed successfully,
    %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_identifier">
        <callback name="get_identifier">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">a newly allocated string containing the
    requested identifier, or %NULL if the #GDrive
    doesn't have this kind of identifier.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
            <parameter name="kind" transfer-ownership="none">
              <doc xml:space="preserve">the kind of identifier to return</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="enumerate_identifiers">
        <callback name="enumerate_identifiers">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a %NULL-terminated
    array of strings containing kinds of identifiers. Use g_strfreev()
    to free.</doc>
            <array c:type="char**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_start_stop_type">
        <callback name="get_start_stop_type">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A value from the #GDriveStartStopType enumeration.</doc>
            <type name="DriveStartStopType" c:type="GDriveStartStopType"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_start">
        <callback name="can_start">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the @drive can be started, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_start_degraded">
        <callback name="can_start_degraded">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the @drive can be started degraded, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="start">
        <callback name="start">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags affecting the start operation.</doc>
              <type name="DriveStartFlags" c:type="GDriveStartFlags"/>
            </parameter>
            <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GMountOperation or %NULL to avoid
    user interaction.</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">user data to pass to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="start_finish">
        <callback name="start_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the drive has been started successfully,
    %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_stop">
        <callback name="can_stop">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the @drive can be stopped, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags affecting the unmount if required for stopping.</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GMountOperation or %NULL to avoid
    user interaction.</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">user data to pass to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop_finish">
        <callback name="stop_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the drive has been stopped successfully,
    %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop_button">
        <callback name="stop_button">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_with_operation">
        <callback name="eject_with_operation">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags affecting the unmount if required for eject</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GMountOperation or %NULL to avoid
    user interaction.</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">user data passed to @callback.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_with_operation_finish">
        <callback name="eject_with_operation_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the drive was successfully ejected. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_sort_key">
        <callback name="get_sort_key">
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve">Sorting key for @drive or %NULL if no such key is available.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">A #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_symbolic_icon">
        <callback name="get_symbolic_icon">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">symbolic #GIcon for the @drive.
   Free the returned object with g_object_unref().</doc>
            <type name="Icon" c:type="GIcon*"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_removable">
        <callback name="is_removable">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @drive and/or its media is considered removable, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <doc xml:space="preserve">a #GDrive.</doc>
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <bitfield name="DriveStartFlags" version="2.22" glib:type-name="GDriveStartFlags" glib:get-type="g_drive_start_flags_get_type" c:type="GDriveStartFlags">
      <doc xml:space="preserve">Flags used when starting a drive.</doc>
      <member name="none" value="0" c:identifier="G_DRIVE_START_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
    </bitfield>
    <enumeration name="DriveStartStopType" version="2.22" glib:type-name="GDriveStartStopType" glib:get-type="g_drive_start_stop_type_get_type" c:type="GDriveStartStopType">
      <doc xml:space="preserve">Enumeration describing how a drive can be started/stopped.</doc>
      <member name="unknown" value="0" c:identifier="G_DRIVE_START_STOP_TYPE_UNKNOWN" glib:nick="unknown">
        <doc xml:space="preserve">Unknown or drive doesn't support
   start/stop.</doc>
      </member>
      <member name="shutdown" value="1" c:identifier="G_DRIVE_START_STOP_TYPE_SHUTDOWN" glib:nick="shutdown">
        <doc xml:space="preserve">The stop method will physically
   shut down the drive and e.g. power down the port the drive is
   attached to.</doc>
      </member>
      <member name="network" value="2" c:identifier="G_DRIVE_START_STOP_TYPE_NETWORK" glib:nick="network">
        <doc xml:space="preserve">The start/stop methods are used
   for connecting/disconnect to the drive over the network.</doc>
      </member>
      <member name="multidisk" value="3" c:identifier="G_DRIVE_START_STOP_TYPE_MULTIDISK" glib:nick="multidisk">
        <doc xml:space="preserve">The start/stop methods will
   assemble/disassemble a virtual drive from several physical
   drives.</doc>
      </member>
      <member name="password" value="4" c:identifier="G_DRIVE_START_STOP_TYPE_PASSWORD" glib:nick="password">
        <doc xml:space="preserve">The start/stop methods will
   unlock/lock the disk (for example using the ATA &lt;quote&gt;SECURITY
   UNLOCK DEVICE&lt;/quote&gt; command)</doc>
      </member>
    </enumeration>
    <interface name="DtlsClientConnection" c:symbol-prefix="dtls_client_connection" c:type="GDtlsClientConnection" version="2.48" glib:type-name="GDtlsClientConnection" glib:get-type="g_dtls_client_connection_get_type" glib:type-struct="DtlsClientConnectionInterface">
      <doc xml:space="preserve">#GDtlsClientConnection is the client-side subclass of
#GDtlsConnection, representing a client-side DTLS connection.</doc>
      <prerequisite name="DatagramBased"/>
      <prerequisite name="DtlsConnection"/>
      <function name="new" c:identifier="g_dtls_client_connection_new" version="2.48" throws="1">
        <doc xml:space="preserve">Creates a new #GDtlsClientConnection wrapping @base_socket which is
assumed to communicate with the server identified by @server_identity.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new
  #GDtlsClientConnection, or %NULL on error</doc>
          <type name="DtlsClientConnection" c:type="GDatagramBased*"/>
        </return-value>
        <parameters>
          <parameter name="base_socket" transfer-ownership="none">
            <doc xml:space="preserve">the #GDatagramBased to wrap</doc>
            <type name="DatagramBased" c:type="GDatagramBased*"/>
          </parameter>
          <parameter name="server_identity" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the expected identity of the server</doc>
            <type name="SocketConnectable" c:type="GSocketConnectable*"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_accepted_cas" c:identifier="g_dtls_client_connection_get_accepted_cas" version="2.48">
        <doc xml:space="preserve">Gets the list of distinguished names of the Certificate Authorities
that the server will accept certificates from. This will be set
during the TLS handshake if the server requests a certificate.
Otherwise, it will be %NULL.

Each item in the list is a #GByteArray which contains the complete
subject DN of the certificate authority.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the list of
CA DNs. You should unref each element with g_byte_array_unref() and then
the free the list with g_list_free().</doc>
          <type name="GLib.List" c:type="GList*">
            <array name="GLib.ByteArray">
              <type name="guint8" c:type="guint8"/>
            </array>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">the #GDtlsClientConnection</doc>
            <type name="DtlsClientConnection" c:type="GDtlsClientConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_server_identity" c:identifier="g_dtls_client_connection_get_server_identity" version="2.48">
        <doc xml:space="preserve">Gets @conn's expected server identity</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GSocketConnectable describing the
expected server identity, or %NULL if the expected identity is not
known.</doc>
          <type name="SocketConnectable" c:type="GSocketConnectable*"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">the #GDtlsClientConnection</doc>
            <type name="DtlsClientConnection" c:type="GDtlsClientConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_validation_flags" c:identifier="g_dtls_client_connection_get_validation_flags" version="2.48">
        <doc xml:space="preserve">Gets @conn's validation flags</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the validation flags</doc>
          <type name="TlsCertificateFlags" c:type="GTlsCertificateFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">the #GDtlsClientConnection</doc>
            <type name="DtlsClientConnection" c:type="GDtlsClientConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_server_identity" c:identifier="g_dtls_client_connection_set_server_identity" version="2.48">
        <doc xml:space="preserve">Sets @conn's expected server identity, which is used both to tell
servers on virtual hosts which certificate to present, and also
to let @conn know what name to look for in the certificate when
performing %G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">the #GDtlsClientConnection</doc>
            <type name="DtlsClientConnection" c:type="GDtlsClientConnection*"/>
          </instance-parameter>
          <parameter name="identity" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketConnectable describing the expected server identity</doc>
            <type name="SocketConnectable" c:type="GSocketConnectable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_validation_flags" c:identifier="g_dtls_client_connection_set_validation_flags" version="2.48">
        <doc xml:space="preserve">Sets @conn's validation flags, to override the default set of
checks performed when validating a server certificate. By default,
%G_TLS_CERTIFICATE_VALIDATE_ALL is used.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">the #GDtlsClientConnection</doc>
            <type name="DtlsClientConnection" c:type="GDtlsClientConnection*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">the #GTlsCertificateFlags to use</doc>
            <type name="TlsCertificateFlags" c:type="GTlsCertificateFlags"/>
          </parameter>
        </parameters>
      </method>
      <property name="accepted-cas" version="2.48" transfer-ownership="none">
        <doc xml:space="preserve">A list of the distinguished names of the Certificate Authorities
that the server will accept client certificates signed by. If the
server requests a client certificate during the handshake, then
this property will be set after the handshake completes.

Each item in the list is a #GByteArray which contains the complete
subject DN of the certificate authority.</doc>
        <type name="GLib.List" c:type="gpointer">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </property>
      <property name="server-identity" version="2.48" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">A #GSocketConnectable describing the identity of the server that
is expected on the other end of the connection.

If the %G_TLS_CERTIFICATE_BAD_IDENTITY flag is set in
#GDtlsClientConnection:validation-flags, this object will be used
to determine the expected identify of the remote end of the
connection; if #GDtlsClientConnection:server-identity is not set,
or does not match the identity presented by the server, then the
%G_TLS_CERTIFICATE_BAD_IDENTITY validation will fail.

In addition to its use in verifying the server certificate,
this is also used to give a hint to the server about what
certificate we expect, which is useful for servers that serve
virtual hosts.</doc>
        <type name="SocketConnectable"/>
      </property>
      <property name="validation-flags" version="2.48" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">What steps to perform when validating a certificate received from
a server. Server certificates that fail to validate in all of the
ways indicated here will be rejected unless the application
overrides the default via #GDtlsConnection::accept-certificate.</doc>
        <type name="TlsCertificateFlags"/>
      </property>
    </interface>
    <record name="DtlsClientConnectionInterface" c:type="GDtlsClientConnectionInterface" glib:is-gtype-struct-for="DtlsClientConnection" version="2.48">
      <doc xml:space="preserve">vtable for a #GDtlsClientConnection implementation.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
    </record>
    <interface name="DtlsConnection" c:symbol-prefix="dtls_connection" c:type="GDtlsConnection" version="2.48" glib:type-name="GDtlsConnection" glib:get-type="g_dtls_connection_get_type" glib:type-struct="DtlsConnectionInterface">
      <doc xml:space="preserve">#GDtlsConnection is the base DTLS connection class type, which wraps
a #GDatagramBased and provides DTLS encryption on top of it. Its
subclasses, #GDtlsClientConnection and #GDtlsServerConnection,
implement client-side and server-side DTLS, respectively.

For TLS support, see #GTlsConnection.

As DTLS is datagram based, #GDtlsConnection implements #GDatagramBased,
presenting a datagram-socket-like API for the encrypted connection. This
operates over a base datagram connection, which is also a #GDatagramBased
(#GDtlsConnection:base-socket).

To close a DTLS connection, use g_dtls_connection_close().

Neither #GDtlsServerConnection or #GDtlsClientConnection set the peer address
on their base #GDatagramBased if it is a #GSocket &#x2014; it is up to the caller to
do that if they wish. If they do not, and g_socket_close() is called on the
base socket, the #GDtlsConnection will not raise a %G_IO_ERROR_NOT_CONNECTED
error on further I/O.</doc>
      <prerequisite name="DatagramBased"/>
      <virtual-method name="accept_certificate">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
          <parameter name="peer_cert" transfer-ownership="none">
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
          <parameter name="errors" transfer-ownership="none">
            <type name="TlsCertificateFlags" c:type="GTlsCertificateFlags"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="handshake" invoker="handshake" version="2.48" throws="1">
        <doc xml:space="preserve">Attempts a TLS handshake on @conn.

On the client side, it is never necessary to call this method;
although the connection needs to perform a handshake after
connecting (or after sending a "STARTTLS"-type command) and may
need to rehandshake later if the server requests it,
#GDtlsConnection will handle this for you automatically when you try
to send or receive data on the connection. However, you can call
g_dtls_connection_handshake() manually if you want to know for sure
whether the initial handshake succeeded or failed (as opposed to
just immediately trying to write to @conn, in which
case if it fails, it may not be possible to tell if it failed
before or after completing the handshake).

Likewise, on the server side, although a handshake is necessary at
the beginning of the communication, you do not need to call this
function explicitly unless you want clearer error reporting.
However, you may call g_dtls_connection_handshake() later on to
renegotiate parameters (encryption methods, etc) with the client.

#GDtlsConnection::accept_certificate may be emitted during the
handshake.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">success or failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="handshake_async" invoker="handshake_async" version="2.48">
        <doc xml:space="preserve">Asynchronously performs a TLS handshake on @conn. See
g_dtls_connection_handshake() for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">callback to call when the handshake is complete</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">the data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="handshake_finish" invoker="handshake_finish" version="2.48" throws="1">
        <doc xml:space="preserve">Finish an asynchronous TLS handshake operation. See
g_dtls_connection_handshake() for more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure, in which
case @error will be set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="shutdown" invoker="shutdown" version="2.48" throws="1">
        <doc xml:space="preserve">Shut down part or all of a DTLS connection.

If @shutdown_read is %TRUE then the receiving side of the connection is shut
down, and further reading is disallowed. Subsequent calls to
g_datagram_based_receive_messages() will return %G_IO_ERROR_CLOSED.

If @shutdown_write is %TRUE then the sending side of the connection is shut
down, and further writing is disallowed. Subsequent calls to
g_datagram_based_send_messages() will return %G_IO_ERROR_CLOSED.

It is allowed for both @shutdown_read and @shutdown_write to be TRUE &#x2014; this
is equivalent to calling g_dtls_connection_close().

If @cancellable is cancelled, the #GDtlsConnection may be left
partially-closed and any pending untransmitted data may be lost. Call
g_dtls_connection_shutdown() again to complete closing the #GDtlsConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
          <parameter name="shutdown_read" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to stop reception of incoming datagrams</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="shutdown_write" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to stop sending outgoing datagrams</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="shutdown_async" invoker="shutdown_async" version="2.48">
        <doc xml:space="preserve">Asynchronously shut down part or all of the DTLS connection. See
g_dtls_connection_shutdown() for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
          <parameter name="shutdown_read" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to stop reception of incoming datagrams</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="shutdown_write" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to stop sending outgoing datagrams</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">callback to call when the shutdown operation is complete</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
            <doc xml:space="preserve">the data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="shutdown_finish" invoker="shutdown_finish" version="2.48" throws="1">
        <doc xml:space="preserve">Finish an asynchronous TLS shutdown operation. See
g_dtls_connection_shutdown() for more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure, in which
case @error will be set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="close" c:identifier="g_dtls_connection_close" version="2.48" throws="1">
        <doc xml:space="preserve">Close the DTLS connection. This is equivalent to calling
g_dtls_connection_shutdown() to shut down both sides of the connection.

Closing a #GDtlsConnection waits for all buffered but untransmitted data to
be sent before it completes. It then sends a `close_notify` DTLS alert to the
peer and may wait for a `close_notify` to be received from the peer. It does
not close the underlying #GDtlsConnection:base-socket; that must be closed
separately.

Once @conn is closed, all other operations will return %G_IO_ERROR_CLOSED.
Closing a #GDtlsConnection multiple times will not return an error.

#GDtlsConnections will be automatically closed when the last reference is
dropped, but you might want to call this function to make sure resources are
released as early as possible.

If @cancellable is cancelled, the #GDtlsConnection may be left
partially-closed and any pending untransmitted data may be lost. Call
g_dtls_connection_close() again to complete closing the #GDtlsConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_async" c:identifier="g_dtls_connection_close_async" version="2.48">
        <doc xml:space="preserve">Asynchronously close the DTLS connection. See g_dtls_connection_close() for
more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">callback to call when the close operation is complete</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_finish" c:identifier="g_dtls_connection_close_finish" version="2.48" throws="1">
        <doc xml:space="preserve">Finish an asynchronous TLS close operation. See g_dtls_connection_close()
for more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure, in which
case @error will be set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="emit_accept_certificate" c:identifier="g_dtls_connection_emit_accept_certificate" version="2.48">
        <doc xml:space="preserve">Used by #GDtlsConnection implementations to emit the
#GDtlsConnection::accept-certificate signal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if one of the signal handlers has returned
    %TRUE to accept @peer_cert</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
          <parameter name="peer_cert" transfer-ownership="none">
            <doc xml:space="preserve">the peer's #GTlsCertificate</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
          <parameter name="errors" transfer-ownership="none">
            <doc xml:space="preserve">the problems with @peer_cert</doc>
            <type name="TlsCertificateFlags" c:type="GTlsCertificateFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_certificate" c:identifier="g_dtls_connection_get_certificate" version="2.48">
        <doc xml:space="preserve">Gets @conn's certificate, as set by
g_dtls_connection_set_certificate().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@conn's certificate, or %NULL</doc>
          <type name="TlsCertificate" c:type="GTlsCertificate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_database" c:identifier="g_dtls_connection_get_database" version="2.48">
        <doc xml:space="preserve">Gets the certificate database that @conn uses to verify
peer certificates. See g_dtls_connection_set_database().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the certificate database that @conn uses or %NULL</doc>
          <type name="TlsDatabase" c:type="GTlsDatabase*"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_interaction" c:identifier="g_dtls_connection_get_interaction" version="2.48">
        <doc xml:space="preserve">Get the object that will be used to interact with the user. It will be used
for things like prompting the user for passwords. If %NULL is returned, then
no user interaction will occur for this connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The interaction object.</doc>
          <type name="TlsInteraction" c:type="GTlsInteraction*"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_peer_certificate" c:identifier="g_dtls_connection_get_peer_certificate" version="2.48">
        <doc xml:space="preserve">Gets @conn's peer's certificate after the handshake has completed.
(It is not set during the emission of
#GDtlsConnection::accept-certificate.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@conn's peer's certificate, or %NULL</doc>
          <type name="TlsCertificate" c:type="GTlsCertificate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_peer_certificate_errors" c:identifier="g_dtls_connection_get_peer_certificate_errors" version="2.48">
        <doc xml:space="preserve">Gets the errors associated with validating @conn's peer's
certificate, after the handshake has completed. (It is not set
during the emission of #GDtlsConnection::accept-certificate.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@conn's peer's certificate errors</doc>
          <type name="TlsCertificateFlags" c:type="GTlsCertificateFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_rehandshake_mode" c:identifier="g_dtls_connection_get_rehandshake_mode" version="2.48">
        <doc xml:space="preserve">Gets @conn rehandshaking mode. See
g_dtls_connection_set_rehandshake_mode() for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@conn's rehandshaking mode</doc>
          <type name="TlsRehandshakeMode" c:type="GTlsRehandshakeMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_require_close_notify" c:identifier="g_dtls_connection_get_require_close_notify" version="2.48">
        <doc xml:space="preserve">Tests whether or not @conn expects a proper TLS close notification
when the connection is closed. See
g_dtls_connection_set_require_close_notify() for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @conn requires a proper TLS close notification.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="handshake" c:identifier="g_dtls_connection_handshake" version="2.48" throws="1">
        <doc xml:space="preserve">Attempts a TLS handshake on @conn.

On the client side, it is never necessary to call this method;
although the connection needs to perform a handshake after
connecting (or after sending a "STARTTLS"-type command) and may
need to rehandshake later if the server requests it,
#GDtlsConnection will handle this for you automatically when you try
to send or receive data on the connection. However, you can call
g_dtls_connection_handshake() manually if you want to know for sure
whether the initial handshake succeeded or failed (as opposed to
just immediately trying to write to @conn, in which
case if it fails, it may not be possible to tell if it failed
before or after completing the handshake).

Likewise, on the server side, although a handshake is necessary at
the beginning of the communication, you do not need to call this
function explicitly unless you want clearer error reporting.
However, you may call g_dtls_connection_handshake() later on to
renegotiate parameters (encryption methods, etc) with the client.

#GDtlsConnection::accept_certificate may be emitted during the
handshake.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">success or failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="handshake_async" c:identifier="g_dtls_connection_handshake_async" version="2.48">
        <doc xml:space="preserve">Asynchronously performs a TLS handshake on @conn. See
g_dtls_connection_handshake() for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">callback to call when the handshake is complete</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="handshake_finish" c:identifier="g_dtls_connection_handshake_finish" version="2.48" throws="1">
        <doc xml:space="preserve">Finish an asynchronous TLS handshake operation. See
g_dtls_connection_handshake() for more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure, in which
case @error will be set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_certificate" c:identifier="g_dtls_connection_set_certificate" version="2.48">
        <doc xml:space="preserve">This sets the certificate that @conn will present to its peer
during the TLS handshake. For a #GDtlsServerConnection, it is
mandatory to set this, and that will normally be done at construct
time.

For a #GDtlsClientConnection, this is optional. If a handshake fails
with %G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server
requires a certificate, and if you try connecting again, you should
call this method first. You can call
g_dtls_client_connection_get_accepted_cas() on the failed connection
to get a list of Certificate Authorities that the server will
accept certificates from.

(It is also possible that a server will allow the connection with
or without a certificate; in that case, if you don't provide a
certificate, you can tell that the server requested one by the fact
that g_dtls_client_connection_get_accepted_cas() will return
non-%NULL.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
          <parameter name="certificate" transfer-ownership="none">
            <doc xml:space="preserve">the certificate to use for @conn</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_database" c:identifier="g_dtls_connection_set_database" version="2.48">
        <doc xml:space="preserve">Sets the certificate database that is used to verify peer certificates.
This is set to the default database by default. See
g_tls_backend_get_default_database(). If set to %NULL, then
peer certificate validation will always set the
%G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
#GDtlsConnection::accept-certificate will always be emitted on
client-side connections, unless that bit is not set in
#GDtlsClientConnection:validation-flags).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
          <parameter name="database" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_interaction" c:identifier="g_dtls_connection_set_interaction" version="2.48">
        <doc xml:space="preserve">Set the object that will be used to interact with the user. It will be used
for things like prompting the user for passwords.

The @interaction argument will normally be a derived subclass of
#GTlsInteraction. %NULL can also be provided if no user interaction
should occur for this connection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
          <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an interaction object, or %NULL</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_rehandshake_mode" c:identifier="g_dtls_connection_set_rehandshake_mode" version="2.48">
        <doc xml:space="preserve">Sets how @conn behaves with respect to rehandshaking requests.

%G_TLS_REHANDSHAKE_NEVER means that it will never agree to
rehandshake after the initial handshake is complete. (For a client,
this means it will refuse rehandshake requests from the server, and
for a server, this means it will close the connection with an error
if the client attempts to rehandshake.)

%G_TLS_REHANDSHAKE_SAFELY means that the connection will allow a
rehandshake only if the other end of the connection supports the
TLS `renegotiation_info` extension. This is the default behavior,
but means that rehandshaking will not work against older
implementations that do not support that extension.

%G_TLS_REHANDSHAKE_UNSAFELY means that the connection will allow
rehandshaking even without the `renegotiation_info` extension. On
the server side in particular, this is not recommended, since it
leaves the server open to certain attacks. However, this mode is
necessary if you need to allow renegotiation with older client
software.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">the rehandshaking mode</doc>
            <type name="TlsRehandshakeMode" c:type="GTlsRehandshakeMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_require_close_notify" c:identifier="g_dtls_connection_set_require_close_notify" version="2.48">
        <doc xml:space="preserve">Sets whether or not @conn expects a proper TLS close notification
before the connection is closed. If this is %TRUE (the default),
then @conn will expect to receive a TLS close notification from its
peer before the connection is closed, and will return a
%G_TLS_ERROR_EOF error if the connection is closed without proper
notification (since this may indicate a network error, or
man-in-the-middle attack).

In some protocols, the application will know whether or not the
connection was closed cleanly based on application-level data
(because the application-level data includes a length field, or is
somehow self-delimiting); in this case, the close notify is
redundant and may be omitted. You
can use g_dtls_connection_set_require_close_notify() to tell @conn
to allow an "unannounced" connection close, in which case the close
will show up as a 0-length read, as in a non-TLS
#GDatagramBased, and it is up to the application to check that
the data has been fully received.

Note that this only affects the behavior when the peer closes the
connection; when the application calls g_dtls_connection_close_async() on
@conn itself, this will send a close notification regardless of the
setting of this property. If you explicitly want to do an unclean
close, you can close @conn's #GDtlsConnection:base-socket rather
than closing @conn itself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
          <parameter name="require_close_notify" transfer-ownership="none">
            <doc xml:space="preserve">whether or not to require close notification</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="shutdown" c:identifier="g_dtls_connection_shutdown" version="2.48" throws="1">
        <doc xml:space="preserve">Shut down part or all of a DTLS connection.

If @shutdown_read is %TRUE then the receiving side of the connection is shut
down, and further reading is disallowed. Subsequent calls to
g_datagram_based_receive_messages() will return %G_IO_ERROR_CLOSED.

If @shutdown_write is %TRUE then the sending side of the connection is shut
down, and further writing is disallowed. Subsequent calls to
g_datagram_based_send_messages() will return %G_IO_ERROR_CLOSED.

It is allowed for both @shutdown_read and @shutdown_write to be TRUE &#x2014; this
is equivalent to calling g_dtls_connection_close().

If @cancellable is cancelled, the #GDtlsConnection may be left
partially-closed and any pending untransmitted data may be lost. Call
g_dtls_connection_shutdown() again to complete closing the #GDtlsConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
          <parameter name="shutdown_read" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to stop reception of incoming datagrams</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="shutdown_write" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to stop sending outgoing datagrams</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="shutdown_async" c:identifier="g_dtls_connection_shutdown_async" version="2.48">
        <doc xml:space="preserve">Asynchronously shut down part or all of the DTLS connection. See
g_dtls_connection_shutdown() for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
          <parameter name="shutdown_read" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to stop reception of incoming datagrams</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="shutdown_write" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to stop sending outgoing datagrams</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">callback to call when the shutdown operation is complete</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="shutdown_finish" c:identifier="g_dtls_connection_shutdown_finish" version="2.48" throws="1">
        <doc xml:space="preserve">Finish an asynchronous TLS shutdown operation. See
g_dtls_connection_shutdown() for more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure, in which
case @error will be set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GDtlsConnection</doc>
            <type name="DtlsConnection" c:type="GDtlsConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="base-socket" version="2.48" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The #GDatagramBased that the connection wraps. Note that this may be any
implementation of #GDatagramBased, not just a #GSocket.</doc>
        <type name="DatagramBased"/>
      </property>
      <property name="certificate" version="2.48" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The connection's certificate; see
g_dtls_connection_set_certificate().</doc>
        <type name="TlsCertificate"/>
      </property>
      <property name="database" version="2.48" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The certificate database to use when verifying this TLS connection.
If no certificate database is set, then the default database will be
used. See g_tls_backend_get_default_database().</doc>
        <type name="TlsDatabase"/>
      </property>
      <property name="interaction" version="2.48" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">A #GTlsInteraction object to be used when the connection or certificate
database need to interact with the user. This will be used to prompt the
user for passwords where necessary.</doc>
        <type name="TlsInteraction"/>
      </property>
      <property name="peer-certificate" version="2.48" transfer-ownership="none">
        <doc xml:space="preserve">The connection's peer's certificate, after the TLS handshake has
completed and the certificate has been accepted. Note in
particular that this is not yet set during the emission of
#GDtlsConnection::accept-certificate.

(You can watch for a #GObject::notify signal on this property to
detect when a handshake has occurred.)</doc>
        <type name="TlsCertificate"/>
      </property>
      <property name="peer-certificate-errors" version="2.48" transfer-ownership="none">
        <doc xml:space="preserve">The errors noticed-and-ignored while verifying
#GDtlsConnection:peer-certificate. Normally this should be 0, but
it may not be if #GDtlsClientConnection:validation-flags is not
%G_TLS_CERTIFICATE_VALIDATE_ALL, or if
#GDtlsConnection::accept-certificate overrode the default
behavior.</doc>
        <type name="TlsCertificateFlags"/>
      </property>
      <property name="rehandshake-mode" version="2.48" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">The rehandshaking mode. See
g_dtls_connection_set_rehandshake_mode().</doc>
        <type name="TlsRehandshakeMode"/>
      </property>
      <property name="require-close-notify" version="2.48" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether or not proper TLS close notification is required.
See g_dtls_connection_set_require_close_notify().</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <glib:signal name="accept-certificate" when="last" version="2.48">
        <doc xml:space="preserve">Emitted during the TLS handshake after the peer certificate has
been received. You can examine @peer_cert's certification path by
calling g_tls_certificate_get_issuer() on it.

For a client-side connection, @peer_cert is the server's
certificate, and the signal will only be emitted if the
certificate was not acceptable according to @conn's
#GDtlsClientConnection:validation_flags. If you would like the
certificate to be accepted despite @errors, return %TRUE from the
signal handler. Otherwise, if no handler accepts the certificate,
the handshake will fail with %G_TLS_ERROR_BAD_CERTIFICATE.

For a server-side connection, @peer_cert is the certificate
presented by the client, if this was requested via the server's
#GDtlsServerConnection:authentication_mode. On the server side,
the signal is always emitted when the client presents a
certificate, and the certificate will only be accepted if a
handler returns %TRUE.

Note that if this signal is emitted as part of asynchronous I/O
in the main thread, then you should not attempt to interact with
the user before returning from the signal handler. If you want to
let the user decide whether or not to accept the certificate, you
would have to return %FALSE from the signal handler on the first
attempt, and then after the connection attempt returns a
%G_TLS_ERROR_HANDSHAKE, you can interact with the user, and if
the user decides to accept the certificate, remember that fact,
create a new connection, and return %TRUE from the signal handler
the next time.

If you are doing I/O in another thread, you do not
need to worry about this, and can simply block in the signal
handler until the UI thread returns an answer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE to accept @peer_cert (which will also
immediately end the signal emission). %FALSE to allow the signal
emission to continue, which will cause the handshake to fail if
no one else overrides it.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="peer_cert" transfer-ownership="none">
            <doc xml:space="preserve">the peer's #GTlsCertificate</doc>
            <type name="TlsCertificate"/>
          </parameter>
          <parameter name="errors" transfer-ownership="none">
            <doc xml:space="preserve">the problems with @peer_cert.</doc>
            <type name="TlsCertificateFlags"/>
          </parameter>
        </parameters>
      </glib:signal>
    </interface>
    <record name="DtlsConnectionInterface" c:type="GDtlsConnectionInterface" glib:is-gtype-struct-for="DtlsConnection" version="2.48">
      <doc xml:space="preserve">Virtual method table for a #GDtlsConnection implementation.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="accept_certificate">
        <callback name="accept_certificate">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="connection" transfer-ownership="none">
              <type name="DtlsConnection" c:type="GDtlsConnection*"/>
            </parameter>
            <parameter name="peer_cert" transfer-ownership="none">
              <type name="TlsCertificate" c:type="GTlsCertificate*"/>
            </parameter>
            <parameter name="errors" transfer-ownership="none">
              <type name="TlsCertificateFlags" c:type="GTlsCertificateFlags"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="handshake">
        <callback name="handshake" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">success or failure</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="conn" transfer-ownership="none">
              <doc xml:space="preserve">a #GDtlsConnection</doc>
              <type name="DtlsConnection" c:type="GDtlsConnection*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="handshake_async">
        <callback name="handshake_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="conn" transfer-ownership="none">
              <doc xml:space="preserve">a #GDtlsConnection</doc>
              <type name="DtlsConnection" c:type="GDtlsConnection*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">callback to call when the handshake is complete</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">the data to pass to the callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="handshake_finish">
        <callback name="handshake_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on failure, in which
case @error will be set.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="conn" transfer-ownership="none">
              <doc xml:space="preserve">a #GDtlsConnection</doc>
              <type name="DtlsConnection" c:type="GDtlsConnection*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="shutdown">
        <callback name="shutdown" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE otherwise</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="conn" transfer-ownership="none">
              <doc xml:space="preserve">a #GDtlsConnection</doc>
              <type name="DtlsConnection" c:type="GDtlsConnection*"/>
            </parameter>
            <parameter name="shutdown_read" transfer-ownership="none">
              <doc xml:space="preserve">%TRUE to stop reception of incoming datagrams</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="shutdown_write" transfer-ownership="none">
              <doc xml:space="preserve">%TRUE to stop sending outgoing datagrams</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="shutdown_async">
        <callback name="shutdown_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="conn" transfer-ownership="none">
              <doc xml:space="preserve">a #GDtlsConnection</doc>
              <type name="DtlsConnection" c:type="GDtlsConnection*"/>
            </parameter>
            <parameter name="shutdown_read" transfer-ownership="none">
              <doc xml:space="preserve">%TRUE to stop reception of incoming datagrams</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="shutdown_write" transfer-ownership="none">
              <doc xml:space="preserve">%TRUE to stop sending outgoing datagrams</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
              <doc xml:space="preserve">callback to call when the shutdown operation is complete</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6">
              <doc xml:space="preserve">the data to pass to the callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="shutdown_finish">
        <callback name="shutdown_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on failure, in which
case @error will be set</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="conn" transfer-ownership="none">
              <doc xml:space="preserve">a #GDtlsConnection</doc>
              <type name="DtlsConnection" c:type="GDtlsConnection*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <interface name="DtlsServerConnection" c:symbol-prefix="dtls_server_connection" c:type="GDtlsServerConnection" version="2.48" glib:type-name="GDtlsServerConnection" glib:get-type="g_dtls_server_connection_get_type" glib:type-struct="DtlsServerConnectionInterface">
      <doc xml:space="preserve">#GDtlsServerConnection is the server-side subclass of #GDtlsConnection,
representing a server-side DTLS connection.</doc>
      <prerequisite name="DatagramBased"/>
      <prerequisite name="DtlsConnection"/>
      <function name="new" c:identifier="g_dtls_server_connection_new" version="2.48" throws="1">
        <doc xml:space="preserve">Creates a new #GDtlsServerConnection wrapping @base_socket.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new
  #GDtlsServerConnection, or %NULL on error</doc>
          <type name="DtlsServerConnection" c:type="GDatagramBased*"/>
        </return-value>
        <parameters>
          <parameter name="base_socket" transfer-ownership="none">
            <doc xml:space="preserve">the #GDatagramBased to wrap</doc>
            <type name="DatagramBased" c:type="GDatagramBased*"/>
          </parameter>
          <parameter name="certificate" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the default server certificate, or %NULL</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
        </parameters>
      </function>
      <property name="authentication-mode" version="2.48" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The #GTlsAuthenticationMode for the server. This can be changed
before calling g_dtls_connection_handshake() if you want to
rehandshake with a different mode from the initial handshake.</doc>
        <type name="TlsAuthenticationMode"/>
      </property>
    </interface>
    <record name="DtlsServerConnectionInterface" c:type="GDtlsServerConnectionInterface" glib:is-gtype-struct-for="DtlsServerConnection" version="2.48">
      <doc xml:space="preserve">vtable for a #GDtlsServerConnection implementation.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
    </record>
    <class name="Emblem" c:symbol-prefix="emblem" c:type="GEmblem" parent="GObject.Object" glib:type-name="GEmblem" glib:get-type="g_emblem_get_type" glib:type-struct="EmblemClass">
      <doc xml:space="preserve">#GEmblem is an implementation of #GIcon that supports
having an emblem, which is an icon with additional properties.
It can than be added to a #GEmblemedIcon.

Currently, only metainformation about the emblem's origin is
supported. More may be added in the future.</doc>
      <implements name="Icon"/>
      <constructor name="new" c:identifier="g_emblem_new" version="2.18">
        <doc xml:space="preserve">Creates a new emblem for @icon.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GEmblem.</doc>
          <type name="Emblem" c:type="GEmblem*"/>
        </return-value>
        <parameters>
          <parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">a GIcon containing the icon.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_origin" c:identifier="g_emblem_new_with_origin" version="2.18">
        <doc xml:space="preserve">Creates a new emblem for @icon.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GEmblem.</doc>
          <type name="Emblem" c:type="GEmblem*"/>
        </return-value>
        <parameters>
          <parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">a GIcon containing the icon.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </parameter>
          <parameter name="origin" transfer-ownership="none">
            <doc xml:space="preserve">a GEmblemOrigin enum defining the emblem's origin</doc>
            <type name="EmblemOrigin" c:type="GEmblemOrigin"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_icon" c:identifier="g_emblem_get_icon" version="2.18">
        <doc xml:space="preserve">Gives back the icon from @emblem.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GIcon. The returned object belongs to
         the emblem and should not be modified or freed.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="emblem" transfer-ownership="none">
            <doc xml:space="preserve">a #GEmblem from which the icon should be extracted.</doc>
            <type name="Emblem" c:type="GEmblem*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_origin" c:identifier="g_emblem_get_origin" version="2.18">
        <doc xml:space="preserve">Gets the origin of the emblem.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the origin of the emblem</doc>
          <type name="EmblemOrigin" c:type="GEmblemOrigin"/>
        </return-value>
        <parameters>
          <instance-parameter name="emblem" transfer-ownership="none">
            <doc xml:space="preserve">a #GEmblem</doc>
            <type name="Emblem" c:type="GEmblem*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="icon" writable="1" construct-only="1" transfer-ownership="none">
        <type name="GObject.Object"/>
      </property>
      <property name="origin" writable="1" construct-only="1" transfer-ownership="none">
        <type name="EmblemOrigin"/>
      </property>
    </class>
    <record name="EmblemClass" c:type="GEmblemClass" disguised="1" glib:is-gtype-struct-for="Emblem">
    </record>
    <enumeration name="EmblemOrigin" version="2.18" glib:type-name="GEmblemOrigin" glib:get-type="g_emblem_origin_get_type" c:type="GEmblemOrigin">
      <doc xml:space="preserve">GEmblemOrigin is used to add information about the origin of the emblem
to #GEmblem.</doc>
      <member name="unknown" value="0" c:identifier="G_EMBLEM_ORIGIN_UNKNOWN" glib:nick="unknown">
        <doc xml:space="preserve">Emblem of unknown origin</doc>
      </member>
      <member name="device" value="1" c:identifier="G_EMBLEM_ORIGIN_DEVICE" glib:nick="device">
        <doc xml:space="preserve">Emblem adds device-specific information</doc>
      </member>
      <member name="livemetadata" value="2" c:identifier="G_EMBLEM_ORIGIN_LIVEMETADATA" glib:nick="livemetadata">
        <doc xml:space="preserve">Emblem depicts live metadata, such as "readonly"</doc>
      </member>
      <member name="tag" value="3" c:identifier="G_EMBLEM_ORIGIN_TAG" glib:nick="tag">
        <doc xml:space="preserve">Emblem comes from a user-defined tag, e.g. set by nautilus (in the future)</doc>
      </member>
    </enumeration>
    <class name="EmblemedIcon" c:symbol-prefix="emblemed_icon" c:type="GEmblemedIcon" parent="GObject.Object" glib:type-name="GEmblemedIcon" glib:get-type="g_emblemed_icon_get_type" glib:type-struct="EmblemedIconClass">
      <doc xml:space="preserve">#GEmblemedIcon is an implementation of #GIcon that supports
adding an emblem to an icon. Adding multiple emblems to an
icon is ensured via g_emblemed_icon_add_emblem().

Note that #GEmblemedIcon allows no control over the position
of the emblems. See also #GEmblem for more information.</doc>
      <implements name="Icon"/>
      <constructor name="new" c:identifier="g_emblemed_icon_new" version="2.18">
        <doc xml:space="preserve">Creates a new emblemed icon for @icon with the emblem @emblem.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GIcon</doc>
          <type name="EmblemedIcon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">a #GIcon</doc>
            <type name="Icon" c:type="GIcon*"/>
          </parameter>
          <parameter name="emblem" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GEmblem, or %NULL</doc>
            <type name="Emblem" c:type="GEmblem*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_emblem" c:identifier="g_emblemed_icon_add_emblem" version="2.18">
        <doc xml:space="preserve">Adds @emblem to the #GList of #GEmblems.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="emblemed" transfer-ownership="none">
            <doc xml:space="preserve">a #GEmblemedIcon</doc>
            <type name="EmblemedIcon" c:type="GEmblemedIcon*"/>
          </instance-parameter>
          <parameter name="emblem" transfer-ownership="none">
            <doc xml:space="preserve">a #GEmblem</doc>
            <type name="Emblem" c:type="GEmblem*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_emblems" c:identifier="g_emblemed_icon_clear_emblems" version="2.28">
        <doc xml:space="preserve">Removes all the emblems from @icon.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="emblemed" transfer-ownership="none">
            <doc xml:space="preserve">a #GEmblemedIcon</doc>
            <type name="EmblemedIcon" c:type="GEmblemedIcon*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_emblems" c:identifier="g_emblemed_icon_get_emblems" version="2.18">
        <doc xml:space="preserve">Gets the list of emblems for the @icon.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GList of
    #GEmblems that is owned by @emblemed</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Emblem"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="emblemed" transfer-ownership="none">
            <doc xml:space="preserve">a #GEmblemedIcon</doc>
            <type name="EmblemedIcon" c:type="GEmblemedIcon*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_icon" c:identifier="g_emblemed_icon_get_icon" version="2.18">
        <doc xml:space="preserve">Gets the main icon for @emblemed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GIcon that is owned by @emblemed</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="emblemed" transfer-ownership="none">
            <doc xml:space="preserve">a #GEmblemedIcon</doc>
            <type name="EmblemedIcon" c:type="GEmblemedIcon*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="gicon" writable="1" construct-only="1" transfer-ownership="none">
        <type name="Icon"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="EmblemedIconPrivate" c:type="GEmblemedIconPrivate*"/>
      </field>
    </class>
    <record name="EmblemedIconClass" c:type="GEmblemedIconClass" glib:is-gtype-struct-for="EmblemedIcon">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="EmblemedIconPrivate" c:type="GEmblemedIconPrivate" disguised="1">
    </record>
    <constant name="FILE_ATTRIBUTE_ACCESS_CAN_DELETE" value="access::can-delete" c:type="G_FILE_ATTRIBUTE_ACCESS_CAN_DELETE">
      <doc xml:space="preserve">A key in the "access" namespace for checking deletion privileges.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
This attribute will be %TRUE if the user is able to delete the file.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE" value="access::can-execute" c:type="G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE">
      <doc xml:space="preserve">A key in the "access" namespace for getting execution privileges.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
This attribute will be %TRUE if the user is able to execute the file.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_ACCESS_CAN_READ" value="access::can-read" c:type="G_FILE_ATTRIBUTE_ACCESS_CAN_READ">
      <doc xml:space="preserve">A key in the "access" namespace for getting read privileges.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
This attribute will be %TRUE if the user is able to read the file.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_ACCESS_CAN_RENAME" value="access::can-rename" c:type="G_FILE_ATTRIBUTE_ACCESS_CAN_RENAME">
      <doc xml:space="preserve">A key in the "access" namespace for checking renaming privileges.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
This attribute will be %TRUE if the user is able to rename the file.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_ACCESS_CAN_TRASH" value="access::can-trash" c:type="G_FILE_ATTRIBUTE_ACCESS_CAN_TRASH">
      <doc xml:space="preserve">A key in the "access" namespace for checking trashing privileges.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
This attribute will be %TRUE if the user is able to move the file to
the trash.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_ACCESS_CAN_WRITE" value="access::can-write" c:type="G_FILE_ATTRIBUTE_ACCESS_CAN_WRITE">
      <doc xml:space="preserve">A key in the "access" namespace for getting write privileges.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
This attribute will be %TRUE if the user is able to write to the file.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_DOS_IS_ARCHIVE" value="dos::is-archive" c:type="G_FILE_ATTRIBUTE_DOS_IS_ARCHIVE">
      <doc xml:space="preserve">A key in the "dos" namespace for checking if the file's archive flag
is set. This attribute is %TRUE if the archive flag is set. This attribute
is only available for DOS file systems. Corresponding #GFileAttributeType
is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_DOS_IS_SYSTEM" value="dos::is-system" c:type="G_FILE_ATTRIBUTE_DOS_IS_SYSTEM">
      <doc xml:space="preserve">A key in the "dos" namespace for checking if the file's backup flag
is set. This attribute is %TRUE if the backup flag is set. This attribute
is only available for DOS file systems. Corresponding #GFileAttributeType
is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_ETAG_VALUE" value="etag::value" c:type="G_FILE_ATTRIBUTE_ETAG_VALUE">
      <doc xml:space="preserve">A key in the "etag" namespace for getting the value of the file's
entity tag. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_FILESYSTEM_FREE" value="filesystem::free" c:type="G_FILE_ATTRIBUTE_FILESYSTEM_FREE">
      <doc xml:space="preserve">A key in the "filesystem" namespace for getting the number of bytes of free space left on the
file system. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_UINT64.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_FILESYSTEM_READONLY" value="filesystem::readonly" c:type="G_FILE_ATTRIBUTE_FILESYSTEM_READONLY">
      <doc xml:space="preserve">A key in the "filesystem" namespace for checking if the file system
is read only. Is set to %TRUE if the file system is read only.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_FILESYSTEM_REMOTE" value="filesystem::remote" c:type="G_FILE_ATTRIBUTE_FILESYSTEM_REMOTE">
      <doc xml:space="preserve">A key in the "filesystem" namespace for checking if the file system
is remote. Is set to %TRUE if the file system is remote.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_FILESYSTEM_SIZE" value="filesystem::size" c:type="G_FILE_ATTRIBUTE_FILESYSTEM_SIZE">
      <doc xml:space="preserve">A key in the "filesystem" namespace for getting the total size (in bytes) of the file system,
used in g_file_query_filesystem_info(). Corresponding #GFileAttributeType
is %G_FILE_ATTRIBUTE_TYPE_UINT64.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_FILESYSTEM_TYPE" value="filesystem::type" c:type="G_FILE_ATTRIBUTE_FILESYSTEM_TYPE">
      <doc xml:space="preserve">A key in the "filesystem" namespace for getting the file system's type.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_FILESYSTEM_USED" value="filesystem::used" c:type="G_FILE_ATTRIBUTE_FILESYSTEM_USED" version="2.32">
      <doc xml:space="preserve">A key in the "filesystem" namespace for getting the number of bytes of used on the
file system. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_UINT64.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW" value="filesystem::use-preview" c:type="G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW">
      <doc xml:space="preserve">A key in the "filesystem" namespace for hinting a file manager
application whether it should preview (e.g. thumbnail) files on the
file system. The value for this key contain a
#GFilesystemPreviewType.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_GVFS_BACKEND" value="gvfs::backend" c:type="G_FILE_ATTRIBUTE_GVFS_BACKEND">
      <doc xml:space="preserve">A key in the "gvfs" namespace that gets the name of the current
GVFS backend in use. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_ID_FILE" value="id::file" c:type="G_FILE_ATTRIBUTE_ID_FILE">
      <doc xml:space="preserve">A key in the "id" namespace for getting a file identifier.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
An example use would be during listing files, to avoid recursive
directory scanning.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_ID_FILESYSTEM" value="id::filesystem" c:type="G_FILE_ATTRIBUTE_ID_FILESYSTEM">
      <doc xml:space="preserve">A key in the "id" namespace for getting the file system identifier.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
An example use would be during drag and drop to see if the source
and target are on the same filesystem (default to move) or not (default
to copy).</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT" value="mountable::can-eject" c:type="G_FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT">
      <doc xml:space="preserve">A key in the "mountable" namespace for checking if a file (of type G_FILE_TYPE_MOUNTABLE) can be ejected.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT" value="mountable::can-mount" c:type="G_FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT">
      <doc xml:space="preserve">A key in the "mountable" namespace for checking if a file (of type G_FILE_TYPE_MOUNTABLE) is mountable.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL" value="mountable::can-poll" c:type="G_FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL" version="2.22">
      <doc xml:space="preserve">A key in the "mountable" namespace for checking if a file (of type G_FILE_TYPE_MOUNTABLE) can be polled.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_MOUNTABLE_CAN_START" value="mountable::can-start" c:type="G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START" version="2.22">
      <doc xml:space="preserve">A key in the "mountable" namespace for checking if a file (of type G_FILE_TYPE_MOUNTABLE) can be started.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED" value="mountable::can-start-degraded" c:type="G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED" version="2.22">
      <doc xml:space="preserve">A key in the "mountable" namespace for checking if a file (of type G_FILE_TYPE_MOUNTABLE) can be started
degraded.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP" value="mountable::can-stop" c:type="G_FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP" version="2.22">
      <doc xml:space="preserve">A key in the "mountable" namespace for checking if a file (of type G_FILE_TYPE_MOUNTABLE) can be stopped.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT" value="mountable::can-unmount" c:type="G_FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT">
      <doc xml:space="preserve">A key in the "mountable" namespace for checking if a file (of type G_FILE_TYPE_MOUNTABLE)  is unmountable.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI" value="mountable::hal-udi" c:type="G_FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI">
      <doc xml:space="preserve">A key in the "mountable" namespace for getting the HAL UDI for the mountable
file. Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC" value="mountable::is-media-check-automatic" c:type="G_FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC" version="2.22">
      <doc xml:space="preserve">A key in the "mountable" namespace for checking if a file (of type G_FILE_TYPE_MOUNTABLE)
is automatically polled for media.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE" value="mountable::start-stop-type" c:type="G_FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE" version="2.22">
      <doc xml:space="preserve">A key in the "mountable" namespace for getting the #GDriveStartStopType.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE" value="mountable::unix-device" c:type="G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE">
      <doc xml:space="preserve">A key in the "mountable" namespace for getting the unix device.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE" value="mountable::unix-device-file" c:type="G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE" version="2.22">
      <doc xml:space="preserve">A key in the "mountable" namespace for getting the unix device file.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_OWNER_GROUP" value="owner::group" c:type="G_FILE_ATTRIBUTE_OWNER_GROUP">
      <doc xml:space="preserve">A key in the "owner" namespace for getting the file owner's group.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_OWNER_USER" value="owner::user" c:type="G_FILE_ATTRIBUTE_OWNER_USER">
      <doc xml:space="preserve">A key in the "owner" namespace for getting the user name of the
file's owner. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_OWNER_USER_REAL" value="owner::user-real" c:type="G_FILE_ATTRIBUTE_OWNER_USER_REAL">
      <doc xml:space="preserve">A key in the "owner" namespace for getting the real name of the
user that owns the file. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_PREVIEW_ICON" value="preview::icon" c:type="G_FILE_ATTRIBUTE_PREVIEW_ICON" version="2.20">
      <doc xml:space="preserve">A key in the "preview" namespace for getting a #GIcon that can be
used to get preview of the file. For example, it may be a low
resolution thumbnail without metadata. Corresponding
#GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_OBJECT.  The value
for this key should contain a #GIcon.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_RECENT_MODIFIED" value="recent::modified" c:type="G_FILE_ATTRIBUTE_RECENT_MODIFIED" version="2.52">
      <doc xml:space="preserve">A key in the "recent" namespace for getting time, when the metadata for the
file in `recent:///` was last changed. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_INT64.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_SELINUX_CONTEXT" value="selinux::context" c:type="G_FILE_ATTRIBUTE_SELINUX_CONTEXT">
      <doc xml:space="preserve">A key in the "selinux" namespace for getting the file's SELinux
context. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_STRING. Note that this attribute is only
available if GLib has been built with SELinux support.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE" value="standard::allocated-size" c:type="G_FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE" version="2.20">
      <doc xml:space="preserve">A key in the "standard" namespace for getting the amount of disk space
that is consumed by the file (in bytes).  This will generally be larger
than the file size (due to block size overhead) but can occasionally be
smaller (for example, for sparse files).
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE" value="standard::content-type" c:type="G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE">
      <doc xml:space="preserve">A key in the "standard" namespace for getting the content type of the file.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
The value for this key should contain a valid content type.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_COPY_NAME" value="standard::copy-name" c:type="G_FILE_ATTRIBUTE_STANDARD_COPY_NAME">
      <doc xml:space="preserve">A key in the "standard" namespace for getting the copy name of the file.
The copy name is an optional version of the name. If available it's always
in UTF8, and corresponds directly to the original filename (only transcoded to
UTF8). This is useful if you want to copy the file to another filesystem that
might have a different encoding. If the filename is not a valid string in the
encoding selected for the filesystem it is in then the copy name will not be set.

Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_DESCRIPTION" value="standard::description" c:type="G_FILE_ATTRIBUTE_STANDARD_DESCRIPTION">
      <doc xml:space="preserve">A key in the "standard" namespace for getting the description of the file.
The description is a utf8 string that describes the file, generally containing
the filename, but can also contain furter information. Example descriptions
could be "filename (on hostname)" for a remote file or "filename (in trash)"
for a file in the trash. This is useful for instance as the window title
when displaying a directory or for a bookmarks menu.

Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME" value="standard::display-name" c:type="G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME">
      <doc xml:space="preserve">A key in the "standard" namespace for getting the display name of the file.
A display name is guaranteed to be in UTF8 and can thus be displayed in
the UI.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_EDIT_NAME" value="standard::edit-name" c:type="G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME">
      <doc xml:space="preserve">A key in the "standard" namespace for edit name of the file.
An edit name is similar to the display name, but it is meant to be
used when you want to rename the file in the UI. The display name
might contain information you don't want in the new filename (such as
"(invalid unicode)" if the filename was in an invalid encoding).

Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE" value="standard::fast-content-type" c:type="G_FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE">
      <doc xml:space="preserve">A key in the "standard" namespace for getting the fast content type.
The fast content type isn't as reliable as the regular one, as it
only uses the filename to guess it, but it is faster to calculate than the
regular content type.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_ICON" value="standard::icon" c:type="G_FILE_ATTRIBUTE_STANDARD_ICON">
      <doc xml:space="preserve">A key in the "standard" namespace for getting the icon for the file.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_OBJECT.
The value for this key should contain a #GIcon.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_IS_BACKUP" value="standard::is-backup" c:type="G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP">
      <doc xml:space="preserve">A key in the "standard" namespace for checking if a file is a backup file.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_IS_HIDDEN" value="standard::is-hidden" c:type="G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN">
      <doc xml:space="preserve">A key in the "standard" namespace for checking if a file is hidden.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_IS_SYMLINK" value="standard::is-symlink" c:type="G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK">
      <doc xml:space="preserve">A key in the "standard" namespace for checking if the file is a symlink.
Typically the actual type is something else, if we followed the symlink
to get the type.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL" value="standard::is-virtual" c:type="G_FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL">
      <doc xml:space="preserve">A key in the "standard" namespace for checking if a file is virtual.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_IS_VOLATILE" value="standard::is-volatile" c:type="G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE" version="2.46">
      <doc xml:space="preserve">A key in the "standard" namespace for checking if a file is
volatile. This is meant for opaque, non-POSIX-like backends to
indicate that the URI is not persistent. Applications should look
at #G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET for the persistent URI.

Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_NAME" value="standard::name" c:type="G_FILE_ATTRIBUTE_STANDARD_NAME">
      <doc xml:space="preserve">A key in the "standard" namespace for getting the name of the file.
The name is the on-disk filename which may not be in any known encoding,
and can thus not be generally displayed as is.
Use #G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME if you need to display the
name in a user interface.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_SIZE" value="standard::size" c:type="G_FILE_ATTRIBUTE_STANDARD_SIZE">
      <doc xml:space="preserve">A key in the "standard" namespace for getting the file's size (in bytes).
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_SORT_ORDER" value="standard::sort-order" c:type="G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER">
      <doc xml:space="preserve">A key in the "standard" namespace for setting the sort order of a file.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_INT32.
An example use would be in file managers, which would use this key
to set the order files are displayed. Files with smaller sort order
should be sorted first, and files without sort order as if sort order
was zero.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON" value="standard::symbolic-icon" c:type="G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON" version="2.34">
      <doc xml:space="preserve">A key in the "standard" namespace for getting the symbolic icon for the file.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_OBJECT.
The value for this key should contain a #GIcon.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET" value="standard::symlink-target" c:type="G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET">
      <doc xml:space="preserve">A key in the "standard" namespace for getting the symlink target, if the file
is a symlink. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_TARGET_URI" value="standard::target-uri" c:type="G_FILE_ATTRIBUTE_STANDARD_TARGET_URI">
      <doc xml:space="preserve">A key in the "standard" namespace for getting the target URI for the file, in
the case of %G_FILE_TYPE_SHORTCUT or %G_FILE_TYPE_MOUNTABLE files.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_TYPE" value="standard::type" c:type="G_FILE_ATTRIBUTE_STANDARD_TYPE">
      <doc xml:space="preserve">A key in the "standard" namespace for storing file types.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
The value for this key should contain a #GFileType.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_THUMBNAILING_FAILED" value="thumbnail::failed" c:type="G_FILE_ATTRIBUTE_THUMBNAILING_FAILED">
      <doc xml:space="preserve">A key in the "thumbnail" namespace for checking if thumbnailing failed.
This attribute is %TRUE if thumbnailing failed. Corresponding
#GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_THUMBNAIL_IS_VALID" value="thumbnail::is-valid" c:type="G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID" version="2.40">
      <doc xml:space="preserve">A key in the "thumbnail" namespace for checking whether the thumbnail is outdated.
This attribute is %TRUE if the thumbnail is up-to-date with the file it represents,
and %FALSE if the file has been modified since the thumbnail was generated.

If %G_FILE_ATTRIBUTE_THUMBNAILING_FAILED is %TRUE and this attribute is %FALSE,
it indicates that thumbnailing may be attempted again and may succeed.

Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_THUMBNAIL_PATH" value="thumbnail::path" c:type="G_FILE_ATTRIBUTE_THUMBNAIL_PATH">
      <doc xml:space="preserve">A key in the "thumbnail" namespace for getting the path to the thumbnail
image. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_TIME_ACCESS" value="time::access" c:type="G_FILE_ATTRIBUTE_TIME_ACCESS">
      <doc xml:space="preserve">A key in the "time" namespace for getting the time the file was last
accessed. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_UINT64, and contains the time since the
file was last accessed, in seconds since the UNIX epoch.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_TIME_ACCESS_USEC" value="time::access-usec" c:type="G_FILE_ATTRIBUTE_TIME_ACCESS_USEC">
      <doc xml:space="preserve">A key in the "time" namespace for getting the microseconds of the time
the file was last accessed. This should be used in conjunction with
#G_FILE_ATTRIBUTE_TIME_ACCESS. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_TIME_CHANGED" value="time::changed" c:type="G_FILE_ATTRIBUTE_TIME_CHANGED">
      <doc xml:space="preserve">A key in the "time" namespace for getting the time the file was last
changed. Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64,
and contains the time since the file was last changed, in seconds since the
UNIX epoch.

This corresponds to the traditional UNIX ctime.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_TIME_CHANGED_USEC" value="time::changed-usec" c:type="G_FILE_ATTRIBUTE_TIME_CHANGED_USEC">
      <doc xml:space="preserve">A key in the "time" namespace for getting the microseconds of the time
the file was last changed. This should be used in conjunction with
#G_FILE_ATTRIBUTE_TIME_CHANGED. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_TIME_CREATED" value="time::created" c:type="G_FILE_ATTRIBUTE_TIME_CREATED">
      <doc xml:space="preserve">A key in the "time" namespace for getting the time the file was created.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64,
and contains the time since the file was created, in seconds since the UNIX
epoch.

This corresponds to the NTFS ctime.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_TIME_CREATED_USEC" value="time::created-usec" c:type="G_FILE_ATTRIBUTE_TIME_CREATED_USEC">
      <doc xml:space="preserve">A key in the "time" namespace for getting the microseconds of the time
the file was created. This should be used in conjunction with
#G_FILE_ATTRIBUTE_TIME_CREATED. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_TIME_MODIFIED" value="time::modified" c:type="G_FILE_ATTRIBUTE_TIME_MODIFIED">
      <doc xml:space="preserve">A key in the "time" namespace for getting the time the file was last
modified. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_UINT64, and contains the time since the
file was modified, in seconds since the UNIX epoch.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_TIME_MODIFIED_USEC" value="time::modified-usec" c:type="G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC">
      <doc xml:space="preserve">A key in the "time" namespace for getting the microseconds of the time
the file was last modified. This should be used in conjunction with
#G_FILE_ATTRIBUTE_TIME_MODIFIED. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_TRASH_DELETION_DATE" value="trash::deletion-date" c:type="G_FILE_ATTRIBUTE_TRASH_DELETION_DATE" version="2.24">
      <doc xml:space="preserve">A key in the "trash" namespace.  When requested against
items in `trash:///`, will return the date and time when the file
was trashed. The format of the returned string is YYYY-MM-DDThh:mm:ss.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_TRASH_ITEM_COUNT" value="trash::item-count" c:type="G_FILE_ATTRIBUTE_TRASH_ITEM_COUNT">
      <doc xml:space="preserve">A key in the "trash" namespace.  When requested against
`trash:///` returns the number of (toplevel) items in the trash folder.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_TRASH_ORIG_PATH" value="trash::orig-path" c:type="G_FILE_ATTRIBUTE_TRASH_ORIG_PATH" version="2.24">
      <doc xml:space="preserve">A key in the "trash" namespace.  When requested against
items in `trash:///`, will return the original path to the file before it
was trashed. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_UNIX_BLOCKS" value="unix::blocks" c:type="G_FILE_ATTRIBUTE_UNIX_BLOCKS">
      <doc xml:space="preserve">A key in the "unix" namespace for getting the number of blocks allocated
for the file. This attribute is only available for UNIX file systems.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_UNIX_BLOCK_SIZE" value="unix::block-size" c:type="G_FILE_ATTRIBUTE_UNIX_BLOCK_SIZE">
      <doc xml:space="preserve">A key in the "unix" namespace for getting the block size for the file
system. This attribute is only available for UNIX file systems.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_UNIX_DEVICE" value="unix::device" c:type="G_FILE_ATTRIBUTE_UNIX_DEVICE">
      <doc xml:space="preserve">A key in the "unix" namespace for getting the device id of the device the
file is located on (see stat() documentation). This attribute is only
available for UNIX file systems. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_UNIX_GID" value="unix::gid" c:type="G_FILE_ATTRIBUTE_UNIX_GID">
      <doc xml:space="preserve">A key in the "unix" namespace for getting the group ID for the file.
This attribute is only available for UNIX file systems.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_UNIX_INODE" value="unix::inode" c:type="G_FILE_ATTRIBUTE_UNIX_INODE">
      <doc xml:space="preserve">A key in the "unix" namespace for getting the inode of the file.
This attribute is only available for UNIX file systems. Corresponding
#GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT" value="unix::is-mountpoint" c:type="G_FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT">
      <doc xml:space="preserve">A key in the "unix" namespace for checking if the file represents a
UNIX mount point. This attribute is %TRUE if the file is a UNIX mount
point. Since 2.58, `/` is considered to be a mount point.
This attribute is only available for UNIX file systems.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_UNIX_MODE" value="unix::mode" c:type="G_FILE_ATTRIBUTE_UNIX_MODE">
      <doc xml:space="preserve">A key in the "unix" namespace for getting the mode of the file
(e.g. whether the file is a regular file, symlink, etc). See lstat()
documentation. This attribute is only available for UNIX file systems.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_UNIX_NLINK" value="unix::nlink" c:type="G_FILE_ATTRIBUTE_UNIX_NLINK">
      <doc xml:space="preserve">A key in the "unix" namespace for getting the number of hard links
for a file. See lstat() documentation. This attribute is only available
for UNIX file systems. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_UNIX_RDEV" value="unix::rdev" c:type="G_FILE_ATTRIBUTE_UNIX_RDEV">
      <doc xml:space="preserve">A key in the "unix" namespace for getting the device ID for the file
(if it is a special file). See lstat() documentation. This attribute
is only available for UNIX file systems. Corresponding #GFileAttributeType
is %G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_UNIX_UID" value="unix::uid" c:type="G_FILE_ATTRIBUTE_UNIX_UID">
      <doc xml:space="preserve">A key in the "unix" namespace for getting the user ID for the file.
This attribute is only available for UNIX file systems.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <interface name="File" c:symbol-prefix="file" c:type="GFile" glib:type-name="GFile" glib:get-type="g_file_get_type" glib:type-struct="FileIface">
      <doc xml:space="preserve">#GFile is a high level abstraction for manipulating files on a
virtual file system. #GFiles are lightweight, immutable objects
that do no I/O upon creation. It is necessary to understand that
#GFile objects do not represent files, merely an identifier for a
file. All file content I/O is implemented as streaming operations
(see #GInputStream and #GOutputStream).

To construct a #GFile, you can use:
- g_file_new_for_path() if you have a path.
- g_file_new_for_uri() if you have a URI.
- g_file_new_for_commandline_arg() for a command line argument.
- g_file_new_tmp() to create a temporary file from a template.
- g_file_parse_name() from a UTF-8 string gotten from g_file_get_parse_name().
- g_file_new_build_filename() to create a file from path elements.

One way to think of a #GFile is as an abstraction of a pathname. For
normal files the system pathname is what is stored internally, but as
#GFiles are extensible it could also be something else that corresponds
to a pathname in a userspace implementation of a filesystem.

#GFiles make up hierarchies of directories and files that correspond to
the files on a filesystem. You can move through the file system with
#GFile using g_file_get_parent() to get an identifier for the parent
directory, g_file_get_child() to get a child within a directory,
g_file_resolve_relative_path() to resolve a relative path between two
#GFiles. There can be multiple hierarchies, so you may not end up at
the same root if you repeatedly call g_file_get_parent() on two different
files.

All #GFiles have a basename (get with g_file_get_basename()). These names
are byte strings that are used to identify the file on the filesystem
(relative to its parent directory) and there is no guarantees that they
have any particular charset encoding or even make any sense at all. If
you want to use filenames in a user interface you should use the display
name that you can get by requesting the
%G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME attribute with g_file_query_info().
This is guaranteed to be in UTF-8 and can be used in a user interface.
But always store the real basename or the #GFile to use to actually
access the file, because there is no way to go from a display name to
the actual name.

Using #GFile as an identifier has the same weaknesses as using a path
in that there may be multiple aliases for the same file. For instance,
hard or soft links may cause two different #GFiles to refer to the same
file. Other possible causes for aliases are: case insensitive filesystems,
short and long names on FAT/NTFS, or bind mounts in Linux. If you want to
check if two #GFiles point to the same file you can query for the
%G_FILE_ATTRIBUTE_ID_FILE attribute. Note that #GFile does some trivial
canonicalization of pathnames passed in, so that trivial differences in
the path string used at creation (duplicated slashes, slash at end of
path, "." or ".." path segments, etc) does not create different #GFiles.

Many #GFile operations have both synchronous and asynchronous versions
to suit your application. Asynchronous versions of synchronous functions
simply have _async() appended to their function names. The asynchronous
I/O functions call a #GAsyncReadyCallback which is then used to finalize
the operation, producing a GAsyncResult which is then passed to the
function's matching _finish() operation.

It is highly recommended to use asynchronous calls when running within a
shared main loop, such as in the main thread of an application. This avoids
I/O operations blocking other sources on the main loop from being dispatched.
Synchronous I/O operations should be performed from worker threads. See the
[introduction to asynchronous programming section][async-programming] for
more.

Some #GFile operations almost always take a noticeable amount of time, and
so do not have synchronous analogs. Notable cases include:
- g_file_mount_mountable() to mount a mountable file.
- g_file_unmount_mountable_with_operation() to unmount a mountable file.
- g_file_eject_mountable_with_operation() to eject a mountable file.

## Entity Tags # {#gfile-etag}

One notable feature of #GFiles are entity tags, or "etags" for
short. Entity tags are somewhat like a more abstract version of the
traditional mtime, and can be used to quickly determine if the file
has been modified from the version on the file system. See the
HTTP 1.1
[specification](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)
for HTTP Etag headers, which are a very similar concept.</doc>
      <function name="new_build_filename" c:identifier="g_file_new_build_filename" version="2.56" introspectable="0">
        <doc xml:space="preserve">Constructs a #GFile from a series of elements using the correct
separator for filenames.

Using this function is equivalent to calling g_build_filename(),
followed by g_file_new_for_path() on the result.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GFile</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <parameter name="first_element" transfer-ownership="none">
            <doc xml:space="preserve">the first element in the path</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">remaining elements in path, terminated by %NULL</doc>
            <varargs/>
          </parameter>
        </parameters>
      </function>
      <function name="new_for_commandline_arg" c:identifier="g_file_new_for_commandline_arg">
        <doc xml:space="preserve">Creates a #GFile with the given argument from the command line.
The value of @arg can be either a URI, an absolute path or a
relative path resolved relative to the current working directory.
This operation never fails, but the returned object might not
support any I/O operation if @arg points to a malformed path.

Note that on Windows, this function expects its argument to be in
UTF-8 -- not the system code page.  This means that you
should not use this function with string from argv as it is passed
to main().  g_win32_get_command_line() will return a UTF-8 version of
the commandline.  #GApplication also uses UTF-8 but
g_application_command_line_create_file_for_arg() may be more useful
for you there.  It is also always possible to use this function with
#GOptionContext arguments of type %G_OPTION_ARG_FILENAME.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GFile.
   Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <parameter name="arg" transfer-ownership="none">
            <doc xml:space="preserve">a command line string</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_for_commandline_arg_and_cwd" c:identifier="g_file_new_for_commandline_arg_and_cwd" version="2.36">
        <doc xml:space="preserve">Creates a #GFile with the given argument from the command line.

This function is similar to g_file_new_for_commandline_arg() except
that it allows for passing the current working directory as an
argument instead of using the current working directory of the
process.

This is useful if the commandline argument was given in a context
other than the invocation of the current process.

See also g_application_command_line_create_file_for_arg().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GFile</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <parameter name="arg" transfer-ownership="none">
            <doc xml:space="preserve">a command line string</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
          <parameter name="cwd" transfer-ownership="none">
            <doc xml:space="preserve">the current working directory of the commandline</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_for_path" c:identifier="g_file_new_for_path">
        <doc xml:space="preserve">Constructs a #GFile for a given path. This operation never
fails, but the returned object might not support any I/O
operation if @path is malformed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GFile for the given @path.
  Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a string containing a relative or absolute path.
    The string must be encoded in the glib filename encoding.</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_for_uri" c:identifier="g_file_new_for_uri">
        <doc xml:space="preserve">Constructs a #GFile for a given URI. This operation never
fails, but the returned object might not support any I/O
operation if @uri is malformed or if the uri type is
not supported.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GFile for the given @uri.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a UTF-8 string containing a URI</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_tmp" c:identifier="g_file_new_tmp" version="2.32" throws="1">
        <doc xml:space="preserve">Opens a file in the preferred directory for temporary files (as
returned by g_get_tmp_dir()) and returns a #GFile and
#GFileIOStream pointing to it.

@tmpl should be a string in the GLib file name encoding
containing a sequence of six 'X' characters, and containing no
directory components. If it is %NULL, a default template is used.

Unlike the other #GFile constructors, this will return %NULL if
a temporary file could not be created.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GFile.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <parameter name="tmpl" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Template for the file
  name, as in g_file_open_tmp(), or %NULL for a default template</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
          <parameter name="iostream" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">on return, a #GFileIOStream for the created file</doc>
            <type name="FileIOStream" c:type="GFileIOStream**"/>
          </parameter>
        </parameters>
      </function>
      <function name="parse_name" c:identifier="g_file_parse_name">
        <doc xml:space="preserve">Constructs a #GFile with the given @parse_name (i.e. something
given by g_file_get_parse_name()). This operation never fails,
but the returned object might not support any I/O operation if
the @parse_name cannot be parsed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GFile.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <parameter name="parse_name" transfer-ownership="none">
            <doc xml:space="preserve">a file name or path to be parsed</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="append_to" invoker="append_to" throws="1">
        <doc xml:space="preserve">Gets an output stream for appending data to the file.
If the file doesn't already exist it is created.

By default files created are generally readable by everyone,
but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
will be made readable only to the current user, to the level that
is supported on the target filesystem.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

Some file systems don't allow all file names, and may return an
%G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
%G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are
possible too, and depend on what kind of filesystem the file is on.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileOutputStream, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="append_to_async" invoker="append_to_async">
        <doc xml:space="preserve">Asynchronously opens @file for appending.

For more details, see g_file_append_to() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_append_to_finish() to get the result
of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="append_to_finish" invoker="append_to_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous file append operation started with
g_file_append_to_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a valid #GFileOutputStream
    or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">#GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="copy" invoker="copy" throws="1">
        <doc xml:space="preserve">Copies the file @source to the location specified by @destination.
Can not handle recursive copies of directories.

If the flag #G_FILE_COPY_OVERWRITE is specified an already
existing @destination file is overwritten.

If the flag #G_FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks
will be copied as symlinks, otherwise the target of the
@source symlink will be copied.

If the flag #G_FILE_COPY_ALL_METADATA is specified then all the metadata
that is possible to copy is copied, not just the default subset (which,
for instance, does not include the owner, see #GFileInfo).

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

If @progress_callback is not %NULL, then the operation can be monitored
by setting this to a #GFileProgressCallback function.
@progress_callback_data will be passed to this function. It is guaranteed
that this callback will be called after all data has been transferred with
the total number of bytes copied during the operation.

If the @source file does not exist, then the %G_IO_ERROR_NOT_FOUND error
is returned, independent on the status of the @destination.

If #G_FILE_COPY_OVERWRITE is not specified and the target exists, then
the error %G_IO_ERROR_EXISTS is returned.

If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
error is returned. If trying to overwrite a directory with a directory the
%G_IO_ERROR_WOULD_MERGE error is returned.

If the source is a directory and the target does not exist, or
#G_FILE_COPY_OVERWRITE is specified and the target is a file, then the
%G_IO_ERROR_WOULD_RECURSE error is returned.

If you are interested in copying the #GFile object itself (not the on-disk
file), see g_file_dup().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="destination" transfer-ownership="none">
            <doc xml:space="preserve">destination #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">set of #GFileCopyFlags</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="4">
            <doc xml:space="preserve">function to callback with
    progress information, or %NULL if progress information is not needed</doc>
            <type name="FileProgressCallback" c:type="GFileProgressCallback"/>
          </parameter>
          <parameter name="progress_callback_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to @progress_callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="copy_async" invoker="copy_async">
        <doc xml:space="preserve">Copies the file @source to the location specified by @destination
asynchronously. For details of the behaviour, see g_file_copy().

If @progress_callback is not %NULL, then that function that will be called
just like in g_file_copy(). The callback will run in the default main context
of the thread calling g_file_copy_async() &#x2014; the same context as @callback is
run in.

When the operation is finished, @callback will be called. You can then call
g_file_copy_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="destination" transfer-ownership="none">
            <doc xml:space="preserve">destination #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">set of #GFileCopyFlags</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="5">
            <doc xml:space="preserve">function to callback with progress
    information, or %NULL if progress information is not needed</doc>
            <type name="FileProgressCallback" c:type="GFileProgressCallback"/>
          </parameter>
          <parameter name="progress_callback_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">user data to pass to @progress_callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="7">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="copy_finish" invoker="copy_finish" throws="1">
        <doc xml:space="preserve">Finishes copying the file started with g_file_copy_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a %TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create" invoker="create" throws="1">
        <doc xml:space="preserve">Creates a new file and returns an output stream for writing to it.
The file must not already exist.

By default files created are generally readable by everyone,
but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
will be made readable only to the current user, to the level
that is supported on the target filesystem.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

If a file or directory with this name already exists the
%G_IO_ERROR_EXISTS error will be returned. Some file systems don't
allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
error, and if the name is to long %G_IO_ERROR_FILENAME_TOO_LONG will
be returned. Other errors are possible too, and depend on what kind
of filesystem the file is on.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileOutputStream for the newly created
    file, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_async" invoker="create_async">
        <doc xml:space="preserve">Asynchronously creates a new file and returns an output stream
for writing to it. The file must not already exist.

For more details, see g_file_create() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_create_finish() to get the result
of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_finish" invoker="create_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous file create operation started with
g_file_create_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileOutputStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_readwrite" invoker="create_readwrite" version="2.22" throws="1">
        <doc xml:space="preserve">Creates a new file and returns a stream for reading and
writing to it. The file must not already exist.

By default files created are generally readable by everyone,
but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
will be made readable only to the current user, to the level
that is supported on the target filesystem.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

If a file or directory with this name already exists, the
%G_IO_ERROR_EXISTS error will be returned. Some file systems don't
allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
error, and if the name is too long, %G_IO_ERROR_FILENAME_TOO_LONG
will be returned. Other errors are possible too, and depend on what
kind of filesystem the file is on.

Note that in many non-local file cases read and write streams are
not supported, so make sure you really need to do read and write
streaming, rather than just opening for reading or writing.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileIOStream for the newly created
    file, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileIOStream" c:type="GFileIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_readwrite_async" invoker="create_readwrite_async" version="2.22">
        <doc xml:space="preserve">Asynchronously creates a new file and returns a stream
for reading and writing to it. The file must not already exist.

For more details, see g_file_create_readwrite() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_create_readwrite_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_readwrite_finish" invoker="create_readwrite_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous file create operation started with
g_file_create_readwrite_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileIOStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileIOStream" c:type="GFileIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="delete_file" invoker="delete" throws="1">
        <doc xml:space="preserve">Deletes a file. If the @file is a directory, it will only be
deleted if it is empty. This has the same semantics as g_unlink().

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the file was deleted. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="delete_file_async" invoker="delete_async" version="2.34">
        <doc xml:space="preserve">Asynchronously delete a file. If the @file is a directory, it will
only be deleted if it is empty.  This has the same semantics as
g_unlink().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="delete_file_finish" invoker="delete_finish" version="2.34" throws="1">
        <doc xml:space="preserve">Finishes deleting a file started with g_file_delete_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the file was deleted. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dup" invoker="dup">
        <doc xml:space="preserve">Duplicates a #GFile handle. This operation does not duplicate
the actual file or directory represented by the #GFile; see
g_file_copy() if attempting to copy a file.

g_file_dup() is useful when a second handle is needed to the same underlying
file, for use in a separate thread (#GFile is not thread-safe). For use
within the same thread, use g_object_ref() to increment the existing object&#x2019;s
reference count.

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GFile that is a duplicate
    of the given #GFile.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_mountable" invoker="eject_mountable" deprecated="1" deprecated-version="2.22">
        <doc xml:space="preserve">Starts an asynchronous eject on a mountable.
When this operation has completed, @callback will be called with
@user_user data, and the operation can be finalized with
g_file_eject_mountable_finish().

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <doc-deprecated xml:space="preserve">Use g_file_eject_mountable_with_operation() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_mountable_finish" invoker="eject_mountable_finish" deprecated="1" deprecated-version="2.22" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous eject operation started by
g_file_eject_mountable().</doc>
        <doc-deprecated xml:space="preserve">Use g_file_eject_mountable_with_operation_finish()
    instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @file was ejected successfully.
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_mountable_with_operation" invoker="eject_mountable_with_operation" version="2.22">
        <doc xml:space="preserve">Starts an asynchronous eject on a mountable.
When this operation has completed, @callback will be called with
@user_user data, and the operation can be finalized with
g_file_eject_mountable_with_operation_finish().

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation,
    or %NULL to avoid user interaction</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_mountable_with_operation_finish" invoker="eject_mountable_with_operation_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous eject operation started by
g_file_eject_mountable_with_operation().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @file was ejected successfully.
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="enumerate_children" invoker="enumerate_children" throws="1">
        <doc xml:space="preserve">Gets the requested information about the files in a directory.
The result is a #GFileEnumerator object that will give out
#GFileInfo objects for all the files in the directory.

The @attributes value is a string that specifies the file
attributes that should be gathered. It is not an error if
it's not possible to read a particular requested attribute
from a file - it just won't be set. @attributes should
be a comma-separated list of attributes or attribute wildcards.
The wildcard "*" means all attributes, and a wildcard like
"standard::*" means all attributes in the standard namespace.
An example attribute query be "standard::*,owner::user".
The standard attributes are available as defines, like
#G_FILE_ATTRIBUTE_STANDARD_NAME.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
be returned. If the file is not a directory, the %G_IO_ERROR_NOT_DIRECTORY
error will be returned. Other errors are possible too.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GFileEnumerator if successful,
    %NULL on error. Free the returned object with g_object_unref().</doc>
          <type name="FileEnumerator" c:type="GFileEnumerator*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">an attribute query string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="enumerate_children_async" invoker="enumerate_children_async">
        <doc xml:space="preserve">Asynchronously gets the requested information about the files
in a directory. The result is a #GFileEnumerator object that will
give out #GFileInfo objects for all the files in the directory.

For more details, see g_file_enumerate_children() which is
the synchronous version of this call.

When the operation is finished, @callback will be called. You can
then call g_file_enumerate_children_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">an attribute query string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the
    request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="enumerate_children_finish" invoker="enumerate_children_finish" throws="1">
        <doc xml:space="preserve">Finishes an async enumerate children operation.
See g_file_enumerate_children_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileEnumerator or %NULL
    if an error occurred.
    Free the returned object with g_object_unref().</doc>
          <type name="FileEnumerator" c:type="GFileEnumerator*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="equal" invoker="equal">
        <doc xml:space="preserve">Checks if the two given #GFiles refer to the same file.

Note that two #GFiles that differ can still refer to the same
file on the filesystem due to various forms of filename
aliasing.

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @file1 and @file2 are equal.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file1" transfer-ownership="none">
            <doc xml:space="preserve">the first #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="file2" transfer-ownership="none">
            <doc xml:space="preserve">the second #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="find_enclosing_mount" invoker="find_enclosing_mount" throws="1">
        <doc xml:space="preserve">Gets a #GMount for the #GFile.

If the #GFileIface for @file does not have a mount (e.g.
possibly a remote share), @error will be set to %G_IO_ERROR_NOT_FOUND
and %NULL will be returned.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GMount where the @file is located
    or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="Mount" c:type="GMount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="find_enclosing_mount_async" invoker="find_enclosing_mount_async">
        <doc xml:space="preserve">Asynchronously gets the mount for the file.

For more details, see g_file_find_enclosing_mount() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_find_enclosing_mount_finish() to
get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="find_enclosing_mount_finish" invoker="find_enclosing_mount_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous find mount request.
See g_file_find_enclosing_mount_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GMount for given @file or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="Mount" c:type="GMount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_basename">
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_child_for_display_name" invoker="get_child_for_display_name" throws="1">
        <doc xml:space="preserve">Gets the child of @file for a given @display_name (i.e. a UTF-8
version of the name). If this function fails, it returns %NULL
and @error will be set. This is very useful when constructing a
#GFile for a new file and the user entered the filename in the
user interface, for instance when you select a directory and
type a filename in the file selector.

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFile to the specified child, or
    %NULL if the display name couldn't be converted.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:space="preserve">string to a possible child</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_parent" invoker="get_parent">
        <doc xml:space="preserve">Gets the parent directory for the @file.
If the @file represents the root directory of the
file system, then %NULL will be returned.

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #GFile structure to the
    parent of the given #GFile or %NULL if there is no parent. Free
    the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_parse_name" invoker="get_parse_name">
        <doc xml:space="preserve">Gets the parse name of the @file.
A parse name is a UTF-8 string that describes the
file such that one can get the #GFile back using
g_file_parse_name().

This is generally used to show the #GFile as a nice
full-pathname kind of string in a user interface,
like in a location entry.

For local files with names that can safely be converted
to UTF-8 the pathname is used, otherwise the IRI is used
(a form of URI that allows UTF-8 characters unescaped).

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a string containing the #GFile's parse name.
    The returned string should be freed with g_free()
    when no longer needed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_path">
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_relative_path">
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="parent" transfer-ownership="none">
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="descendant" transfer-ownership="none">
            <type name="File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_uri" invoker="get_uri">
        <doc xml:space="preserve">Gets the URI for the @file.

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a string containing the #GFile's URI.
    The returned string should be freed with g_free()
    when no longer needed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_uri_scheme" invoker="get_uri_scheme">
        <doc xml:space="preserve">Gets the URI scheme for a #GFile.
RFC 3986 decodes the scheme as:
|[
URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
]|
Common schemes include "file", "http", "ftp", etc.

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a string containing the URI scheme for the given
    #GFile. The returned string should be freed with g_free()
    when no longer needed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="has_uri_scheme" invoker="has_uri_scheme">
        <doc xml:space="preserve">Checks to see if a #GFile has a given URI scheme.

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if #GFile's backend supports the
    given URI scheme, %FALSE if URI scheme is %NULL,
    not supported, or #GFile is invalid.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="uri_scheme" transfer-ownership="none">
            <doc xml:space="preserve">a string containing a URI scheme</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="hash" invoker="hash">
        <doc xml:space="preserve">Creates a hash value for a #GFile.

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 if @file is not a valid #GFile, otherwise an
    integer that can be used as hash value for the #GFile.
    This function is intended for easily hashing a #GFile to
    add to a #GHashTable or similar data structure.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">#gconstpointer to a #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_native" invoker="is_native">
        <doc xml:space="preserve">Checks to see if a file is native to the platform.

A native file is one expressed in the platform-native filename format,
e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
as it might be on a locally mounted remote filesystem.

On some systems non-native files may be available using the native
filesystem via a userspace filesystem (FUSE), in these cases this call
will return %FALSE, but g_file_get_path() will still return a native path.

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @file is native</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="make_directory" invoker="make_directory" throws="1">
        <doc xml:space="preserve">Creates a directory. Note that this will only create a child directory
of the immediate parent directory of the path or URI given by the #GFile.
To recursively create directories, see g_file_make_directory_with_parents().
This function will fail if the parent directory does not exist, setting
@error to %G_IO_ERROR_NOT_FOUND. If the file system doesn't support
creating directories, this function will fail, setting @error to
%G_IO_ERROR_NOT_SUPPORTED.

For a local #GFile the newly created directory will have the default
(current) ownership and permissions of the current process.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on successful creation, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="make_directory_async" invoker="make_directory_async" version="2.38">
        <doc xml:space="preserve">Asynchronously creates a directory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="make_directory_finish" invoker="make_directory_finish" version="2.38" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous directory creation, started with
g_file_make_directory_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on successful directory creation, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="make_symbolic_link" invoker="make_symbolic_link" throws="1">
        <doc xml:space="preserve">Creates a symbolic link named @file which contains the string
@symlink_value.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on the creation of a new symlink, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile with the name of the symlink to create</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="symlink_value" transfer-ownership="none">
            <doc xml:space="preserve">a string with the path for the target
    of the new symlink</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="measure_disk_usage" invoker="measure_disk_usage" version="2.38" introspectable="0" throws="1">
        <doc xml:space="preserve">Recursively measures the disk usage of @file.

This is essentially an analog of the 'du' command, but it also
reports the number of directories and non-directory files encountered
(including things like symbolic links).

By default, errors are only reported against the toplevel file
itself.  Errors found while recursing are silently ignored, unless
%G_FILE_DISK_USAGE_REPORT_ALL_ERRORS is given in @flags.

The returned size, @disk_usage, is in bytes and should be formatted
with g_format_size() in order to get something reasonable for showing
in a user interface.

@progress_callback and @progress_data can be given to request
periodic progress updates while scanning.  See the documentation for
#GFileMeasureProgressCallback for information about when and how the
callback will be invoked.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if successful, with the out parameters set.
         %FALSE otherwise, with @error set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">#GFileMeasureFlags</doc>
            <type name="FileMeasureFlags" c:type="GFileMeasureFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">a #GFileMeasureProgressCallback</doc>
            <type name="FileMeasureProgressCallback" c:type="GFileMeasureProgressCallback"/>
          </parameter>
          <parameter name="progress_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user_data for @progress_callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="disk_usage" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the number of bytes of disk space used</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="num_dirs" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the number of directories encountered</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="num_files" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the number of non-directories encountered</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="measure_disk_usage_async" invoker="measure_disk_usage_async" version="2.38" introspectable="0">
        <doc xml:space="preserve">Recursively measures the disk usage of @file.

This is the asynchronous version of g_file_measure_disk_usage().  See
there for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">#GFileMeasureFlags</doc>
            <type name="FileMeasureFlags" c:type="GFileMeasureFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">a #GFileMeasureProgressCallback</doc>
            <type name="FileMeasureProgressCallback" c:type="GFileMeasureProgressCallback"/>
          </parameter>
          <parameter name="progress_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user_data for @progress_callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when complete</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="measure_disk_usage_finish" invoker="measure_disk_usage_finish" version="2.38" throws="1">
        <doc xml:space="preserve">Collects the results from an earlier call to
g_file_measure_disk_usage_async().  See g_file_measure_disk_usage() for
more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if successful, with the out parameters set.
         %FALSE otherwise, with @error set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="disk_usage" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the number of bytes of disk space used</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="num_dirs" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the number of directories encountered</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="num_files" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the number of non-directories encountered</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="monitor_dir" invoker="monitor_directory" throws="1">
        <doc xml:space="preserve">Obtains a directory monitor for the given file.
This may fail if directory monitoring is not supported.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

It does not make sense for @flags to contain
%G_FILE_MONITOR_WATCH_HARD_LINKS, since hard links can not be made to
directories.  It is not possible to monitor all the files in a
directory for changes made via hard links; if you want to do this then
you must register individual watches with g_file_monitor().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileMonitor for the given @file,
    or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileMonitor" c:type="GFileMonitor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileMonitorFlags</doc>
            <type name="FileMonitorFlags" c:type="GFileMonitorFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="monitor_file" invoker="monitor_file" throws="1">
        <doc xml:space="preserve">Obtains a file monitor for the given file. If no file notification
mechanism exists, then regular polling of the file is used.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

If @flags contains %G_FILE_MONITOR_WATCH_HARD_LINKS then the monitor
will also attempt to report changes made to the file via another
filename (ie, a hard link). Without this flag, you can only rely on
changes made through the filename contained in @file to be
reported. Using this flag may result in an increase in resource
usage, and may not have any effect depending on the #GFileMonitor
backend and/or filesystem type.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileMonitor for the given @file,
    or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileMonitor" c:type="GFileMonitor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileMonitorFlags</doc>
            <type name="FileMonitorFlags" c:type="GFileMonitorFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="mount_enclosing_volume" invoker="mount_enclosing_volume">
        <doc xml:space="preserve">Starts a @mount_operation, mounting the volume that contains
the file @location.

When this operation has completed, @callback will be called with
@user_user data, and the operation can be finalized with
g_file_mount_enclosing_volume_finish().

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="location" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the operation</doc>
            <type name="MountMountFlags" c:type="GMountMountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation
    or %NULL to avoid user interaction</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="mount_enclosing_volume_finish" invoker="mount_enclosing_volume_finish" throws="1">
        <doc xml:space="preserve">Finishes a mount operation started by g_file_mount_enclosing_volume().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if successful. If an error has occurred,
    this function will return %FALSE and set @error
    appropriately if present.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="location" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="mount_mountable" invoker="mount_mountable">
        <doc xml:space="preserve">Mounts a file of type G_FILE_TYPE_MOUNTABLE.
Using @mount_operation, you can request callbacks when, for instance,
passwords are needed during authentication.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

When the operation is finished, @callback will be called.
You can then call g_file_mount_mountable_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the operation</doc>
            <type name="MountMountFlags" c:type="GMountMountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation,
    or %NULL to avoid user interaction</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="mount_mountable_finish" invoker="mount_mountable_finish" throws="1">
        <doc xml:space="preserve">Finishes a mount operation. See g_file_mount_mountable() for details.

Finish an asynchronous mount operation that was started
with g_file_mount_mountable().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFile or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="move" invoker="move" throws="1">
        <doc xml:space="preserve">Tries to move the file or directory @source to the location specified
by @destination. If native move operations are supported then this is
used, otherwise a copy + delete fallback is used. The native
implementation may support moving directories (for instance on moves
inside the same filesystem), but the fallback code does not.

If the flag #G_FILE_COPY_OVERWRITE is specified an already
existing @destination file is overwritten.

If the flag #G_FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks
will be copied as symlinks, otherwise the target of the
@source symlink will be copied.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

If @progress_callback is not %NULL, then the operation can be monitored
by setting this to a #GFileProgressCallback function.
@progress_callback_data will be passed to this function. It is
guaranteed that this callback will be called after all data has been
transferred with the total number of bytes copied during the operation.

If the @source file does not exist, then the %G_IO_ERROR_NOT_FOUND
error is returned, independent on the status of the @destination.

If #G_FILE_COPY_OVERWRITE is not specified and the target exists,
then the error %G_IO_ERROR_EXISTS is returned.

If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
error is returned. If trying to overwrite a directory with a directory the
%G_IO_ERROR_WOULD_MERGE error is returned.

If the source is a directory and the target does not exist, or
#G_FILE_COPY_OVERWRITE is specified and the target is a file, then
the %G_IO_ERROR_WOULD_RECURSE error may be returned (if the native
move operation isn't available).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on successful move, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">#GFile pointing to the source location</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="destination" transfer-ownership="none">
            <doc xml:space="preserve">#GFile pointing to the destination location</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">set of #GFileCopyFlags</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="4">
            <doc xml:space="preserve">#GFileProgressCallback
    function for updates</doc>
            <type name="FileProgressCallback" c:type="GFileProgressCallback"/>
          </parameter>
          <parameter name="progress_callback_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">gpointer to user data for
    the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="open_readwrite" invoker="open_readwrite" version="2.22" throws="1">
        <doc xml:space="preserve">Opens an existing file for reading and writing. The result is
a #GFileIOStream that can be used to read and write the contents
of the file.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
be returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
error will be returned. Other errors are possible too, and depend on
what kind of filesystem the file is on. Note that in many non-local
file cases read and write streams are not supported, so make sure you
really need to do read and write streaming, rather than just opening
for reading or writing.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GFileIOStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileIOStream" c:type="GFileIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">#GFile to open</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="open_readwrite_async" invoker="open_readwrite_async" version="2.22">
        <doc xml:space="preserve">Asynchronously opens @file for reading and writing.

For more details, see g_file_open_readwrite() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_open_readwrite_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="open_readwrite_finish" invoker="open_readwrite_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous file read operation started with
g_file_open_readwrite_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileIOStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileIOStream" c:type="GFileIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="poll_mountable" invoker="poll_mountable" version="2.22">
        <doc xml:space="preserve">Polls a file of type #G_FILE_TYPE_MOUNTABLE.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

When the operation is finished, @callback will be called.
You can then call g_file_mount_mountable_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="poll_mountable_finish" invoker="poll_mountable_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes a poll operation. See g_file_poll_mountable() for details.

Finish an asynchronous poll operation that was polled
with g_file_poll_mountable().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation finished successfully. %FALSE
otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="prefix_matches" invoker="has_prefix">
        <doc xml:space="preserve">Checks whether @file has the prefix specified by @prefix.

In other words, if the names of initial elements of @file's
pathname match @prefix. Only full pathname elements are matched,
so a path like /foo is not considered a prefix of /foobar, only
of /foo/bar.

A #GFile is not a prefix of itself. If you want to check for
equality, use g_file_equal().

This call does no I/O, as it works purely on names. As such it can
sometimes return %FALSE even if @file is inside a @prefix (from a
filesystem point of view), because the prefix of @file is an alias
of @prefix.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @files's parent, grandparent, etc is @prefix,
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="prefix" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_filesystem_info" invoker="query_filesystem_info" throws="1">
        <doc xml:space="preserve">Similar to g_file_query_info(), but obtains information
about the filesystem the @file is on, rather than the file itself.
For instance the amount of space available and the type of
the filesystem.

The @attributes value is a string that specifies the attributes
that should be gathered. It is not an error if it's not possible
to read a particular requested attribute from a file - it just
won't be set. @attributes should be a comma-separated list of
attributes or attribute wildcards. The wildcard "*" means all
attributes, and a wildcard like "filesystem::*" means all attributes
in the filesystem namespace. The standard namespace for filesystem
attributes is "filesystem". Common attributes of interest are
#G_FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem
in bytes), #G_FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes available),
and #G_FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
be returned. Other errors are possible too, and depend on what
kind of filesystem the file is on.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileInfo or %NULL if there was an error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">an attribute query string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_filesystem_info_async" invoker="query_filesystem_info_async">
        <doc xml:space="preserve">Asynchronously gets the requested information about the filesystem
that the specified @file is on. The result is a #GFileInfo object
that contains key-value attributes (such as type or size for the
file).

For more details, see g_file_query_filesystem_info() which is the
synchronous version of this call.

When the operation is finished, @callback will be called. You can
then call g_file_query_info_finish() to get the result of the
operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">an attribute query string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_filesystem_info_finish" invoker="query_filesystem_info_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous filesystem info query.
See g_file_query_filesystem_info_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GFileInfo for given @file
    or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_info" invoker="query_info" throws="1">
        <doc xml:space="preserve">Gets the requested information about specified @file.
The result is a #GFileInfo object that contains key-value
attributes (such as the type or size of the file).

The @attributes value is a string that specifies the file
attributes that should be gathered. It is not an error if
it's not possible to read a particular requested attribute
from a file - it just won't be set. @attributes should be a
comma-separated list of attributes or attribute wildcards.
The wildcard "*" means all attributes, and a wildcard like
"standard::*" means all attributes in the standard namespace.
An example attribute query be "standard::*,owner::user".
The standard attributes are available as defines, like
#G_FILE_ATTRIBUTE_STANDARD_NAME.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

For symlinks, normally the information about the target of the
symlink is returned, rather than information about the symlink
itself. However if you pass #G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS
in @flags the information about the symlink itself will be returned.
Also, for symlinks that point to non-existing files the information
about the symlink itself will be returned.

If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
returned. Other errors are possible too, and depend on what kind of
filesystem the file is on.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileInfo for the given @file, or %NULL
    on error. Free the returned object with g_object_unref().</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">an attribute query string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_info_async" invoker="query_info_async">
        <doc xml:space="preserve">Asynchronously gets the requested information about specified @file.
The result is a #GFileInfo object that contains key-value attributes
(such as type or size for the file).

For more details, see g_file_query_info() which is the synchronous
version of this call.

When the operation is finished, @callback will be called. You can
then call g_file_query_info_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">an attribute query string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the
    request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_info_finish" invoker="query_info_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous file info query.
See g_file_query_info_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GFileInfo for given @file
    or %NULL on error. Free the returned object with
    g_object_unref().</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_settable_attributes" invoker="query_settable_attributes" throws="1">
        <doc xml:space="preserve">Obtain the list of settable attributes for the file.

Returns the type and full attribute name of all the attributes
that can be set on this file. This doesn't mean setting it will
always succeed though, you might get an access failure, or some
specific file may not support a specific attribute.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileAttributeInfoList describing the settable attributes.
    When you are done with it, release it with
    g_file_attribute_info_list_unref()</doc>
          <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_writable_namespaces" invoker="query_writable_namespaces" throws="1">
        <doc xml:space="preserve">Obtain the list of attribute namespaces where new attributes
can be created by a user. An example of this is extended
attributes (in the "xattr" namespace).

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileAttributeInfoList describing the writable namespaces.
    When you are done with it, release it with
    g_file_attribute_info_list_unref()</doc>
          <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read_async" invoker="read_async">
        <doc xml:space="preserve">Asynchronously opens @file for reading.

For more details, see g_file_read() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_read_finish() to get the result
of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read_finish" invoker="read_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous file read operation started with
g_file_read_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileInputStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileInputStream" c:type="GFileInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read_fn" invoker="read" throws="1">
        <doc xml:space="preserve">Opens a file for reading. The result is a #GFileInputStream that
can be used to read the contents of the file.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
error will be returned. Other errors are possible too, and depend
on what kind of filesystem the file is on.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GFileInputStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileInputStream" c:type="GFileInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">#GFile to read</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="replace" invoker="replace" throws="1">
        <doc xml:space="preserve">Returns an output stream for overwriting the file, possibly
creating a backup copy of the file first. If the file doesn't exist,
it will be created.

This will try to replace the file in the safest way possible so
that any errors during the writing will not affect an already
existing copy of the file. For instance, for local files it
may write to a temporary file and then atomically rename over
the destination when the stream is closed.

By default files created are generally readable by everyone,
but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
will be made readable only to the current user, to the level that
is supported on the target filesystem.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

If you pass in a non-%NULL @etag value and @file already exists, then
this value is compared to the current entity tag of the file, and if
they differ an %G_IO_ERROR_WRONG_ETAG error is returned. This
generally means that the file has been changed since you last read
it. You can get the new etag from g_file_output_stream_get_etag()
after you've finished writing and closed the #GFileOutputStream. When
you load a new file you can use g_file_input_stream_query_info() to
get the etag of the file.

If @make_backup is %TRUE, this function will attempt to make a
backup of the current file before overwriting it. If this fails
a %G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you
want to replace anyway, try again with @make_backup set to %FALSE.

If the file is a directory the %G_IO_ERROR_IS_DIRECTORY error will
be returned, and if the file is some other form of non-regular file
then a %G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some
file systems don't allow all file names, and may return an
%G_IO_ERROR_INVALID_FILENAME error, and if the name is to long
%G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are
possible too, and depend on what kind of filesystem the file is on.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileOutputStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an optional [entity tag][gfile-etag]
    for the current #GFile, or #NULL to ignore</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="make_backup" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="replace_async" invoker="replace_async">
        <doc xml:space="preserve">Asynchronously overwrites the file, replacing the contents,
possibly creating a backup copy of the file first.

For more details, see g_file_replace() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_replace_finish() to get the result
of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an [entity tag][gfile-etag] for the current #GFile,
    or %NULL to ignore</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="make_backup" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="replace_finish" invoker="replace_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous file replace operation started with
g_file_replace_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileOutputStream, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="replace_readwrite" invoker="replace_readwrite" version="2.22" throws="1">
        <doc xml:space="preserve">Returns an output stream for overwriting the file in readwrite mode,
possibly creating a backup copy of the file first. If the file doesn't
exist, it will be created.

For details about the behaviour, see g_file_replace() which does the
same thing but returns an output stream only.

Note that in many non-local file cases read and write streams are not
supported, so make sure you really need to do read and write streaming,
rather than just opening for reading or writing.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileIOStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileIOStream" c:type="GFileIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an optional [entity tag][gfile-etag]
    for the current #GFile, or #NULL to ignore</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="make_backup" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="replace_readwrite_async" invoker="replace_readwrite_async" version="2.22">
        <doc xml:space="preserve">Asynchronously overwrites the file in read-write mode,
replacing the contents, possibly creating a backup copy
of the file first.

For more details, see g_file_replace_readwrite() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_replace_readwrite_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an [entity tag][gfile-etag] for the current #GFile,
    or %NULL to ignore</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="make_backup" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="replace_readwrite_finish" invoker="replace_readwrite_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous file replace operation started with
g_file_replace_readwrite_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileIOStream, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileIOStream" c:type="GFileIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="resolve_relative_path" invoker="resolve_relative_path">
        <doc xml:space="preserve">Resolves a relative path for @file to an absolute path.

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GFile to the resolved path.
    %NULL if @relative_path is %NULL or if @file is invalid.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="relative_path" transfer-ownership="none">
            <doc xml:space="preserve">a given relative path string</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_attribute" invoker="set_attribute" throws="1">
        <doc xml:space="preserve">Sets an attribute in the file with attribute name @attribute to @value.

Some attributes can be unset by setting @type to
%G_FILE_ATTRIBUTE_TYPE_INVALID and @value_p to %NULL.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the attribute was set, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a string containing the attribute's name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">The type of the attribute</doc>
            <type name="FileAttributeType" c:type="GFileAttributeType"/>
          </parameter>
          <parameter name="value_p" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a pointer to the value (or the pointer
    itself if the type is a pointer type)</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_attributes_async" invoker="set_attributes_async">
        <doc xml:space="preserve">Asynchronously sets the attributes of @file with @info.

For more details, see g_file_set_attributes_from_info(),
which is the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_set_attributes_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
            <doc xml:space="preserve">a #gpointer</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_attributes_finish" invoker="set_attributes_finish" throws="1">
        <doc xml:space="preserve">Finishes setting an attribute started in g_file_set_attributes_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the attributes were set correctly, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="info" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_attributes_from_info" invoker="set_attributes_from_info" throws="1">
        <doc xml:space="preserve">Tries to set all attributes in the #GFileInfo on the target
values, not stopping on the first error.

If there is any error during this operation then @error will
be set to the first error. Error on particular fields are flagged
by setting the "status" field in the attribute value to
%G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can
also detect further errors.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%FALSE if there was any error, %TRUE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">#GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_display_name" invoker="set_display_name" throws="1">
        <doc xml:space="preserve">Renames @file to the specified display name.

The display name is converted from UTF-8 to the correct encoding
for the target filesystem if possible and the @file is renamed to this.

If you want to implement a rename operation in the user interface the
edit name (#G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the
initial value in the rename widget, and then the result after editing
should be passed to g_file_set_display_name().

On success the resulting converted filename is returned.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFile specifying what @file was renamed to,
    or %NULL if there was an error.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:space="preserve">a string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_display_name_async" invoker="set_display_name_async">
        <doc xml:space="preserve">Asynchronously sets the display name for a given #GFile.

For more details, see g_file_set_display_name() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_set_display_name_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:space="preserve">a string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_display_name_finish" invoker="set_display_name_finish" throws="1">
        <doc xml:space="preserve">Finishes setting a display name started with
g_file_set_display_name_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFile or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start_mountable" invoker="start_mountable" version="2.22">
        <doc xml:space="preserve">Starts a file of type #G_FILE_TYPE_MOUNTABLE.
Using @start_operation, you can request callbacks when, for instance,
passwords are needed during authentication.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

When the operation is finished, @callback will be called.
You can then call g_file_mount_mountable_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the operation</doc>
            <type name="DriveStartFlags" c:type="GDriveStartFlags"/>
          </parameter>
          <parameter name="start_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation, or %NULL to avoid user interaction</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start_mountable_finish" invoker="start_mountable_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes a start operation. See g_file_start_mountable() for details.

Finish an asynchronous start operation that was started
with g_file_start_mountable().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation finished successfully. %FALSE
otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="stop_mountable" invoker="stop_mountable" version="2.22">
        <doc xml:space="preserve">Stops a file of type #G_FILE_TYPE_MOUNTABLE.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

When the operation is finished, @callback will be called.
You can then call g_file_stop_mountable_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation,
    or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="stop_mountable_finish" invoker="stop_mountable_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes an stop operation, see g_file_stop_mountable() for details.

Finish an asynchronous stop operation that was started
with g_file_stop_mountable().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation finished successfully.
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="trash" invoker="trash" throws="1">
        <doc xml:space="preserve">Sends @file to the "Trashcan", if possible. This is similar to
deleting it, but the user can recover it before emptying the trashcan.
Not all file systems support trashing, so this call can return the
%G_IO_ERROR_NOT_SUPPORTED error.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on successful trash, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">#GFile to send to trash</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="trash_async" invoker="trash_async" version="2.38">
        <doc xml:space="preserve">Asynchronously sends @file to the Trash location, if possible.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="trash_finish" invoker="trash_finish" version="2.38" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous file trashing operation, started with
g_file_trash_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on successful trash, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unmount_mountable" invoker="unmount_mountable" deprecated="1" deprecated-version="2.22">
        <doc xml:space="preserve">Unmounts a file of type G_FILE_TYPE_MOUNTABLE.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

When the operation is finished, @callback will be called.
You can then call g_file_unmount_mountable_finish() to get
the result of the operation.</doc>
        <doc-deprecated xml:space="preserve">Use g_file_unmount_mountable_with_operation() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unmount_mountable_finish" invoker="unmount_mountable_finish" deprecated="1" deprecated-version="2.22" throws="1">
        <doc xml:space="preserve">Finishes an unmount operation, see g_file_unmount_mountable() for details.

Finish an asynchronous unmount operation that was started
with g_file_unmount_mountable().</doc>
        <doc-deprecated xml:space="preserve">Use g_file_unmount_mountable_with_operation_finish()
    instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation finished successfully.
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unmount_mountable_with_operation" invoker="unmount_mountable_with_operation" version="2.22">
        <doc xml:space="preserve">Unmounts a file of type #G_FILE_TYPE_MOUNTABLE.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

When the operation is finished, @callback will be called.
You can then call g_file_unmount_mountable_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation,
    or %NULL to avoid user interaction</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unmount_mountable_with_operation_finish" invoker="unmount_mountable_with_operation_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes an unmount operation,
see g_file_unmount_mountable_with_operation() for details.

Finish an asynchronous unmount operation that was started
with g_file_unmount_mountable_with_operation().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation finished successfully.
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="append_to" c:identifier="g_file_append_to" throws="1">
        <doc xml:space="preserve">Gets an output stream for appending data to the file.
If the file doesn't already exist it is created.

By default files created are generally readable by everyone,
but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
will be made readable only to the current user, to the level that
is supported on the target filesystem.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

Some file systems don't allow all file names, and may return an
%G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
%G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are
possible too, and depend on what kind of filesystem the file is on.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileOutputStream, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_to_async" c:identifier="g_file_append_to_async">
        <doc xml:space="preserve">Asynchronously opens @file for appending.

For more details, see g_file_append_to() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_append_to_finish() to get the result
of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_to_finish" c:identifier="g_file_append_to_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous file append operation started with
g_file_append_to_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a valid #GFileOutputStream
    or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">#GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="g_file_copy" throws="1">
        <doc xml:space="preserve">Copies the file @source to the location specified by @destination.
Can not handle recursive copies of directories.

If the flag #G_FILE_COPY_OVERWRITE is specified an already
existing @destination file is overwritten.

If the flag #G_FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks
will be copied as symlinks, otherwise the target of the
@source symlink will be copied.

If the flag #G_FILE_COPY_ALL_METADATA is specified then all the metadata
that is possible to copy is copied, not just the default subset (which,
for instance, does not include the owner, see #GFileInfo).

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

If @progress_callback is not %NULL, then the operation can be monitored
by setting this to a #GFileProgressCallback function.
@progress_callback_data will be passed to this function. It is guaranteed
that this callback will be called after all data has been transferred with
the total number of bytes copied during the operation.

If the @source file does not exist, then the %G_IO_ERROR_NOT_FOUND error
is returned, independent on the status of the @destination.

If #G_FILE_COPY_OVERWRITE is not specified and the target exists, then
the error %G_IO_ERROR_EXISTS is returned.

If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
error is returned. If trying to overwrite a directory with a directory the
%G_IO_ERROR_WOULD_MERGE error is returned.

If the source is a directory and the target does not exist, or
#G_FILE_COPY_OVERWRITE is specified and the target is a file, then the
%G_IO_ERROR_WOULD_RECURSE error is returned.

If you are interested in copying the #GFile object itself (not the on-disk
file), see g_file_dup().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="destination" transfer-ownership="none">
            <doc xml:space="preserve">destination #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">set of #GFileCopyFlags</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="4">
            <doc xml:space="preserve">function to callback with
    progress information, or %NULL if progress information is not needed</doc>
            <type name="FileProgressCallback" c:type="GFileProgressCallback"/>
          </parameter>
          <parameter name="progress_callback_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to @progress_callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy_async" c:identifier="g_file_copy_async">
        <doc xml:space="preserve">Copies the file @source to the location specified by @destination
asynchronously. For details of the behaviour, see g_file_copy().

If @progress_callback is not %NULL, then that function that will be called
just like in g_file_copy(). The callback will run in the default main context
of the thread calling g_file_copy_async() &#x2014; the same context as @callback is
run in.

When the operation is finished, @callback will be called. You can then call
g_file_copy_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="destination" transfer-ownership="none">
            <doc xml:space="preserve">destination #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">set of #GFileCopyFlags</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="5">
            <doc xml:space="preserve">function to callback with progress
    information, or %NULL if progress information is not needed</doc>
            <type name="FileProgressCallback" c:type="GFileProgressCallback"/>
          </parameter>
          <parameter name="progress_callback_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">user data to pass to @progress_callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="7">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy_attributes" c:identifier="g_file_copy_attributes" throws="1">
        <doc xml:space="preserve">Copies the file attributes from @source to @destination.

Normally only a subset of the file attributes are copied,
those that are copies in a normal file copy operation
(which for instance does not include e.g. owner). However
if #G_FILE_COPY_ALL_METADATA is specified in @flags, then
all the metadata that is possible to copy is copied. This
is useful when implementing move by copy + delete source.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the attributes were copied successfully,
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile with attributes</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="destination" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile to copy attributes to</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileCopyFlags</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy_finish" c:identifier="g_file_copy_finish" throws="1">
        <doc xml:space="preserve">Finishes copying the file started with g_file_copy_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a %TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create" c:identifier="g_file_create" throws="1">
        <doc xml:space="preserve">Creates a new file and returns an output stream for writing to it.
The file must not already exist.

By default files created are generally readable by everyone,
but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
will be made readable only to the current user, to the level
that is supported on the target filesystem.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

If a file or directory with this name already exists the
%G_IO_ERROR_EXISTS error will be returned. Some file systems don't
allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
error, and if the name is to long %G_IO_ERROR_FILENAME_TOO_LONG will
be returned. Other errors are possible too, and depend on what kind
of filesystem the file is on.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileOutputStream for the newly created
    file, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_async" c:identifier="g_file_create_async">
        <doc xml:space="preserve">Asynchronously creates a new file and returns an output stream
for writing to it. The file must not already exist.

For more details, see g_file_create() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_create_finish() to get the result
of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_finish" c:identifier="g_file_create_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous file create operation started with
g_file_create_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileOutputStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_readwrite" c:identifier="g_file_create_readwrite" version="2.22" throws="1">
        <doc xml:space="preserve">Creates a new file and returns a stream for reading and
writing to it. The file must not already exist.

By default files created are generally readable by everyone,
but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
will be made readable only to the current user, to the level
that is supported on the target filesystem.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

If a file or directory with this name already exists, the
%G_IO_ERROR_EXISTS error will be returned. Some file systems don't
allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
error, and if the name is too long, %G_IO_ERROR_FILENAME_TOO_LONG
will be returned. Other errors are possible too, and depend on what
kind of filesystem the file is on.

Note that in many non-local file cases read and write streams are
not supported, so make sure you really need to do read and write
streaming, rather than just opening for reading or writing.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileIOStream for the newly created
    file, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileIOStream" c:type="GFileIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_readwrite_async" c:identifier="g_file_create_readwrite_async" version="2.22">
        <doc xml:space="preserve">Asynchronously creates a new file and returns a stream
for reading and writing to it. The file must not already exist.

For more details, see g_file_create_readwrite() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_create_readwrite_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_readwrite_finish" c:identifier="g_file_create_readwrite_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous file create operation started with
g_file_create_readwrite_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileIOStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileIOStream" c:type="GFileIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete" c:identifier="g_file_delete" throws="1">
        <doc xml:space="preserve">Deletes a file. If the @file is a directory, it will only be
deleted if it is empty. This has the same semantics as g_unlink().

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the file was deleted. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete_async" c:identifier="g_file_delete_async" version="2.34">
        <doc xml:space="preserve">Asynchronously delete a file. If the @file is a directory, it will
only be deleted if it is empty.  This has the same semantics as
g_unlink().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete_finish" c:identifier="g_file_delete_finish" version="2.34" throws="1">
        <doc xml:space="preserve">Finishes deleting a file started with g_file_delete_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the file was deleted. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="g_file_dup">
        <doc xml:space="preserve">Duplicates a #GFile handle. This operation does not duplicate
the actual file or directory represented by the #GFile; see
g_file_copy() if attempting to copy a file.

g_file_dup() is useful when a second handle is needed to the same underlying
file, for use in a separate thread (#GFile is not thread-safe). For use
within the same thread, use g_object_ref() to increment the existing object&#x2019;s
reference count.

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GFile that is a duplicate
    of the given #GFile.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="eject_mountable" c:identifier="g_file_eject_mountable" deprecated="1" deprecated-version="2.22">
        <doc xml:space="preserve">Starts an asynchronous eject on a mountable.
When this operation has completed, @callback will be called with
@user_user data, and the operation can be finalized with
g_file_eject_mountable_finish().

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <doc-deprecated xml:space="preserve">Use g_file_eject_mountable_with_operation() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="eject_mountable_finish" c:identifier="g_file_eject_mountable_finish" deprecated="1" deprecated-version="2.22" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous eject operation started by
g_file_eject_mountable().</doc>
        <doc-deprecated xml:space="preserve">Use g_file_eject_mountable_with_operation_finish()
    instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @file was ejected successfully.
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="eject_mountable_with_operation" c:identifier="g_file_eject_mountable_with_operation" version="2.22">
        <doc xml:space="preserve">Starts an asynchronous eject on a mountable.
When this operation has completed, @callback will be called with
@user_user data, and the operation can be finalized with
g_file_eject_mountable_with_operation_finish().

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation,
    or %NULL to avoid user interaction</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="eject_mountable_with_operation_finish" c:identifier="g_file_eject_mountable_with_operation_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous eject operation started by
g_file_eject_mountable_with_operation().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @file was ejected successfully.
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="enumerate_children" c:identifier="g_file_enumerate_children" throws="1">
        <doc xml:space="preserve">Gets the requested information about the files in a directory.
The result is a #GFileEnumerator object that will give out
#GFileInfo objects for all the files in the directory.

The @attributes value is a string that specifies the file
attributes that should be gathered. It is not an error if
it's not possible to read a particular requested attribute
from a file - it just won't be set. @attributes should
be a comma-separated list of attributes or attribute wildcards.
The wildcard "*" means all attributes, and a wildcard like
"standard::*" means all attributes in the standard namespace.
An example attribute query be "standard::*,owner::user".
The standard attributes are available as defines, like
#G_FILE_ATTRIBUTE_STANDARD_NAME.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
be returned. If the file is not a directory, the %G_IO_ERROR_NOT_DIRECTORY
error will be returned. Other errors are possible too.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GFileEnumerator if successful,
    %NULL on error. Free the returned object with g_object_unref().</doc>
          <type name="FileEnumerator" c:type="GFileEnumerator*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">an attribute query string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="enumerate_children_async" c:identifier="g_file_enumerate_children_async">
        <doc xml:space="preserve">Asynchronously gets the requested information about the files
in a directory. The result is a #GFileEnumerator object that will
give out #GFileInfo objects for all the files in the directory.

For more details, see g_file_enumerate_children() which is
the synchronous version of this call.

When the operation is finished, @callback will be called. You can
then call g_file_enumerate_children_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">an attribute query string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the
    request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="enumerate_children_finish" c:identifier="g_file_enumerate_children_finish" throws="1">
        <doc xml:space="preserve">Finishes an async enumerate children operation.
See g_file_enumerate_children_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileEnumerator or %NULL
    if an error occurred.
    Free the returned object with g_object_unref().</doc>
          <type name="FileEnumerator" c:type="GFileEnumerator*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="g_file_equal">
        <doc xml:space="preserve">Checks if the two given #GFiles refer to the same file.

Note that two #GFiles that differ can still refer to the same
file on the filesystem due to various forms of filename
aliasing.

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @file1 and @file2 are equal.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file1" transfer-ownership="none">
            <doc xml:space="preserve">the first #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="file2" transfer-ownership="none">
            <doc xml:space="preserve">the second #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_enclosing_mount" c:identifier="g_file_find_enclosing_mount" throws="1">
        <doc xml:space="preserve">Gets a #GMount for the #GFile.

If the #GFileIface for @file does not have a mount (e.g.
possibly a remote share), @error will be set to %G_IO_ERROR_NOT_FOUND
and %NULL will be returned.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GMount where the @file is located
    or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="Mount" c:type="GMount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_enclosing_mount_async" c:identifier="g_file_find_enclosing_mount_async">
        <doc xml:space="preserve">Asynchronously gets the mount for the file.

For more details, see g_file_find_enclosing_mount() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_find_enclosing_mount_finish() to
get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_enclosing_mount_finish" c:identifier="g_file_find_enclosing_mount_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous find mount request.
See g_file_find_enclosing_mount_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GMount for given @file or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="Mount" c:type="GMount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_basename" c:identifier="g_file_get_basename">
        <doc xml:space="preserve">Gets the base name (the last component of the path) for a given #GFile.

If called for the top level of a system (such as the filesystem root
or a uri like sftp://host/) it will return a single directory separator
(and on Windows, possibly a drive letter).

The base name is a byte string (not UTF-8). It has no defined encoding
or rules other than it may not contain zero bytes.  If you want to use
filenames in a user interface you should use the display name that you
can get by requesting the %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
attribute with g_file_query_info().

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">string containing the #GFile's
    base name, or %NULL if given #GFile is invalid. The returned string
    should be freed with g_free() when no longer needed.</doc>
          <type name="filename" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_child" c:identifier="g_file_get_child">
        <doc xml:space="preserve">Gets a child of @file with basename equal to @name.

Note that the file with that specific name might not exist, but
you can still have a #GFile that points to it. You can use this
for instance to create that file.

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFile to a child specified by @name.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">string containing the child's basename</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_child_for_display_name" c:identifier="g_file_get_child_for_display_name" throws="1">
        <doc xml:space="preserve">Gets the child of @file for a given @display_name (i.e. a UTF-8
version of the name). If this function fails, it returns %NULL
and @error will be set. This is very useful when constructing a
#GFile for a new file and the user entered the filename in the
user interface, for instance when you select a directory and
type a filename in the file selector.

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFile to the specified child, or
    %NULL if the display name couldn't be converted.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:space="preserve">string to a possible child</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_parent" c:identifier="g_file_get_parent">
        <doc xml:space="preserve">Gets the parent directory for the @file.
If the @file represents the root directory of the
file system, then %NULL will be returned.

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #GFile structure to the
    parent of the given #GFile or %NULL if there is no parent. Free
    the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parse_name" c:identifier="g_file_get_parse_name">
        <doc xml:space="preserve">Gets the parse name of the @file.
A parse name is a UTF-8 string that describes the
file such that one can get the #GFile back using
g_file_parse_name().

This is generally used to show the #GFile as a nice
full-pathname kind of string in a user interface,
like in a location entry.

For local files with names that can safely be converted
to UTF-8 the pathname is used, otherwise the IRI is used
(a form of URI that allows UTF-8 characters unescaped).

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a string containing the #GFile's parse name.
    The returned string should be freed with g_free()
    when no longer needed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_path" c:identifier="g_file_get_path">
        <doc xml:space="preserve">Gets the local pathname for #GFile, if one exists. If non-%NULL, this is
guaranteed to be an absolute, canonical path. It might contain symlinks.

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">string containing the #GFile's path,
    or %NULL if no such path exists. The returned string should be freed
    with g_free() when no longer needed.</doc>
          <type name="filename" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_relative_path" c:identifier="g_file_get_relative_path">
        <doc xml:space="preserve">Gets the path for @descendant relative to @parent.

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">string with the relative path from
    @descendant to @parent, or %NULL if @descendant doesn't have @parent as
    prefix. The returned string should be freed with g_free() when
    no longer needed.</doc>
          <type name="filename" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="parent" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="descendant" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uri" c:identifier="g_file_get_uri">
        <doc xml:space="preserve">Gets the URI for the @file.

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a string containing the #GFile's URI.
    The returned string should be freed with g_free()
    when no longer needed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uri_scheme" c:identifier="g_file_get_uri_scheme">
        <doc xml:space="preserve">Gets the URI scheme for a #GFile.
RFC 3986 decodes the scheme as:
|[
URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
]|
Common schemes include "file", "http", "ftp", etc.

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a string containing the URI scheme for the given
    #GFile. The returned string should be freed with g_free()
    when no longer needed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_parent" c:identifier="g_file_has_parent" version="2.24">
        <doc xml:space="preserve">Checks if @file has a parent, and optionally, if it is @parent.

If @parent is %NULL then this function returns %TRUE if @file has any
parent at all.  If @parent is non-%NULL then %TRUE is only returned
if @file is an immediate child of @parent.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @file is an immediate child of @parent (or any parent in
         the case that @parent is %NULL).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="parent" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the parent to check for, or %NULL</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_prefix" c:identifier="g_file_has_prefix">
        <doc xml:space="preserve">Checks whether @file has the prefix specified by @prefix.

In other words, if the names of initial elements of @file's
pathname match @prefix. Only full pathname elements are matched,
so a path like /foo is not considered a prefix of /foobar, only
of /foo/bar.

A #GFile is not a prefix of itself. If you want to check for
equality, use g_file_equal().

This call does no I/O, as it works purely on names. As such it can
sometimes return %FALSE even if @file is inside a @prefix (from a
filesystem point of view), because the prefix of @file is an alias
of @prefix.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @files's parent, grandparent, etc is @prefix,
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="prefix" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_uri_scheme" c:identifier="g_file_has_uri_scheme">
        <doc xml:space="preserve">Checks to see if a #GFile has a given URI scheme.

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if #GFile's backend supports the
    given URI scheme, %FALSE if URI scheme is %NULL,
    not supported, or #GFile is invalid.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="uri_scheme" transfer-ownership="none">
            <doc xml:space="preserve">a string containing a URI scheme</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="hash" c:identifier="g_file_hash">
        <doc xml:space="preserve">Creates a hash value for a #GFile.

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 if @file is not a valid #GFile, otherwise an
    integer that can be used as hash value for the #GFile.
    This function is intended for easily hashing a #GFile to
    add to a #GHashTable or similar data structure.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">#gconstpointer to a #GFile</doc>
            <type name="File" c:type="gconstpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_native" c:identifier="g_file_is_native">
        <doc xml:space="preserve">Checks to see if a file is native to the platform.

A native file is one expressed in the platform-native filename format,
e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
as it might be on a locally mounted remote filesystem.

On some systems non-native files may be available using the native
filesystem via a userspace filesystem (FUSE), in these cases this call
will return %FALSE, but g_file_get_path() will still return a native path.

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @file is native</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="load_bytes" c:identifier="g_file_load_bytes" version="2.56" throws="1">
        <doc xml:space="preserve">Loads the contents of @file and returns it as #GBytes.

If @file is a resource:// based URI, the resulting bytes will reference the
embedded resource instead of a copy. Otherwise, this is equivalent to calling
g_file_load_contents() and g_bytes_new_take().

For resources, @etag_out will be set to %NULL.

The data contained in the resulting #GBytes is always zero-terminated, but
this is not included in the #GBytes length. The resulting #GBytes should be
freed with g_bytes_unref() when no longer in use.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GBytes or %NULL and @error is set</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="etag_out" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">a location to place the current
    entity tag for the file, or %NULL if the entity tag is not needed</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_bytes_async" c:identifier="g_file_load_bytes_async" version="2.56">
        <doc xml:space="preserve">Asynchronously loads the contents of @file as #GBytes.

If @file is a resource:// based URI, the resulting bytes will reference the
embedded resource instead of a copy. Otherwise, this is equivalent to calling
g_file_load_contents_async() and g_bytes_new_take().

@callback should call g_file_load_bytes_finish() to get the result of this
asynchronous operation.

See g_file_load_bytes() for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the
    request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_bytes_finish" c:identifier="g_file_load_bytes_finish" version="2.56" throws="1">
        <doc xml:space="preserve">Completes an asynchronous request to g_file_load_bytes_async().

For resources, @etag_out will be set to %NULL.

The data contained in the resulting #GBytes is always zero-terminated, but
this is not included in the #GBytes length. The resulting #GBytes should be
freed with g_bytes_unref() when no longer in use.

See g_file_load_bytes() for more information.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GBytes or %NULL and @error is set</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult provided to the callback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="etag_out" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">a location to place the current
    entity tag for the file, or %NULL if the entity tag is not needed</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_contents" c:identifier="g_file_load_contents" throws="1">
        <doc xml:space="preserve">Loads the content of the file into memory. The data is always
zero-terminated, but this is not included in the resultant @length.
The returned @content should be freed with g_free() when no longer
needed.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @file's contents were successfully loaded.
    %FALSE if there were errors.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="contents" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">a location to place the contents of the file</doc>
            <array length="2" zero-terminated="0" c:type="char**">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a location to place the length of the contents of the file,
   or %NULL if the length is not needed</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="etag_out" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a location to place the current entity tag for the file,
   or %NULL if the entity tag is not needed</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_contents_async" c:identifier="g_file_load_contents_async">
        <doc xml:space="preserve">Starts an asynchronous load of the @file's contents.

For more details, see g_file_load_contents() which is
the synchronous version of this call.

When the load operation has completed, @callback will be called
with @user data. To finish the operation, call
g_file_load_contents_finish() with the #GAsyncResult returned by
the @callback.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_contents_finish" c:identifier="g_file_load_contents_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous load of the @file's contents.
The contents are placed in @contents, and @length is set to the
size of the @contents string. The @content should be freed with
g_free() when no longer needed. If @etag_out is present, it will be
set to the new entity tag for the @file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the load was successful. If %FALSE and @error is
    present, it will be set appropriately.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="contents" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">a location to place the contents of the file</doc>
            <array length="2" zero-terminated="0" c:type="char**">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a location to place the length of the contents of the file,
    or %NULL if the length is not needed</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="etag_out" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a location to place the current entity tag for the file,
    or %NULL if the entity tag is not needed</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_partial_contents_async" c:identifier="g_file_load_partial_contents_async" introspectable="0">
        <doc xml:space="preserve">Reads the partial contents of a file. A #GFileReadMoreCallback should
be used to stop reading from the file when appropriate, else this
function will behave exactly as g_file_load_contents_async(). This
operation can be finished by g_file_load_partial_contents_finish().

Users of this function should be aware that @user_data is passed to
both the @read_more_callback and the @callback.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="read_more_callback" transfer-ownership="none" scope="call" closure="3">
            <doc xml:space="preserve">a
    #GFileReadMoreCallback to receive partial data
    and to specify whether further data should be read</doc>
            <type name="FileReadMoreCallback" c:type="GFileReadMoreCallback"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to the callback functions</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_partial_contents_finish" c:identifier="g_file_load_partial_contents_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous partial load operation that was started
with g_file_load_partial_contents_async(). The data is always
zero-terminated, but this is not included in the resultant @length.
The returned @content should be freed with g_free() when no longer
needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the load was successful. If %FALSE and @error is
    present, it will be set appropriately.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="contents" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">a location to place the contents of the file</doc>
            <array length="2" zero-terminated="0" c:type="char**">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a location to place the length of the contents of the file,
    or %NULL if the length is not needed</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="etag_out" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a location to place the current entity tag for the file,
    or %NULL if the entity tag is not needed</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="make_directory" c:identifier="g_file_make_directory" throws="1">
        <doc xml:space="preserve">Creates a directory. Note that this will only create a child directory
of the immediate parent directory of the path or URI given by the #GFile.
To recursively create directories, see g_file_make_directory_with_parents().
This function will fail if the parent directory does not exist, setting
@error to %G_IO_ERROR_NOT_FOUND. If the file system doesn't support
creating directories, this function will fail, setting @error to
%G_IO_ERROR_NOT_SUPPORTED.

For a local #GFile the newly created directory will have the default
(current) ownership and permissions of the current process.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on successful creation, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="make_directory_async" c:identifier="g_file_make_directory_async" version="2.38">
        <doc xml:space="preserve">Asynchronously creates a directory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="make_directory_finish" c:identifier="g_file_make_directory_finish" version="2.38" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous directory creation, started with
g_file_make_directory_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on successful directory creation, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="make_directory_with_parents" c:identifier="g_file_make_directory_with_parents" version="2.18" throws="1">
        <doc xml:space="preserve">Creates a directory and any parent directories that may not
exist similar to 'mkdir -p'. If the file system does not support
creating directories, this function will fail, setting @error to
%G_IO_ERROR_NOT_SUPPORTED. If the directory itself already exists,
this function will fail setting @error to %G_IO_ERROR_EXISTS, unlike
the similar g_mkdir_with_parents().

For a local #GFile the newly created directories will have the default
(current) ownership and permissions of the current process.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if all directories have been successfully created, %FALSE
otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="make_symbolic_link" c:identifier="g_file_make_symbolic_link" throws="1">
        <doc xml:space="preserve">Creates a symbolic link named @file which contains the string
@symlink_value.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on the creation of a new symlink, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile with the name of the symlink to create</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="symlink_value" transfer-ownership="none">
            <doc xml:space="preserve">a string with the path for the target
    of the new symlink</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="measure_disk_usage" c:identifier="g_file_measure_disk_usage" version="2.38" introspectable="0" throws="1">
        <doc xml:space="preserve">Recursively measures the disk usage of @file.

This is essentially an analog of the 'du' command, but it also
reports the number of directories and non-directory files encountered
(including things like symbolic links).

By default, errors are only reported against the toplevel file
itself.  Errors found while recursing are silently ignored, unless
%G_FILE_DISK_USAGE_REPORT_ALL_ERRORS is given in @flags.

The returned size, @disk_usage, is in bytes and should be formatted
with g_format_size() in order to get something reasonable for showing
in a user interface.

@progress_callback and @progress_data can be given to request
periodic progress updates while scanning.  See the documentation for
#GFileMeasureProgressCallback for information about when and how the
callback will be invoked.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if successful, with the out parameters set.
         %FALSE otherwise, with @error set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">#GFileMeasureFlags</doc>
            <type name="FileMeasureFlags" c:type="GFileMeasureFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">a #GFileMeasureProgressCallback</doc>
            <type name="FileMeasureProgressCallback" c:type="GFileMeasureProgressCallback"/>
          </parameter>
          <parameter name="progress_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user_data for @progress_callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="disk_usage" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the number of bytes of disk space used</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="num_dirs" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the number of directories encountered</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="num_files" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the number of non-directories encountered</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="measure_disk_usage_async" c:identifier="g_file_measure_disk_usage_async" version="2.38" introspectable="0">
        <doc xml:space="preserve">Recursively measures the disk usage of @file.

This is the asynchronous version of g_file_measure_disk_usage().  See
there for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">#GFileMeasureFlags</doc>
            <type name="FileMeasureFlags" c:type="GFileMeasureFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">a #GFileMeasureProgressCallback</doc>
            <type name="FileMeasureProgressCallback" c:type="GFileMeasureProgressCallback"/>
          </parameter>
          <parameter name="progress_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user_data for @progress_callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when complete</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="measure_disk_usage_finish" c:identifier="g_file_measure_disk_usage_finish" version="2.38" throws="1">
        <doc xml:space="preserve">Collects the results from an earlier call to
g_file_measure_disk_usage_async().  See g_file_measure_disk_usage() for
more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if successful, with the out parameters set.
         %FALSE otherwise, with @error set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="disk_usage" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the number of bytes of disk space used</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="num_dirs" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the number of directories encountered</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="num_files" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the number of non-directories encountered</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="monitor" c:identifier="g_file_monitor" version="2.18" throws="1">
        <doc xml:space="preserve">Obtains a file or directory monitor for the given file,
depending on the type of the file.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileMonitor for the given @file,
    or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileMonitor" c:type="GFileMonitor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileMonitorFlags</doc>
            <type name="FileMonitorFlags" c:type="GFileMonitorFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="monitor_directory" c:identifier="g_file_monitor_directory" throws="1">
        <doc xml:space="preserve">Obtains a directory monitor for the given file.
This may fail if directory monitoring is not supported.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

It does not make sense for @flags to contain
%G_FILE_MONITOR_WATCH_HARD_LINKS, since hard links can not be made to
directories.  It is not possible to monitor all the files in a
directory for changes made via hard links; if you want to do this then
you must register individual watches with g_file_monitor().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileMonitor for the given @file,
    or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileMonitor" c:type="GFileMonitor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileMonitorFlags</doc>
            <type name="FileMonitorFlags" c:type="GFileMonitorFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="monitor_file" c:identifier="g_file_monitor_file" throws="1">
        <doc xml:space="preserve">Obtains a file monitor for the given file. If no file notification
mechanism exists, then regular polling of the file is used.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

If @flags contains %G_FILE_MONITOR_WATCH_HARD_LINKS then the monitor
will also attempt to report changes made to the file via another
filename (ie, a hard link). Without this flag, you can only rely on
changes made through the filename contained in @file to be
reported. Using this flag may result in an increase in resource
usage, and may not have any effect depending on the #GFileMonitor
backend and/or filesystem type.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileMonitor for the given @file,
    or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileMonitor" c:type="GFileMonitor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileMonitorFlags</doc>
            <type name="FileMonitorFlags" c:type="GFileMonitorFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="mount_enclosing_volume" c:identifier="g_file_mount_enclosing_volume">
        <doc xml:space="preserve">Starts a @mount_operation, mounting the volume that contains
the file @location.

When this operation has completed, @callback will be called with
@user_user data, and the operation can be finalized with
g_file_mount_enclosing_volume_finish().

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="location" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the operation</doc>
            <type name="MountMountFlags" c:type="GMountMountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation
    or %NULL to avoid user interaction</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="mount_enclosing_volume_finish" c:identifier="g_file_mount_enclosing_volume_finish" throws="1">
        <doc xml:space="preserve">Finishes a mount operation started by g_file_mount_enclosing_volume().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if successful. If an error has occurred,
    this function will return %FALSE and set @error
    appropriately if present.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="location" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="mount_mountable" c:identifier="g_file_mount_mountable">
        <doc xml:space="preserve">Mounts a file of type G_FILE_TYPE_MOUNTABLE.
Using @mount_operation, you can request callbacks when, for instance,
passwords are needed during authentication.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

When the operation is finished, @callback will be called.
You can then call g_file_mount_mountable_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the operation</doc>
            <type name="MountMountFlags" c:type="GMountMountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation,
    or %NULL to avoid user interaction</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="mount_mountable_finish" c:identifier="g_file_mount_mountable_finish" throws="1">
        <doc xml:space="preserve">Finishes a mount operation. See g_file_mount_mountable() for details.

Finish an asynchronous mount operation that was started
with g_file_mount_mountable().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFile or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="move" c:identifier="g_file_move" throws="1">
        <doc xml:space="preserve">Tries to move the file or directory @source to the location specified
by @destination. If native move operations are supported then this is
used, otherwise a copy + delete fallback is used. The native
implementation may support moving directories (for instance on moves
inside the same filesystem), but the fallback code does not.

If the flag #G_FILE_COPY_OVERWRITE is specified an already
existing @destination file is overwritten.

If the flag #G_FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks
will be copied as symlinks, otherwise the target of the
@source symlink will be copied.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

If @progress_callback is not %NULL, then the operation can be monitored
by setting this to a #GFileProgressCallback function.
@progress_callback_data will be passed to this function. It is
guaranteed that this callback will be called after all data has been
transferred with the total number of bytes copied during the operation.

If the @source file does not exist, then the %G_IO_ERROR_NOT_FOUND
error is returned, independent on the status of the @destination.

If #G_FILE_COPY_OVERWRITE is not specified and the target exists,
then the error %G_IO_ERROR_EXISTS is returned.

If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
error is returned. If trying to overwrite a directory with a directory the
%G_IO_ERROR_WOULD_MERGE error is returned.

If the source is a directory and the target does not exist, or
#G_FILE_COPY_OVERWRITE is specified and the target is a file, then
the %G_IO_ERROR_WOULD_RECURSE error may be returned (if the native
move operation isn't available).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on successful move, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">#GFile pointing to the source location</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="destination" transfer-ownership="none">
            <doc xml:space="preserve">#GFile pointing to the destination location</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">set of #GFileCopyFlags</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="4">
            <doc xml:space="preserve">#GFileProgressCallback
    function for updates</doc>
            <type name="FileProgressCallback" c:type="GFileProgressCallback"/>
          </parameter>
          <parameter name="progress_callback_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">gpointer to user data for
    the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="open_readwrite" c:identifier="g_file_open_readwrite" version="2.22" throws="1">
        <doc xml:space="preserve">Opens an existing file for reading and writing. The result is
a #GFileIOStream that can be used to read and write the contents
of the file.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
be returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
error will be returned. Other errors are possible too, and depend on
what kind of filesystem the file is on. Note that in many non-local
file cases read and write streams are not supported, so make sure you
really need to do read and write streaming, rather than just opening
for reading or writing.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GFileIOStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileIOStream" c:type="GFileIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">#GFile to open</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="open_readwrite_async" c:identifier="g_file_open_readwrite_async" version="2.22">
        <doc xml:space="preserve">Asynchronously opens @file for reading and writing.

For more details, see g_file_open_readwrite() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_open_readwrite_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="open_readwrite_finish" c:identifier="g_file_open_readwrite_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous file read operation started with
g_file_open_readwrite_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileIOStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileIOStream" c:type="GFileIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_path" c:identifier="g_file_peek_path" version="2.56">
        <doc xml:space="preserve">Exactly like g_file_get_path(), but caches the result via
g_object_set_qdata_full().  This is useful for example in C
applications which mix `g_file_*` APIs with native ones.  It
also avoids an extra duplicated string when possible, so will be
generally more efficient.

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">string containing the #GFile's path,
    or %NULL if no such path exists. The returned string is owned by @file.</doc>
          <type name="filename" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="poll_mountable" c:identifier="g_file_poll_mountable" version="2.22">
        <doc xml:space="preserve">Polls a file of type #G_FILE_TYPE_MOUNTABLE.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

When the operation is finished, @callback will be called.
You can then call g_file_mount_mountable_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="poll_mountable_finish" c:identifier="g_file_poll_mountable_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes a poll operation. See g_file_poll_mountable() for details.

Finish an asynchronous poll operation that was polled
with g_file_poll_mountable().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation finished successfully. %FALSE
otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_default_handler" c:identifier="g_file_query_default_handler" throws="1">
        <doc xml:space="preserve">Returns the #GAppInfo that is registered as the default
application to handle the file specified by @file.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GAppInfo if the handle was found,
    %NULL if there were errors.
    When you are done with it, release it with g_object_unref()</doc>
          <type name="AppInfo" c:type="GAppInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile to open</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_exists" c:identifier="g_file_query_exists">
        <doc xml:space="preserve">Utility function to check if a particular file exists. This is
implemented using g_file_query_info() and as such does blocking I/O.

Note that in many cases it is [racy to first check for file existence](https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use)
and then execute something based on the outcome of that, because the
file might have been created or removed in between the operations. The
general approach to handling that is to not check, but just do the
operation and handle the errors as they come.

As an example of race-free checking, take the case of reading a file,
and if it doesn't exist, creating it. There are two racy versions: read
it, and on error create it; and: check if it exists, if not create it.
These can both result in two processes creating the file (with perhaps
a partially written file as the result). The correct approach is to
always try to create the file with g_file_create() which will either
atomically create the file or fail with a %G_IO_ERROR_EXISTS error.

However, in many cases an existence check is useful in a user interface,
for instance to make a menu item sensitive/insensitive, so that you don't
have to fool users that something is possible and then just show an error
dialog. If you do this, you should make sure to also handle the errors
that can happen due to races when you execute the operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the file exists (and can be detected without error),
    %FALSE otherwise (or if cancelled).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_file_type" c:identifier="g_file_query_file_type" version="2.18">
        <doc xml:space="preserve">Utility function to inspect the #GFileType of a file. This is
implemented using g_file_query_info() and as such does blocking I/O.

The primary use case of this method is to check if a file is
a regular file, directory, or symlink.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #GFileType of the file and #G_FILE_TYPE_UNKNOWN
    if the file does not exist</doc>
          <type name="FileType" c:type="GFileType"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileQueryInfoFlags passed to g_file_query_info()</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_filesystem_info" c:identifier="g_file_query_filesystem_info" throws="1">
        <doc xml:space="preserve">Similar to g_file_query_info(), but obtains information
about the filesystem the @file is on, rather than the file itself.
For instance the amount of space available and the type of
the filesystem.

The @attributes value is a string that specifies the attributes
that should be gathered. It is not an error if it's not possible
to read a particular requested attribute from a file - it just
won't be set. @attributes should be a comma-separated list of
attributes or attribute wildcards. The wildcard "*" means all
attributes, and a wildcard like "filesystem::*" means all attributes
in the filesystem namespace. The standard namespace for filesystem
attributes is "filesystem". Common attributes of interest are
#G_FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem
in bytes), #G_FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes available),
and #G_FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
be returned. Other errors are possible too, and depend on what
kind of filesystem the file is on.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileInfo or %NULL if there was an error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">an attribute query string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_filesystem_info_async" c:identifier="g_file_query_filesystem_info_async">
        <doc xml:space="preserve">Asynchronously gets the requested information about the filesystem
that the specified @file is on. The result is a #GFileInfo object
that contains key-value attributes (such as type or size for the
file).

For more details, see g_file_query_filesystem_info() which is the
synchronous version of this call.

When the operation is finished, @callback will be called. You can
then call g_file_query_info_finish() to get the result of the
operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">an attribute query string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_filesystem_info_finish" c:identifier="g_file_query_filesystem_info_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous filesystem info query.
See g_file_query_filesystem_info_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GFileInfo for given @file
    or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_info" c:identifier="g_file_query_info" throws="1">
        <doc xml:space="preserve">Gets the requested information about specified @file.
The result is a #GFileInfo object that contains key-value
attributes (such as the type or size of the file).

The @attributes value is a string that specifies the file
attributes that should be gathered. It is not an error if
it's not possible to read a particular requested attribute
from a file - it just won't be set. @attributes should be a
comma-separated list of attributes or attribute wildcards.
The wildcard "*" means all attributes, and a wildcard like
"standard::*" means all attributes in the standard namespace.
An example attribute query be "standard::*,owner::user".
The standard attributes are available as defines, like
#G_FILE_ATTRIBUTE_STANDARD_NAME.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

For symlinks, normally the information about the target of the
symlink is returned, rather than information about the symlink
itself. However if you pass #G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS
in @flags the information about the symlink itself will be returned.
Also, for symlinks that point to non-existing files the information
about the symlink itself will be returned.

If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
returned. Other errors are possible too, and depend on what kind of
filesystem the file is on.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileInfo for the given @file, or %NULL
    on error. Free the returned object with g_object_unref().</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">an attribute query string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_info_async" c:identifier="g_file_query_info_async">
        <doc xml:space="preserve">Asynchronously gets the requested information about specified @file.
The result is a #GFileInfo object that contains key-value attributes
(such as type or size for the file).

For more details, see g_file_query_info() which is the synchronous
version of this call.

When the operation is finished, @callback will be called. You can
then call g_file_query_info_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">an attribute query string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the
    request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_info_finish" c:identifier="g_file_query_info_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous file info query.
See g_file_query_info_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GFileInfo for given @file
    or %NULL on error. Free the returned object with
    g_object_unref().</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_settable_attributes" c:identifier="g_file_query_settable_attributes" throws="1">
        <doc xml:space="preserve">Obtain the list of settable attributes for the file.

Returns the type and full attribute name of all the attributes
that can be set on this file. This doesn't mean setting it will
always succeed though, you might get an access failure, or some
specific file may not support a specific attribute.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileAttributeInfoList describing the settable attributes.
    When you are done with it, release it with
    g_file_attribute_info_list_unref()</doc>
          <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_writable_namespaces" c:identifier="g_file_query_writable_namespaces" throws="1">
        <doc xml:space="preserve">Obtain the list of attribute namespaces where new attributes
can be created by a user. An example of this is extended
attributes (in the "xattr" namespace).

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileAttributeInfoList describing the writable namespaces.
    When you are done with it, release it with
    g_file_attribute_info_list_unref()</doc>
          <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read" c:identifier="g_file_read" throws="1">
        <doc xml:space="preserve">Opens a file for reading. The result is a #GFileInputStream that
can be used to read the contents of the file.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
error will be returned. Other errors are possible too, and depend
on what kind of filesystem the file is on.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GFileInputStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileInputStream" c:type="GFileInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">#GFile to read</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_async" c:identifier="g_file_read_async">
        <doc xml:space="preserve">Asynchronously opens @file for reading.

For more details, see g_file_read() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_read_finish() to get the result
of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_finish" c:identifier="g_file_read_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous file read operation started with
g_file_read_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileInputStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileInputStream" c:type="GFileInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace" c:identifier="g_file_replace" throws="1">
        <doc xml:space="preserve">Returns an output stream for overwriting the file, possibly
creating a backup copy of the file first. If the file doesn't exist,
it will be created.

This will try to replace the file in the safest way possible so
that any errors during the writing will not affect an already
existing copy of the file. For instance, for local files it
may write to a temporary file and then atomically rename over
the destination when the stream is closed.

By default files created are generally readable by everyone,
but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
will be made readable only to the current user, to the level that
is supported on the target filesystem.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

If you pass in a non-%NULL @etag value and @file already exists, then
this value is compared to the current entity tag of the file, and if
they differ an %G_IO_ERROR_WRONG_ETAG error is returned. This
generally means that the file has been changed since you last read
it. You can get the new etag from g_file_output_stream_get_etag()
after you've finished writing and closed the #GFileOutputStream. When
you load a new file you can use g_file_input_stream_query_info() to
get the etag of the file.

If @make_backup is %TRUE, this function will attempt to make a
backup of the current file before overwriting it. If this fails
a %G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you
want to replace anyway, try again with @make_backup set to %FALSE.

If the file is a directory the %G_IO_ERROR_IS_DIRECTORY error will
be returned, and if the file is some other form of non-regular file
then a %G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some
file systems don't allow all file names, and may return an
%G_IO_ERROR_INVALID_FILENAME error, and if the name is to long
%G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are
possible too, and depend on what kind of filesystem the file is on.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileOutputStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an optional [entity tag][gfile-etag]
    for the current #GFile, or #NULL to ignore</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="make_backup" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_async" c:identifier="g_file_replace_async">
        <doc xml:space="preserve">Asynchronously overwrites the file, replacing the contents,
possibly creating a backup copy of the file first.

For more details, see g_file_replace() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_replace_finish() to get the result
of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an [entity tag][gfile-etag] for the current #GFile,
    or %NULL to ignore</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="make_backup" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_contents" c:identifier="g_file_replace_contents" throws="1">
        <doc xml:space="preserve">Replaces the contents of @file with @contents of @length bytes.

If @etag is specified (not %NULL), any existing file must have that etag,
or the error %G_IO_ERROR_WRONG_ETAG will be returned.

If @make_backup is %TRUE, this function will attempt to make a backup
of @file. Internally, it uses g_file_replace(), so will try to replace the
file contents in the safest way possible. For example, atomic renames are
used when replacing local files&#x2019; contents.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

The returned @new_etag can be used to verify that the file hasn't
changed the next time it is saved over.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if successful. If an error has occurred, this function
    will return %FALSE and set @error appropriately if present.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="contents" transfer-ownership="none">
            <doc xml:space="preserve">a string containing the new contents for @file</doc>
            <array length="1" zero-terminated="0" c:type="const char*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of @contents in bytes</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the old [entity-tag][gfile-etag] for the document,
    or %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="make_backup" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="new_etag" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a location to a new [entity tag][gfile-etag]
     for the document. This should be freed with g_free() when no longer
     needed, or %NULL</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_contents_async" c:identifier="g_file_replace_contents_async">
        <doc xml:space="preserve">Starts an asynchronous replacement of @file with the given
@contents of @length bytes. @etag will replace the document's
current entity tag.

When this operation has completed, @callback will be called with
@user_user data, and the operation can be finalized with
g_file_replace_contents_finish().

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

If @make_backup is %TRUE, this function will attempt to
make a backup of @file.

Note that no copy of @content will be made, so it must stay valid
until @callback is called. See g_file_replace_contents_bytes_async()
for a #GBytes version that will automatically hold a reference to the
contents (without copying) for the duration of the call.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="contents" transfer-ownership="none">
            <doc xml:space="preserve">string of contents to replace the file with</doc>
            <array length="1" zero-terminated="0" c:type="const char*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of @contents in bytes</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a new [entity tag][gfile-etag] for the @file, or %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="make_backup" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="7">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_contents_bytes_async" c:identifier="g_file_replace_contents_bytes_async" version="2.40">
        <doc xml:space="preserve">Same as g_file_replace_contents_async() but takes a #GBytes input instead.
This function will keep a ref on @contents until the operation is done.
Unlike g_file_replace_contents_async() this allows forgetting about the
content without waiting for the callback.

When this operation has completed, @callback will be called with
@user_user data, and the operation can be finalized with
g_file_replace_contents_finish().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="contents" transfer-ownership="none">
            <doc xml:space="preserve">a #GBytes</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a new [entity tag][gfile-etag] for the @file, or %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="make_backup" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_contents_finish" c:identifier="g_file_replace_contents_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous replace of the given @file. See
g_file_replace_contents_async(). Sets @new_etag to the new entity
tag for the document, if present.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="new_etag" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a location of a new [entity tag][gfile-etag]
    for the document. This should be freed with g_free() when it is no
    longer needed, or %NULL</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_finish" c:identifier="g_file_replace_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous file replace operation started with
g_file_replace_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileOutputStream, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_readwrite" c:identifier="g_file_replace_readwrite" version="2.22" throws="1">
        <doc xml:space="preserve">Returns an output stream for overwriting the file in readwrite mode,
possibly creating a backup copy of the file first. If the file doesn't
exist, it will be created.

For details about the behaviour, see g_file_replace() which does the
same thing but returns an output stream only.

Note that in many non-local file cases read and write streams are not
supported, so make sure you really need to do read and write streaming,
rather than just opening for reading or writing.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileIOStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileIOStream" c:type="GFileIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an optional [entity tag][gfile-etag]
    for the current #GFile, or #NULL to ignore</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="make_backup" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_readwrite_async" c:identifier="g_file_replace_readwrite_async" version="2.22">
        <doc xml:space="preserve">Asynchronously overwrites the file in read-write mode,
replacing the contents, possibly creating a backup copy
of the file first.

For more details, see g_file_replace_readwrite() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_replace_readwrite_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an [entity tag][gfile-etag] for the current #GFile,
    or %NULL to ignore</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="make_backup" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_readwrite_finish" c:identifier="g_file_replace_readwrite_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous file replace operation started with
g_file_replace_readwrite_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileIOStream, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileIOStream" c:type="GFileIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="resolve_relative_path" c:identifier="g_file_resolve_relative_path">
        <doc xml:space="preserve">Resolves a relative path for @file to an absolute path.

This call does no blocking I/O.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GFile to the resolved path.
    %NULL if @relative_path is %NULL or if @file is invalid.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="relative_path" transfer-ownership="none">
            <doc xml:space="preserve">a given relative path string</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute" c:identifier="g_file_set_attribute" throws="1">
        <doc xml:space="preserve">Sets an attribute in the file with attribute name @attribute to @value.

Some attributes can be unset by setting @type to
%G_FILE_ATTRIBUTE_TYPE_INVALID and @value_p to %NULL.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the attribute was set, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a string containing the attribute's name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">The type of the attribute</doc>
            <type name="FileAttributeType" c:type="GFileAttributeType"/>
          </parameter>
          <parameter name="value_p" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a pointer to the value (or the pointer
    itself if the type is a pointer type)</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_byte_string" c:identifier="g_file_set_attribute_byte_string" throws="1">
        <doc xml:space="preserve">Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING to @value.
If @attribute is of a different type, this operation will fail,
returning %FALSE.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @attribute was successfully set to @value
    in the @file, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a string containing the attribute's name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a string containing the attribute's new value</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_int32" c:identifier="g_file_set_attribute_int32" throws="1">
        <doc xml:space="preserve">Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_INT32 to @value.
If @attribute is of a different type, this operation will fail.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @attribute was successfully set to @value
    in the @file, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a string containing the attribute's name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #gint32 containing the attribute's new value</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_int64" c:identifier="g_file_set_attribute_int64" throws="1">
        <doc xml:space="preserve">Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_INT64 to @value.
If @attribute is of a different type, this operation will fail.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @attribute was successfully set, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a string containing the attribute's name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #guint64 containing the attribute's new value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_string" c:identifier="g_file_set_attribute_string" throws="1">
        <doc xml:space="preserve">Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_STRING to @value.
If @attribute is of a different type, this operation will fail.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @attribute was successfully set, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a string containing the attribute's name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a string containing the attribute's value</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">#GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_uint32" c:identifier="g_file_set_attribute_uint32" throws="1">
        <doc xml:space="preserve">Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_UINT32 to @value.
If @attribute is of a different type, this operation will fail.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @attribute was successfully set to @value
    in the @file, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a string containing the attribute's name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #guint32 containing the attribute's new value</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_uint64" c:identifier="g_file_set_attribute_uint64" throws="1">
        <doc xml:space="preserve">Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_UINT64 to @value.
If @attribute is of a different type, this operation will fail.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @attribute was successfully set to @value
    in the @file, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a string containing the attribute's name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #guint64 containing the attribute's new value</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attributes_async" c:identifier="g_file_set_attributes_async">
        <doc xml:space="preserve">Asynchronously sets the attributes of @file with @info.

For more details, see g_file_set_attributes_from_info(),
which is the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_set_attributes_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #gpointer</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attributes_finish" c:identifier="g_file_set_attributes_finish" throws="1">
        <doc xml:space="preserve">Finishes setting an attribute started in g_file_set_attributes_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the attributes were set correctly, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="info" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo**"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attributes_from_info" c:identifier="g_file_set_attributes_from_info" throws="1">
        <doc xml:space="preserve">Tries to set all attributes in the #GFileInfo on the target
values, not stopping on the first error.

If there is any error during this operation then @error will
be set to the first error. Error on particular fields are flagged
by setting the "status" field in the attribute value to
%G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can
also detect further errors.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%FALSE if there was any error, %TRUE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">#GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_display_name" c:identifier="g_file_set_display_name" throws="1">
        <doc xml:space="preserve">Renames @file to the specified display name.

The display name is converted from UTF-8 to the correct encoding
for the target filesystem if possible and the @file is renamed to this.

If you want to implement a rename operation in the user interface the
edit name (#G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the
initial value in the rename widget, and then the result after editing
should be passed to g_file_set_display_name().

On success the resulting converted filename is returned.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFile specifying what @file was renamed to,
    or %NULL if there was an error.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:space="preserve">a string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_display_name_async" c:identifier="g_file_set_display_name_async">
        <doc xml:space="preserve">Asynchronously sets the display name for a given #GFile.

For more details, see g_file_set_display_name() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_set_display_name_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:space="preserve">a string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_display_name_finish" c:identifier="g_file_set_display_name_finish" throws="1">
        <doc xml:space="preserve">Finishes setting a display name started with
g_file_set_display_name_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFile or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="start_mountable" c:identifier="g_file_start_mountable" version="2.22">
        <doc xml:space="preserve">Starts a file of type #G_FILE_TYPE_MOUNTABLE.
Using @start_operation, you can request callbacks when, for instance,
passwords are needed during authentication.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

When the operation is finished, @callback will be called.
You can then call g_file_mount_mountable_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the operation</doc>
            <type name="DriveStartFlags" c:type="GDriveStartFlags"/>
          </parameter>
          <parameter name="start_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation, or %NULL to avoid user interaction</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="start_mountable_finish" c:identifier="g_file_start_mountable_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes a start operation. See g_file_start_mountable() for details.

Finish an asynchronous start operation that was started
with g_file_start_mountable().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation finished successfully. %FALSE
otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="stop_mountable" c:identifier="g_file_stop_mountable" version="2.22">
        <doc xml:space="preserve">Stops a file of type #G_FILE_TYPE_MOUNTABLE.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

When the operation is finished, @callback will be called.
You can then call g_file_stop_mountable_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation,
    or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="stop_mountable_finish" c:identifier="g_file_stop_mountable_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes an stop operation, see g_file_stop_mountable() for details.

Finish an asynchronous stop operation that was started
with g_file_stop_mountable().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation finished successfully.
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_thread_contexts" c:identifier="g_file_supports_thread_contexts" version="2.22">
        <doc xml:space="preserve">Checks if @file supports
[thread-default contexts][g-main-context-push-thread-default-context].
If this returns %FALSE, you cannot perform asynchronous operations on
@file in a thread that has a thread-default context.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether or not @file supports thread-default contexts.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="trash" c:identifier="g_file_trash" throws="1">
        <doc xml:space="preserve">Sends @file to the "Trashcan", if possible. This is similar to
deleting it, but the user can recover it before emptying the trashcan.
Not all file systems support trashing, so this call can return the
%G_IO_ERROR_NOT_SUPPORTED error.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on successful trash, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">#GFile to send to trash</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="trash_async" c:identifier="g_file_trash_async" version="2.38">
        <doc xml:space="preserve">Asynchronously sends @file to the Trash location, if possible.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="trash_finish" c:identifier="g_file_trash_finish" version="2.38" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous file trashing operation, started with
g_file_trash_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on successful trash, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unmount_mountable" c:identifier="g_file_unmount_mountable" deprecated="1" deprecated-version="2.22">
        <doc xml:space="preserve">Unmounts a file of type G_FILE_TYPE_MOUNTABLE.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

When the operation is finished, @callback will be called.
You can then call g_file_unmount_mountable_finish() to get
the result of the operation.</doc>
        <doc-deprecated xml:space="preserve">Use g_file_unmount_mountable_with_operation() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unmount_mountable_finish" c:identifier="g_file_unmount_mountable_finish" deprecated="1" deprecated-version="2.22" throws="1">
        <doc xml:space="preserve">Finishes an unmount operation, see g_file_unmount_mountable() for details.

Finish an asynchronous unmount operation that was started
with g_file_unmount_mountable().</doc>
        <doc-deprecated xml:space="preserve">Use g_file_unmount_mountable_with_operation_finish()
    instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation finished successfully.
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unmount_mountable_with_operation" c:identifier="g_file_unmount_mountable_with_operation" version="2.22">
        <doc xml:space="preserve">Unmounts a file of type #G_FILE_TYPE_MOUNTABLE.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

When the operation is finished, @callback will be called.
You can then call g_file_unmount_mountable_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation,
    or %NULL to avoid user interaction</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unmount_mountable_with_operation_finish" c:identifier="g_file_unmount_mountable_with_operation_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes an unmount operation,
see g_file_unmount_mountable_with_operation() for details.

Finish an asynchronous unmount operation that was started
with g_file_unmount_mountable_with_operation().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation finished successfully.
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">input #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="FileAttributeInfo" c:type="GFileAttributeInfo">
      <doc xml:space="preserve">Information about a specific attribute.</doc>
      <field name="name" writable="1">
        <doc xml:space="preserve">the name of the attribute.</doc>
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="type" writable="1">
        <doc xml:space="preserve">the #GFileAttributeType type of the attribute.</doc>
        <type name="FileAttributeType" c:type="GFileAttributeType"/>
      </field>
      <field name="flags" writable="1">
        <doc xml:space="preserve">a set of #GFileAttributeInfoFlags.</doc>
        <type name="FileAttributeInfoFlags" c:type="GFileAttributeInfoFlags"/>
      </field>
    </record>
    <bitfield name="FileAttributeInfoFlags" glib:type-name="GFileAttributeInfoFlags" glib:get-type="g_file_attribute_info_flags_get_type" c:type="GFileAttributeInfoFlags">
      <doc xml:space="preserve">Flags specifying the behaviour of an attribute.</doc>
      <member name="none" value="0" c:identifier="G_FILE_ATTRIBUTE_INFO_NONE" glib:nick="none">
        <doc xml:space="preserve">no flags set.</doc>
      </member>
      <member name="copy_with_file" value="1" c:identifier="G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE" glib:nick="copy-with-file">
        <doc xml:space="preserve">copy the attribute values when the file is copied.</doc>
      </member>
      <member name="copy_when_moved" value="2" c:identifier="G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED" glib:nick="copy-when-moved">
        <doc xml:space="preserve">copy the attribute values when the file is moved.</doc>
      </member>
    </bitfield>
    <record name="FileAttributeInfoList" c:type="GFileAttributeInfoList" glib:type-name="GFileAttributeInfoList" glib:get-type="g_file_attribute_info_list_get_type" c:symbol-prefix="file_attribute_info_list">
      <doc xml:space="preserve">Acts as a lightweight registry for possible valid file attributes.
The registry stores Key-Value pair formats as #GFileAttributeInfos.</doc>
      <field name="infos" writable="1">
        <doc xml:space="preserve">an array of #GFileAttributeInfos.</doc>
        <type name="FileAttributeInfo" c:type="GFileAttributeInfo*"/>
      </field>
      <field name="n_infos" writable="1">
        <doc xml:space="preserve">the number of values in the array.</doc>
        <type name="gint" c:type="int"/>
      </field>
      <constructor name="new" c:identifier="g_file_attribute_info_list_new">
        <doc xml:space="preserve">Creates a new file attribute info list.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileAttributeInfoList.</doc>
          <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*"/>
        </return-value>
      </constructor>
      <method name="add" c:identifier="g_file_attribute_info_list_add">
        <doc xml:space="preserve">Adds a new attribute with @name to the @list, setting
its @type and @flags.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileAttributeInfoList.</doc>
            <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the attribute to add.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the #GFileAttributeType for the attribute.</doc>
            <type name="FileAttributeType" c:type="GFileAttributeType"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">#GFileAttributeInfoFlags for the attribute.</doc>
            <type name="FileAttributeInfoFlags" c:type="GFileAttributeInfoFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="g_file_attribute_info_list_dup">
        <doc xml:space="preserve">Makes a duplicate of a file attribute info list.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a copy of the given @list.</doc>
          <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*"/>
        </return-value>
        <parameters>
          <instance-parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileAttributeInfoList to duplicate.</doc>
            <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="lookup" c:identifier="g_file_attribute_info_list_lookup">
        <doc xml:space="preserve">Gets the file attribute with the name @name from @list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GFileAttributeInfo for the @name, or %NULL if an
attribute isn't found.</doc>
          <type name="FileAttributeInfo" c:type="const GFileAttributeInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileAttributeInfoList.</doc>
            <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the attribute to lookup.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_file_attribute_info_list_ref">
        <doc xml:space="preserve">References a file attribute info list.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GFileAttributeInfoList or %NULL on error.</doc>
          <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*"/>
        </return-value>
        <parameters>
          <instance-parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileAttributeInfoList to reference.</doc>
            <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_file_attribute_info_list_unref">
        <doc xml:space="preserve">Removes a reference from the given @list. If the reference count
falls to zero, the @list is deleted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">The #GFileAttributeInfoList to unreference.</doc>
            <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="FileAttributeMatcher" c:type="GFileAttributeMatcher" glib:type-name="GFileAttributeMatcher" glib:get-type="g_file_attribute_matcher_get_type" c:symbol-prefix="file_attribute_matcher">
      <doc xml:space="preserve">Determines if a string matches a file attribute.</doc>
      <constructor name="new" c:identifier="g_file_attribute_matcher_new">
        <doc xml:space="preserve">Creates a new file attribute matcher, which matches attributes
against a given string. #GFileAttributeMatchers are reference
counted structures, and are created with a reference count of 1. If
the number of references falls to 0, the #GFileAttributeMatcher is
automatically destroyed.

The @attribute string should be formatted with specific keys separated
from namespaces with a double colon. Several "namespace::key" strings may be
concatenated with a single comma (e.g. "standard::type,standard::is-hidden").
The wildcard "*" may be used to match all keys and namespaces, or
"namespace::*" will match all keys in a given namespace.

## Examples of file attribute matcher strings and results

- `"*"`: matches all attributes.
- `"standard::is-hidden"`: matches only the key is-hidden in the
  standard namespace.
- `"standard::type,unix::*"`: matches the type key in the standard
  namespace and all keys in the unix namespace.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileAttributeMatcher</doc>
          <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">an attribute string to match.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="enumerate_namespace" c:identifier="g_file_attribute_matcher_enumerate_namespace">
        <doc xml:space="preserve">Checks if the matcher will match all of the keys in a given namespace.
This will always return %TRUE if a wildcard character is in use (e.g. if
matcher was created with "standard::*" and @ns is "standard", or if matcher was created
using "*" and namespace is anything.)

TODO: this is awkwardly worded.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the matcher matches all of the entries
in the given @ns, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="matcher" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileAttributeMatcher.</doc>
            <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*"/>
          </instance-parameter>
          <parameter name="ns" transfer-ownership="none">
            <doc xml:space="preserve">a string containing a file attribute namespace.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="enumerate_next" c:identifier="g_file_attribute_matcher_enumerate_next">
        <doc xml:space="preserve">Gets the next matched attribute from a #GFileAttributeMatcher.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string containing the next attribute or %NULL if
no more attribute exist.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="matcher" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileAttributeMatcher.</doc>
            <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="matches" c:identifier="g_file_attribute_matcher_matches">
        <doc xml:space="preserve">Checks if an attribute will be matched by an attribute matcher. If
the matcher was created with the "*" matching string, this function
will always return %TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @attribute matches @matcher. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="matcher" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileAttributeMatcher.</doc>
            <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="matches_only" c:identifier="g_file_attribute_matcher_matches_only">
        <doc xml:space="preserve">Checks if a attribute matcher only matches a given attribute. Always
returns %FALSE if "*" was used when creating the matcher.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the matcher only matches @attribute. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="matcher" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileAttributeMatcher.</doc>
            <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_file_attribute_matcher_ref">
        <doc xml:space="preserve">References a file attribute matcher.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileAttributeMatcher.</doc>
          <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*"/>
        </return-value>
        <parameters>
          <instance-parameter name="matcher" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileAttributeMatcher.</doc>
            <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="subtract" c:identifier="g_file_attribute_matcher_subtract">
        <doc xml:space="preserve">Subtracts all attributes of @subtract from @matcher and returns
a matcher that supports those attributes.

Note that currently it is not possible to remove a single
attribute when the @matcher matches the whole namespace - or remove
a namespace or attribute when the matcher matches everything. This
is a limitation of the current implementation, but may be fixed
in the future.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A file attribute matcher matching all attributes of
    @matcher that are not matched by @subtract</doc>
          <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*"/>
        </return-value>
        <parameters>
          <instance-parameter name="matcher" transfer-ownership="none">
            <doc xml:space="preserve">Matcher to subtract from</doc>
            <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*"/>
          </instance-parameter>
          <parameter name="subtract" transfer-ownership="none">
            <doc xml:space="preserve">The matcher to subtract</doc>
            <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="g_file_attribute_matcher_to_string" version="2.32">
        <doc xml:space="preserve">Prints what the matcher is matching against. The format will be
equal to the format passed to g_file_attribute_matcher_new().
The output however, might not be identical, as the matcher may
decide to use a different order or omit needless parts.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a string describing the attributes the matcher matches
  against or %NULL if @matcher was %NULL.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="matcher" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GFileAttributeMatcher.</doc>
            <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_file_attribute_matcher_unref">
        <doc xml:space="preserve">Unreferences @matcher. If the reference count falls below 1,
the @matcher is automatically freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matcher" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileAttributeMatcher.</doc>
            <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="FileAttributeStatus" glib:type-name="GFileAttributeStatus" glib:get-type="g_file_attribute_status_get_type" c:type="GFileAttributeStatus">
      <doc xml:space="preserve">Used by g_file_set_attributes_from_info() when setting file attributes.</doc>
      <member name="unset" value="0" c:identifier="G_FILE_ATTRIBUTE_STATUS_UNSET" glib:nick="unset">
        <doc xml:space="preserve">Attribute value is unset (empty).</doc>
      </member>
      <member name="set" value="1" c:identifier="G_FILE_ATTRIBUTE_STATUS_SET" glib:nick="set">
        <doc xml:space="preserve">Attribute value is set.</doc>
      </member>
      <member name="error_setting" value="2" c:identifier="G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING" glib:nick="error-setting">
        <doc xml:space="preserve">Indicates an error in setting the value.</doc>
      </member>
    </enumeration>
    <enumeration name="FileAttributeType" glib:type-name="GFileAttributeType" glib:get-type="g_file_attribute_type_get_type" c:type="GFileAttributeType">
      <doc xml:space="preserve">The data types for file attributes.</doc>
      <member name="invalid" value="0" c:identifier="G_FILE_ATTRIBUTE_TYPE_INVALID" glib:nick="invalid">
        <doc xml:space="preserve">indicates an invalid or uninitalized type.</doc>
      </member>
      <member name="string" value="1" c:identifier="G_FILE_ATTRIBUTE_TYPE_STRING" glib:nick="string">
        <doc xml:space="preserve">a null terminated UTF8 string.</doc>
      </member>
      <member name="byte_string" value="2" c:identifier="G_FILE_ATTRIBUTE_TYPE_BYTE_STRING" glib:nick="byte-string">
        <doc xml:space="preserve">a zero terminated string of non-zero bytes.</doc>
      </member>
      <member name="boolean" value="3" c:identifier="G_FILE_ATTRIBUTE_TYPE_BOOLEAN" glib:nick="boolean">
        <doc xml:space="preserve">a boolean value.</doc>
      </member>
      <member name="uint32" value="4" c:identifier="G_FILE_ATTRIBUTE_TYPE_UINT32" glib:nick="uint32">
        <doc xml:space="preserve">an unsigned 4-byte/32-bit integer.</doc>
      </member>
      <member name="int32" value="5" c:identifier="G_FILE_ATTRIBUTE_TYPE_INT32" glib:nick="int32">
        <doc xml:space="preserve">a signed 4-byte/32-bit integer.</doc>
      </member>
      <member name="uint64" value="6" c:identifier="G_FILE_ATTRIBUTE_TYPE_UINT64" glib:nick="uint64">
        <doc xml:space="preserve">an unsigned 8-byte/64-bit integer.</doc>
      </member>
      <member name="int64" value="7" c:identifier="G_FILE_ATTRIBUTE_TYPE_INT64" glib:nick="int64">
        <doc xml:space="preserve">a signed 8-byte/64-bit integer.</doc>
      </member>
      <member name="object" value="8" c:identifier="G_FILE_ATTRIBUTE_TYPE_OBJECT" glib:nick="object">
        <doc xml:space="preserve">a #GObject.</doc>
      </member>
      <member name="stringv" value="9" c:identifier="G_FILE_ATTRIBUTE_TYPE_STRINGV" glib:nick="stringv">
        <doc xml:space="preserve">a %NULL terminated char **. Since 2.22</doc>
      </member>
    </enumeration>
    <bitfield name="FileCopyFlags" glib:type-name="GFileCopyFlags" glib:get-type="g_file_copy_flags_get_type" c:type="GFileCopyFlags">
      <doc xml:space="preserve">Flags used when copying or moving files.</doc>
      <member name="none" value="0" c:identifier="G_FILE_COPY_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
      <member name="overwrite" value="1" c:identifier="G_FILE_COPY_OVERWRITE" glib:nick="overwrite">
        <doc xml:space="preserve">Overwrite any existing files</doc>
      </member>
      <member name="backup" value="2" c:identifier="G_FILE_COPY_BACKUP" glib:nick="backup">
        <doc xml:space="preserve">Make a backup of any existing files.</doc>
      </member>
      <member name="nofollow_symlinks" value="4" c:identifier="G_FILE_COPY_NOFOLLOW_SYMLINKS" glib:nick="nofollow-symlinks">
        <doc xml:space="preserve">Don't follow symlinks.</doc>
      </member>
      <member name="all_metadata" value="8" c:identifier="G_FILE_COPY_ALL_METADATA" glib:nick="all-metadata">
        <doc xml:space="preserve">Copy all file metadata instead of just default set used for copy (see #GFileInfo).</doc>
      </member>
      <member name="no_fallback_for_move" value="16" c:identifier="G_FILE_COPY_NO_FALLBACK_FOR_MOVE" glib:nick="no-fallback-for-move">
        <doc xml:space="preserve">Don't use copy and delete fallback if native move not supported.</doc>
      </member>
      <member name="target_default_perms" value="32" c:identifier="G_FILE_COPY_TARGET_DEFAULT_PERMS" glib:nick="target-default-perms">
        <doc xml:space="preserve">Leaves target file with default perms, instead of setting the source file perms.</doc>
      </member>
    </bitfield>
    <bitfield name="FileCreateFlags" glib:type-name="GFileCreateFlags" glib:get-type="g_file_create_flags_get_type" c:type="GFileCreateFlags">
      <doc xml:space="preserve">Flags used when an operation may create a file.</doc>
      <member name="none" value="0" c:identifier="G_FILE_CREATE_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
      <member name="private" value="1" c:identifier="G_FILE_CREATE_PRIVATE" glib:nick="private">
        <doc xml:space="preserve">Create a file that can only be
   accessed by the current user.</doc>
      </member>
      <member name="replace_destination" value="2" c:identifier="G_FILE_CREATE_REPLACE_DESTINATION" glib:nick="replace-destination">
        <doc xml:space="preserve">Replace the destination
   as if it didn't exist before. Don't try to keep any old
   permissions, replace instead of following links. This
   is generally useful if you're doing a "copy over"
   rather than a "save new version of" replace operation.
   You can think of it as "unlink destination" before
   writing to it, although the implementation may not
   be exactly like that. Since 2.20</doc>
      </member>
    </bitfield>
    <interface name="FileDescriptorBased" c:symbol-prefix="file_descriptor_based" c:type="GFileDescriptorBased" glib:type-name="GFileDescriptorBased" glib:get-type="g_file_descriptor_based_get_type" glib:type-struct="FileDescriptorBasedIface">
      <doc xml:space="preserve">#GFileDescriptorBased is implemented by streams (implementations of
#GInputStream or #GOutputStream) that are based on file descriptors.

Note that `&lt;gio/gfiledescriptorbased.h&gt;` belongs to the UNIX-specific
GIO interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
file when using it.</doc>
      <virtual-method name="get_fd" invoker="get_fd" version="2.24">
        <doc xml:space="preserve">Gets the underlying file descriptor.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The file descriptor</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="fd_based" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileDescriptorBased.</doc>
            <type name="FileDescriptorBased" c:type="GFileDescriptorBased*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="get_fd" c:identifier="g_file_descriptor_based_get_fd" version="2.24">
        <doc xml:space="preserve">Gets the underlying file descriptor.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The file descriptor</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="fd_based" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileDescriptorBased.</doc>
            <type name="FileDescriptorBased" c:type="GFileDescriptorBased*"/>
          </instance-parameter>
        </parameters>
      </method>
    </interface>
    <record name="FileDescriptorBasedIface" c:type="GFileDescriptorBasedIface" glib:is-gtype-struct-for="FileDescriptorBased">
      <doc xml:space="preserve">An interface for file descriptor based io objects.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_fd">
        <callback name="get_fd">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The file descriptor</doc>
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="fd_based" transfer-ownership="none">
              <doc xml:space="preserve">a #GFileDescriptorBased.</doc>
              <type name="FileDescriptorBased" c:type="GFileDescriptorBased*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="FileEnumerator" c:symbol-prefix="file_enumerator" c:type="GFileEnumerator" parent="GObject.Object" glib:type-name="GFileEnumerator" glib:get-type="g_file_enumerator_get_type" glib:type-struct="FileEnumeratorClass">
      <doc xml:space="preserve">#GFileEnumerator allows you to operate on a set of #GFiles,
returning a #GFileInfo structure for each file enumerated (e.g.
g_file_enumerate_children() will return a #GFileEnumerator for each
of the children within a directory).

To get the next file's information from a #GFileEnumerator, use
g_file_enumerator_next_file() or its asynchronous version,
g_file_enumerator_next_files_async(). Note that the asynchronous
version will return a list of #GFileInfos, whereas the
synchronous will only return the next file in the enumerator.

The ordering of returned files is unspecified for non-Unix
platforms; for more information, see g_dir_read_name().  On Unix,
when operating on local files, returned files will be sorted by
inode number.  Effectively you can assume that the ordering of
returned files will be stable between successive calls (and
applications) assuming the directory is unchanged.

If your application needs a specific ordering, such as by name or
modification time, you will have to implement that in your
application code.

To close a #GFileEnumerator, use g_file_enumerator_close(), or
its asynchronous version, g_file_enumerator_close_async(). Once
a #GFileEnumerator is closed, no further actions may be performed
on it, and it should be freed with g_object_unref().</doc>
      <virtual-method name="close_async" invoker="close_async">
        <doc xml:space="preserve">Asynchronously closes the file enumerator.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned in
g_file_enumerator_close_finish().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileEnumerator.</doc>
            <type name="FileEnumerator" c:type="GFileEnumerator*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="close_finish" invoker="close_finish" throws="1">
        <doc xml:space="preserve">Finishes closing a file enumerator, started from g_file_enumerator_close_async().

If the file enumerator was already closed when g_file_enumerator_close_async()
was called, then this function will report %G_IO_ERROR_CLOSED in @error, and
return %FALSE. If the file enumerator had pending operation when the close
operation was started, then this function will report %G_IO_ERROR_PENDING, and
return %FALSE.  If @cancellable was not %NULL, then the operation may have been
cancelled by triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %FALSE will be
returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the close operation has finished successfully.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileEnumerator.</doc>
            <type name="FileEnumerator" c:type="GFileEnumerator*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="close_fn" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <type name="FileEnumerator" c:type="GFileEnumerator*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="next_file" invoker="next_file" throws="1">
        <doc xml:space="preserve">Returns information for the next file in the enumerated object.
Will block until the information is available. The #GFileInfo
returned from this function will contain attributes that match the
attribute string that was passed when the #GFileEnumerator was created.

See the documentation of #GFileEnumerator for information about the
order of returned files.

On error, returns %NULL and sets @error to the error. If the
enumerator is at the end, %NULL will be returned and @error will
be unset.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">A #GFileInfo or %NULL on error
   or end of enumerator.  Free the returned object with
   g_object_unref() when no longer needed.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileEnumerator.</doc>
            <type name="FileEnumerator" c:type="GFileEnumerator*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="next_files_async" invoker="next_files_async">
        <doc xml:space="preserve">Request information for a number of files from the enumerator asynchronously.
When all i/o for the operation is finished the @callback will be called with
the requested information.

See the documentation of #GFileEnumerator for information about the
order of returned files.

The callback can be called with less than @num_files files in case of error
or at the end of the enumerator. In case of a partial error the callback will
be called with any succeeding items and no error, and on the next request the
error will be reported. If a request is cancelled the callback will be called
with %G_IO_ERROR_CANCELLED.

During an async request no other sync and async calls are allowed, and will
result in %G_IO_ERROR_PENDING errors.

Any outstanding i/o request with higher priority (lower numerical value) will
be executed before an outstanding request with lower priority. Default
priority is %G_PRIORITY_DEFAULT.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileEnumerator.</doc>
            <type name="FileEnumerator" c:type="GFileEnumerator*"/>
          </instance-parameter>
          <parameter name="num_files" transfer-ownership="none">
            <doc xml:space="preserve">the number of file info objects to request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="next_files_finish" invoker="next_files_finish" throws="1">
        <doc xml:space="preserve">Finishes the asynchronous operation started with g_file_enumerator_next_files_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GList of #GFileInfos. You must free the list with
    g_list_free() and unref the infos with g_object_unref() when you're
    done with them.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="FileInfo"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileEnumerator.</doc>
            <type name="FileEnumerator" c:type="GFileEnumerator*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="close" c:identifier="g_file_enumerator_close" throws="1">
        <doc xml:space="preserve">Releases all resources used by this enumerator, making the
enumerator return %G_IO_ERROR_CLOSED on all calls.

This will be automatically called when the last reference
is dropped, but you might want to call this function to make
sure resources are released as early as possible.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#TRUE on success or #FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileEnumerator.</doc>
            <type name="FileEnumerator" c:type="GFileEnumerator*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_async" c:identifier="g_file_enumerator_close_async">
        <doc xml:space="preserve">Asynchronously closes the file enumerator.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned in
g_file_enumerator_close_finish().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileEnumerator.</doc>
            <type name="FileEnumerator" c:type="GFileEnumerator*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_finish" c:identifier="g_file_enumerator_close_finish" throws="1">
        <doc xml:space="preserve">Finishes closing a file enumerator, started from g_file_enumerator_close_async().

If the file enumerator was already closed when g_file_enumerator_close_async()
was called, then this function will report %G_IO_ERROR_CLOSED in @error, and
return %FALSE. If the file enumerator had pending operation when the close
operation was started, then this function will report %G_IO_ERROR_PENDING, and
return %FALSE.  If @cancellable was not %NULL, then the operation may have been
cancelled by triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %FALSE will be
returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the close operation has finished successfully.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileEnumerator.</doc>
            <type name="FileEnumerator" c:type="GFileEnumerator*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_child" c:identifier="g_file_enumerator_get_child" version="2.36">
        <doc xml:space="preserve">Return a new #GFile which refers to the file named by @info in the source
directory of @enumerator.  This function is primarily intended to be used
inside loops with g_file_enumerator_next_file().

This is a convenience method that's equivalent to:
|[&lt;!-- language="C" --&gt;
  gchar *name = g_file_info_get_name (info);
  GFile *child = g_file_get_child (g_file_enumerator_get_container (enumr),
                                   name);
]|</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFile for the #GFileInfo passed it.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileEnumerator</doc>
            <type name="FileEnumerator" c:type="GFileEnumerator*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo gotten from g_file_enumerator_next_file()
  or the async equivalents.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_container" c:identifier="g_file_enumerator_get_container" version="2.18">
        <doc xml:space="preserve">Get the #GFile container which is being enumerated.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GFile which is being enumerated.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileEnumerator</doc>
            <type name="FileEnumerator" c:type="GFileEnumerator*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_pending" c:identifier="g_file_enumerator_has_pending">
        <doc xml:space="preserve">Checks if the file enumerator has pending operations.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @enumerator has pending operations.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileEnumerator.</doc>
            <type name="FileEnumerator" c:type="GFileEnumerator*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_closed" c:identifier="g_file_enumerator_is_closed">
        <doc xml:space="preserve">Checks if the file enumerator has been closed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @enumerator is closed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileEnumerator.</doc>
            <type name="FileEnumerator" c:type="GFileEnumerator*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="iterate" c:identifier="g_file_enumerator_iterate" version="2.44" throws="1">
        <doc xml:space="preserve">This is a version of g_file_enumerator_next_file() that's easier to
use correctly from C programs.  With g_file_enumerator_next_file(),
the gboolean return value signifies "end of iteration or error", which
requires allocation of a temporary #GError.

In contrast, with this function, a %FALSE return from
g_file_enumerator_iterate() *always* means
"error".  End of iteration is signaled by @out_info or @out_child being %NULL.

Another crucial difference is that the references for @out_info and
@out_child are owned by @direnum (they are cached as hidden
properties).  You must not unref them in your own code.  This makes
memory management significantly easier for C code in combination
with loops.

Finally, this function optionally allows retrieving a #GFile as
well.

You must specify at least one of @out_info or @out_child.

The code pattern for correctly using g_file_enumerator_iterate() from C
is:

|[
direnum = g_file_enumerate_children (file, ...);
while (TRUE)
  {
    GFileInfo *info;
    if (!g_file_enumerator_iterate (direnum, &amp;info, NULL, cancellable, error))
      goto out;
    if (!info)
      break;
    ... do stuff with "info"; do not unref it! ...
  }

out:
  g_object_unref (direnum); // Note: frees the last @info
]|</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="direnum" transfer-ownership="none">
            <doc xml:space="preserve">an open #GFileEnumerator</doc>
            <type name="FileEnumerator" c:type="GFileEnumerator*"/>
          </instance-parameter>
          <parameter name="out_info" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1">
            <doc xml:space="preserve">Output location for the next #GFileInfo, or %NULL</doc>
            <type name="FileInfo" c:type="GFileInfo**"/>
          </parameter>
          <parameter name="out_child" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1">
            <doc xml:space="preserve">Output location for the next #GFile, or %NULL</doc>
            <type name="File" c:type="GFile**"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="next_file" c:identifier="g_file_enumerator_next_file" throws="1">
        <doc xml:space="preserve">Returns information for the next file in the enumerated object.
Will block until the information is available. The #GFileInfo
returned from this function will contain attributes that match the
attribute string that was passed when the #GFileEnumerator was created.

See the documentation of #GFileEnumerator for information about the
order of returned files.

On error, returns %NULL and sets @error to the error. If the
enumerator is at the end, %NULL will be returned and @error will
be unset.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">A #GFileInfo or %NULL on error
   or end of enumerator.  Free the returned object with
   g_object_unref() when no longer needed.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileEnumerator.</doc>
            <type name="FileEnumerator" c:type="GFileEnumerator*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="next_files_async" c:identifier="g_file_enumerator_next_files_async">
        <doc xml:space="preserve">Request information for a number of files from the enumerator asynchronously.
When all i/o for the operation is finished the @callback will be called with
the requested information.

See the documentation of #GFileEnumerator for information about the
order of returned files.

The callback can be called with less than @num_files files in case of error
or at the end of the enumerator. In case of a partial error the callback will
be called with any succeeding items and no error, and on the next request the
error will be reported. If a request is cancelled the callback will be called
with %G_IO_ERROR_CANCELLED.

During an async request no other sync and async calls are allowed, and will
result in %G_IO_ERROR_PENDING errors.

Any outstanding i/o request with higher priority (lower numerical value) will
be executed before an outstanding request with lower priority. Default
priority is %G_PRIORITY_DEFAULT.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileEnumerator.</doc>
            <type name="FileEnumerator" c:type="GFileEnumerator*"/>
          </instance-parameter>
          <parameter name="num_files" transfer-ownership="none">
            <doc xml:space="preserve">the number of file info objects to request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="next_files_finish" c:identifier="g_file_enumerator_next_files_finish" throws="1">
        <doc xml:space="preserve">Finishes the asynchronous operation started with g_file_enumerator_next_files_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GList of #GFileInfos. You must free the list with
    g_list_free() and unref the infos with g_object_unref() when you're
    done with them.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="FileInfo"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileEnumerator.</doc>
            <type name="FileEnumerator" c:type="GFileEnumerator*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pending" c:identifier="g_file_enumerator_set_pending">
        <doc xml:space="preserve">Sets the file enumerator as having pending operations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileEnumerator.</doc>
            <type name="FileEnumerator" c:type="GFileEnumerator*"/>
          </instance-parameter>
          <parameter name="pending" transfer-ownership="none">
            <doc xml:space="preserve">a boolean value.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="container" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <type name="File"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="FileEnumeratorPrivate" c:type="GFileEnumeratorPrivate*"/>
      </field>
    </class>
    <record name="FileEnumeratorClass" c:type="GFileEnumeratorClass" glib:is-gtype-struct-for="FileEnumerator">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="next_file">
        <callback name="next_file" throws="1">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">A #GFileInfo or %NULL on error
   or end of enumerator.  Free the returned object with
   g_object_unref() when no longer needed.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </return-value>
          <parameters>
            <parameter name="enumerator" transfer-ownership="none">
              <doc xml:space="preserve">a #GFileEnumerator.</doc>
              <type name="FileEnumerator" c:type="GFileEnumerator*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_fn">
        <callback name="close_fn" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enumerator" transfer-ownership="none">
              <type name="FileEnumerator" c:type="GFileEnumerator*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="next_files_async">
        <callback name="next_files_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="enumerator" transfer-ownership="none">
              <doc xml:space="preserve">a #GFileEnumerator.</doc>
              <type name="FileEnumerator" c:type="GFileEnumerator*"/>
            </parameter>
            <parameter name="num_files" transfer-ownership="none">
              <doc xml:space="preserve">the number of file info objects to request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="next_files_finish">
        <callback name="next_files_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GList of #GFileInfos. You must free the list with
    g_list_free() and unref the infos with g_object_unref() when you're
    done with them.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="FileInfo"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="enumerator" transfer-ownership="none">
              <doc xml:space="preserve">a #GFileEnumerator.</doc>
              <type name="FileEnumerator" c:type="GFileEnumerator*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_async">
        <callback name="close_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="enumerator" transfer-ownership="none">
              <doc xml:space="preserve">a #GFileEnumerator.</doc>
              <type name="FileEnumerator" c:type="GFileEnumerator*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_finish">
        <callback name="close_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the close operation has finished successfully.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enumerator" transfer-ownership="none">
              <doc xml:space="preserve">a #GFileEnumerator.</doc>
              <type name="FileEnumerator" c:type="GFileEnumerator*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved6" introspectable="0">
        <callback name="_g_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved7" introspectable="0">
        <callback name="_g_reserved7">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="FileEnumeratorPrivate" c:type="GFileEnumeratorPrivate" disguised="1">
    </record>
    <class name="FileIOStream" c:symbol-prefix="file_io_stream" c:type="GFileIOStream" parent="IOStream" glib:type-name="GFileIOStream" glib:get-type="g_file_io_stream_get_type" glib:type-struct="FileIOStreamClass">
      <doc xml:space="preserve">GFileIOStream provides io streams that both read and write to the same
file handle.

GFileIOStream implements #GSeekable, which allows the io
stream to jump to arbitrary positions in the file and to truncate
the file, provided the filesystem of the file supports these
operations.

To find the position of a file io stream, use
g_seekable_tell().

To find out if a file io stream supports seeking, use g_seekable_can_seek().
To position a file io stream, use g_seekable_seek().
To find out if a file io stream supports truncating, use
g_seekable_can_truncate(). To truncate a file io
stream, use g_seekable_truncate().

The default implementation of all the #GFileIOStream operations
and the implementation of #GSeekable just call into the same operations
on the output stream.</doc>
      <implements name="Seekable"/>
      <virtual-method name="can_seek">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <type name="FileIOStream" c:type="GFileIOStream*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="can_truncate">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <type name="FileIOStream" c:type="GFileIOStream*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_etag" invoker="get_etag" version="2.22">
        <doc xml:space="preserve">Gets the entity tag for the file when it has been written.
This must be called after the stream has been written
and closed, as the etag can change while writing.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the entity tag for the stream.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileIOStream.</doc>
            <type name="FileIOStream" c:type="GFileIOStream*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_info" invoker="query_info" version="2.22" throws="1">
        <doc xml:space="preserve">Queries a file io stream for the given @attributes.
This function blocks while querying the stream. For the asynchronous
version of this function, see g_file_io_stream_query_info_async().
While the stream is blocked, the stream will set the pending flag
internally, and any other operations on the stream will fail with
%G_IO_ERROR_PENDING.

Can fail if the stream was already closed (with @error being set to
%G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
set to %G_IO_ERROR_PENDING), or if querying info is not supported for
the stream's interface (with @error being set to %G_IO_ERROR_NOT_SUPPORTED). I
all cases of failure, %NULL will be returned.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileInfo for the @stream, or %NULL on error.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileIOStream.</doc>
            <type name="FileIOStream" c:type="GFileIOStream*"/>
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_info_async" invoker="query_info_async" version="2.22">
        <doc xml:space="preserve">Asynchronously queries the @stream for a #GFileInfo. When completed,
@callback will be called with a #GAsyncResult which can be used to
finish the operation with g_file_io_stream_query_info_finish().

For the synchronous version of this function, see
g_file_io_stream_query_info().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileIOStream.</doc>
            <type name="FileIOStream" c:type="GFileIOStream*"/>
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][gio-GIOScheduler] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_info_finish" invoker="query_info_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finalizes the asynchronous query started
by g_file_io_stream_query_info_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GFileInfo for the finished query.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileIOStream.</doc>
            <type name="FileIOStream" c:type="GFileIOStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="seek" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <type name="FileIOStream" c:type="GFileIOStream*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <type name="GLib.SeekType" c:type="GSeekType"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="tell">
        <return-value transfer-ownership="none">
          <type name="gint64" c:type="goffset"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <type name="FileIOStream" c:type="GFileIOStream*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="truncate_fn" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <type name="FileIOStream" c:type="GFileIOStream*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_etag" c:identifier="g_file_io_stream_get_etag" version="2.22">
        <doc xml:space="preserve">Gets the entity tag for the file when it has been written.
This must be called after the stream has been written
and closed, as the etag can change while writing.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the entity tag for the stream.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileIOStream.</doc>
            <type name="FileIOStream" c:type="GFileIOStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="query_info" c:identifier="g_file_io_stream_query_info" version="2.22" throws="1">
        <doc xml:space="preserve">Queries a file io stream for the given @attributes.
This function blocks while querying the stream. For the asynchronous
version of this function, see g_file_io_stream_query_info_async().
While the stream is blocked, the stream will set the pending flag
internally, and any other operations on the stream will fail with
%G_IO_ERROR_PENDING.

Can fail if the stream was already closed (with @error being set to
%G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
set to %G_IO_ERROR_PENDING), or if querying info is not supported for
the stream's interface (with @error being set to %G_IO_ERROR_NOT_SUPPORTED). I
all cases of failure, %NULL will be returned.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileInfo for the @stream, or %NULL on error.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileIOStream.</doc>
            <type name="FileIOStream" c:type="GFileIOStream*"/>
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_info_async" c:identifier="g_file_io_stream_query_info_async" version="2.22">
        <doc xml:space="preserve">Asynchronously queries the @stream for a #GFileInfo. When completed,
@callback will be called with a #GAsyncResult which can be used to
finish the operation with g_file_io_stream_query_info_finish().

For the synchronous version of this function, see
g_file_io_stream_query_info().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileIOStream.</doc>
            <type name="FileIOStream" c:type="GFileIOStream*"/>
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][gio-GIOScheduler] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_info_finish" c:identifier="g_file_io_stream_query_info_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finalizes the asynchronous query started
by g_file_io_stream_query_info_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GFileInfo for the finished query.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileIOStream.</doc>
            <type name="FileIOStream" c:type="GFileIOStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="IOStream" c:type="GIOStream"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="FileIOStreamPrivate" c:type="GFileIOStreamPrivate*"/>
      </field>
    </class>
    <record name="FileIOStreamClass" c:type="GFileIOStreamClass" glib:is-gtype-struct-for="FileIOStream">
      <field name="parent_class">
        <type name="IOStreamClass" c:type="GIOStreamClass"/>
      </field>
      <field name="tell">
        <callback name="tell">
          <return-value transfer-ownership="none">
            <type name="gint64" c:type="goffset"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileIOStream" c:type="GFileIOStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_seek">
        <callback name="can_seek">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileIOStream" c:type="GFileIOStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="seek">
        <callback name="seek" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileIOStream" c:type="GFileIOStream*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <type name="gint64" c:type="goffset"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <type name="GLib.SeekType" c:type="GSeekType"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_truncate">
        <callback name="can_truncate">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileIOStream" c:type="GFileIOStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="truncate_fn">
        <callback name="truncate_fn" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileIOStream" c:type="GFileIOStream*"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="gint64" c:type="goffset"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_info">
        <callback name="query_info" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFileInfo for the @stream, or %NULL on error.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GFileIOStream.</doc>
              <type name="FileIOStream" c:type="GFileIOStream*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:space="preserve">a file attribute query string.</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_info_async">
        <callback name="query_info_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GFileIOStream.</doc>
              <type name="FileIOStream" c:type="GFileIOStream*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:space="preserve">a file attribute query string.</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][gio-GIOScheduler] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_info_finish">
        <callback name="query_info_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A #GFileInfo for the finished query.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GFileIOStream.</doc>
              <type name="FileIOStream" c:type="GFileIOStream*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_etag">
        <callback name="get_etag">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the entity tag for the stream.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GFileIOStream.</doc>
              <type name="FileIOStream" c:type="GFileIOStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="FileIOStreamPrivate" c:type="GFileIOStreamPrivate" disguised="1">
    </record>
    <class name="FileIcon" c:symbol-prefix="file_icon" c:type="GFileIcon" parent="GObject.Object" glib:type-name="GFileIcon" glib:get-type="g_file_icon_get_type" glib:type-struct="FileIconClass">
      <doc xml:space="preserve">#GFileIcon specifies an icon by pointing to an image file
to be used as icon.</doc>
      <implements name="Icon"/>
      <implements name="LoadableIcon"/>
      <constructor name="new" c:identifier="g_file_icon_new">
        <doc xml:space="preserve">Creates a new icon for a file.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GIcon for the given
  @file, or %NULL on error.</doc>
          <type name="FileIcon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile.</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_file" c:identifier="g_file_icon_get_file">
        <doc xml:space="preserve">Gets the #GFile associated with the given @icon.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GFile, or %NULL.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">a #GIcon.</doc>
            <type name="FileIcon" c:type="GFileIcon*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="file" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The file containing the icon.</doc>
        <type name="File"/>
      </property>
    </class>
    <record name="FileIconClass" c:type="GFileIconClass" disguised="1" glib:is-gtype-struct-for="FileIcon">
    </record>
    <record name="FileIface" c:type="GFileIface" glib:is-gtype-struct-for="File">
      <doc xml:space="preserve">An interface for writing VFS file handles.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="dup">
        <callback name="dup">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a new #GFile that is a duplicate
    of the given #GFile.</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="hash">
        <callback name="hash">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">0 if @file is not a valid #GFile, otherwise an
    integer that can be used as hash value for the #GFile.
    This function is intended for easily hashing a #GFile to
    add to a #GHashTable or similar data structure.</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">#gconstpointer to a #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="equal">
        <callback name="equal">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @file1 and @file2 are equal.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file1" transfer-ownership="none">
              <doc xml:space="preserve">the first #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="file2" transfer-ownership="none">
              <doc xml:space="preserve">the second #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_native">
        <callback name="is_native">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @file is native</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="has_uri_scheme">
        <callback name="has_uri_scheme">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if #GFile's backend supports the
    given URI scheme, %FALSE if URI scheme is %NULL,
    not supported, or #GFile is invalid.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="uri_scheme" transfer-ownership="none">
              <doc xml:space="preserve">a string containing a URI scheme</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_uri_scheme">
        <callback name="get_uri_scheme">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a string containing the URI scheme for the given
    #GFile. The returned string should be freed with g_free()
    when no longer needed.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_basename">
        <callback name="get_basename">
          <return-value transfer-ownership="full">
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_path">
        <callback name="get_path">
          <return-value transfer-ownership="full">
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_uri">
        <callback name="get_uri">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a string containing the #GFile's URI.
    The returned string should be freed with g_free()
    when no longer needed.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_parse_name">
        <callback name="get_parse_name">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a string containing the #GFile's parse name.
    The returned string should be freed with g_free()
    when no longer needed.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_parent">
        <callback name="get_parent">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">a #GFile structure to the
    parent of the given #GFile or %NULL if there is no parent. Free
    the returned object with g_object_unref().</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prefix_matches">
        <callback name="prefix_matches">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the @files's parent, grandparent, etc is @prefix,
    %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="prefix" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_relative_path">
        <callback name="get_relative_path">
          <return-value transfer-ownership="full">
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="parent" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="descendant" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="resolve_relative_path">
        <callback name="resolve_relative_path">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">#GFile to the resolved path.
    %NULL if @relative_path is %NULL or if @file is invalid.
    Free the returned object with g_object_unref().</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="relative_path" transfer-ownership="none">
              <doc xml:space="preserve">a given relative path string</doc>
              <type name="filename" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_child_for_display_name">
        <callback name="get_child_for_display_name" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFile to the specified child, or
    %NULL if the display name couldn't be converted.
    Free the returned object with g_object_unref().</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="display_name" transfer-ownership="none">
              <doc xml:space="preserve">string to a possible child</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="enumerate_children">
        <callback name="enumerate_children" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A #GFileEnumerator if successful,
    %NULL on error. Free the returned object with g_object_unref().</doc>
            <type name="FileEnumerator" c:type="GFileEnumerator*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:space="preserve">an attribute query string</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">a set of #GFileQueryInfoFlags</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="enumerate_children_async">
        <callback name="enumerate_children_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:space="preserve">an attribute query string</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">a set of #GFileQueryInfoFlags</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call when the
    request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="enumerate_children_finish">
        <callback name="enumerate_children_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFileEnumerator or %NULL
    if an error occurred.
    Free the returned object with g_object_unref().</doc>
            <type name="FileEnumerator" c:type="GFileEnumerator*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_info">
        <callback name="query_info" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFileInfo for the given @file, or %NULL
    on error. Free the returned object with g_object_unref().</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:space="preserve">an attribute query string</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">a set of #GFileQueryInfoFlags</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_info_async">
        <callback name="query_info_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:space="preserve">an attribute query string</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">a set of #GFileQueryInfoFlags</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call when the
    request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_info_finish">
        <callback name="query_info_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">#GFileInfo for given @file
    or %NULL on error. Free the returned object with
    g_object_unref().</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_filesystem_info">
        <callback name="query_filesystem_info" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFileInfo or %NULL if there was an error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:space="preserve">an attribute query string</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_filesystem_info_async">
        <callback name="query_filesystem_info_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:space="preserve">an attribute query string</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_filesystem_info_finish">
        <callback name="query_filesystem_info_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">#GFileInfo for given @file
    or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="find_enclosing_mount">
        <callback name="find_enclosing_mount" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GMount where the @file is located
    or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="Mount" c:type="GMount*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="find_enclosing_mount_async">
        <callback name="find_enclosing_mount_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">a #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="find_enclosing_mount_finish">
        <callback name="find_enclosing_mount_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">#GMount for given @file or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="Mount" c:type="GMount*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">a #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_display_name">
        <callback name="set_display_name" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFile specifying what @file was renamed to,
    or %NULL if there was an error.
    Free the returned object with g_object_unref().</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="display_name" transfer-ownership="none">
              <doc xml:space="preserve">a string</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_display_name_async">
        <callback name="set_display_name_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="display_name" transfer-ownership="none">
              <doc xml:space="preserve">a string</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_display_name_finish">
        <callback name="set_display_name_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFile or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_settable_attributes">
        <callback name="query_settable_attributes" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFileAttributeInfoList describing the settable attributes.
    When you are done with it, release it with
    g_file_attribute_info_list_unref()</doc>
            <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_query_settable_attributes_async" introspectable="0">
        <callback name="_query_settable_attributes_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_query_settable_attributes_finish" introspectable="0">
        <callback name="_query_settable_attributes_finish">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="query_writable_namespaces">
        <callback name="query_writable_namespaces" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFileAttributeInfoList describing the writable namespaces.
    When you are done with it, release it with
    g_file_attribute_info_list_unref()</doc>
            <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_query_writable_namespaces_async" introspectable="0">
        <callback name="_query_writable_namespaces_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_query_writable_namespaces_finish" introspectable="0">
        <callback name="_query_writable_namespaces_finish">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="set_attribute">
        <callback name="set_attribute" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the attribute was set, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="attribute" transfer-ownership="none">
              <doc xml:space="preserve">a string containing the attribute's name</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <doc xml:space="preserve">The type of the attribute</doc>
              <type name="FileAttributeType" c:type="GFileAttributeType"/>
            </parameter>
            <parameter name="value_p" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a pointer to the value (or the pointer
    itself if the type is a pointer type)</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">a set of #GFileQueryInfoFlags</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_attributes_from_info">
        <callback name="set_attributes_from_info" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%FALSE if there was any error, %TRUE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <doc xml:space="preserve">a #GFileInfo</doc>
              <type name="FileInfo" c:type="GFileInfo*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">#GFileQueryInfoFlags</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_attributes_async">
        <callback name="set_attributes_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <doc xml:space="preserve">a #GFileInfo</doc>
              <type name="FileInfo" c:type="GFileInfo*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">a #GFileQueryInfoFlags</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
              <doc xml:space="preserve">a #GAsyncReadyCallback</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6">
              <doc xml:space="preserve">a #gpointer</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_attributes_finish">
        <callback name="set_attributes_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the attributes were set correctly, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
            <parameter name="info" direction="out" caller-allocates="0" transfer-ownership="full">
              <doc xml:space="preserve">a #GFileInfo</doc>
              <type name="FileInfo" c:type="GFileInfo**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="read_fn">
        <callback name="read_fn" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">#GFileInputStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileInputStream" c:type="GFileInputStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">#GFile to read</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="read_async">
        <callback name="read_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="read_finish">
        <callback name="read_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFileInputStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileInputStream" c:type="GFileInputStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="append_to">
        <callback name="append_to" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFileOutputStream, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="append_to_async">
        <callback name="append_to_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="append_to_finish">
        <callback name="append_to_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a valid #GFileOutputStream
    or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:space="preserve">#GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create">
        <callback name="create" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFileOutputStream for the newly created
    file, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_async">
        <callback name="create_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_finish">
        <callback name="create_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFileOutputStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="replace">
        <callback name="replace" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFileOutputStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">an optional [entity tag][gfile-etag]
    for the current #GFile, or #NULL to ignore</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="make_backup" transfer-ownership="none">
              <doc xml:space="preserve">%TRUE if a backup should be created</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="replace_async">
        <callback name="replace_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">an [entity tag][gfile-etag] for the current #GFile,
    or %NULL to ignore</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="make_backup" transfer-ownership="none">
              <doc xml:space="preserve">%TRUE if a backup should be created</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="7">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="7">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="replace_finish">
        <callback name="replace_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFileOutputStream, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="delete_file">
        <callback name="delete_file" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the file was deleted. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="delete_file_async">
        <callback name="delete_file_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="delete_file_finish">
        <callback name="delete_file_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the file was deleted. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="trash">
        <callback name="trash" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on successful trash, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">#GFile to send to trash</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="trash_async">
        <callback name="trash_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="trash_finish">
        <callback name="trash_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on successful trash, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="make_directory">
        <callback name="make_directory" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on successful creation, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="make_directory_async">
        <callback name="make_directory_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="make_directory_finish">
        <callback name="make_directory_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on successful directory creation, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="make_symbolic_link">
        <callback name="make_symbolic_link" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on the creation of a new symlink, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">a #GFile with the name of the symlink to create</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="symlink_value" transfer-ownership="none">
              <doc xml:space="preserve">a string with the path for the target
    of the new symlink</doc>
              <type name="filename" c:type="const char*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_make_symbolic_link_async" introspectable="0">
        <callback name="_make_symbolic_link_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_make_symbolic_link_finish" introspectable="0">
        <callback name="_make_symbolic_link_finish">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="copy">
        <callback name="copy" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="source" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="destination" transfer-ownership="none">
              <doc xml:space="preserve">destination #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">set of #GFileCopyFlags</doc>
              <type name="FileCopyFlags" c:type="GFileCopyFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="5">
              <doc xml:space="preserve">function to callback with
    progress information, or %NULL if progress information is not needed</doc>
              <type name="FileProgressCallback" c:type="GFileProgressCallback"/>
            </parameter>
            <parameter name="progress_callback_data" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">user data to pass to @progress_callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="copy_async">
        <callback name="copy_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="source" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="destination" transfer-ownership="none">
              <doc xml:space="preserve">destination #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">set of #GFileCopyFlags</doc>
              <type name="FileCopyFlags" c:type="GFileCopyFlags"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="6">
              <doc xml:space="preserve">function to callback with progress
    information, or %NULL if progress information is not needed</doc>
              <type name="FileProgressCallback" c:type="GFileProgressCallback"/>
            </parameter>
            <parameter name="progress_callback_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">user data to pass to @progress_callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="8">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="7">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="copy_finish">
        <callback name="copy_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">a %TRUE on success, %FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="move">
        <callback name="move" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on successful move, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="source" transfer-ownership="none">
              <doc xml:space="preserve">#GFile pointing to the source location</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="destination" transfer-ownership="none">
              <doc xml:space="preserve">#GFile pointing to the destination location</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">set of #GFileCopyFlags</doc>
              <type name="FileCopyFlags" c:type="GFileCopyFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="5">
              <doc xml:space="preserve">#GFileProgressCallback
    function for updates</doc>
              <type name="FileProgressCallback" c:type="GFileProgressCallback"/>
            </parameter>
            <parameter name="progress_callback_data" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">gpointer to user data for
    the callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_move_async" introspectable="0">
        <callback name="_move_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_move_finish" introspectable="0">
        <callback name="_move_finish">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="mount_mountable">
        <callback name="mount_mountable">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags affecting the operation</doc>
              <type name="MountMountFlags" c:type="GMountMountFlags"/>
            </parameter>
            <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GMountOperation,
    or %NULL to avoid user interaction</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="mount_mountable_finish">
        <callback name="mount_mountable_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFile or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unmount_mountable">
        <callback name="unmount_mountable">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags affecting the operation</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unmount_mountable_finish">
        <callback name="unmount_mountable_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the operation finished successfully.
    %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_mountable">
        <callback name="eject_mountable">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags affecting the operation</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_mountable_finish">
        <callback name="eject_mountable_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the @file was ejected successfully.
    %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="mount_enclosing_volume">
        <callback name="mount_enclosing_volume">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="location" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags affecting the operation</doc>
              <type name="MountMountFlags" c:type="GMountMountFlags"/>
            </parameter>
            <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GMountOperation
    or %NULL to avoid user interaction</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="mount_enclosing_volume_finish">
        <callback name="mount_enclosing_volume_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if successful. If an error has occurred,
    this function will return %FALSE and set @error
    appropriately if present.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="location" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="monitor_dir">
        <callback name="monitor_dir" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFileMonitor for the given @file,
    or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileMonitor" c:type="GFileMonitor*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">a set of #GFileMonitorFlags</doc>
              <type name="FileMonitorFlags" c:type="GFileMonitorFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="monitor_file">
        <callback name="monitor_file" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFileMonitor for the given @file,
    or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileMonitor" c:type="GFileMonitor*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">a set of #GFileMonitorFlags</doc>
              <type name="FileMonitorFlags" c:type="GFileMonitorFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="open_readwrite">
        <callback name="open_readwrite" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">#GFileIOStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileIOStream" c:type="GFileIOStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">#GFile to open</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="open_readwrite_async">
        <callback name="open_readwrite_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="open_readwrite_finish">
        <callback name="open_readwrite_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFileIOStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileIOStream" c:type="GFileIOStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_readwrite">
        <callback name="create_readwrite" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFileIOStream for the newly created
    file, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileIOStream" c:type="GFileIOStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">a #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_readwrite_async">
        <callback name="create_readwrite_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_readwrite_finish">
        <callback name="create_readwrite_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFileIOStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileIOStream" c:type="GFileIOStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="replace_readwrite">
        <callback name="replace_readwrite" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFileIOStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileIOStream" c:type="GFileIOStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">a #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">an optional [entity tag][gfile-etag]
    for the current #GFile, or #NULL to ignore</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="make_backup" transfer-ownership="none">
              <doc xml:space="preserve">%TRUE if a backup should be created</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="replace_readwrite_async">
        <callback name="replace_readwrite_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">an [entity tag][gfile-etag] for the current #GFile,
    or %NULL to ignore</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="make_backup" transfer-ownership="none">
              <doc xml:space="preserve">%TRUE if a backup should be created</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="7">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="7">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="replace_readwrite_finish">
        <callback name="replace_readwrite_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFileIOStream, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileIOStream" c:type="GFileIOStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="start_mountable">
        <callback name="start_mountable">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags affecting the operation</doc>
              <type name="DriveStartFlags" c:type="GDriveStartFlags"/>
            </parameter>
            <parameter name="start_operation" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GMountOperation, or %NULL to avoid user interaction</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="start_mountable_finish">
        <callback name="start_mountable_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the operation finished successfully. %FALSE
otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop_mountable">
        <callback name="stop_mountable">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags affecting the operation</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GMountOperation,
    or %NULL to avoid user interaction.</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop_mountable_finish">
        <callback name="stop_mountable_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the operation finished successfully.
    %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="supports_thread_contexts">
        <doc xml:space="preserve">a boolean that indicates whether the #GFile implementation supports thread-default contexts. Since 2.22.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="unmount_mountable_with_operation">
        <callback name="unmount_mountable_with_operation">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags affecting the operation</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GMountOperation,
    or %NULL to avoid user interaction</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unmount_mountable_with_operation_finish">
        <callback name="unmount_mountable_with_operation_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the operation finished successfully.
    %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_mountable_with_operation">
        <callback name="eject_mountable_with_operation">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags affecting the operation</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GMountOperation,
    or %NULL to avoid user interaction</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_mountable_with_operation_finish">
        <callback name="eject_mountable_with_operation_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the @file was ejected successfully.
    %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="poll_mountable">
        <callback name="poll_mountable">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="poll_mountable_finish">
        <callback name="poll_mountable_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the operation finished successfully. %FALSE
otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">input #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="measure_disk_usage" introspectable="0">
        <callback name="measure_disk_usage" introspectable="0" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if successful, with the out parameters set.
         %FALSE otherwise, with @error set.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">a #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">#GFileMeasureFlags</doc>
              <type name="FileMeasureFlags" c:type="GFileMeasureFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">a #GFileMeasureProgressCallback</doc>
              <type name="FileMeasureProgressCallback" c:type="GFileMeasureProgressCallback"/>
            </parameter>
            <parameter name="progress_data" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">user_data for @progress_callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="disk_usage" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
              <doc xml:space="preserve">the number of bytes of disk space used</doc>
              <type name="guint64" c:type="guint64*"/>
            </parameter>
            <parameter name="num_dirs" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
              <doc xml:space="preserve">the number of directories encountered</doc>
              <type name="guint64" c:type="guint64*"/>
            </parameter>
            <parameter name="num_files" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
              <doc xml:space="preserve">the number of non-directories encountered</doc>
              <type name="guint64" c:type="guint64*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="measure_disk_usage_async" introspectable="0">
        <callback name="measure_disk_usage_async" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">a #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">#GFileMeasureFlags</doc>
              <type name="FileMeasureFlags" c:type="GFileMeasureFlags"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">a #GFileMeasureProgressCallback</doc>
              <type name="FileMeasureProgressCallback" c:type="GFileMeasureProgressCallback"/>
            </parameter>
            <parameter name="progress_data" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">user_data for @progress_callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="7">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call when complete</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="7">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="measure_disk_usage_finish">
        <callback name="measure_disk_usage_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if successful, with the out parameters set.
         %FALSE otherwise, with @error set.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <doc xml:space="preserve">a #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">the #GAsyncResult passed to your #GAsyncReadyCallback</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
            <parameter name="disk_usage" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
              <doc xml:space="preserve">the number of bytes of disk space used</doc>
              <type name="guint64" c:type="guint64*"/>
            </parameter>
            <parameter name="num_dirs" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
              <doc xml:space="preserve">the number of directories encountered</doc>
              <type name="guint64" c:type="guint64*"/>
            </parameter>
            <parameter name="num_files" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
              <doc xml:space="preserve">the number of non-directories encountered</doc>
              <type name="guint64" c:type="guint64*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="FileInfo" c:symbol-prefix="file_info" c:type="GFileInfo" parent="GObject.Object" glib:type-name="GFileInfo" glib:get-type="g_file_info_get_type" glib:type-struct="FileInfoClass">
      <doc xml:space="preserve">Functionality for manipulating basic metadata for files. #GFileInfo
implements methods for getting information that all files should
contain, and allows for manipulation of extended attributes.

See [GFileAttribute][gio-GFileAttribute] for more information on how
GIO handles file attributes.

To obtain a #GFileInfo for a #GFile, use g_file_query_info() (or its
async variant). To obtain a #GFileInfo for a file input or output
stream, use g_file_input_stream_query_info() or
g_file_output_stream_query_info() (or their async variants).

To change the actual attributes of a file, you should then set the
attribute in the #GFileInfo and call g_file_set_attributes_from_info()
or g_file_set_attributes_async() on a GFile.

However, not all attributes can be changed in the file. For instance,
the actual size of a file cannot be changed via g_file_info_set_size().
You may call g_file_query_settable_attributes() and
g_file_query_writable_namespaces() to discover the settable attributes
of a particular file at runtime.

#GFileAttributeMatcher allows for searching through a #GFileInfo for
attributes.</doc>
      <constructor name="new" c:identifier="g_file_info_new">
        <doc xml:space="preserve">Creates a new file info structure.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileInfo.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
      </constructor>
      <method name="clear_status" c:identifier="g_file_info_clear_status">
        <doc xml:space="preserve">Clears the status information from @info.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="copy_into" c:identifier="g_file_info_copy_into">
        <doc xml:space="preserve">First clears all of the [GFileAttribute][gio-GFileAttribute] of @dest_info,
and then copies all of the file attributes from @src_info to @dest_info.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="src_info" transfer-ownership="none">
            <doc xml:space="preserve">source to copy attributes from.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="dest_info" transfer-ownership="none">
            <doc xml:space="preserve">destination to copy attributes to.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="g_file_info_dup">
        <doc xml:space="preserve">Duplicates a file info structure.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a duplicate #GFileInfo of @other.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_attribute_as_string" c:identifier="g_file_info_get_attribute_as_string">
        <doc xml:space="preserve">Gets the value of a attribute, formated as a string.
This escapes things as needed to make the string valid
utf8.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a UTF-8 string associated with the given @attribute.
   When you're done with the string it must be freed with g_free().</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_boolean" c:identifier="g_file_info_get_attribute_boolean">
        <doc xml:space="preserve">Gets the value of a boolean attribute. If the attribute does not
contain a boolean value, %FALSE will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the boolean value contained within the attribute.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_byte_string" c:identifier="g_file_info_get_attribute_byte_string">
        <doc xml:space="preserve">Gets the value of a byte string attribute. If the attribute does
not contain a byte string, %NULL will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the contents of the @attribute value as a byte string, or
%NULL otherwise.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_data" c:identifier="g_file_info_get_attribute_data">
        <doc xml:space="preserve">Gets the attribute type, value and status for an attribute key.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @info has an attribute named @attribute,
     %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the attribute type, or %NULL</doc>
            <type name="FileAttributeType" c:type="GFileAttributeType*"/>
          </parameter>
          <parameter name="value_pp" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the
   attribute value, or %NULL; the attribute value will not be %NULL</doc>
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
          <parameter name="status" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the attribute status, or %NULL</doc>
            <type name="FileAttributeStatus" c:type="GFileAttributeStatus*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_int32" c:identifier="g_file_info_get_attribute_int32">
        <doc xml:space="preserve">Gets a signed 32-bit integer contained within the attribute. If the
attribute does not contain a signed 32-bit integer, or is invalid,
0 will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a signed 32-bit integer from the attribute.</doc>
          <type name="gint32" c:type="gint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_int64" c:identifier="g_file_info_get_attribute_int64">
        <doc xml:space="preserve">Gets a signed 64-bit integer contained within the attribute. If the
attribute does not contain an signed 64-bit integer, or is invalid,
0 will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a signed 64-bit integer from the attribute.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_object" c:identifier="g_file_info_get_attribute_object">
        <doc xml:space="preserve">Gets the value of a #GObject attribute. If the attribute does
not contain a #GObject, %NULL will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GObject associated with the given @attribute, or
%NULL otherwise.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_status" c:identifier="g_file_info_get_attribute_status">
        <doc xml:space="preserve">Gets the attribute status for an attribute key.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GFileAttributeStatus for the given @attribute, or
   %G_FILE_ATTRIBUTE_STATUS_UNSET if the key is invalid.</doc>
          <type name="FileAttributeStatus" c:type="GFileAttributeStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_string" c:identifier="g_file_info_get_attribute_string">
        <doc xml:space="preserve">Gets the value of a string attribute. If the attribute does
not contain a string, %NULL will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the contents of the @attribute value as a UTF-8 string, or
%NULL otherwise.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_stringv" c:identifier="g_file_info_get_attribute_stringv" version="2.22">
        <doc xml:space="preserve">Gets the value of a stringv attribute. If the attribute does
not contain a stringv, %NULL will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the contents of the @attribute value as a stringv, or
%NULL otherwise. Do not free. These returned strings are UTF-8.</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_type" c:identifier="g_file_info_get_attribute_type">
        <doc xml:space="preserve">Gets the attribute type for an attribute key.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GFileAttributeType for the given @attribute, or
%G_FILE_ATTRIBUTE_TYPE_INVALID if the key is not set.</doc>
          <type name="FileAttributeType" c:type="GFileAttributeType"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_uint32" c:identifier="g_file_info_get_attribute_uint32">
        <doc xml:space="preserve">Gets an unsigned 32-bit integer contained within the attribute. If the
attribute does not contain an unsigned 32-bit integer, or is invalid,
0 will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an unsigned 32-bit integer from the attribute.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_uint64" c:identifier="g_file_info_get_attribute_uint64">
        <doc xml:space="preserve">Gets a unsigned 64-bit integer contained within the attribute. If the
attribute does not contain an unsigned 64-bit integer, or is invalid,
0 will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a unsigned 64-bit integer from the attribute.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_content_type" c:identifier="g_file_info_get_content_type">
        <doc xml:space="preserve">Gets the file's content type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string containing the file's content type.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_deletion_date" c:identifier="g_file_info_get_deletion_date" version="2.36">
        <doc xml:space="preserve">Returns the #GDateTime representing the deletion date of the file, as
available in G_FILE_ATTRIBUTE_TRASH_DELETION_DATE. If the
G_FILE_ATTRIBUTE_TRASH_DELETION_DATE attribute is unset, %NULL is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GDateTime, or %NULL.</doc>
          <type name="GLib.DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_display_name" c:identifier="g_file_info_get_display_name">
        <doc xml:space="preserve">Gets a display name for a file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string containing the display name.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_edit_name" c:identifier="g_file_info_get_edit_name">
        <doc xml:space="preserve">Gets the edit name for a file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string containing the edit name.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_etag" c:identifier="g_file_info_get_etag">
        <doc xml:space="preserve">Gets the [entity tag][gfile-etag] for a given
#GFileInfo. See %G_FILE_ATTRIBUTE_ETAG_VALUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string containing the value of the "etag:value" attribute.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_file_type" c:identifier="g_file_info_get_file_type">
        <doc xml:space="preserve">Gets a file's type (whether it is a regular file, symlink, etc).
This is different from the file's content type, see g_file_info_get_content_type().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GFileType for the given file.</doc>
          <type name="FileType" c:type="GFileType"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_icon" c:identifier="g_file_info_get_icon">
        <doc xml:space="preserve">Gets the icon for a file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#GIcon for the given @info.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_backup" c:identifier="g_file_info_get_is_backup">
        <doc xml:space="preserve">Checks if a file is a backup file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if file is a backup file, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_hidden" c:identifier="g_file_info_get_is_hidden">
        <doc xml:space="preserve">Checks if a file is hidden.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the file is a hidden file, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_symlink" c:identifier="g_file_info_get_is_symlink">
        <doc xml:space="preserve">Checks if a file is a symlink.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the given @info is a symlink.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_modification_time" c:identifier="g_file_info_get_modification_time">
        <doc xml:space="preserve">Gets the modification time of the current @info and sets it
in @result.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="result" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimeVal.</doc>
            <type name="GLib.TimeVal" c:type="GTimeVal*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="g_file_info_get_name">
        <doc xml:space="preserve">Gets the name for a file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string containing the file name.</doc>
          <type name="filename" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_size" c:identifier="g_file_info_get_size">
        <doc xml:space="preserve">Gets the file's size.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #goffset containing the file's size.</doc>
          <type name="gint64" c:type="goffset"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sort_order" c:identifier="g_file_info_get_sort_order">
        <doc xml:space="preserve">Gets the value of the sort_order attribute from the #GFileInfo.
See %G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #gint32 containing the value of the "standard::sort_order" attribute.</doc>
          <type name="gint32" c:type="gint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_symbolic_icon" c:identifier="g_file_info_get_symbolic_icon" version="2.34">
        <doc xml:space="preserve">Gets the symbolic icon for a file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#GIcon for the given @info.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_symlink_target" c:identifier="g_file_info_get_symlink_target">
        <doc xml:space="preserve">Gets the symlink target for a given #GFileInfo.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string containing the symlink target.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_attribute" c:identifier="g_file_info_has_attribute">
        <doc xml:space="preserve">Checks if a file info structure has an attribute named @attribute.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @Ginfo has an attribute named @attribute,
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_namespace" c:identifier="g_file_info_has_namespace" version="2.22">
        <doc xml:space="preserve">Checks if a file info structure has an attribute in the
specified @name_space.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @Ginfo has an attribute in @name_space,
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="name_space" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute namespace.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_attributes" c:identifier="g_file_info_list_attributes">
        <doc xml:space="preserve">Lists the file info structure's attributes.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a
null-terminated array of strings of all of the possible attribute
types for the given @name_space, or %NULL on error.</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="name_space" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a file attribute key's namespace, or %NULL to list
  all attributes.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_attribute" c:identifier="g_file_info_remove_attribute">
        <doc xml:space="preserve">Removes all cases of @attribute from @info if it exists.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute" c:identifier="g_file_info_set_attribute">
        <doc xml:space="preserve">Sets the @attribute to contain the given value, if possible. To unset the
attribute, use %G_FILE_ATTRIBUTE_TYPE_INVALID for @type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileAttributeType</doc>
            <type name="FileAttributeType" c:type="GFileAttributeType"/>
          </parameter>
          <parameter name="value_p" transfer-ownership="none">
            <doc xml:space="preserve">pointer to the value</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_boolean" c:identifier="g_file_info_set_attribute_boolean">
        <doc xml:space="preserve">Sets the @attribute to contain the given @attr_value,
if possible.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="attr_value" transfer-ownership="none">
            <doc xml:space="preserve">a boolean value.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_byte_string" c:identifier="g_file_info_set_attribute_byte_string">
        <doc xml:space="preserve">Sets the @attribute to contain the given @attr_value,
if possible.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="attr_value" transfer-ownership="none">
            <doc xml:space="preserve">a byte string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_int32" c:identifier="g_file_info_set_attribute_int32">
        <doc xml:space="preserve">Sets the @attribute to contain the given @attr_value,
if possible.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="attr_value" transfer-ownership="none">
            <doc xml:space="preserve">a signed 32-bit integer</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_int64" c:identifier="g_file_info_set_attribute_int64">
        <doc xml:space="preserve">Sets the @attribute to contain the given @attr_value,
if possible.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">attribute name to set.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="attr_value" transfer-ownership="none">
            <doc xml:space="preserve">int64 value to set attribute to.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_mask" c:identifier="g_file_info_set_attribute_mask">
        <doc xml:space="preserve">Sets @mask on @info to match specific attribute types.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileAttributeMatcher.</doc>
            <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_object" c:identifier="g_file_info_set_attribute_object">
        <doc xml:space="preserve">Sets the @attribute to contain the given @attr_value,
if possible.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="attr_value" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject.</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_status" c:identifier="g_file_info_set_attribute_status" version="2.22">
        <doc xml:space="preserve">Sets the attribute status for an attribute key. This is only
needed by external code that implement g_file_set_attributes_from_info()
or similar functions.

The attribute must exist in @info for this to work. Otherwise %FALSE
is returned and @info is unchanged.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the status was changed, %FALSE if the key was not set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileAttributeStatus</doc>
            <type name="FileAttributeStatus" c:type="GFileAttributeStatus"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_string" c:identifier="g_file_info_set_attribute_string">
        <doc xml:space="preserve">Sets the @attribute to contain the given @attr_value,
if possible.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="attr_value" transfer-ownership="none">
            <doc xml:space="preserve">a UTF-8 string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_stringv" c:identifier="g_file_info_set_attribute_stringv">
        <doc xml:space="preserve">Sets the @attribute to contain the given @attr_value,
if possible.

Sinze: 2.22</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="attr_value" transfer-ownership="none">
            <doc xml:space="preserve">a %NULL terminated array of UTF-8 strings.</doc>
            <array zero-terminated="0" c:type="char**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_uint32" c:identifier="g_file_info_set_attribute_uint32">
        <doc xml:space="preserve">Sets the @attribute to contain the given @attr_value,
if possible.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="attr_value" transfer-ownership="none">
            <doc xml:space="preserve">an unsigned 32-bit integer.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_uint64" c:identifier="g_file_info_set_attribute_uint64">
        <doc xml:space="preserve">Sets the @attribute to contain the given @attr_value,
if possible.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="attr_value" transfer-ownership="none">
            <doc xml:space="preserve">an unsigned 64-bit integer.</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_content_type" c:identifier="g_file_info_set_content_type">
        <doc xml:space="preserve">Sets the content type attribute for a given #GFileInfo.
See %G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve">a content type. See [GContentType][gio-GContentType]</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_display_name" c:identifier="g_file_info_set_display_name">
        <doc xml:space="preserve">Sets the display name for the current #GFileInfo.
See %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:space="preserve">a string containing a display name.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_edit_name" c:identifier="g_file_info_set_edit_name">
        <doc xml:space="preserve">Sets the edit name for the current file.
See %G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="edit_name" transfer-ownership="none">
            <doc xml:space="preserve">a string containing an edit name.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_file_type" c:identifier="g_file_info_set_file_type">
        <doc xml:space="preserve">Sets the file type in a #GFileInfo to @type.
See %G_FILE_ATTRIBUTE_STANDARD_TYPE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileType.</doc>
            <type name="FileType" c:type="GFileType"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_icon" c:identifier="g_file_info_set_icon">
        <doc xml:space="preserve">Sets the icon for a given #GFileInfo.
See %G_FILE_ATTRIBUTE_STANDARD_ICON.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">a #GIcon.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_is_hidden" c:identifier="g_file_info_set_is_hidden">
        <doc xml:space="preserve">Sets the "is_hidden" attribute in a #GFileInfo according to @is_hidden.
See %G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="is_hidden" transfer-ownership="none">
            <doc xml:space="preserve">a #gboolean.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_is_symlink" c:identifier="g_file_info_set_is_symlink">
        <doc xml:space="preserve">Sets the "is_symlink" attribute in a #GFileInfo according to @is_symlink.
See %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="is_symlink" transfer-ownership="none">
            <doc xml:space="preserve">a #gboolean.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_modification_time" c:identifier="g_file_info_set_modification_time">
        <doc xml:space="preserve">Sets the %G_FILE_ATTRIBUTE_TIME_MODIFIED attribute in the file
info to the given time value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="mtime" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimeVal.</doc>
            <type name="GLib.TimeVal" c:type="GTimeVal*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_name" c:identifier="g_file_info_set_name">
        <doc xml:space="preserve">Sets the name attribute for the current #GFileInfo.
See %G_FILE_ATTRIBUTE_STANDARD_NAME.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a string containing a name.</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_size" c:identifier="g_file_info_set_size">
        <doc xml:space="preserve">Sets the %G_FILE_ATTRIBUTE_STANDARD_SIZE attribute in the file info
to the given size.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">a #goffset containing the file's size.</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sort_order" c:identifier="g_file_info_set_sort_order">
        <doc xml:space="preserve">Sets the sort order attribute in the file info structure. See
%G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="sort_order" transfer-ownership="none">
            <doc xml:space="preserve">a sort order integer.</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_symbolic_icon" c:identifier="g_file_info_set_symbolic_icon" version="2.34">
        <doc xml:space="preserve">Sets the symbolic icon for a given #GFileInfo.
See %G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">a #GIcon.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_symlink_target" c:identifier="g_file_info_set_symlink_target">
        <doc xml:space="preserve">Sets the %G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET attribute in the file info
to the given symlink target.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
          <parameter name="symlink_target" transfer-ownership="none">
            <doc xml:space="preserve">a static string containing a path to a symlink target.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unset_attribute_mask" c:identifier="g_file_info_unset_attribute_mask">
        <doc xml:space="preserve">Unsets a mask set by g_file_info_set_attribute_mask(), if one
is set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">#GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <record name="FileInfoClass" c:type="GFileInfoClass" disguised="1" glib:is-gtype-struct-for="FileInfo">
    </record>
    <class name="FileInputStream" c:symbol-prefix="file_input_stream" c:type="GFileInputStream" parent="InputStream" glib:type-name="GFileInputStream" glib:get-type="g_file_input_stream_get_type" glib:type-struct="FileInputStreamClass">
      <doc xml:space="preserve">GFileInputStream provides input streams that take their
content from a file.

GFileInputStream implements #GSeekable, which allows the input
stream to jump to arbitrary positions in the file, provided the
filesystem of the file allows it. To find the position of a file
input stream, use g_seekable_tell(). To find out if a file input
stream supports seeking, use g_seekable_can_seek().
To position a file input stream, use g_seekable_seek().</doc>
      <implements name="Seekable"/>
      <virtual-method name="can_seek">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <type name="FileInputStream" c:type="GFileInputStream*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_info" invoker="query_info" throws="1">
        <doc xml:space="preserve">Queries a file input stream the given @attributes. This function blocks
while querying the stream. For the asynchronous (non-blocking) version
of this function, see g_file_input_stream_query_info_async(). While the
stream is blocked, the stream will set the pending flag internally, and
any other operations on the stream will fail with %G_IO_ERROR_PENDING.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileInfo, or %NULL on error.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInputStream.</doc>
            <type name="FileInputStream" c:type="GFileInputStream*"/>
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_info_async" invoker="query_info_async">
        <doc xml:space="preserve">Queries the stream information asynchronously.
When the operation is finished @callback will be called.
You can then call g_file_input_stream_query_info_finish()
to get the result of the operation.

For the synchronous version of this function,
see g_file_input_stream_query_info().

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be set</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInputStream.</doc>
            <type name="FileInputStream" c:type="GFileInputStream*"/>
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_info_finish" invoker="query_info_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous info query operation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GFileInfo.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInputStream.</doc>
            <type name="FileInputStream" c:type="GFileInputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="seek" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <type name="FileInputStream" c:type="GFileInputStream*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <type name="GLib.SeekType" c:type="GSeekType"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="tell">
        <return-value transfer-ownership="none">
          <type name="gint64" c:type="goffset"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <type name="FileInputStream" c:type="GFileInputStream*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="query_info" c:identifier="g_file_input_stream_query_info" throws="1">
        <doc xml:space="preserve">Queries a file input stream the given @attributes. This function blocks
while querying the stream. For the asynchronous (non-blocking) version
of this function, see g_file_input_stream_query_info_async(). While the
stream is blocked, the stream will set the pending flag internally, and
any other operations on the stream will fail with %G_IO_ERROR_PENDING.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileInfo, or %NULL on error.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInputStream.</doc>
            <type name="FileInputStream" c:type="GFileInputStream*"/>
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_info_async" c:identifier="g_file_input_stream_query_info_async">
        <doc xml:space="preserve">Queries the stream information asynchronously.
When the operation is finished @callback will be called.
You can then call g_file_input_stream_query_info_finish()
to get the result of the operation.

For the synchronous version of this function,
see g_file_input_stream_query_info().

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be set</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInputStream.</doc>
            <type name="FileInputStream" c:type="GFileInputStream*"/>
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_info_finish" c:identifier="g_file_input_stream_query_info_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous info query operation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GFileInfo.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileInputStream.</doc>
            <type name="FileInputStream" c:type="GFileInputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="InputStream" c:type="GInputStream"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="FileInputStreamPrivate" c:type="GFileInputStreamPrivate*"/>
      </field>
    </class>
    <record name="FileInputStreamClass" c:type="GFileInputStreamClass" glib:is-gtype-struct-for="FileInputStream">
      <field name="parent_class">
        <type name="InputStreamClass" c:type="GInputStreamClass"/>
      </field>
      <field name="tell">
        <callback name="tell">
          <return-value transfer-ownership="none">
            <type name="gint64" c:type="goffset"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileInputStream" c:type="GFileInputStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_seek">
        <callback name="can_seek">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileInputStream" c:type="GFileInputStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="seek">
        <callback name="seek" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileInputStream" c:type="GFileInputStream*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <type name="gint64" c:type="goffset"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <type name="GLib.SeekType" c:type="GSeekType"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_info">
        <callback name="query_info" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFileInfo, or %NULL on error.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GFileInputStream.</doc>
              <type name="FileInputStream" c:type="GFileInputStream*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:space="preserve">a file attribute query string.</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_info_async">
        <callback name="query_info_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GFileInputStream.</doc>
              <type name="FileInputStream" c:type="GFileInputStream*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:space="preserve">a file attribute query string.</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_info_finish">
        <callback name="query_info_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">#GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GFileInputStream.</doc>
              <type name="FileInputStream" c:type="GFileInputStream*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="FileInputStreamPrivate" c:type="GFileInputStreamPrivate" disguised="1">
    </record>
    <bitfield name="FileMeasureFlags" version="2.38" glib:type-name="GFileMeasureFlags" glib:get-type="g_file_measure_flags_get_type" c:type="GFileMeasureFlags">
      <doc xml:space="preserve">Flags that can be used with g_file_measure_disk_usage().</doc>
      <member name="none" value="0" c:identifier="G_FILE_MEASURE_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
      <member name="report_any_error" value="2" c:identifier="G_FILE_MEASURE_REPORT_ANY_ERROR" glib:nick="report-any-error">
        <doc xml:space="preserve">Report any error encountered
  while traversing the directory tree.  Normally errors are only
  reported for the toplevel file.</doc>
      </member>
      <member name="apparent_size" value="4" c:identifier="G_FILE_MEASURE_APPARENT_SIZE" glib:nick="apparent-size">
        <doc xml:space="preserve">Tally usage based on apparent file
  sizes.  Normally, the block-size is used, if available, as this is a
  more accurate representation of disk space used.
  Compare with `du --apparent-size`.</doc>
      </member>
      <member name="no_xdev" value="8" c:identifier="G_FILE_MEASURE_NO_XDEV" glib:nick="no-xdev">
        <doc xml:space="preserve">Do not cross mount point boundaries.
  Compare with `du -x`.</doc>
      </member>
    </bitfield>
    <callback name="FileMeasureProgressCallback" c:type="GFileMeasureProgressCallback" version="2.38">
      <doc xml:space="preserve">This callback type is used by g_file_measure_disk_usage() to make
periodic progress reports when measuring the amount of disk spaced
used by a directory.

These calls are made on a best-effort basis and not all types of
#GFile will support them.  At the minimum, however, one call will
always be made immediately.

In the case that there is no support, @reporting will be set to
%FALSE (and the other values undefined) and no further calls will be
made.  Otherwise, the @reporting will be %TRUE and the other values
all-zeros during the first (immediate) call.  In this way, you can
know which type of progress UI to show without a delay.

For g_file_measure_disk_usage() the callback is made directly.  For
g_file_measure_disk_usage_async() the callback is made via the
default main context of the calling thread (ie: the same way that the
final async result would be reported).

@current_size is in the same units as requested by the operation (see
%G_FILE_DISK_USAGE_APPARENT_SIZE).

The frequency of the updates is implementation defined, but is
ideally about once every 200ms.

The last progress callback may or may not be equal to the final
result.  Always check the async result to get the final value.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="reporting" transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if more reports will come</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="current_size" transfer-ownership="none">
          <doc xml:space="preserve">the current cumulative size measurement</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="num_dirs" transfer-ownership="none">
          <doc xml:space="preserve">the number of directories visited so far</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="num_files" transfer-ownership="none">
          <doc xml:space="preserve">the number of non-directory files encountered</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
          <doc xml:space="preserve">the data passed to the original request for this callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="FileMonitor" c:symbol-prefix="file_monitor" c:type="GFileMonitor" parent="GObject.Object" abstract="1" glib:type-name="GFileMonitor" glib:get-type="g_file_monitor_get_type" glib:type-struct="FileMonitorClass">
      <doc xml:space="preserve">Monitors a file or directory for changes.

To obtain a #GFileMonitor for a file or directory, use
g_file_monitor(), g_file_monitor_file(), or
g_file_monitor_directory().

To get informed about changes to the file or directory you are
monitoring, connect to the #GFileMonitor::changed signal. The
signal will be emitted in the
[thread-default main context][g-main-context-push-thread-default]
of the thread that the monitor was created in
(though if the global default main context is blocked, this may
cause notifications to be blocked even if the thread-default
context is still running).</doc>
      <virtual-method name="cancel" invoker="cancel">
        <doc xml:space="preserve">Cancels a file monitor.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">always %TRUE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="monitor" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileMonitor.</doc>
            <type name="FileMonitor" c:type="GFileMonitor*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="monitor" transfer-ownership="none">
            <type name="FileMonitor" c:type="GFileMonitor*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <type name="File" c:type="GFile*"/>
          </parameter>
          <parameter name="other_file" transfer-ownership="none">
            <type name="File" c:type="GFile*"/>
          </parameter>
          <parameter name="event_type" transfer-ownership="none">
            <type name="FileMonitorEvent" c:type="GFileMonitorEvent"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="cancel" c:identifier="g_file_monitor_cancel">
        <doc xml:space="preserve">Cancels a file monitor.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">always %TRUE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="monitor" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileMonitor.</doc>
            <type name="FileMonitor" c:type="GFileMonitor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="emit_event" c:identifier="g_file_monitor_emit_event">
        <doc xml:space="preserve">Emits the #GFileMonitor::changed signal if a change
has taken place. Should be called from file monitor
implementations only.

Implementations are responsible to call this method from the
[thread-default main context][g-main-context-push-thread-default] of the
thread that the monitor was created in.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="monitor" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileMonitor.</doc>
            <type name="FileMonitor" c:type="GFileMonitor*"/>
          </instance-parameter>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile.</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
          <parameter name="other_file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile.</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
          <parameter name="event_type" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GFileMonitorEvent flags.</doc>
            <type name="FileMonitorEvent" c:type="GFileMonitorEvent"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_cancelled" c:identifier="g_file_monitor_is_cancelled">
        <doc xml:space="preserve">Returns whether the monitor is canceled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if monitor is canceled. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="monitor" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileMonitor</doc>
            <type name="FileMonitor" c:type="GFileMonitor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_rate_limit" c:identifier="g_file_monitor_set_rate_limit">
        <doc xml:space="preserve">Sets the rate limit to which the @monitor will report
consecutive change events to the same file.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="monitor" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileMonitor.</doc>
            <type name="FileMonitor" c:type="GFileMonitor*"/>
          </instance-parameter>
          <parameter name="limit_msecs" transfer-ownership="none">
            <doc xml:space="preserve">a non-negative integer with the limit in milliseconds
    to poll for changes</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <property name="cancelled" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="rate-limit" writable="1" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="FileMonitorPrivate" c:type="GFileMonitorPrivate*"/>
      </field>
      <glib:signal name="changed" when="last">
        <doc xml:space="preserve">Emitted when @file has been changed.

If using %G_FILE_MONITOR_WATCH_MOVES on a directory monitor, and
the information is available (and if supported by the backend),
@event_type may be %G_FILE_MONITOR_EVENT_RENAMED,
%G_FILE_MONITOR_EVENT_MOVED_IN or %G_FILE_MONITOR_EVENT_MOVED_OUT.

In all cases @file will be a child of the monitored directory.  For
renames, @file will be the old name and @other_file is the new
name.  For "moved in" events, @file is the name of the file that
appeared and @other_file is the old name that it was moved from (in
another directory).  For "moved out" events, @file is the name of
the file that used to be in this directory and @other_file is the
name of the file at its new location.

It makes sense to treat %G_FILE_MONITOR_EVENT_MOVED_IN as
equivalent to %G_FILE_MONITOR_EVENT_CREATED and
%G_FILE_MONITOR_EVENT_MOVED_OUT as equivalent to
%G_FILE_MONITOR_EVENT_DELETED, with extra information.
%G_FILE_MONITOR_EVENT_RENAMED is equivalent to a delete/create
pair.  This is exactly how the events will be reported in the case
that the %G_FILE_MONITOR_WATCH_MOVES flag is not in use.

If using the deprecated flag %G_FILE_MONITOR_SEND_MOVED flag and @event_type is
#G_FILE_MONITOR_EVENT_MOVED, @file will be set to a #GFile containing the
old path, and @other_file will be set to a #GFile containing the new path.

In all the other cases, @other_file will be set to #NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile.</doc>
            <type name="File"/>
          </parameter>
          <parameter name="other_file" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GFile or #NULL.</doc>
            <type name="File"/>
          </parameter>
          <parameter name="event_type" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileMonitorEvent.</doc>
            <type name="FileMonitorEvent"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="FileMonitorClass" c:type="GFileMonitorClass" glib:is-gtype-struct-for="FileMonitor">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="changed">
        <callback name="changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="monitor" transfer-ownership="none">
              <type name="FileMonitor" c:type="GFileMonitor*"/>
            </parameter>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="other_file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="event_type" transfer-ownership="none">
              <type name="FileMonitorEvent" c:type="GFileMonitorEvent"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="cancel">
        <callback name="cancel">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">always %TRUE</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="monitor" transfer-ownership="none">
              <doc xml:space="preserve">a #GFileMonitor.</doc>
              <type name="FileMonitor" c:type="GFileMonitor*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="FileMonitorEvent" glib:type-name="GFileMonitorEvent" glib:get-type="g_file_monitor_event_get_type" c:type="GFileMonitorEvent">
      <doc xml:space="preserve">Specifies what type of event a monitor event is.</doc>
      <member name="changed" value="0" c:identifier="G_FILE_MONITOR_EVENT_CHANGED" glib:nick="changed">
        <doc xml:space="preserve">a file changed.</doc>
      </member>
      <member name="changes_done_hint" value="1" c:identifier="G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT" glib:nick="changes-done-hint">
        <doc xml:space="preserve">a hint that this was probably the last change in a set of changes.</doc>
      </member>
      <member name="deleted" value="2" c:identifier="G_FILE_MONITOR_EVENT_DELETED" glib:nick="deleted">
        <doc xml:space="preserve">a file was deleted.</doc>
      </member>
      <member name="created" value="3" c:identifier="G_FILE_MONITOR_EVENT_CREATED" glib:nick="created">
        <doc xml:space="preserve">a file was created.</doc>
      </member>
      <member name="attribute_changed" value="4" c:identifier="G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED" glib:nick="attribute-changed">
        <doc xml:space="preserve">a file attribute was changed.</doc>
      </member>
      <member name="pre_unmount" value="5" c:identifier="G_FILE_MONITOR_EVENT_PRE_UNMOUNT" glib:nick="pre-unmount">
        <doc xml:space="preserve">the file location will soon be unmounted.</doc>
      </member>
      <member name="unmounted" value="6" c:identifier="G_FILE_MONITOR_EVENT_UNMOUNTED" glib:nick="unmounted">
        <doc xml:space="preserve">the file location was unmounted.</doc>
      </member>
      <member name="moved" value="7" c:identifier="G_FILE_MONITOR_EVENT_MOVED" glib:nick="moved">
        <doc xml:space="preserve">the file was moved -- only sent if the
  (deprecated) %G_FILE_MONITOR_SEND_MOVED flag is set</doc>
      </member>
      <member name="renamed" value="8" c:identifier="G_FILE_MONITOR_EVENT_RENAMED" glib:nick="renamed">
        <doc xml:space="preserve">the file was renamed within the
  current directory -- only sent if the %G_FILE_MONITOR_WATCH_MOVES
  flag is set.  Since: 2.46.</doc>
      </member>
      <member name="moved_in" value="9" c:identifier="G_FILE_MONITOR_EVENT_MOVED_IN" glib:nick="moved-in">
        <doc xml:space="preserve">the file was moved into the
  monitored directory from another location -- only sent if the
  %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46.</doc>
      </member>
      <member name="moved_out" value="10" c:identifier="G_FILE_MONITOR_EVENT_MOVED_OUT" glib:nick="moved-out">
        <doc xml:space="preserve">the file was moved out of the
  monitored directory to another location -- only sent if the
  %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46</doc>
      </member>
    </enumeration>
    <bitfield name="FileMonitorFlags" glib:type-name="GFileMonitorFlags" glib:get-type="g_file_monitor_flags_get_type" c:type="GFileMonitorFlags">
      <doc xml:space="preserve">Flags used to set what a #GFileMonitor will watch for.</doc>
      <member name="none" value="0" c:identifier="G_FILE_MONITOR_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
      <member name="watch_mounts" value="1" c:identifier="G_FILE_MONITOR_WATCH_MOUNTS" glib:nick="watch-mounts">
        <doc xml:space="preserve">Watch for mount events.</doc>
      </member>
      <member name="send_moved" value="2" c:identifier="G_FILE_MONITOR_SEND_MOVED" glib:nick="send-moved">
        <doc xml:space="preserve">Pair DELETED and CREATED events caused
  by file renames (moves) and send a single G_FILE_MONITOR_EVENT_MOVED
  event instead (NB: not supported on all backends; the default
  behaviour -without specifying this flag- is to send single DELETED
  and CREATED events).  Deprecated since 2.46: use
  %G_FILE_MONITOR_WATCH_MOVES instead.</doc>
      </member>
      <member name="watch_hard_links" value="4" c:identifier="G_FILE_MONITOR_WATCH_HARD_LINKS" glib:nick="watch-hard-links">
        <doc xml:space="preserve">Watch for changes to the file made
  via another hard link. Since 2.36.</doc>
      </member>
      <member name="watch_moves" value="8" c:identifier="G_FILE_MONITOR_WATCH_MOVES" glib:nick="watch-moves">
        <doc xml:space="preserve">Watch for rename operations on a
  monitored directory.  This causes %G_FILE_MONITOR_EVENT_RENAMED,
  %G_FILE_MONITOR_EVENT_MOVED_IN and %G_FILE_MONITOR_EVENT_MOVED_OUT
  events to be emitted when possible.  Since: 2.46.</doc>
      </member>
    </bitfield>
    <record name="FileMonitorPrivate" c:type="GFileMonitorPrivate" disguised="1">
    </record>
    <class name="FileOutputStream" c:symbol-prefix="file_output_stream" c:type="GFileOutputStream" parent="OutputStream" glib:type-name="GFileOutputStream" glib:get-type="g_file_output_stream_get_type" glib:type-struct="FileOutputStreamClass">
      <doc xml:space="preserve">GFileOutputStream provides output streams that write their
content to a file.

GFileOutputStream implements #GSeekable, which allows the output
stream to jump to arbitrary positions in the file and to truncate
the file, provided the filesystem of the file supports these
operations.

To find the position of a file output stream, use g_seekable_tell().
To find out if a file output stream supports seeking, use
g_seekable_can_seek().To position a file output stream, use
g_seekable_seek(). To find out if a file output stream supports
truncating, use g_seekable_can_truncate(). To truncate a file output
stream, use g_seekable_truncate().</doc>
      <implements name="Seekable"/>
      <virtual-method name="can_seek">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <type name="FileOutputStream" c:type="GFileOutputStream*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="can_truncate">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <type name="FileOutputStream" c:type="GFileOutputStream*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_etag" invoker="get_etag">
        <doc xml:space="preserve">Gets the entity tag for the file when it has been written.
This must be called after the stream has been written
and closed, as the etag can change while writing.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the entity tag for the stream.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileOutputStream.</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_info" invoker="query_info" throws="1">
        <doc xml:space="preserve">Queries a file output stream for the given @attributes.
This function blocks while querying the stream. For the asynchronous
version of this function, see g_file_output_stream_query_info_async().
While the stream is blocked, the stream will set the pending flag
internally, and any other operations on the stream will fail with
%G_IO_ERROR_PENDING.

Can fail if the stream was already closed (with @error being set to
%G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
set to %G_IO_ERROR_PENDING), or if querying info is not supported for
the stream's interface (with @error being set to %G_IO_ERROR_NOT_SUPPORTED). In
all cases of failure, %NULL will be returned.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileInfo for the @stream, or %NULL on error.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileOutputStream.</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*"/>
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_info_async" invoker="query_info_async">
        <doc xml:space="preserve">Asynchronously queries the @stream for a #GFileInfo. When completed,
@callback will be called with a #GAsyncResult which can be used to
finish the operation with g_file_output_stream_query_info_finish().

For the synchronous version of this function, see
g_file_output_stream_query_info().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileOutputStream.</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*"/>
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][gio-GIOScheduler] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_info_finish" invoker="query_info_finish" throws="1">
        <doc xml:space="preserve">Finalizes the asynchronous query started
by g_file_output_stream_query_info_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GFileInfo for the finished query.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileOutputStream.</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="seek" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <type name="FileOutputStream" c:type="GFileOutputStream*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <type name="GLib.SeekType" c:type="GSeekType"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="tell">
        <return-value transfer-ownership="none">
          <type name="gint64" c:type="goffset"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <type name="FileOutputStream" c:type="GFileOutputStream*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="truncate_fn" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <type name="FileOutputStream" c:type="GFileOutputStream*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_etag" c:identifier="g_file_output_stream_get_etag">
        <doc xml:space="preserve">Gets the entity tag for the file when it has been written.
This must be called after the stream has been written
and closed, as the etag can change while writing.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the entity tag for the stream.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileOutputStream.</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="query_info" c:identifier="g_file_output_stream_query_info" throws="1">
        <doc xml:space="preserve">Queries a file output stream for the given @attributes.
This function blocks while querying the stream. For the asynchronous
version of this function, see g_file_output_stream_query_info_async().
While the stream is blocked, the stream will set the pending flag
internally, and any other operations on the stream will fail with
%G_IO_ERROR_PENDING.

Can fail if the stream was already closed (with @error being set to
%G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
set to %G_IO_ERROR_PENDING), or if querying info is not supported for
the stream's interface (with @error being set to %G_IO_ERROR_NOT_SUPPORTED). In
all cases of failure, %NULL will be returned.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFileInfo for the @stream, or %NULL on error.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileOutputStream.</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*"/>
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_info_async" c:identifier="g_file_output_stream_query_info_async">
        <doc xml:space="preserve">Asynchronously queries the @stream for a #GFileInfo. When completed,
@callback will be called with a #GAsyncResult which can be used to
finish the operation with g_file_output_stream_query_info_finish().

For the synchronous version of this function, see
g_file_output_stream_query_info().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileOutputStream.</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*"/>
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][gio-GIOScheduler] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_info_finish" c:identifier="g_file_output_stream_query_info_finish" throws="1">
        <doc xml:space="preserve">Finalizes the asynchronous query started
by g_file_output_stream_query_info_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GFileInfo for the finished query.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileOutputStream.</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="OutputStream" c:type="GOutputStream"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="FileOutputStreamPrivate" c:type="GFileOutputStreamPrivate*"/>
      </field>
    </class>
    <record name="FileOutputStreamClass" c:type="GFileOutputStreamClass" glib:is-gtype-struct-for="FileOutputStream">
      <field name="parent_class">
        <type name="OutputStreamClass" c:type="GOutputStreamClass"/>
      </field>
      <field name="tell">
        <callback name="tell">
          <return-value transfer-ownership="none">
            <type name="gint64" c:type="goffset"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileOutputStream" c:type="GFileOutputStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_seek">
        <callback name="can_seek">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileOutputStream" c:type="GFileOutputStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="seek">
        <callback name="seek" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileOutputStream" c:type="GFileOutputStream*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <type name="gint64" c:type="goffset"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <type name="GLib.SeekType" c:type="GSeekType"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_truncate">
        <callback name="can_truncate">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileOutputStream" c:type="GFileOutputStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="truncate_fn">
        <callback name="truncate_fn" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileOutputStream" c:type="GFileOutputStream*"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="gint64" c:type="goffset"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_info">
        <callback name="query_info" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFileInfo for the @stream, or %NULL on error.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GFileOutputStream.</doc>
              <type name="FileOutputStream" c:type="GFileOutputStream*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:space="preserve">a file attribute query string.</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_info_async">
        <callback name="query_info_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GFileOutputStream.</doc>
              <type name="FileOutputStream" c:type="GFileOutputStream*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:space="preserve">a file attribute query string.</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][gio-GIOScheduler] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_info_finish">
        <callback name="query_info_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A #GFileInfo for the finished query.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GFileOutputStream.</doc>
              <type name="FileOutputStream" c:type="GFileOutputStream*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_etag">
        <callback name="get_etag">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the entity tag for the stream.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GFileOutputStream.</doc>
              <type name="FileOutputStream" c:type="GFileOutputStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="FileOutputStreamPrivate" c:type="GFileOutputStreamPrivate" disguised="1">
    </record>
    <callback name="FileProgressCallback" c:type="GFileProgressCallback">
      <doc xml:space="preserve">When doing file operations that may take a while, such as moving
a file or copying a file, a progress callback is used to pass how
far along that operation is to the application.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="current_num_bytes" transfer-ownership="none">
          <doc xml:space="preserve">the current number of bytes in the operation.</doc>
          <type name="gint64" c:type="goffset"/>
        </parameter>
        <parameter name="total_num_bytes" transfer-ownership="none">
          <doc xml:space="preserve">the total number of bytes in the operation.</doc>
          <type name="gint64" c:type="goffset"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">user data passed to the callback.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="FileQueryInfoFlags" glib:type-name="GFileQueryInfoFlags" glib:get-type="g_file_query_info_flags_get_type" c:type="GFileQueryInfoFlags">
      <doc xml:space="preserve">Flags used when querying a #GFileInfo.</doc>
      <member name="none" value="0" c:identifier="G_FILE_QUERY_INFO_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
      <member name="nofollow_symlinks" value="1" c:identifier="G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS" glib:nick="nofollow-symlinks">
        <doc xml:space="preserve">Don't follow symlinks.</doc>
      </member>
    </bitfield>
    <callback name="FileReadMoreCallback" c:type="GFileReadMoreCallback">
      <doc xml:space="preserve">When loading the partial contents of a file with g_file_load_partial_contents_async(),
it may become necessary to determine if any more data from the file should be loaded.
A #GFileReadMoreCallback function facilitates this by returning %TRUE if more data
should be read, or %FALSE otherwise.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if more data should be read back. %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="file_contents" transfer-ownership="none">
          <doc xml:space="preserve">the data as currently read.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="file_size" transfer-ownership="none">
          <doc xml:space="preserve">the size of the data currently read.</doc>
          <type name="gint64" c:type="goffset"/>
        </parameter>
        <parameter name="callback_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">data passed to the callback.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="FileType" glib:type-name="GFileType" glib:get-type="g_file_type_get_type" c:type="GFileType">
      <doc xml:space="preserve">Indicates the file's on-disk type.</doc>
      <member name="unknown" value="0" c:identifier="G_FILE_TYPE_UNKNOWN" glib:nick="unknown">
        <doc xml:space="preserve">File's type is unknown.</doc>
      </member>
      <member name="regular" value="1" c:identifier="G_FILE_TYPE_REGULAR" glib:nick="regular">
        <doc xml:space="preserve">File handle represents a regular file.</doc>
      </member>
      <member name="directory" value="2" c:identifier="G_FILE_TYPE_DIRECTORY" glib:nick="directory">
        <doc xml:space="preserve">File handle represents a directory.</doc>
      </member>
      <member name="symbolic_link" value="3" c:identifier="G_FILE_TYPE_SYMBOLIC_LINK" glib:nick="symbolic-link">
        <doc xml:space="preserve">File handle represents a symbolic link
   (Unix systems).</doc>
      </member>
      <member name="special" value="4" c:identifier="G_FILE_TYPE_SPECIAL" glib:nick="special">
        <doc xml:space="preserve">File is a "special" file, such as a socket, fifo,
   block device, or character device.</doc>
      </member>
      <member name="shortcut" value="5" c:identifier="G_FILE_TYPE_SHORTCUT" glib:nick="shortcut">
        <doc xml:space="preserve">File is a shortcut (Windows systems).</doc>
      </member>
      <member name="mountable" value="6" c:identifier="G_FILE_TYPE_MOUNTABLE" glib:nick="mountable">
        <doc xml:space="preserve">File is a mountable location.</doc>
      </member>
    </enumeration>
    <class name="FilenameCompleter" c:symbol-prefix="filename_completer" c:type="GFilenameCompleter" parent="GObject.Object" glib:type-name="GFilenameCompleter" glib:get-type="g_filename_completer_get_type" glib:type-struct="FilenameCompleterClass">
      <doc xml:space="preserve">Completes partial file and directory names given a partial string by
looking in the file system for clues. Can return a list of possible
completion strings for widget implementations.</doc>
      <constructor name="new" c:identifier="g_filename_completer_new">
        <doc xml:space="preserve">Creates a new filename completer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFilenameCompleter.</doc>
          <type name="FilenameCompleter" c:type="GFilenameCompleter*"/>
        </return-value>
      </constructor>
      <virtual-method name="got_completion_data">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="filename_completer" transfer-ownership="none">
            <type name="FilenameCompleter" c:type="GFilenameCompleter*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="get_completion_suffix" c:identifier="g_filename_completer_get_completion_suffix">
        <doc xml:space="preserve">Obtains a completion for @initial_text from @completer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a completed string, or %NULL if no completion exists.
    This string is not owned by GIO, so remember to g_free() it
    when finished.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="completer" transfer-ownership="none">
            <doc xml:space="preserve">the filename completer.</doc>
            <type name="FilenameCompleter" c:type="GFilenameCompleter*"/>
          </instance-parameter>
          <parameter name="initial_text" transfer-ownership="none">
            <doc xml:space="preserve">text to be completed.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_completions" c:identifier="g_filename_completer_get_completions">
        <doc xml:space="preserve">Gets an array of completion strings for a given initial text.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">array of strings with possible completions for @initial_text.
This array must be freed by g_strfreev() when finished.</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="completer" transfer-ownership="none">
            <doc xml:space="preserve">the filename completer.</doc>
            <type name="FilenameCompleter" c:type="GFilenameCompleter*"/>
          </instance-parameter>
          <parameter name="initial_text" transfer-ownership="none">
            <doc xml:space="preserve">text to be completed.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_dirs_only" c:identifier="g_filename_completer_set_dirs_only">
        <doc xml:space="preserve">If @dirs_only is %TRUE, @completer will only
complete directory names, and not file names.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="completer" transfer-ownership="none">
            <doc xml:space="preserve">the filename completer.</doc>
            <type name="FilenameCompleter" c:type="GFilenameCompleter*"/>
          </instance-parameter>
          <parameter name="dirs_only" transfer-ownership="none">
            <doc xml:space="preserve">a #gboolean.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <glib:signal name="got-completion-data" when="last">
        <doc xml:space="preserve">Emitted when the file name completion information comes available.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="FilenameCompleterClass" c:type="GFilenameCompleterClass" glib:is-gtype-struct-for="FilenameCompleter">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="got_completion_data">
        <callback name="got_completion_data">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="filename_completer" transfer-ownership="none">
              <type name="FilenameCompleter" c:type="GFilenameCompleter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="FilesystemPreviewType" glib:type-name="GFilesystemPreviewType" glib:get-type="g_filesystem_preview_type_get_type" c:type="GFilesystemPreviewType">
      <doc xml:space="preserve">Indicates a hint from the file system whether files should be
previewed in a file manager. Returned as the value of the key
#G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW.</doc>
      <member name="if_always" value="0" c:identifier="G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS" glib:nick="if-always">
        <doc xml:space="preserve">Only preview files if user has explicitly requested it.</doc>
      </member>
      <member name="if_local" value="1" c:identifier="G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL" glib:nick="if-local">
        <doc xml:space="preserve">Preview files if user has requested preview of "local" files.</doc>
      </member>
      <member name="never" value="2" c:identifier="G_FILESYSTEM_PREVIEW_TYPE_NEVER" glib:nick="never">
        <doc xml:space="preserve">Never preview files.</doc>
      </member>
    </enumeration>
    <class name="FilterInputStream" c:symbol-prefix="filter_input_stream" c:type="GFilterInputStream" parent="InputStream" abstract="1" glib:type-name="GFilterInputStream" glib:get-type="g_filter_input_stream_get_type" glib:type-struct="FilterInputStreamClass">
      <doc xml:space="preserve">Base class for input stream implementations that perform some
kind of filtering operation on a base stream. Typical examples
of filtering operations are character set conversion, compression
and byte order flipping.</doc>
      <method name="get_base_stream" c:identifier="g_filter_input_stream_get_base_stream">
        <doc xml:space="preserve">Gets the base stream for the filter stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GInputStream.</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFilterInputStream.</doc>
            <type name="FilterInputStream" c:type="GFilterInputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_close_base_stream" c:identifier="g_filter_input_stream_get_close_base_stream">
        <doc xml:space="preserve">Returns whether the base stream will be closed when @stream is
closed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the base stream will be closed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFilterInputStream.</doc>
            <type name="FilterInputStream" c:type="GFilterInputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_close_base_stream" c:identifier="g_filter_input_stream_set_close_base_stream">
        <doc xml:space="preserve">Sets whether the base stream will be closed when @stream is closed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFilterInputStream.</doc>
            <type name="FilterInputStream" c:type="GFilterInputStream*"/>
          </instance-parameter>
          <parameter name="close_base" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to close the base stream.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="base-stream" writable="1" construct-only="1" transfer-ownership="none">
        <type name="InputStream"/>
      </property>
      <property name="close-base-stream" writable="1" construct="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent_instance">
        <type name="InputStream" c:type="GInputStream"/>
      </field>
      <field name="base_stream">
        <type name="InputStream" c:type="GInputStream*"/>
      </field>
    </class>
    <record name="FilterInputStreamClass" c:type="GFilterInputStreamClass" glib:is-gtype-struct-for="FilterInputStream">
      <field name="parent_class">
        <type name="InputStreamClass" c:type="GInputStreamClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <class name="FilterOutputStream" c:symbol-prefix="filter_output_stream" c:type="GFilterOutputStream" parent="OutputStream" abstract="1" glib:type-name="GFilterOutputStream" glib:get-type="g_filter_output_stream_get_type" glib:type-struct="FilterOutputStreamClass">
      <doc xml:space="preserve">Base class for output stream implementations that perform some
kind of filtering operation on a base stream. Typical examples
of filtering operations are character set conversion, compression
and byte order flipping.</doc>
      <method name="get_base_stream" c:identifier="g_filter_output_stream_get_base_stream">
        <doc xml:space="preserve">Gets the base stream for the filter stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GOutputStream.</doc>
          <type name="OutputStream" c:type="GOutputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFilterOutputStream.</doc>
            <type name="FilterOutputStream" c:type="GFilterOutputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_close_base_stream" c:identifier="g_filter_output_stream_get_close_base_stream">
        <doc xml:space="preserve">Returns whether the base stream will be closed when @stream is
closed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the base stream will be closed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFilterOutputStream.</doc>
            <type name="FilterOutputStream" c:type="GFilterOutputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_close_base_stream" c:identifier="g_filter_output_stream_set_close_base_stream">
        <doc xml:space="preserve">Sets whether the base stream will be closed when @stream is closed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GFilterOutputStream.</doc>
            <type name="FilterOutputStream" c:type="GFilterOutputStream*"/>
          </instance-parameter>
          <parameter name="close_base" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to close the base stream.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="base-stream" writable="1" construct-only="1" transfer-ownership="none">
        <type name="OutputStream"/>
      </property>
      <property name="close-base-stream" writable="1" construct-only="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent_instance">
        <type name="OutputStream" c:type="GOutputStream"/>
      </field>
      <field name="base_stream">
        <type name="OutputStream" c:type="GOutputStream*"/>
      </field>
    </class>
    <record name="FilterOutputStreamClass" c:type="GFilterOutputStreamClass" glib:is-gtype-struct-for="FilterOutputStream">
      <field name="parent_class">
        <type name="OutputStreamClass" c:type="GOutputStreamClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="IOErrorEnum" glib:type-name="GIOErrorEnum" glib:get-type="g_io_error_enum_get_type" c:type="GIOErrorEnum" glib:error-domain="g-io-error-quark">
      <doc xml:space="preserve">Error codes returned by GIO functions.

Note that this domain may be extended in future GLib releases. In
general, new error codes either only apply to new APIs, or else
replace %G_IO_ERROR_FAILED in cases that were not explicitly
distinguished before. You should therefore avoid writing code like
|[&lt;!-- language="C" --&gt;
if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED))
  {
    // Assume that this is EPRINTERONFIRE
    ...
  }
]|
but should instead treat all unrecognized error codes the same as
#G_IO_ERROR_FAILED.</doc>
      <member name="failed" value="0" c:identifier="G_IO_ERROR_FAILED" glib:nick="failed">
        <doc xml:space="preserve">Generic error condition for when an operation fails
    and no more specific #GIOErrorEnum value is defined.</doc>
      </member>
      <member name="not_found" value="1" c:identifier="G_IO_ERROR_NOT_FOUND" glib:nick="not-found">
        <doc xml:space="preserve">File not found.</doc>
      </member>
      <member name="exists" value="2" c:identifier="G_IO_ERROR_EXISTS" glib:nick="exists">
        <doc xml:space="preserve">File already exists.</doc>
      </member>
      <member name="is_directory" value="3" c:identifier="G_IO_ERROR_IS_DIRECTORY" glib:nick="is-directory">
        <doc xml:space="preserve">File is a directory.</doc>
      </member>
      <member name="not_directory" value="4" c:identifier="G_IO_ERROR_NOT_DIRECTORY" glib:nick="not-directory">
        <doc xml:space="preserve">File is not a directory.</doc>
      </member>
      <member name="not_empty" value="5" c:identifier="G_IO_ERROR_NOT_EMPTY" glib:nick="not-empty">
        <doc xml:space="preserve">File is a directory that isn't empty.</doc>
      </member>
      <member name="not_regular_file" value="6" c:identifier="G_IO_ERROR_NOT_REGULAR_FILE" glib:nick="not-regular-file">
        <doc xml:space="preserve">File is not a regular file.</doc>
      </member>
      <member name="not_symbolic_link" value="7" c:identifier="G_IO_ERROR_NOT_SYMBOLIC_LINK" glib:nick="not-symbolic-link">
        <doc xml:space="preserve">File is not a symbolic link.</doc>
      </member>
      <member name="not_mountable_file" value="8" c:identifier="G_IO_ERROR_NOT_MOUNTABLE_FILE" glib:nick="not-mountable-file">
        <doc xml:space="preserve">File cannot be mounted.</doc>
      </member>
      <member name="filename_too_long" value="9" c:identifier="G_IO_ERROR_FILENAME_TOO_LONG" glib:nick="filename-too-long">
        <doc xml:space="preserve">Filename is too many characters.</doc>
      </member>
      <member name="invalid_filename" value="10" c:identifier="G_IO_ERROR_INVALID_FILENAME" glib:nick="invalid-filename">
        <doc xml:space="preserve">Filename is invalid or contains invalid characters.</doc>
      </member>
      <member name="too_many_links" value="11" c:identifier="G_IO_ERROR_TOO_MANY_LINKS" glib:nick="too-many-links">
        <doc xml:space="preserve">File contains too many symbolic links.</doc>
      </member>
      <member name="no_space" value="12" c:identifier="G_IO_ERROR_NO_SPACE" glib:nick="no-space">
        <doc xml:space="preserve">No space left on drive.</doc>
      </member>
      <member name="invalid_argument" value="13" c:identifier="G_IO_ERROR_INVALID_ARGUMENT" glib:nick="invalid-argument">
        <doc xml:space="preserve">Invalid argument.</doc>
      </member>
      <member name="permission_denied" value="14" c:identifier="G_IO_ERROR_PERMISSION_DENIED" glib:nick="permission-denied">
        <doc xml:space="preserve">Permission denied.</doc>
      </member>
      <member name="not_supported" value="15" c:identifier="G_IO_ERROR_NOT_SUPPORTED" glib:nick="not-supported">
        <doc xml:space="preserve">Operation (or one of its parameters) not supported</doc>
      </member>
      <member name="not_mounted" value="16" c:identifier="G_IO_ERROR_NOT_MOUNTED" glib:nick="not-mounted">
        <doc xml:space="preserve">File isn't mounted.</doc>
      </member>
      <member name="already_mounted" value="17" c:identifier="G_IO_ERROR_ALREADY_MOUNTED" glib:nick="already-mounted">
        <doc xml:space="preserve">File is already mounted.</doc>
      </member>
      <member name="closed" value="18" c:identifier="G_IO_ERROR_CLOSED" glib:nick="closed">
        <doc xml:space="preserve">File was closed.</doc>
      </member>
      <member name="cancelled" value="19" c:identifier="G_IO_ERROR_CANCELLED" glib:nick="cancelled">
        <doc xml:space="preserve">Operation was cancelled. See #GCancellable.</doc>
      </member>
      <member name="pending" value="20" c:identifier="G_IO_ERROR_PENDING" glib:nick="pending">
        <doc xml:space="preserve">Operations are still pending.</doc>
      </member>
      <member name="read_only" value="21" c:identifier="G_IO_ERROR_READ_ONLY" glib:nick="read-only">
        <doc xml:space="preserve">File is read only.</doc>
      </member>
      <member name="cant_create_backup" value="22" c:identifier="G_IO_ERROR_CANT_CREATE_BACKUP" glib:nick="cant-create-backup">
        <doc xml:space="preserve">Backup couldn't be created.</doc>
      </member>
      <member name="wrong_etag" value="23" c:identifier="G_IO_ERROR_WRONG_ETAG" glib:nick="wrong-etag">
        <doc xml:space="preserve">File's Entity Tag was incorrect.</doc>
      </member>
      <member name="timed_out" value="24" c:identifier="G_IO_ERROR_TIMED_OUT" glib:nick="timed-out">
        <doc xml:space="preserve">Operation timed out.</doc>
      </member>
      <member name="would_recurse" value="25" c:identifier="G_IO_ERROR_WOULD_RECURSE" glib:nick="would-recurse">
        <doc xml:space="preserve">Operation would be recursive.</doc>
      </member>
      <member name="busy" value="26" c:identifier="G_IO_ERROR_BUSY" glib:nick="busy">
        <doc xml:space="preserve">File is busy.</doc>
      </member>
      <member name="would_block" value="27" c:identifier="G_IO_ERROR_WOULD_BLOCK" glib:nick="would-block">
        <doc xml:space="preserve">Operation would block.</doc>
      </member>
      <member name="host_not_found" value="28" c:identifier="G_IO_ERROR_HOST_NOT_FOUND" glib:nick="host-not-found">
        <doc xml:space="preserve">Host couldn't be found (remote operations).</doc>
      </member>
      <member name="would_merge" value="29" c:identifier="G_IO_ERROR_WOULD_MERGE" glib:nick="would-merge">
        <doc xml:space="preserve">Operation would merge files.</doc>
      </member>
      <member name="failed_handled" value="30" c:identifier="G_IO_ERROR_FAILED_HANDLED" glib:nick="failed-handled">
        <doc xml:space="preserve">Operation failed and a helper program has
    already interacted with the user. Do not display any error dialog.</doc>
      </member>
      <member name="too_many_open_files" value="31" c:identifier="G_IO_ERROR_TOO_MANY_OPEN_FILES" glib:nick="too-many-open-files">
        <doc xml:space="preserve">The current process has too many files
    open and can't open any more. Duplicate descriptors do count toward
    this limit. Since 2.20</doc>
      </member>
      <member name="not_initialized" value="32" c:identifier="G_IO_ERROR_NOT_INITIALIZED" glib:nick="not-initialized">
        <doc xml:space="preserve">The object has not been initialized. Since 2.22</doc>
      </member>
      <member name="address_in_use" value="33" c:identifier="G_IO_ERROR_ADDRESS_IN_USE" glib:nick="address-in-use">
        <doc xml:space="preserve">The requested address is already in use. Since 2.22</doc>
      </member>
      <member name="partial_input" value="34" c:identifier="G_IO_ERROR_PARTIAL_INPUT" glib:nick="partial-input">
        <doc xml:space="preserve">Need more input to finish operation. Since 2.24</doc>
      </member>
      <member name="invalid_data" value="35" c:identifier="G_IO_ERROR_INVALID_DATA" glib:nick="invalid-data">
        <doc xml:space="preserve">The input data was invalid. Since 2.24</doc>
      </member>
      <member name="dbus_error" value="36" c:identifier="G_IO_ERROR_DBUS_ERROR" glib:nick="dbus-error">
        <doc xml:space="preserve">A remote object generated an error that
    doesn't correspond to a locally registered #GError error
    domain. Use g_dbus_error_get_remote_error() to extract the D-Bus
    error name and g_dbus_error_strip_remote_error() to fix up the
    message so it matches what was received on the wire. Since 2.26.</doc>
      </member>
      <member name="host_unreachable" value="37" c:identifier="G_IO_ERROR_HOST_UNREACHABLE" glib:nick="host-unreachable">
        <doc xml:space="preserve">Host unreachable. Since 2.26</doc>
      </member>
      <member name="network_unreachable" value="38" c:identifier="G_IO_ERROR_NETWORK_UNREACHABLE" glib:nick="network-unreachable">
        <doc xml:space="preserve">Network unreachable. Since 2.26</doc>
      </member>
      <member name="connection_refused" value="39" c:identifier="G_IO_ERROR_CONNECTION_REFUSED" glib:nick="connection-refused">
        <doc xml:space="preserve">Connection refused. Since 2.26</doc>
      </member>
      <member name="proxy_failed" value="40" c:identifier="G_IO_ERROR_PROXY_FAILED" glib:nick="proxy-failed">
        <doc xml:space="preserve">Connection to proxy server failed. Since 2.26</doc>
      </member>
      <member name="proxy_auth_failed" value="41" c:identifier="G_IO_ERROR_PROXY_AUTH_FAILED" glib:nick="proxy-auth-failed">
        <doc xml:space="preserve">Proxy authentication failed. Since 2.26</doc>
      </member>
      <member name="proxy_need_auth" value="42" c:identifier="G_IO_ERROR_PROXY_NEED_AUTH" glib:nick="proxy-need-auth">
        <doc xml:space="preserve">Proxy server needs authentication. Since 2.26</doc>
      </member>
      <member name="proxy_not_allowed" value="43" c:identifier="G_IO_ERROR_PROXY_NOT_ALLOWED" glib:nick="proxy-not-allowed">
        <doc xml:space="preserve">Proxy connection is not allowed by ruleset.
    Since 2.26</doc>
      </member>
      <member name="broken_pipe" value="44" c:identifier="G_IO_ERROR_BROKEN_PIPE" glib:nick="broken-pipe">
        <doc xml:space="preserve">Broken pipe. Since 2.36</doc>
      </member>
      <member name="connection_closed" value="44" c:identifier="G_IO_ERROR_CONNECTION_CLOSED" glib:nick="connection-closed">
        <doc xml:space="preserve">Connection closed by peer. Note that this
    is the same code as %G_IO_ERROR_BROKEN_PIPE; before 2.44 some
    "connection closed" errors returned %G_IO_ERROR_BROKEN_PIPE, but others
    returned %G_IO_ERROR_FAILED. Now they should all return the same
    value, which has this more logical name. Since 2.44.</doc>
      </member>
      <member name="not_connected" value="45" c:identifier="G_IO_ERROR_NOT_CONNECTED" glib:nick="not-connected">
        <doc xml:space="preserve">Transport endpoint is not connected. Since 2.44</doc>
      </member>
      <member name="message_too_large" value="46" c:identifier="G_IO_ERROR_MESSAGE_TOO_LARGE" glib:nick="message-too-large">
        <doc xml:space="preserve">Message too large. Since 2.48.</doc>
      </member>
    </enumeration>
    <record name="IOExtension" c:type="GIOExtension" disguised="1">
      <doc xml:space="preserve">#GIOExtension is an opaque data structure and can only be accessed
using the following functions.</doc>
      <method name="get_name" c:identifier="g_io_extension_get_name">
        <doc xml:space="preserve">Gets the name under which @extension was registered.

Note that the same type may be registered as extension
for multiple extension points, under different names.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of @extension.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="extension" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOExtension</doc>
            <type name="IOExtension" c:type="GIOExtension*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_priority" c:identifier="g_io_extension_get_priority">
        <doc xml:space="preserve">Gets the priority with which @extension was registered.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the priority of @extension</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="extension" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOExtension</doc>
            <type name="IOExtension" c:type="GIOExtension*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_type" c:identifier="g_io_extension_get_type">
        <doc xml:space="preserve">Gets the type associated with @extension.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type of @extension</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="extension" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOExtension</doc>
            <type name="IOExtension" c:type="GIOExtension*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref_class" c:identifier="g_io_extension_ref_class" introspectable="0">
        <doc xml:space="preserve">Gets a reference to the class for the type that is
associated with @extension.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the #GTypeClass for the type of @extension</doc>
          <type name="GObject.TypeClass" c:type="GTypeClass*"/>
        </return-value>
        <parameters>
          <instance-parameter name="extension" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOExtension</doc>
            <type name="IOExtension" c:type="GIOExtension*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="IOExtensionPoint" c:type="GIOExtensionPoint" disguised="1">
      <doc xml:space="preserve">#GIOExtensionPoint is an opaque data structure and can only be accessed
using the following functions.</doc>
      <method name="get_extension_by_name" c:identifier="g_io_extension_point_get_extension_by_name">
        <doc xml:space="preserve">Finds a #GIOExtension for an extension point by name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GIOExtension for @extension_point that has the
   given name, or %NULL if there is no extension with that name</doc>
          <type name="IOExtension" c:type="GIOExtension*"/>
        </return-value>
        <parameters>
          <instance-parameter name="extension_point" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOExtensionPoint</doc>
            <type name="IOExtensionPoint" c:type="GIOExtensionPoint*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the extension to get</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_extensions" c:identifier="g_io_extension_point_get_extensions">
        <doc xml:space="preserve">Gets a list of all extensions that implement this extension point.
The list is sorted by priority, beginning with the highest priority.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GList of
    #GIOExtensions. The list is owned by GIO and should not be
    modified.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="IOExtension"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="extension_point" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOExtensionPoint</doc>
            <type name="IOExtensionPoint" c:type="GIOExtensionPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_required_type" c:identifier="g_io_extension_point_get_required_type">
        <doc xml:space="preserve">Gets the required type for @extension_point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GType that all implementations must have,
    or #G_TYPE_INVALID if the extension point has no required type</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="extension_point" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOExtensionPoint</doc>
            <type name="IOExtensionPoint" c:type="GIOExtensionPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_required_type" c:identifier="g_io_extension_point_set_required_type">
        <doc xml:space="preserve">Sets the required type for @extension_point to @type.
All implementations must henceforth have this type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="extension_point" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOExtensionPoint</doc>
            <type name="IOExtensionPoint" c:type="GIOExtensionPoint*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType to require</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <function name="implement" c:identifier="g_io_extension_point_implement">
        <doc xml:space="preserve">Registers @type as extension for the extension point with name
@extension_point_name.

If @type has already been registered as an extension for this
extension point, the existing #GIOExtension object is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GIOExtension object for #GType</doc>
          <type name="IOExtension" c:type="GIOExtension*"/>
        </return-value>
        <parameters>
          <parameter name="extension_point_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the extension point</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType to register as extension</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="extension_name" transfer-ownership="none">
            <doc xml:space="preserve">the name for the extension</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="priority" transfer-ownership="none">
            <doc xml:space="preserve">the priority for the extension</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </function>
      <function name="lookup" c:identifier="g_io_extension_point_lookup">
        <doc xml:space="preserve">Looks up an existing extension point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GIOExtensionPoint, or %NULL if there
   is no registered extension point with the given name.</doc>
          <type name="IOExtensionPoint" c:type="GIOExtensionPoint*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the extension point</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="register" c:identifier="g_io_extension_point_register">
        <doc xml:space="preserve">Registers an extension point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the new #GIOExtensionPoint. This object is
   owned by GIO and should not be freed.</doc>
          <type name="IOExtensionPoint" c:type="GIOExtensionPoint*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the extension point</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <class name="IOModule" c:symbol-prefix="io_module" c:type="GIOModule" parent="GObject.TypeModule" glib:type-name="GIOModule" glib:get-type="g_io_module_get_type" glib:type-struct="IOModuleClass">
      <doc xml:space="preserve">Provides an interface and default functions for loading and unloading
modules. This is used internally to make GIO extensible, but can also
be used by others to implement module loading.</doc>
      <implements name="GObject.TypePlugin"/>
      <constructor name="new" c:identifier="g_io_module_new">
        <doc xml:space="preserve">Creates a new GIOModule that will load the specific
shared library when in use.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GIOModule from given @filename,
or %NULL on error.</doc>
          <type name="IOModule" c:type="GIOModule*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">filename of the shared library module.</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="query" c:identifier="g_io_module_query" version="2.24">
        <doc xml:space="preserve">Optional API for GIO modules to implement.

Should return a list of all the extension points that may be
implemented in this module.

This method will not be called in normal use, however it may be
called when probing existing modules and recording which extension
points that this model is used for. This means we won't have to
load and initialize this module unless its needed.

If this function is not implemented by the module the module will
always be loaded, initialized and then unloaded on application
startup so that it can register its extension points during init.

Note that a module need not actually implement all the extension
points that g_io_module_query() returns, since the exact list of
extension may depend on runtime issues. However all extension
points actually implemented must be returned by g_io_module_query()
(if defined).

When installing a module that implements g_io_module_query() you must
run gio-querymodules in order to build the cache files required for
lazy loading.

Since 2.56, this function should be named `g_io_&lt;modulename&gt;_query`, where
`modulename` is the plugin&#x2019;s filename with the `lib` or `libgio` prefix and
everything after the first dot removed, and with `-` replaced with `_`
throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`.
Using the new symbol names avoids name clashes when building modules
statically. The old symbol names continue to be supported, but cannot be used
for static builds.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A %NULL-terminated array of strings,
    listing the supported extension points of the module. The array
    must be suitable for freeing with g_strfreev().</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
      </function>
      <method name="load" c:identifier="g_io_module_load">
        <doc xml:space="preserve">Required API for GIO modules to implement.

This function is run after the module has been loaded into GIO,
to initialize the module. Typically, this function will call
g_io_extension_point_implement().

Since 2.56, this function should be named `g_io_&lt;modulename&gt;_load`, where
`modulename` is the plugin&#x2019;s filename with the `lib` or `libgio` prefix and
everything after the first dot removed, and with `-` replaced with `_`
throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`.
Using the new symbol names avoids name clashes when building modules
statically. The old symbol names continue to be supported, but cannot be used
for static builds.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="module" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOModule.</doc>
            <type name="IOModule" c:type="GIOModule*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unload" c:identifier="g_io_module_unload">
        <doc xml:space="preserve">Required API for GIO modules to implement.

This function is run when the module is being unloaded from GIO,
to finalize the module.

Since 2.56, this function should be named `g_io_&lt;modulename&gt;_unload`, where
`modulename` is the plugin&#x2019;s filename with the `lib` or `libgio` prefix and
everything after the first dot removed, and with `-` replaced with `_`
throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`.
Using the new symbol names avoids name clashes when building modules
statically. The old symbol names continue to be supported, but cannot be used
for static builds.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="module" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOModule.</doc>
            <type name="IOModule" c:type="GIOModule*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <record name="IOModuleClass" c:type="GIOModuleClass" disguised="1" glib:is-gtype-struct-for="IOModule">
    </record>
    <record name="IOModuleScope" c:type="GIOModuleScope" disguised="1" version="2.30">
      <doc xml:space="preserve">Represents a scope for loading IO modules. A scope can be used for blocking
duplicate modules, or blocking a module you don't want to load.

The scope can be used with g_io_modules_load_all_in_directory_with_scope()
or g_io_modules_scan_all_in_directory_with_scope().</doc>
      <method name="block" c:identifier="g_io_module_scope_block" version="2.30">
        <doc xml:space="preserve">Block modules with the given @basename from being loaded when
this scope is used with g_io_modules_scan_all_in_directory_with_scope()
or g_io_modules_load_all_in_directory_with_scope().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scope" transfer-ownership="none">
            <doc xml:space="preserve">a module loading scope</doc>
            <type name="IOModuleScope" c:type="GIOModuleScope*"/>
          </instance-parameter>
          <parameter name="basename" transfer-ownership="none">
            <doc xml:space="preserve">the basename to block</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_io_module_scope_free" version="2.30">
        <doc xml:space="preserve">Free a module scope.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scope" transfer-ownership="none">
            <doc xml:space="preserve">a module loading scope</doc>
            <type name="IOModuleScope" c:type="GIOModuleScope*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="g_io_module_scope_new" version="2.30" introspectable="0">
        <doc xml:space="preserve">Create a new scope for loading of IO modules. A scope can be used for
blocking duplicate modules, or blocking a module you don't want to load.

Specify the %G_IO_MODULE_SCOPE_BLOCK_DUPLICATES flag to block modules
which have the same base name as a module that has already been seen
in this scope.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new module scope</doc>
          <type name="IOModuleScope" c:type="GIOModuleScope*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags for the new scope</doc>
            <type name="IOModuleScopeFlags" c:type="GIOModuleScopeFlags"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="IOModuleScopeFlags" version="2.30" glib:type-name="GIOModuleScopeFlags" glib:get-type="g_io_module_scope_flags_get_type" c:type="GIOModuleScopeFlags">
      <doc xml:space="preserve">Flags for use with g_io_module_scope_new().</doc>
      <member name="none" value="0" c:identifier="G_IO_MODULE_SCOPE_NONE" glib:nick="none">
        <doc xml:space="preserve">No module scan flags</doc>
      </member>
      <member name="block_duplicates" value="1" c:identifier="G_IO_MODULE_SCOPE_BLOCK_DUPLICATES" glib:nick="block-duplicates">
        <doc xml:space="preserve">When using this scope to load or
    scan modules, automatically block a modules which has the same base
    basename as previously loaded module.</doc>
      </member>
    </enumeration>
    <record name="IOSchedulerJob" c:type="GIOSchedulerJob" disguised="1">
      <doc xml:space="preserve">Opaque class for defining and scheduling IO jobs.</doc>
      <method name="send_to_mainloop" c:identifier="g_io_scheduler_job_send_to_mainloop" deprecated="1">
        <doc xml:space="preserve">Used from an I/O job to send a callback to be run in the thread
that the job was started from, waiting for the result (and thus
blocking the I/O job).</doc>
        <doc-deprecated xml:space="preserve">Use g_main_context_invoke().</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The return value of @func</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="job" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOSchedulerJob</doc>
            <type name="IOSchedulerJob" c:type="GIOSchedulerJob*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" scope="notified" closure="1" destroy="2">
            <doc xml:space="preserve">a #GSourceFunc callback that will be called in the original thread</doc>
            <type name="GLib.SourceFunc" c:type="GSourceFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a #GDestroyNotify for @user_data, or %NULL</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_to_mainloop_async" c:identifier="g_io_scheduler_job_send_to_mainloop_async" deprecated="1">
        <doc xml:space="preserve">Used from an I/O job to send a callback to be run asynchronously in
the thread that the job was started from. The callback will be run
when the main loop is available, but at that time the I/O job might
have finished. The return value from the callback is ignored.

Note that if you are passing the @user_data from g_io_scheduler_push_job()
on to this function you have to ensure that it is not freed before
@func is called, either by passing %NULL as @notify to
g_io_scheduler_push_job() or by using refcounting for @user_data.</doc>
        <doc-deprecated xml:space="preserve">Use g_main_context_invoke().</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="job" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOSchedulerJob</doc>
            <type name="IOSchedulerJob" c:type="GIOSchedulerJob*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" scope="notified" closure="1" destroy="2">
            <doc xml:space="preserve">a #GSourceFunc callback that will be called in the original thread</doc>
            <type name="GLib.SourceFunc" c:type="GSourceFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a #GDestroyNotify for @user_data, or %NULL</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <callback name="IOSchedulerJobFunc" c:type="GIOSchedulerJobFunc">
      <doc xml:space="preserve">I/O Job function.

Long-running jobs should periodically check the @cancellable
to see if they have been cancelled.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if this function should be called again to
   complete the job, %FALSE if the job is complete (or cancelled)</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="job" transfer-ownership="none">
          <doc xml:space="preserve">a #GIOSchedulerJob.</doc>
          <type name="IOSchedulerJob" c:type="GIOSchedulerJob*"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">the data to pass to callback function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="IOStream" c:symbol-prefix="io_stream" c:type="GIOStream" parent="GObject.Object" abstract="1" glib:type-name="GIOStream" glib:get-type="g_io_stream_get_type" glib:type-struct="IOStreamClass">
      <doc xml:space="preserve">GIOStream represents an object that has both read and write streams.
Generally the two streams act as separate input and output streams,
but they share some common resources and state. For instance, for
seekable streams, both streams may use the same position.

Examples of #GIOStream objects are #GSocketConnection, which represents
a two-way network connection; and #GFileIOStream, which represents a
file handle opened in read-write mode.

To do the actual reading and writing you need to get the substreams
with g_io_stream_get_input_stream() and g_io_stream_get_output_stream().

The #GIOStream object owns the input and the output streams, not the other
way around, so keeping the substreams alive will not keep the #GIOStream
object alive. If the #GIOStream object is freed it will be closed, thus
closing the substreams, so even if the substreams stay alive they will
always return %G_IO_ERROR_CLOSED for all operations.

To close a stream use g_io_stream_close() which will close the common
stream object and also the individual substreams. You can also close
the substreams themselves. In most cases this only marks the
substream as closed, so further I/O on it fails but common state in the
#GIOStream may still be open. However, some streams may support
"half-closed" states where one direction of the stream is actually shut down.

Operations on #GIOStreams cannot be started while another operation on the
#GIOStream or its substreams is in progress. Specifically, an application can
read from the #GInputStream and write to the #GOutputStream simultaneously
(either in separate threads, or as asynchronous operations in the same
thread), but an application cannot start any #GIOStream operation while there
is a #GIOStream, #GInputStream or #GOutputStream operation in progress, and
an application can&#x2019;t start any #GInputStream or #GOutputStream operation
while there is a #GIOStream operation in progress.

This is a product of individual stream operations being associated with a
given #GMainContext (the thread-default context at the time the operation was
started), rather than entire streams being associated with a single
#GMainContext.

GIO may run operations on #GIOStreams from other (worker) threads, and this
may be exposed to application code in the behaviour of wrapper streams, such
as #GBufferedInputStream or #GTlsConnection. With such wrapper APIs,
application code may only run operations on the base (wrapped) stream when
the wrapper stream is idle. Note that the semantics of such operations may
not be well-defined due to the state the wrapper stream leaves the base
stream in (though they are guaranteed not to crash).</doc>
      <function name="splice_finish" c:identifier="g_io_stream_splice_finish" version="2.28" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous io stream splice operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="close_async" invoker="close_async" version="2.22">
        <doc xml:space="preserve">Requests an asynchronous close of the stream, releasing resources
related to it. When the operation is finished @callback will be
called. You can then call g_io_stream_close_finish() to get
the result of the operation.

For behaviour details see g_io_stream_close().

The asynchronous methods have a default fallback that uses threads
to implement asynchronicity, so they are optional for inheriting
classes. However, if you override one you must override all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the io priority of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="close_finish" invoker="close_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Closes a stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if stream was successfully closed, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="close_fn" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <type name="IOStream" c:type="GIOStream*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_input_stream" invoker="get_input_stream" version="2.22">
        <doc xml:space="preserve">Gets the input stream for this object. This is used
for reading.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GInputStream, owned by the #GIOStream.
Do not free.</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_output_stream" invoker="get_output_stream" version="2.22">
        <doc xml:space="preserve">Gets the output stream for this object. This is used for
writing.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GOutputStream, owned by the #GIOStream.
Do not free.</doc>
          <type name="OutputStream" c:type="GOutputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="clear_pending" c:identifier="g_io_stream_clear_pending" version="2.22">
        <doc xml:space="preserve">Clears the pending flag on @stream.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="close" c:identifier="g_io_stream_close" version="2.22" throws="1">
        <doc xml:space="preserve">Closes the stream, releasing resources related to it. This will also
close the individual input and output streams, if they are not already
closed.

Once the stream is closed, all other operations will return
%G_IO_ERROR_CLOSED. Closing a stream multiple times will not
return an error.

Closing a stream will automatically flush any outstanding buffers
in the stream.

Streams will be automatically closed when the last reference
is dropped, but you might want to call this function to make sure
resources are released as early as possible.

Some streams might keep the backing store of the stream (e.g. a file
descriptor) open after the stream is closed. See the documentation for
the individual stream for details.

On failure the first error that happened will be reported, but the
close operation will finish as much as possible. A stream that failed
to close will still return %G_IO_ERROR_CLOSED for all operations.
Still, it is important to check and report the error to the user,
otherwise there might be a loss of data as all data might not be written.

If @cancellable is not NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
Cancelling a close will still leave the stream closed, but some streams
can use a faster close that doesn't block to e.g. check errors.

The default implementation of this method just calls close on the
individual input/output streams.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_async" c:identifier="g_io_stream_close_async" version="2.22">
        <doc xml:space="preserve">Requests an asynchronous close of the stream, releasing resources
related to it. When the operation is finished @callback will be
called. You can then call g_io_stream_close_finish() to get
the result of the operation.

For behaviour details see g_io_stream_close().

The asynchronous methods have a default fallback that uses threads
to implement asynchronicity, so they are optional for inheriting
classes. However, if you override one you must override all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the io priority of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_finish" c:identifier="g_io_stream_close_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Closes a stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if stream was successfully closed, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_input_stream" c:identifier="g_io_stream_get_input_stream" version="2.22">
        <doc xml:space="preserve">Gets the input stream for this object. This is used
for reading.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GInputStream, owned by the #GIOStream.
Do not free.</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_output_stream" c:identifier="g_io_stream_get_output_stream" version="2.22">
        <doc xml:space="preserve">Gets the output stream for this object. This is used for
writing.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GOutputStream, owned by the #GIOStream.
Do not free.</doc>
          <type name="OutputStream" c:type="GOutputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_pending" c:identifier="g_io_stream_has_pending" version="2.22">
        <doc xml:space="preserve">Checks if a stream has pending actions.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @stream has pending actions.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_closed" c:identifier="g_io_stream_is_closed" version="2.22">
        <doc xml:space="preserve">Checks if a stream is closed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the stream is closed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_pending" c:identifier="g_io_stream_set_pending" version="2.22" throws="1">
        <doc xml:space="preserve">Sets @stream to have actions pending. If the pending flag is
already set or @stream is closed, it will return %FALSE and set
@error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if pending was previously unset and is now set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="splice_async" c:identifier="g_io_stream_splice_async" version="2.28">
        <doc xml:space="preserve">Asyncronously splice the output stream of @stream1 to the input stream of
@stream2, and splice the output stream of @stream2 to the input stream of
@stream1.

When the operation is finished @callback will be called.
You can then call g_io_stream_splice_finish() to get the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream1" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream.</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </instance-parameter>
          <parameter name="stream2" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream.</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GIOStreamSpliceFlags.</doc>
            <type name="IOStreamSpliceFlags" c:type="GIOStreamSpliceFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the io priority of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">a #GAsyncReadyCallback.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <property name="closed" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="input-stream" transfer-ownership="none">
        <type name="InputStream"/>
      </property>
      <property name="output-stream" transfer-ownership="none">
        <type name="OutputStream"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="IOStreamPrivate" c:type="GIOStreamPrivate*"/>
      </field>
    </class>
    <record name="IOStreamAdapter" c:type="GIOStreamAdapter" disguised="1">
    </record>
    <record name="IOStreamClass" c:type="GIOStreamClass" glib:is-gtype-struct-for="IOStream">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="get_input_stream">
        <callback name="get_input_stream">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream, owned by the #GIOStream.
Do not free.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GIOStream</doc>
              <type name="IOStream" c:type="GIOStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_output_stream">
        <callback name="get_output_stream">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream, owned by the #GIOStream.
Do not free.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GIOStream</doc>
              <type name="IOStream" c:type="GIOStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_fn">
        <callback name="close_fn" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="IOStream" c:type="GIOStream*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_async">
        <callback name="close_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GIOStream</doc>
              <type name="IOStream" c:type="GIOStream*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the io priority of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional cancellable object</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_finish">
        <callback name="close_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if stream was successfully closed, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GIOStream</doc>
              <type name="IOStream" c:type="GIOStream*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved6" introspectable="0">
        <callback name="_g_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved7" introspectable="0">
        <callback name="_g_reserved7">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved8" introspectable="0">
        <callback name="_g_reserved8">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved9" introspectable="0">
        <callback name="_g_reserved9">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved10" introspectable="0">
        <callback name="_g_reserved10">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="IOStreamPrivate" c:type="GIOStreamPrivate" disguised="1">
    </record>
    <bitfield name="IOStreamSpliceFlags" version="2.28" glib:type-name="GIOStreamSpliceFlags" glib:get-type="g_io_stream_splice_flags_get_type" c:type="GIOStreamSpliceFlags">
      <doc xml:space="preserve">GIOStreamSpliceFlags determine how streams should be spliced.</doc>
      <member name="none" value="0" c:identifier="G_IO_STREAM_SPLICE_NONE" glib:nick="none">
        <doc xml:space="preserve">Do not close either stream.</doc>
      </member>
      <member name="close_stream1" value="1" c:identifier="G_IO_STREAM_SPLICE_CLOSE_STREAM1" glib:nick="close-stream1">
        <doc xml:space="preserve">Close the first stream after
    the splice.</doc>
      </member>
      <member name="close_stream2" value="2" c:identifier="G_IO_STREAM_SPLICE_CLOSE_STREAM2" glib:nick="close-stream2">
        <doc xml:space="preserve">Close the second stream after
    the splice.</doc>
      </member>
      <member name="wait_for_both" value="4" c:identifier="G_IO_STREAM_SPLICE_WAIT_FOR_BOTH" glib:nick="wait-for-both">
        <doc xml:space="preserve">Wait for both splice operations to finish
    before calling the callback.</doc>
      </member>
    </bitfield>
    <interface name="Icon" c:symbol-prefix="icon" c:type="GIcon" glib:type-name="GIcon" glib:get-type="g_icon_get_type" glib:type-struct="IconIface">
      <doc xml:space="preserve">#GIcon is a very minimal interface for icons. It provides functions
for checking the equality of two icons, hashing of icons and
serializing an icon to and from strings.

#GIcon does not provide the actual pixmap for the icon as this is out
of GIO's scope, however implementations of #GIcon may contain the name
of an icon (see #GThemedIcon), or the path to an icon (see #GLoadableIcon).

To obtain a hash of a #GIcon, see g_icon_hash().

To check if two #GIcons are equal, see g_icon_equal().

For serializing a #GIcon, use g_icon_serialize() and
g_icon_deserialize().

If you want to consume #GIcon (for example, in a toolkit) you must
be prepared to handle at least the three following cases:
#GLoadableIcon, #GThemedIcon and #GEmblemedIcon.  It may also make
sense to have fast-paths for other cases (like handling #GdkPixbuf
directly, for example) but all compliant #GIcon implementations
outside of GIO must implement #GLoadableIcon.

If your application or library provides one or more #GIcon
implementations you need to ensure that your new implementation also
implements #GLoadableIcon.  Additionally, you must provide an
implementation of g_icon_serialize() that gives a result that is
understood by g_icon_deserialize(), yielding one of the built-in icon
types.</doc>
      <function name="deserialize" c:identifier="g_icon_deserialize" version="2.38">
        <doc xml:space="preserve">Deserializes a #GIcon previously serialized using g_icon_serialize().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GIcon, or %NULL when deserialization fails.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant created with g_icon_serialize()</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </function>
      <function name="hash" c:identifier="g_icon_hash">
        <doc xml:space="preserve">Gets a hash for an icon.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #guint containing a hash for the @icon, suitable for
use in a #GHashTable or similar data structure.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">#gconstpointer to an icon object.</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_for_string" c:identifier="g_icon_new_for_string" version="2.20" throws="1">
        <doc xml:space="preserve">Generate a #GIcon instance from @str. This function can fail if
@str is not valid - see g_icon_to_string() for discussion.

If your application or library provides one or more #GIcon
implementations you need to ensure that each #GType is registered
with the type system prior to calling g_icon_new_for_string().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">An object implementing the #GIcon
         interface or %NULL if @error is set.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve">A string obtained via g_icon_to_string().</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="equal" invoker="equal">
        <doc xml:space="preserve">Checks if two icons are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @icon1 is equal to @icon2. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="icon1" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">pointer to the first #GIcon.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </instance-parameter>
          <parameter name="icon2" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">pointer to the second #GIcon.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="hash" invoker="hash">
        <doc xml:space="preserve">Gets a hash for an icon.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #guint containing a hash for the @icon, suitable for
use in a #GHashTable or similar data structure.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">#gconstpointer to an icon object.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="serialize" invoker="serialize" version="2.38">
        <doc xml:space="preserve">Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
back by calling g_icon_deserialize() on the returned value.
As serialization will avoid using raw icon data when possible, it only
makes sense to transfer the #GVariant between processes on the same machine,
(as opposed to over the network), and within the same file system namespace.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GVariant, or %NULL when serialization fails.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">a #GIcon</doc>
            <type name="Icon" c:type="GIcon*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="to_tokens" invoker="to_string" version="2.20" introspectable="0">
        <doc xml:space="preserve">Generates a textual representation of @icon that can be used for
serialization such as when passing @icon to a different process or
saving it to persistent storage. Use g_icon_new_for_string() to
get @icon back from the returned string.

The encoding of the returned string is proprietary to #GIcon except
in the following two cases

- If @icon is a #GFileIcon, the returned string is a native path
  (such as `/path/to/my icon.png`) without escaping
  if the #GFile for @icon is a native file.  If the file is not
  native, the returned string is the result of g_file_get_uri()
  (such as `sftp://path/to/my%20icon.png`).

- If @icon is a #GThemedIcon with exactly one name and no fallbacks,
  the encoding is simply the name (such as `network-server`).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">An allocated NUL-terminated UTF8 string or
%NULL if @icon can't be serialized. Use g_free() to free.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">a #GIcon.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </instance-parameter>
          <parameter name="tokens" transfer-ownership="none">
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="out_version" transfer-ownership="none">
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="equal" c:identifier="g_icon_equal">
        <doc xml:space="preserve">Checks if two icons are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @icon1 is equal to @icon2. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="icon1" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">pointer to the first #GIcon.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </instance-parameter>
          <parameter name="icon2" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">pointer to the second #GIcon.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </parameter>
        </parameters>
      </method>
      <method name="serialize" c:identifier="g_icon_serialize" version="2.38">
        <doc xml:space="preserve">Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
back by calling g_icon_deserialize() on the returned value.
As serialization will avoid using raw icon data when possible, it only
makes sense to transfer the #GVariant between processes on the same machine,
(as opposed to over the network), and within the same file system namespace.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GVariant, or %NULL when serialization fails.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">a #GIcon</doc>
            <type name="Icon" c:type="GIcon*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="g_icon_to_string" version="2.20">
        <doc xml:space="preserve">Generates a textual representation of @icon that can be used for
serialization such as when passing @icon to a different process or
saving it to persistent storage. Use g_icon_new_for_string() to
get @icon back from the returned string.

The encoding of the returned string is proprietary to #GIcon except
in the following two cases

- If @icon is a #GFileIcon, the returned string is a native path
  (such as `/path/to/my icon.png`) without escaping
  if the #GFile for @icon is a native file.  If the file is not
  native, the returned string is the result of g_file_get_uri()
  (such as `sftp://path/to/my%20icon.png`).

- If @icon is a #GThemedIcon with exactly one name and no fallbacks,
  the encoding is simply the name (such as `network-server`).</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">An allocated NUL-terminated UTF8 string or
%NULL if @icon can't be serialized. Use g_free() to free.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">a #GIcon.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </instance-parameter>
        </parameters>
      </method>
    </interface>
    <record name="IconIface" c:type="GIconIface" glib:is-gtype-struct-for="Icon">
      <doc xml:space="preserve">GIconIface is used to implement GIcon types for various
different systems. See #GThemedIcon and #GLoadableIcon for
examples of how to implement this interface.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="hash">
        <callback name="hash">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">a #guint containing a hash for the @icon, suitable for
use in a #GHashTable or similar data structure.</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="icon" transfer-ownership="none">
              <doc xml:space="preserve">#gconstpointer to an icon object.</doc>
              <type name="Icon" c:type="GIcon*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="equal">
        <callback name="equal">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @icon1 is equal to @icon2. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="icon1" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">pointer to the first #GIcon.</doc>
              <type name="Icon" c:type="GIcon*"/>
            </parameter>
            <parameter name="icon2" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">pointer to the second #GIcon.</doc>
              <type name="Icon" c:type="GIcon*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="to_tokens" introspectable="0">
        <callback name="to_tokens" introspectable="0">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">An allocated NUL-terminated UTF8 string or
%NULL if @icon can't be serialized. Use g_free() to free.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="icon" transfer-ownership="none">
              <doc xml:space="preserve">a #GIcon.</doc>
              <type name="Icon" c:type="GIcon*"/>
            </parameter>
            <parameter name="tokens" transfer-ownership="none">
              <array name="GLib.PtrArray" c:type="GPtrArray*">
                <type name="gpointer" c:type="gpointer"/>
              </array>
            </parameter>
            <parameter name="out_version" transfer-ownership="none">
              <type name="gint" c:type="gint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="from_tokens" introspectable="0">
        <callback name="from_tokens" introspectable="0" throws="1">
          <return-value>
            <type name="Icon" c:type="GIcon*"/>
          </return-value>
          <parameters>
            <parameter name="tokens" transfer-ownership="none">
              <type name="utf8" c:type="gchar**"/>
            </parameter>
            <parameter name="num_tokens" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="version" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="serialize">
        <callback name="serialize">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GVariant, or %NULL when serialization fails.</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </return-value>
          <parameters>
            <parameter name="icon" transfer-ownership="none">
              <doc xml:space="preserve">a #GIcon</doc>
              <type name="Icon" c:type="GIcon*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="InetAddress" c:symbol-prefix="inet_address" c:type="GInetAddress" parent="GObject.Object" glib:type-name="GInetAddress" glib:get-type="g_inet_address_get_type" glib:type-struct="InetAddressClass">
      <doc xml:space="preserve">#GInetAddress represents an IPv4 or IPv6 internet address. Use
g_resolver_lookup_by_name() or g_resolver_lookup_by_name_async() to
look up the #GInetAddress for a hostname. Use
g_resolver_lookup_by_address() or
g_resolver_lookup_by_address_async() to look up the hostname for a
#GInetAddress.

To actually connect to a remote host, you will need a
#GInetSocketAddress (which includes a #GInetAddress as well as a
port number).</doc>
      <constructor name="new_any" c:identifier="g_inet_address_new_any" version="2.22">
        <doc xml:space="preserve">Creates a #GInetAddress for the "any" address (unassigned/"don't
care") for @family.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GInetAddress corresponding to the "any" address
for @family.
    Free the returned object with g_object_unref().</doc>
          <type name="InetAddress" c:type="GInetAddress*"/>
        </return-value>
        <parameters>
          <parameter name="family" transfer-ownership="none">
            <doc xml:space="preserve">the address family</doc>
            <type name="SocketFamily" c:type="GSocketFamily"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_bytes" c:identifier="g_inet_address_new_from_bytes" version="2.22">
        <doc xml:space="preserve">Creates a new #GInetAddress from the given @family and @bytes.
@bytes should be 4 bytes for %G_SOCKET_FAMILY_IPV4 and 16 bytes for
%G_SOCKET_FAMILY_IPV6.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GInetAddress corresponding to @family and @bytes.
    Free the returned object with g_object_unref().</doc>
          <type name="InetAddress" c:type="GInetAddress*"/>
        </return-value>
        <parameters>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve">raw address data</doc>
            <array zero-terminated="0" c:type="const guint8*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="family" transfer-ownership="none">
            <doc xml:space="preserve">the address family of @bytes</doc>
            <type name="SocketFamily" c:type="GSocketFamily"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_string" c:identifier="g_inet_address_new_from_string" version="2.22">
        <doc xml:space="preserve">Parses @string as an IP address and creates a new #GInetAddress.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GInetAddress corresponding to @string, or %NULL if
@string could not be parsed.
    Free the returned object with g_object_unref().</doc>
          <type name="InetAddress" c:type="GInetAddress*"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a string representation of an IP address</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_loopback" c:identifier="g_inet_address_new_loopback" version="2.22">
        <doc xml:space="preserve">Creates a #GInetAddress for the loopback address for @family.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GInetAddress corresponding to the loopback address
for @family.
    Free the returned object with g_object_unref().</doc>
          <type name="InetAddress" c:type="GInetAddress*"/>
        </return-value>
        <parameters>
          <parameter name="family" transfer-ownership="none">
            <doc xml:space="preserve">the address family</doc>
            <type name="SocketFamily" c:type="GSocketFamily"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="to_bytes" invoker="to_bytes" version="2.22" introspectable="0">
        <doc xml:space="preserve">Gets the raw binary address data from @address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a pointer to an internal array of the bytes in @address,
which should not be modified, stored, or freed. The size of this
array can be gotten with g_inet_address_get_native_size().</doc>
          <type name="guint8" c:type="const guint8*"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddress</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="to_string" invoker="to_string" version="2.22">
        <doc xml:space="preserve">Converts @address to string form.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a representation of @address as a string, which should be
freed after use.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddress</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="equal" c:identifier="g_inet_address_equal" version="2.30">
        <doc xml:space="preserve">Checks if two #GInetAddress instances are equal, e.g. the same address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @address and @other_address are equal, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">A #GInetAddress.</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </instance-parameter>
          <parameter name="other_address" transfer-ownership="none">
            <doc xml:space="preserve">Another #GInetAddress.</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_family" c:identifier="g_inet_address_get_family" version="2.22">
        <doc xml:space="preserve">Gets @address's family</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@address's family</doc>
          <type name="SocketFamily" c:type="GSocketFamily"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddress</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_any" c:identifier="g_inet_address_get_is_any" version="2.22">
        <doc xml:space="preserve">Tests whether @address is the "any" address for its family.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @address is the "any" address for its family.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddress</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_link_local" c:identifier="g_inet_address_get_is_link_local" version="2.22">
        <doc xml:space="preserve">Tests whether @address is a link-local address (that is, if it
identifies a host on a local network that is not connected to the
Internet).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @address is a link-local address.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddress</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_loopback" c:identifier="g_inet_address_get_is_loopback" version="2.22">
        <doc xml:space="preserve">Tests whether @address is the loopback address for its family.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @address is the loopback address for its family.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddress</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_mc_global" c:identifier="g_inet_address_get_is_mc_global" version="2.22">
        <doc xml:space="preserve">Tests whether @address is a global multicast address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @address is a global multicast address.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddress</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_mc_link_local" c:identifier="g_inet_address_get_is_mc_link_local" version="2.22">
        <doc xml:space="preserve">Tests whether @address is a link-local multicast address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @address is a link-local multicast address.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddress</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_mc_node_local" c:identifier="g_inet_address_get_is_mc_node_local" version="2.22">
        <doc xml:space="preserve">Tests whether @address is a node-local multicast address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @address is a node-local multicast address.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddress</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_mc_org_local" c:identifier="g_inet_address_get_is_mc_org_local" version="2.22">
        <doc xml:space="preserve">Tests whether @address is an organization-local multicast address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @address is an organization-local multicast address.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddress</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_mc_site_local" c:identifier="g_inet_address_get_is_mc_site_local" version="2.22">
        <doc xml:space="preserve">Tests whether @address is a site-local multicast address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @address is a site-local multicast address.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddress</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_multicast" c:identifier="g_inet_address_get_is_multicast" version="2.22">
        <doc xml:space="preserve">Tests whether @address is a multicast address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @address is a multicast address.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddress</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_site_local" c:identifier="g_inet_address_get_is_site_local" version="2.22">
        <doc xml:space="preserve">Tests whether @address is a site-local address such as 10.0.0.1
(that is, the address identifies a host on a local network that can
not be reached directly from the Internet, but which may have
outgoing Internet connectivity via a NAT or firewall).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @address is a site-local address.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddress</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_native_size" c:identifier="g_inet_address_get_native_size" version="2.22">
        <doc xml:space="preserve">Gets the size of the native raw binary address for @address. This
is the size of the data that you get from g_inet_address_to_bytes().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes used for the native version of @address.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddress</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_bytes" c:identifier="g_inet_address_to_bytes" version="2.22" introspectable="0">
        <doc xml:space="preserve">Gets the raw binary address data from @address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a pointer to an internal array of the bytes in @address,
which should not be modified, stored, or freed. The size of this
array can be gotten with g_inet_address_get_native_size().</doc>
          <type name="guint8" c:type="const guint8*"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddress</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="g_inet_address_to_string" version="2.22">
        <doc xml:space="preserve">Converts @address to string form.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a representation of @address as a string, which should be
freed after use.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddress</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="bytes" writable="1" construct-only="1" transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="family" writable="1" construct-only="1" transfer-ownership="none">
        <type name="SocketFamily"/>
      </property>
      <property name="is-any" version="2.22" transfer-ownership="none">
        <doc xml:space="preserve">Whether this is the "any" address for its family.
See g_inet_address_get_is_any().</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="is-link-local" version="2.22" transfer-ownership="none">
        <doc xml:space="preserve">Whether this is a link-local address.
See g_inet_address_get_is_link_local().</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="is-loopback" version="2.22" transfer-ownership="none">
        <doc xml:space="preserve">Whether this is the loopback address for its family.
See g_inet_address_get_is_loopback().</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="is-mc-global" version="2.22" transfer-ownership="none">
        <doc xml:space="preserve">Whether this is a global multicast address.
See g_inet_address_get_is_mc_global().</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="is-mc-link-local" version="2.22" transfer-ownership="none">
        <doc xml:space="preserve">Whether this is a link-local multicast address.
See g_inet_address_get_is_mc_link_local().</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="is-mc-node-local" version="2.22" transfer-ownership="none">
        <doc xml:space="preserve">Whether this is a node-local multicast address.
See g_inet_address_get_is_mc_node_local().</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="is-mc-org-local" version="2.22" transfer-ownership="none">
        <doc xml:space="preserve">Whether this is an organization-local multicast address.
See g_inet_address_get_is_mc_org_local().</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="is-mc-site-local" version="2.22" transfer-ownership="none">
        <doc xml:space="preserve">Whether this is a site-local multicast address.
See g_inet_address_get_is_mc_site_local().</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="is-multicast" version="2.22" transfer-ownership="none">
        <doc xml:space="preserve">Whether this is a multicast address.
See g_inet_address_get_is_multicast().</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="is-site-local" version="2.22" transfer-ownership="none">
        <doc xml:space="preserve">Whether this is a site-local address.
See g_inet_address_get_is_loopback().</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="InetAddressPrivate" c:type="GInetAddressPrivate*"/>
      </field>
    </class>
    <record name="InetAddressClass" c:type="GInetAddressClass" glib:is-gtype-struct-for="InetAddress">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="to_string">
        <callback name="to_string">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a representation of @address as a string, which should be
freed after use.</doc>
            <type name="utf8" c:type="gchar*"/>
          </return-value>
          <parameters>
            <parameter name="address" transfer-ownership="none">
              <doc xml:space="preserve">a #GInetAddress</doc>
              <type name="InetAddress" c:type="GInetAddress*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="to_bytes">
        <callback name="to_bytes">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">a pointer to an internal array of the bytes in @address,
which should not be modified, stored, or freed. The size of this
array can be gotten with g_inet_address_get_native_size().</doc>
            <type name="guint8" c:type="const guint8*"/>
          </return-value>
          <parameters>
            <parameter name="address" transfer-ownership="none">
              <doc xml:space="preserve">a #GInetAddress</doc>
              <type name="InetAddress" c:type="GInetAddress*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="InetAddressMask" c:symbol-prefix="inet_address_mask" c:type="GInetAddressMask" version="2.32" parent="GObject.Object" glib:type-name="GInetAddressMask" glib:get-type="g_inet_address_mask_get_type" glib:type-struct="InetAddressMaskClass">
      <doc xml:space="preserve">#GInetAddressMask represents a range of IPv4 or IPv6 addresses
described by a base address and a length indicating how many bits
of the base address are relevant for matching purposes. These are
often given in string form. Eg, "10.0.0.0/8", or "fe80::/10".</doc>
      <implements name="Initable"/>
      <constructor name="new" c:identifier="g_inet_address_mask_new" version="2.32" throws="1">
        <doc xml:space="preserve">Creates a new #GInetAddressMask representing all addresses whose
first @length bits match @addr.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GInetAddressMask, or %NULL on error</doc>
          <type name="InetAddressMask" c:type="GInetAddressMask*"/>
        </return-value>
        <parameters>
          <parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddress</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">number of bits of @addr to use</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_string" c:identifier="g_inet_address_mask_new_from_string" version="2.32" throws="1">
        <doc xml:space="preserve">Parses @mask_string as an IP address and (optional) length, and
creates a new #GInetAddressMask. The length, if present, is
delimited by a "/". If it is not present, then the length is
assumed to be the full length of the address.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GInetAddressMask corresponding to @string, or %NULL
on error.</doc>
          <type name="InetAddressMask" c:type="GInetAddressMask*"/>
        </return-value>
        <parameters>
          <parameter name="mask_string" transfer-ownership="none">
            <doc xml:space="preserve">an IP address or address/length string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="equal" c:identifier="g_inet_address_mask_equal" version="2.32">
        <doc xml:space="preserve">Tests if @mask and @mask2 are the same mask.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @mask and @mask2 are the same mask</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddressMask</doc>
            <type name="InetAddressMask" c:type="GInetAddressMask*"/>
          </instance-parameter>
          <parameter name="mask2" transfer-ownership="none">
            <doc xml:space="preserve">another #GInetAddressMask</doc>
            <type name="InetAddressMask" c:type="GInetAddressMask*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_address" c:identifier="g_inet_address_mask_get_address" version="2.32">
        <doc xml:space="preserve">Gets @mask's base address</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@mask's base address</doc>
          <type name="InetAddress" c:type="GInetAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddressMask</doc>
            <type name="InetAddressMask" c:type="GInetAddressMask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_family" c:identifier="g_inet_address_mask_get_family" version="2.32">
        <doc xml:space="preserve">Gets the #GSocketFamily of @mask's address</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GSocketFamily of @mask's address</doc>
          <type name="SocketFamily" c:type="GSocketFamily"/>
        </return-value>
        <parameters>
          <instance-parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddressMask</doc>
            <type name="InetAddressMask" c:type="GInetAddressMask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_length" c:identifier="g_inet_address_mask_get_length" version="2.32">
        <doc xml:space="preserve">Gets @mask's length</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@mask's length</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddressMask</doc>
            <type name="InetAddressMask" c:type="GInetAddressMask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="matches" c:identifier="g_inet_address_mask_matches" version="2.32">
        <doc xml:space="preserve">Tests if @address falls within the range described by @mask.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @address falls within the range described by
@mask.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddressMask</doc>
            <type name="InetAddressMask" c:type="GInetAddressMask*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddress</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="g_inet_address_mask_to_string" version="2.32">
        <doc xml:space="preserve">Converts @mask back to its corresponding string form.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a string corresponding to @mask.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddressMask</doc>
            <type name="InetAddressMask" c:type="GInetAddressMask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="address" writable="1" transfer-ownership="none">
        <type name="InetAddress"/>
      </property>
      <property name="family" transfer-ownership="none">
        <type name="SocketFamily"/>
      </property>
      <property name="length" writable="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="InetAddressMaskPrivate" c:type="GInetAddressMaskPrivate*"/>
      </field>
    </class>
    <record name="InetAddressMaskClass" c:type="GInetAddressMaskClass" glib:is-gtype-struct-for="InetAddressMask">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="InetAddressMaskPrivate" c:type="GInetAddressMaskPrivate" disguised="1">
    </record>
    <record name="InetAddressPrivate" c:type="GInetAddressPrivate" disguised="1">
    </record>
    <class name="InetSocketAddress" c:symbol-prefix="inet_socket_address" c:type="GInetSocketAddress" parent="SocketAddress" glib:type-name="GInetSocketAddress" glib:get-type="g_inet_socket_address_get_type" glib:type-struct="InetSocketAddressClass">
      <doc xml:space="preserve">An IPv4 or IPv6 socket address; that is, the combination of a
#GInetAddress and a port number.</doc>
      <implements name="SocketConnectable"/>
      <constructor name="new" c:identifier="g_inet_socket_address_new" version="2.22">
        <doc xml:space="preserve">Creates a new #GInetSocketAddress for @address and @port.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GInetSocketAddress</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddress</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">a port number</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_string" c:identifier="g_inet_socket_address_new_from_string" version="2.40">
        <doc xml:space="preserve">Creates a new #GInetSocketAddress for @address and @port.

If @address is an IPv6 address, it can also contain a scope ID
(separated from the address by a `%`).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GInetSocketAddress, or %NULL if @address cannot be
parsed.</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the string form of an IP address</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">a port number</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_address" c:identifier="g_inet_socket_address_get_address" version="2.22">
        <doc xml:space="preserve">Gets @address's #GInetAddress.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GInetAddress for @address, which must be
g_object_ref()'d if it will be stored</doc>
          <type name="InetAddress" c:type="GInetAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetSocketAddress</doc>
            <type name="InetSocketAddress" c:type="GInetSocketAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flowinfo" c:identifier="g_inet_socket_address_get_flowinfo" version="2.32">
        <doc xml:space="preserve">Gets the `sin6_flowinfo` field from @address,
which must be an IPv6 address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the flowinfo field</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a %G_SOCKET_FAMILY_IPV6 #GInetSocketAddress</doc>
            <type name="InetSocketAddress" c:type="GInetSocketAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_port" c:identifier="g_inet_socket_address_get_port" version="2.22">
        <doc xml:space="preserve">Gets @address's port.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the port for @address</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetSocketAddress</doc>
            <type name="InetSocketAddress" c:type="GInetSocketAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_scope_id" c:identifier="g_inet_socket_address_get_scope_id" version="2.32">
        <doc xml:space="preserve">Gets the `sin6_scope_id` field from @address,
which must be an IPv6 address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the scope id field</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a %G_SOCKET_FAMILY_IPV6 #GInetAddress</doc>
            <type name="InetSocketAddress" c:type="GInetSocketAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="address" writable="1" construct-only="1" transfer-ownership="none">
        <type name="InetAddress"/>
      </property>
      <property name="flowinfo" version="2.32" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The `sin6_flowinfo` field, for IPv6 addresses.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="port" writable="1" construct-only="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="scope-id" writable="1" construct-only="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent_instance">
        <type name="SocketAddress" c:type="GSocketAddress"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="InetSocketAddressPrivate" c:type="GInetSocketAddressPrivate*"/>
      </field>
    </class>
    <record name="InetSocketAddressClass" c:type="GInetSocketAddressClass" glib:is-gtype-struct-for="InetSocketAddress">
      <field name="parent_class">
        <type name="SocketAddressClass" c:type="GSocketAddressClass"/>
      </field>
    </record>
    <record name="InetSocketAddressPrivate" c:type="GInetSocketAddressPrivate" disguised="1">
    </record>
    <interface name="Initable" c:symbol-prefix="initable" c:type="GInitable" version="2.22" glib:type-name="GInitable" glib:get-type="g_initable_get_type" glib:type-struct="InitableIface">
      <doc xml:space="preserve">#GInitable is implemented by objects that can fail during
initialization. If an object implements this interface then
it must be initialized as the first thing after construction,
either via g_initable_init() or g_async_initable_init_async()
(the latter is only available if it also implements #GAsyncInitable).

If the object is not initialized, or initialization returns with an
error, then all operations on the object except g_object_ref() and
g_object_unref() are considered to be invalid, and have undefined
behaviour. They will often fail with g_critical() or g_warning(), but
this must not be relied on.

Users of objects implementing this are not intended to use
the interface method directly, instead it will be used automatically
in various ways. For C applications you generally just call
g_initable_new() directly, or indirectly via a foo_thing_new() wrapper.
This will call g_initable_init() under the cover, returning %NULL and
setting a #GError on failure (at which point the instance is
unreferenced).

For bindings in languages where the native constructor supports
exceptions the binding could check for objects implemention %GInitable
during normal construction and automatically initialize them, throwing
an exception on failure.</doc>
      <function name="new" c:identifier="g_initable_new" version="2.22" introspectable="0">
        <doc xml:space="preserve">Helper function for constructing #GInitable object. This is
similar to g_object_new() but also initializes the object
and returns %NULL, setting an error on failure.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated
     #GObject, or %NULL on error</doc>
          <type name="GObject.Object" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="object_type" transfer-ownership="none">
            <doc xml:space="preserve">a #GType supporting #GInitable.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">a #GError location to store the error occurring, or %NULL to
   ignore.</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="first_property_name" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the name of the first property, or %NULL if no
    properties</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the value if the first property, followed by and other property
   value pairs, and ended by %NULL.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </function>
      <function name="new_valist" c:identifier="g_initable_new_valist" version="2.22" introspectable="0" throws="1">
        <doc xml:space="preserve">Helper function for constructing #GInitable object. This is
similar to g_object_new_valist() but also initializes the object
and returns %NULL, setting an error on failure.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated
     #GObject, or %NULL on error</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="object_type" transfer-ownership="none">
            <doc xml:space="preserve">a #GType supporting #GInitable.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the first property, followed by
the value, and other property value pairs, and ended by %NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:space="preserve">The var args list generated from @first_property_name.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </function>
      <function name="newv" c:identifier="g_initable_newv" version="2.22" deprecated="1" deprecated-version="2.54" throws="1">
        <doc xml:space="preserve">Helper function for constructing #GInitable object. This is
similar to g_object_newv() but also initializes the object
and returns %NULL, setting an error on failure.</doc>
        <doc-deprecated xml:space="preserve">Use g_object_new_with_properties() and
g_initable_init() instead. See #GParameter for more information.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated
     #GObject, or %NULL on error</doc>
          <type name="GObject.Object" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="object_type" transfer-ownership="none">
            <doc xml:space="preserve">a #GType supporting #GInitable.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="n_parameters" transfer-ownership="none">
            <doc xml:space="preserve">the number of parameters in @parameters</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:space="preserve">the parameters to use to construct the object</doc>
            <array length="1" zero-terminated="0" c:type="GParameter*">
              <type name="GObject.Parameter" c:type="GParameter"/>
            </array>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="init" invoker="init" version="2.22" throws="1">
        <doc xml:space="preserve">Initializes the object implementing the interface.

This method is intended for language bindings. If writing in C,
g_initable_new() should typically be used instead.

The object must be initialized before any real use after initial
construction, either with this function or g_async_initable_init_async().

Implementations may also support cancellation. If @cancellable is not %NULL,
then initialization can be cancelled by triggering the cancellable object
from another thread. If the operation was cancelled, the error
%G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL and
the object doesn't support cancellable initialization the error
%G_IO_ERROR_NOT_SUPPORTED will be returned.

If the object is not initialized, or initialization returns with an
error, then all operations on the object except g_object_ref() and
g_object_unref() are considered to be invalid, and have undefined
behaviour. See the [introduction][ginitable] for more details.

Callers should not assume that a class which implements #GInitable can be
initialized multiple times, unless the class explicitly documents itself as
supporting this. Generally, a class&#x2019; implementation of init() can assume
(and assert) that it will only be called once. Previously, this documentation
recommended all #GInitable implementations should be idempotent; that
recommendation was relaxed in GLib 2.54.

If a class explicitly supports being initialized multiple times, it is
recommended that the method is idempotent: multiple calls with the same
arguments should return the same results. Only the first call initializes
the object; further calls return the result of the first call.

One reason why a class might need to support idempotent initialization is if
it is designed to be used via the singleton pattern, with a
#GObjectClass.constructor that sometimes returns an existing instance.
In this pattern, a caller would expect to be able to call g_initable_init()
on the result of g_object_new(), regardless of whether it is in fact a new
instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if successful. If an error has occurred, this function will
    return %FALSE and set @error appropriately if present.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="initable" transfer-ownership="none">
            <doc xml:space="preserve">a #GInitable.</doc>
            <type name="Initable" c:type="GInitable*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="init" c:identifier="g_initable_init" version="2.22" throws="1">
        <doc xml:space="preserve">Initializes the object implementing the interface.

This method is intended for language bindings. If writing in C,
g_initable_new() should typically be used instead.

The object must be initialized before any real use after initial
construction, either with this function or g_async_initable_init_async().

Implementations may also support cancellation. If @cancellable is not %NULL,
then initialization can be cancelled by triggering the cancellable object
from another thread. If the operation was cancelled, the error
%G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL and
the object doesn't support cancellable initialization the error
%G_IO_ERROR_NOT_SUPPORTED will be returned.

If the object is not initialized, or initialization returns with an
error, then all operations on the object except g_object_ref() and
g_object_unref() are considered to be invalid, and have undefined
behaviour. See the [introduction][ginitable] for more details.

Callers should not assume that a class which implements #GInitable can be
initialized multiple times, unless the class explicitly documents itself as
supporting this. Generally, a class&#x2019; implementation of init() can assume
(and assert) that it will only be called once. Previously, this documentation
recommended all #GInitable implementations should be idempotent; that
recommendation was relaxed in GLib 2.54.

If a class explicitly supports being initialized multiple times, it is
recommended that the method is idempotent: multiple calls with the same
arguments should return the same results. Only the first call initializes
the object; further calls return the result of the first call.

One reason why a class might need to support idempotent initialization is if
it is designed to be used via the singleton pattern, with a
#GObjectClass.constructor that sometimes returns an existing instance.
In this pattern, a caller would expect to be able to call g_initable_init()
on the result of g_object_new(), regardless of whether it is in fact a new
instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if successful. If an error has occurred, this function will
    return %FALSE and set @error appropriately if present.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="initable" transfer-ownership="none">
            <doc xml:space="preserve">a #GInitable.</doc>
            <type name="Initable" c:type="GInitable*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="InitableIface" c:type="GInitableIface" glib:is-gtype-struct-for="Initable" version="2.22">
      <doc xml:space="preserve">Provides an interface for initializing object such that initialization
may fail.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="init">
        <callback name="init" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if successful. If an error has occurred, this function will
    return %FALSE and set @error appropriately if present.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="initable" transfer-ownership="none">
              <doc xml:space="preserve">a #GInitable.</doc>
              <type name="Initable" c:type="GInitable*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="InputMessage" c:type="GInputMessage" version="2.48">
      <doc xml:space="preserve">Structure used for scatter/gather data input when receiving multiple
messages or packets in one go. You generally pass in an array of empty
#GInputVectors and the operation will use all the buffers as if they
were one buffer, and will set @bytes_received to the total number of bytes
received across all #GInputVectors.

This structure closely mirrors `struct mmsghdr` and `struct msghdr` from
the POSIX sockets API (see `man 2 recvmmsg`).

If @address is non-%NULL then it is set to the source address the message
was received from, and the caller must free it afterwards.

If @control_messages is non-%NULL then it is set to an array of control
messages received with the message (if any), and the caller must free it
afterwards. @num_control_messages is set to the number of elements in
this array, which may be zero.

Flags relevant to this message will be returned in @flags. For example,
`MSG_EOR` or `MSG_TRUNC`.</doc>
      <field name="address" writable="1">
        <doc xml:space="preserve">return location
  for a #GSocketAddress, or %NULL</doc>
        <type name="SocketAddress" c:type="GSocketAddress**"/>
      </field>
      <field name="vectors" writable="1">
        <doc xml:space="preserve">pointer to an
  array of input vectors</doc>
        <array length="2" zero-terminated="0" c:type="GInputVector*">
          <type name="InputVector" c:type="GInputVector"/>
        </array>
      </field>
      <field name="num_vectors" writable="1">
        <doc xml:space="preserve">the number of input vectors pointed to by @vectors</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="bytes_received" writable="1">
        <doc xml:space="preserve">will be set to the number of bytes that have been
  received</doc>
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="flags" writable="1">
        <doc xml:space="preserve">collection of #GSocketMsgFlags for the received message,
  outputted by the call</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="control_messages" writable="1">
        <doc xml:space="preserve">return location for a
  caller-allocated array of #GSocketControlMessages, or %NULL</doc>
        <array length="6" zero-terminated="0" c:type="GSocketControlMessage***">
          <type name="SocketControlMessage" c:type="GSocketControlMessage**"/>
        </array>
      </field>
      <field name="num_control_messages" writable="1">
        <doc xml:space="preserve">return location for the number of
  elements in @control_messages</doc>
        <type name="guint" c:type="guint*"/>
      </field>
    </record>
    <class name="InputStream" c:symbol-prefix="input_stream" c:type="GInputStream" parent="GObject.Object" abstract="1" glib:type-name="GInputStream" glib:get-type="g_input_stream_get_type" glib:type-struct="InputStreamClass">
      <doc xml:space="preserve">#GInputStream has functions to read from a stream (g_input_stream_read()),
to close a stream (g_input_stream_close()) and to skip some content
(g_input_stream_skip()).

To copy the content of an input stream to an output stream without
manually handling the reads and writes, use g_output_stream_splice().

See the documentation for #GIOStream for details of thread safety of
streaming APIs.

All of these functions have async variants too.</doc>
      <virtual-method name="close_async" invoker="close_async">
        <doc xml:space="preserve">Requests an asynchronous closes of the stream, releasing resources related to it.
When the operation is finished @callback will be called.
You can then call g_input_stream_close_finish() to get the result of the
operation.

For behaviour details see g_input_stream_close().

The asynchronous methods have a default fallback that uses threads to implement
asynchronicity, so they are optional for inheriting classes. However, if you
override one you must override all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">A #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="close_finish" invoker="close_finish" throws="1">
        <doc xml:space="preserve">Finishes closing a stream asynchronously, started from g_input_stream_close_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the stream was closed successfully.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="close_fn" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read_async" invoker="read_async">
        <doc xml:space="preserve">Request an asynchronous read of @count bytes from the stream into the buffer
starting at @buffer. When the operation is finished @callback will be called.
You can then call g_input_stream_read_finish() to get the result of the
operation.

During an async request no other sync and async calls are allowed on @stream, and will
result in %G_IO_ERROR_PENDING errors.

A value of @count larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.

On success, the number of bytes read into the buffer will be passed to the
callback. It is not an error if this is not the same as the requested size, as it
can happen e.g. near the end of a file, but generally we try to read
as many bytes as requested. Zero is returned on end of file
(or if @count is zero),  but never otherwise.

Any outstanding i/o request with higher priority (lower numerical value) will
be executed before an outstanding request with lower priority. Default
priority is %G_PRIORITY_DEFAULT.

The asynchronous methods have a default fallback that uses threads to implement
asynchronicity, so they are optional for inheriting classes. However, if you
override one you must override all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">A #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a buffer to
    read data into (which should be at least count bytes long).</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes that will be read from the stream</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority]
of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read_finish" invoker="read_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous stream read operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">number of bytes read in, or -1 on error, or 0 on end of file.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read_fn" throws="1">
        <return-value transfer-ownership="none">
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="skip" invoker="skip" throws="1">
        <doc xml:space="preserve">Tries to skip @count bytes from the stream. Will block during the operation.

This is identical to g_input_stream_read(), from a behaviour standpoint,
but the bytes that are skipped are not returned to the user. Some
streams have an implementation that is more efficient than reading the data.

This function is optional for inherited classes, as the default implementation
emulates it using read.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Number of bytes skipped, or -1 on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes that will be skipped from the stream</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="skip_async" invoker="skip_async">
        <doc xml:space="preserve">Request an asynchronous skip of @count bytes from the stream.
When the operation is finished @callback will be called.
You can then call g_input_stream_skip_finish() to get the result
of the operation.

During an async request no other sync and async calls are allowed,
and will result in %G_IO_ERROR_PENDING errors.

A value of @count larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.

On success, the number of bytes skipped will be passed to the callback.
It is not an error if this is not the same as the requested size, as it
can happen e.g. near the end of a file, but generally we try to skip
as many bytes as requested. Zero is returned on end of file
(or if @count is zero), but never otherwise.

Any outstanding i/o request with higher priority (lower numerical value)
will be executed before an outstanding request with lower priority.
Default priority is %G_PRIORITY_DEFAULT.

The asynchronous methods have a default fallback that uses threads to
implement asynchronicity, so they are optional for inheriting classes.
However, if you override one, you must override all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">A #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes that will be skipped from the stream</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="skip_finish" invoker="skip_finish" throws="1">
        <doc xml:space="preserve">Finishes a stream skip operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the size of the bytes skipped, or %-1 on error.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="clear_pending" c:identifier="g_input_stream_clear_pending">
        <doc xml:space="preserve">Clears the pending flag on @stream.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">input stream</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="close" c:identifier="g_input_stream_close" throws="1">
        <doc xml:space="preserve">Closes the stream, releasing resources related to it.

Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
Closing a stream multiple times will not return an error.

Streams will be automatically closed when the last reference
is dropped, but you might want to call this function to make sure
resources are released as early as possible.

Some streams might keep the backing store of the stream (e.g. a file descriptor)
open after the stream is closed. See the documentation for the individual
stream for details.

On failure the first error that happened will be reported, but the close
operation will finish as much as possible. A stream that failed to
close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
is important to check and report the error to the user.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
Cancelling a close will still leave the stream closed, but some streams
can use a faster close that doesn't block to e.g. check errors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">A #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_async" c:identifier="g_input_stream_close_async">
        <doc xml:space="preserve">Requests an asynchronous closes of the stream, releasing resources related to it.
When the operation is finished @callback will be called.
You can then call g_input_stream_close_finish() to get the result of the
operation.

For behaviour details see g_input_stream_close().

The asynchronous methods have a default fallback that uses threads to implement
asynchronicity, so they are optional for inheriting classes. However, if you
override one you must override all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">A #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_finish" c:identifier="g_input_stream_close_finish" throws="1">
        <doc xml:space="preserve">Finishes closing a stream asynchronously, started from g_input_stream_close_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the stream was closed successfully.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_pending" c:identifier="g_input_stream_has_pending">
        <doc xml:space="preserve">Checks if an input stream has pending actions.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @stream has pending actions.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">input stream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_closed" c:identifier="g_input_stream_is_closed">
        <doc xml:space="preserve">Checks if an input stream is closed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the stream is closed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">input stream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="read" c:identifier="g_input_stream_read" throws="1">
        <doc xml:space="preserve">Tries to read @count bytes from the stream into the buffer starting at
@buffer. Will block during this read.

If count is zero returns zero and does nothing. A value of @count
larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.

On success, the number of bytes read into the buffer is returned.
It is not an error if this is not the same as the requested size, as it
can happen e.g. near the end of a file. Zero is returned on end of file
(or if @count is zero),  but never otherwise.

The returned @buffer is not a nul-terminated string, it can contain nul bytes
at any position, and this function doesn't nul-terminate the @buffer.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.

On error -1 is returned and @error is set accordingly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Number of bytes read, or -1 on error, or 0 on end of file.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a buffer to
    read data into (which should be at least count bytes long).</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes that will be read from the stream</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_all" c:identifier="g_input_stream_read_all" throws="1">
        <doc xml:space="preserve">Tries to read @count bytes from the stream into the buffer starting at
@buffer. Will block during this read.

This function is similar to g_input_stream_read(), except it tries to
read as many bytes as requested, only stopping on an error or end of stream.

On a successful read of @count bytes, or if we reached the end of the
stream,  %TRUE is returned, and @bytes_read is set to the number of bytes
read into @buffer.

If there is an error during the operation %FALSE is returned and @error
is set to indicate the error status.

As a special exception to the normal conventions for functions that
use #GError, if this function returns %FALSE (and sets @error) then
@bytes_read will be set to the number of bytes that were successfully
read before the error was encountered.  This functionality is only
available from C.  If you need it from another language then you must
write your own loop around g_input_stream_read().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if there was an error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a buffer to
    read data into (which should be at least count bytes long).</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes that will be read from the stream</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="bytes_read" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">location to store the number of bytes that was read from the stream</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_all_async" c:identifier="g_input_stream_read_all_async" version="2.44">
        <doc xml:space="preserve">Request an asynchronous read of @count bytes from the stream into the
buffer starting at @buffer.

This is the asynchronous equivalent of g_input_stream_read_all().

Call g_input_stream_read_all_finish() to collect the result.

Any outstanding I/O request with higher priority (lower numerical
value) will be executed before an outstanding request with lower
priority. Default priority is %G_PRIORITY_DEFAULT.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">A #GInputStream</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a buffer to
    read data into (which should be at least count bytes long)</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes that will be read from the stream</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_all_finish" c:identifier="g_input_stream_read_all_finish" version="2.44" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous stream read operation started with
g_input_stream_read_all_async().

As a special exception to the normal conventions for functions that
use #GError, if this function returns %FALSE (and sets @error) then
@bytes_read will be set to the number of bytes that were successfully
read before the error was encountered.  This functionality is only
available from C.  If you need it from another language then you must
write your own loop around g_input_stream_read_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if there was an error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="bytes_read" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">location to store the number of bytes that was read from the stream</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_async" c:identifier="g_input_stream_read_async">
        <doc xml:space="preserve">Request an asynchronous read of @count bytes from the stream into the buffer
starting at @buffer. When the operation is finished @callback will be called.
You can then call g_input_stream_read_finish() to get the result of the
operation.

During an async request no other sync and async calls are allowed on @stream, and will
result in %G_IO_ERROR_PENDING errors.

A value of @count larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.

On success, the number of bytes read into the buffer will be passed to the
callback. It is not an error if this is not the same as the requested size, as it
can happen e.g. near the end of a file, but generally we try to read
as many bytes as requested. Zero is returned on end of file
(or if @count is zero),  but never otherwise.

Any outstanding i/o request with higher priority (lower numerical value) will
be executed before an outstanding request with lower priority. Default
priority is %G_PRIORITY_DEFAULT.

The asynchronous methods have a default fallback that uses threads to implement
asynchronicity, so they are optional for inheriting classes. However, if you
override one you must override all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">A #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a buffer to
    read data into (which should be at least count bytes long).</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes that will be read from the stream</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority]
of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_bytes" c:identifier="g_input_stream_read_bytes" version="2.34" throws="1">
        <doc xml:space="preserve">Like g_input_stream_read(), this tries to read @count bytes from
the stream in a blocking fashion. However, rather than reading into
a user-supplied buffer, this will create a new #GBytes containing
the data that was read. This may be easier to use from language
bindings.

If count is zero, returns a zero-length #GBytes and does nothing. A
value of @count larger than %G_MAXSSIZE will cause a
%G_IO_ERROR_INVALID_ARGUMENT error.

On success, a new #GBytes is returned. It is not an error if the
size of this object is not the same as the requested size, as it
can happen e.g. near the end of a file. A zero-length #GBytes is
returned on end of file (or if @count is zero), but never
otherwise.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.

On error %NULL is returned and @error is set accordingly.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GBytes, or %NULL on error</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">maximum number of bytes that will be read from the stream. Common
values include 4096 and 8192.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_bytes_async" c:identifier="g_input_stream_read_bytes_async" version="2.34">
        <doc xml:space="preserve">Request an asynchronous read of @count bytes from the stream into a
new #GBytes. When the operation is finished @callback will be
called. You can then call g_input_stream_read_bytes_finish() to get the
result of the operation.

During an async request no other sync and async calls are allowed
on @stream, and will result in %G_IO_ERROR_PENDING errors.

A value of @count larger than %G_MAXSSIZE will cause a
%G_IO_ERROR_INVALID_ARGUMENT error.

On success, the new #GBytes will be passed to the callback. It is
not an error if this is smaller than the requested size, as it can
happen e.g. near the end of a file, but generally we try to read as
many bytes as requested. Zero is returned on end of file (or if
@count is zero), but never otherwise.

Any outstanding I/O request with higher priority (lower numerical
value) will be executed before an outstanding request with lower
priority. Default priority is %G_PRIORITY_DEFAULT.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">A #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes that will be read from the stream</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_bytes_finish" c:identifier="g_input_stream_read_bytes_finish" version="2.34" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous stream read-into-#GBytes operation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly-allocated #GBytes, or %NULL on error</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_finish" c:identifier="g_input_stream_read_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous stream read operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">number of bytes read in, or -1 on error, or 0 on end of file.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pending" c:identifier="g_input_stream_set_pending" throws="1">
        <doc xml:space="preserve">Sets @stream to have actions pending. If the pending flag is
already set or @stream is closed, it will return %FALSE and set
@error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if pending was previously unset and is now set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">input stream</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="skip" c:identifier="g_input_stream_skip" throws="1">
        <doc xml:space="preserve">Tries to skip @count bytes from the stream. Will block during the operation.

This is identical to g_input_stream_read(), from a behaviour standpoint,
but the bytes that are skipped are not returned to the user. Some
streams have an implementation that is more efficient than reading the data.

This function is optional for inherited classes, as the default implementation
emulates it using read.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Number of bytes skipped, or -1 on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes that will be skipped from the stream</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="skip_async" c:identifier="g_input_stream_skip_async">
        <doc xml:space="preserve">Request an asynchronous skip of @count bytes from the stream.
When the operation is finished @callback will be called.
You can then call g_input_stream_skip_finish() to get the result
of the operation.

During an async request no other sync and async calls are allowed,
and will result in %G_IO_ERROR_PENDING errors.

A value of @count larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.

On success, the number of bytes skipped will be passed to the callback.
It is not an error if this is not the same as the requested size, as it
can happen e.g. near the end of a file, but generally we try to skip
as many bytes as requested. Zero is returned on end of file
(or if @count is zero), but never otherwise.

Any outstanding i/o request with higher priority (lower numerical value)
will be executed before an outstanding request with lower priority.
Default priority is %G_PRIORITY_DEFAULT.

The asynchronous methods have a default fallback that uses threads to
implement asynchronicity, so they are optional for inheriting classes.
However, if you override one, you must override all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">A #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes that will be skipped from the stream</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="skip_finish" c:identifier="g_input_stream_skip_finish" throws="1">
        <doc xml:space="preserve">Finishes a stream skip operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the size of the bytes skipped, or %-1 on error.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="InputStreamPrivate" c:type="GInputStreamPrivate*"/>
      </field>
    </class>
    <record name="InputStreamClass" c:type="GInputStreamClass" glib:is-gtype-struct-for="InputStream">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="read_fn">
        <callback name="read_fn" throws="1">
          <return-value transfer-ownership="none">
            <type name="gssize" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="InputStream" c:type="GInputStream*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none" nullable="1" allow-none="1">
              <type name="gpointer" c:type="void*"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="skip">
        <callback name="skip" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Number of bytes skipped, or -1 on error</doc>
            <type name="gssize" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <doc xml:space="preserve">the number of bytes that will be skipped from the stream</doc>
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_fn">
        <callback name="close_fn" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="InputStream" c:type="GInputStream*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="read_async">
        <callback name="read_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">A #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a buffer to
    read data into (which should be at least count bytes long).</doc>
              <array length="2" zero-terminated="0" c:type="void*">
                <type name="guint8"/>
              </array>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <doc xml:space="preserve">the number of bytes that will be read from the stream</doc>
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority]
of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
              <doc xml:space="preserve">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="read_finish">
        <callback name="read_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">number of bytes read in, or -1 on error, or 0 on end of file.</doc>
            <type name="gssize" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="skip_async">
        <callback name="skip_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">A #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <doc xml:space="preserve">the number of bytes that will be skipped from the stream</doc>
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="skip_finish">
        <callback name="skip_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the size of the bytes skipped, or %-1 on error.</doc>
            <type name="gssize" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_async">
        <callback name="close_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">A #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional cancellable object</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_finish">
        <callback name="close_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the stream was closed successfully.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="InputStreamPrivate" c:type="GInputStreamPrivate" disguised="1">
    </record>
    <record name="InputVector" c:type="GInputVector" version="2.22">
      <doc xml:space="preserve">Structure used for scatter/gather data input.
You generally pass in an array of #GInputVectors
and the operation will store the read data starting in the
first buffer, switching to the next as needed.</doc>
      <field name="buffer" writable="1">
        <doc xml:space="preserve">Pointer to a buffer where data will be written.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="size" writable="1">
        <doc xml:space="preserve">the available size in @buffer.</doc>
        <type name="gsize" c:type="gsize"/>
      </field>
    </record>
    <interface name="ListModel" c:symbol-prefix="list_model" c:type="GListModel" glib:type-name="GListModel" glib:get-type="g_list_model_get_type" glib:type-struct="ListModelInterface">
      <doc xml:space="preserve">#GListModel is an interface that represents a mutable list of
#GObjects. Its main intention is as a model for various widgets in
user interfaces, such as list views, but it can also be used as a
convenient method of returning lists of data, with support for
updates.

Each object in the list may also report changes in itself via some
mechanism (normally the #GObject::notify signal).  Taken together
with the #GListModel::items-changed signal, this provides for a list
that can change its membership, and in which the members can change
their individual properties.

A good example would be the list of visible wireless network access
points, where each access point can report dynamic properties such as
signal strength.

It is important to note that the #GListModel itself does not report
changes to the individual items.  It only reports changes to the list
membership.  If you want to observe changes to the objects themselves
then you need to connect signals to the objects that you are
interested in.

All items in a #GListModel are of (or derived from) the same type.
g_list_model_get_item_type() returns that type.  The type may be an
interface, in which case all objects in the list must implement it.

The semantics are close to that of an array:
g_list_model_get_n_items() returns the number of items in the list and
g_list_model_get_item() returns an item at a (0-based) position. In
order to allow implementations to calculate the list length lazily,
you can also iterate over items: starting from 0, repeatedly call
g_list_model_get_item() until it returns %NULL.

An implementation may create objects lazily, but must take care to
return the same object for a given position until all references to
it are gone.

On the other side, a consumer is expected only to hold references on
objects that are currently "user visible", in order to faciliate the
maximum level of laziness in the implementation of the list and to
reduce the required number of signal connections at a given time.

This interface is intended only to be used from a single thread.  The
thread in which it is appropriate to use it depends on the particular
implementation, but typically it will be from the thread that owns
the [thread-default main context][g-main-context-push-thread-default]
in effect at the time that the model was created.</doc>
      <virtual-method name="get_item" version="2.44">
        <doc xml:space="preserve">Get the item at @position. If @position is greater than the number of
items in @list, %NULL is returned.

%NULL is never returned for an index that is smaller than the length
of the list.  See g_list_model_get_n_items().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the object at @position.</doc>
          <type name="GObject.Object" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GListModel</doc>
            <type name="ListModel" c:type="GListModel*"/>
          </instance-parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">the position of the item to fetch</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_item_type" invoker="get_item_type" version="2.44">
        <doc xml:space="preserve">Gets the type of the items in @list. All items returned from
g_list_model_get_type() are of that type or a subtype, or are an
implementation of that interface.

The item type of a #GListModel can not change during the life of the
model.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GType of the items contained in @list.</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GListModel</doc>
            <type name="ListModel" c:type="GListModel*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_n_items" invoker="get_n_items" version="2.44">
        <doc xml:space="preserve">Gets the number of items in @list.

Depending on the model implementation, calling this function may be
less efficient than iterating the list with increasing values for
@position until g_list_model_get_item() returns %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of items in @list.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GListModel</doc>
            <type name="ListModel" c:type="GListModel*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="get_item" c:identifier="g_list_model_get_item" shadowed-by="get_object" version="2.44" introspectable="0">
        <doc xml:space="preserve">Get the item at @position. If @position is greater than the number of
items in @list, %NULL is returned.

%NULL is never returned for an index that is smaller than the length
of the list.  See g_list_model_get_n_items().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the item at @position.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GListModel</doc>
            <type name="ListModel" c:type="GListModel*"/>
          </instance-parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">the position of the item to fetch</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_item_type" c:identifier="g_list_model_get_item_type" version="2.44">
        <doc xml:space="preserve">Gets the type of the items in @list. All items returned from
g_list_model_get_type() are of that type or a subtype, or are an
implementation of that interface.

The item type of a #GListModel can not change during the life of the
model.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GType of the items contained in @list.</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GListModel</doc>
            <type name="ListModel" c:type="GListModel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_items" c:identifier="g_list_model_get_n_items" version="2.44">
        <doc xml:space="preserve">Gets the number of items in @list.

Depending on the model implementation, calling this function may be
less efficient than iterating the list with increasing values for
@position until g_list_model_get_item() returns %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of items in @list.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GListModel</doc>
            <type name="ListModel" c:type="GListModel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_object" c:identifier="g_list_model_get_object" shadows="get_item" version="2.44">
        <doc xml:space="preserve">Get the item at @position. If @position is greater than the number of
items in @list, %NULL is returned.

%NULL is never returned for an index that is smaller than the length
of the list.  See g_list_model_get_n_items().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the object at @position.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GListModel</doc>
            <type name="ListModel" c:type="GListModel*"/>
          </instance-parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">the position of the item to fetch</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="items_changed" c:identifier="g_list_model_items_changed" version="2.44">
        <doc xml:space="preserve">Emits the #GListModel::items-changed signal on @list.

This function should only be called by classes implementing
#GListModel. It has to be called after the internal representation
of @list has been updated, because handlers connected to this signal
might query the new state of the list.

Implementations must only make changes to the model (as visible to
its consumer) in places that will not cause problems for that
consumer.  For models that are driven directly by a write API (such
as #GListStore), changes can be reported in response to uses of that
API.  For models that represent remote data, changes should only be
made from a fresh mainloop dispatch.  It is particularly not
permitted to make changes in response to a call to the #GListModel
consumer API.

Stated another way: in general, it is assumed that code making a
series of accesses to the model via the API, without returning to the
mainloop, and without calling other code, will continue to view the
same contents of the model.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GListModel</doc>
            <type name="ListModel" c:type="GListModel*"/>
          </instance-parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">the position at which @list changed</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:space="preserve">the number of items removed</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="added" transfer-ownership="none">
            <doc xml:space="preserve">the number of items added</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <glib:signal name="items-changed" when="last" version="2.44">
        <doc xml:space="preserve">This signal is emitted whenever items were added or removed to
@list. At @position, @removed items were removed and @added items
were added in their place.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">the position at which @list changed</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:space="preserve">the number of items removed</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="added" transfer-ownership="none">
            <doc xml:space="preserve">the number of items added</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
    </interface>
    <record name="ListModelInterface" c:type="GListModelInterface" glib:is-gtype-struct-for="ListModel" version="2.44">
      <doc xml:space="preserve">The virtual function table for #GListModel.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">parent #GTypeInterface</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_item_type">
        <callback name="get_item_type">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the #GType of the items contained in @list.</doc>
            <type name="GType" c:type="GType"/>
          </return-value>
          <parameters>
            <parameter name="list" transfer-ownership="none">
              <doc xml:space="preserve">a #GListModel</doc>
              <type name="ListModel" c:type="GListModel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_n_items">
        <callback name="get_n_items">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the number of items in @list.</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="list" transfer-ownership="none">
              <doc xml:space="preserve">a #GListModel</doc>
              <type name="ListModel" c:type="GListModel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_item">
        <callback name="get_item">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">the object at @position.</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </return-value>
          <parameters>
            <parameter name="list" transfer-ownership="none">
              <doc xml:space="preserve">a #GListModel</doc>
              <type name="ListModel" c:type="GListModel*"/>
            </parameter>
            <parameter name="position" transfer-ownership="none">
              <doc xml:space="preserve">the position of the item to fetch</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="ListStore" c:symbol-prefix="list_store" c:type="GListStore" parent="GObject.Object" glib:type-name="GListStore" glib:get-type="g_list_store_get_type" glib:type-struct="ListStoreClass">
      <doc xml:space="preserve">#GListStore is a simple implementation of #GListModel that stores all
items in memory.

It provides insertions, deletions, and lookups in logarithmic time
with a fast path for the common case of iterating the list linearly.</doc>
      <implements name="ListModel"/>
      <constructor name="new" c:identifier="g_list_store_new" version="2.44">
        <doc xml:space="preserve">Creates a new #GListStore with items of type @item_type. @item_type
must be a subclass of #GObject.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GListStore</doc>
          <type name="ListStore" c:type="GListStore*"/>
        </return-value>
        <parameters>
          <parameter name="item_type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of items in the list</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="append" c:identifier="g_list_store_append" version="2.44">
        <doc xml:space="preserve">Appends @item to @store. @item must be of type #GListStore:item-type.

This function takes a ref on @item.

Use g_list_store_splice() to append multiple items at the same time
efficiently.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #GListStore</doc>
            <type name="ListStore" c:type="GListStore*"/>
          </instance-parameter>
          <parameter name="item" transfer-ownership="none">
            <doc xml:space="preserve">the new item</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert" c:identifier="g_list_store_insert" version="2.44">
        <doc xml:space="preserve">Inserts @item into @store at @position. @item must be of type
#GListStore:item-type or derived from it. @position must be smaller
than the length of the list, or equal to it to append.

This function takes a ref on @item.

Use g_list_store_splice() to insert multiple items at the same time
efficiently.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #GListStore</doc>
            <type name="ListStore" c:type="GListStore*"/>
          </instance-parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">the position at which to insert the new item</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="item" transfer-ownership="none">
            <doc xml:space="preserve">the new item</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_sorted" c:identifier="g_list_store_insert_sorted" version="2.44">
        <doc xml:space="preserve">Inserts @item into @store at a position to be determined by the
@compare_func.

The list must already be sorted before calling this function or the
result is undefined.  Usually you would approach this by only ever
inserting items by way of this function.

This function takes a ref on @item.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the position at which @item was inserted</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #GListStore</doc>
            <type name="ListStore" c:type="GListStore*"/>
          </instance-parameter>
          <parameter name="item" transfer-ownership="none">
            <doc xml:space="preserve">the new item</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">pairwise comparison function for sorting</doc>
            <type name="GLib.CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data for @compare_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="g_list_store_remove" version="2.44">
        <doc xml:space="preserve">Removes the item from @store that is at @position. @position must be
smaller than the current length of the list.

Use g_list_store_splice() to remove multiple items at the same time
efficiently.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #GListStore</doc>
            <type name="ListStore" c:type="GListStore*"/>
          </instance-parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">the position of the item that is to be removed</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_all" c:identifier="g_list_store_remove_all" version="2.44">
        <doc xml:space="preserve">Removes all items from @store.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #GListStore</doc>
            <type name="ListStore" c:type="GListStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="sort" c:identifier="g_list_store_sort" version="2.46">
        <doc xml:space="preserve">Sort the items in @store according to @compare_func.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #GListStore</doc>
            <type name="ListStore" c:type="GListStore*"/>
          </instance-parameter>
          <parameter name="compare_func" transfer-ownership="none" scope="call" closure="1">
            <doc xml:space="preserve">pairwise comparison function for sorting</doc>
            <type name="GLib.CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data for @compare_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="splice" c:identifier="g_list_store_splice" version="2.44">
        <doc xml:space="preserve">Changes @store by removing @n_removals items and adding @n_additions
items to it. @additions must contain @n_additions items of type
#GListStore:item-type.  %NULL is not permitted.

This function is more efficient than g_list_store_insert() and
g_list_store_remove(), because it only emits
#GListModel::items-changed once for the change.

This function takes a ref on each item in @additions.

The parameters @position and @n_removals must be correct (ie:
@position + @n_removals must be less than or equal to the length of
the list at the time this function is called).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #GListStore</doc>
            <type name="ListStore" c:type="GListStore*"/>
          </instance-parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">the position at which to make the change</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="n_removals" transfer-ownership="none">
            <doc xml:space="preserve">the number of items to remove</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="additions" transfer-ownership="none">
            <doc xml:space="preserve">the items to add</doc>
            <array length="3" zero-terminated="0" c:type="gpointer*">
              <type name="GObject.Object"/>
            </array>
          </parameter>
          <parameter name="n_additions" transfer-ownership="none">
            <doc xml:space="preserve">the number of items to add</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <property name="item-type" version="2.44" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The type of items contained in this list store. Items must be
subclasses of #GObject.</doc>
        <type name="GType" c:type="GType"/>
      </property>
    </class>
    <record name="ListStoreClass" c:type="GListStoreClass" glib:is-gtype-struct-for="ListStore">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <interface name="LoadableIcon" c:symbol-prefix="loadable_icon" c:type="GLoadableIcon" glib:type-name="GLoadableIcon" glib:get-type="g_loadable_icon_get_type" glib:type-struct="LoadableIconIface">
      <doc xml:space="preserve">Extends the #GIcon interface and adds the ability to
load icons from streams.</doc>
      <prerequisite name="Icon"/>
      <virtual-method name="load" invoker="load" throws="1">
        <doc xml:space="preserve">Loads a loadable icon. For the asynchronous version of this function,
see g_loadable_icon_load_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GInputStream to read the icon from.</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">a #GLoadableIcon.</doc>
            <type name="LoadableIcon" c:type="GLoadableIcon*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">an integer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a location to store the type of the loaded
icon, %NULL to ignore.</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to
ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="load_async" invoker="load_async">
        <doc xml:space="preserve">Loads an icon asynchronously. To finish this function, see
g_loadable_icon_load_finish(). For the synchronous, blocking
version of this function, see g_loadable_icon_load().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">a #GLoadableIcon.</doc>
            <type name="LoadableIcon" c:type="GLoadableIcon*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">an integer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the
           request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="load_finish" invoker="load_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous icon load started in g_loadable_icon_load_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GInputStream to read the icon from.</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">a #GLoadableIcon.</doc>
            <type name="LoadableIcon" c:type="GLoadableIcon*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a location to store the type of the loaded
       icon, %NULL to ignore.</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="load" c:identifier="g_loadable_icon_load" throws="1">
        <doc xml:space="preserve">Loads a loadable icon. For the asynchronous version of this function,
see g_loadable_icon_load_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GInputStream to read the icon from.</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">a #GLoadableIcon.</doc>
            <type name="LoadableIcon" c:type="GLoadableIcon*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">an integer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a location to store the type of the loaded
icon, %NULL to ignore.</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to
ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_async" c:identifier="g_loadable_icon_load_async">
        <doc xml:space="preserve">Loads an icon asynchronously. To finish this function, see
g_loadable_icon_load_finish(). For the synchronous, blocking
version of this function, see g_loadable_icon_load().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">a #GLoadableIcon.</doc>
            <type name="LoadableIcon" c:type="GLoadableIcon*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">an integer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the
           request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_finish" c:identifier="g_loadable_icon_load_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous icon load started in g_loadable_icon_load_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GInputStream to read the icon from.</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">a #GLoadableIcon.</doc>
            <type name="LoadableIcon" c:type="GLoadableIcon*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a location to store the type of the loaded
       icon, %NULL to ignore.</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="LoadableIconIface" c:type="GLoadableIconIface" glib:is-gtype-struct-for="LoadableIcon">
      <doc xml:space="preserve">Interface for icons that can be loaded as a stream.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="load">
        <callback name="load" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GInputStream to read the icon from.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </return-value>
          <parameters>
            <parameter name="icon" transfer-ownership="none">
              <doc xml:space="preserve">a #GLoadableIcon.</doc>
              <type name="LoadableIcon" c:type="GLoadableIcon*"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <doc xml:space="preserve">an integer.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
              <doc xml:space="preserve">a location to store the type of the loaded
icon, %NULL to ignore.</doc>
              <type name="utf8" c:type="char**"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to
ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="load_async">
        <callback name="load_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="icon" transfer-ownership="none">
              <doc xml:space="preserve">a #GLoadableIcon.</doc>
              <type name="LoadableIcon" c:type="GLoadableIcon*"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <doc xml:space="preserve">an integer.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call when the
           request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="load_finish">
        <callback name="load_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GInputStream to read the icon from.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </return-value>
          <parameters>
            <parameter name="icon" transfer-ownership="none">
              <doc xml:space="preserve">a #GLoadableIcon.</doc>
              <type name="LoadableIcon" c:type="GLoadableIcon*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
            <parameter name="type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
              <doc xml:space="preserve">a location to store the type of the loaded
       icon, %NULL to ignore.</doc>
              <type name="utf8" c:type="char**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <constant name="MENU_ATTRIBUTE_ACTION" value="action" c:type="G_MENU_ATTRIBUTE_ACTION" version="2.32">
      <doc xml:space="preserve">The menu item attribute which holds the action name of the item.  Action
names are namespaced with an identifier for the action group in which the
action resides. For example, "win." for window-specific actions and "app."
for application-wide actions.

See also g_menu_model_get_item_attribute() and g_menu_item_set_attribute().</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MENU_ATTRIBUTE_ACTION_NAMESPACE" value="action-namespace" c:type="G_MENU_ATTRIBUTE_ACTION_NAMESPACE" version="2.36">
      <doc xml:space="preserve">The menu item attribute that holds the namespace for all action names in
menus that are linked from this item.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MENU_ATTRIBUTE_ICON" value="icon" c:type="G_MENU_ATTRIBUTE_ICON" version="2.38">
      <doc xml:space="preserve">The menu item attribute which holds the icon of the item.

The icon is stored in the format returned by g_icon_serialize().

This attribute is intended only to represent 'noun' icons such as
favicons for a webpage, or application icons.  It should not be used
for 'verbs' (ie: stock icons).</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MENU_ATTRIBUTE_LABEL" value="label" c:type="G_MENU_ATTRIBUTE_LABEL" version="2.32">
      <doc xml:space="preserve">The menu item attribute which holds the label of the item.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MENU_ATTRIBUTE_TARGET" value="target" c:type="G_MENU_ATTRIBUTE_TARGET" version="2.32">
      <doc xml:space="preserve">The menu item attribute which holds the target with which the item's action
will be activated.

See also g_menu_item_set_action_and_target()</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MENU_LINK_SECTION" value="section" c:type="G_MENU_LINK_SECTION" version="2.32">
      <doc xml:space="preserve">The name of the link that associates a menu item with a section.  The linked
menu will usually be shown in place of the menu item, using the item's label
as a header.

See also g_menu_item_set_link().</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MENU_LINK_SUBMENU" value="submenu" c:type="G_MENU_LINK_SUBMENU" version="2.32">
      <doc xml:space="preserve">The name of the link that associates a menu item with a submenu.

See also g_menu_item_set_link().</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="MemoryInputStream" c:symbol-prefix="memory_input_stream" c:type="GMemoryInputStream" parent="InputStream" glib:type-name="GMemoryInputStream" glib:get-type="g_memory_input_stream_get_type" glib:type-struct="MemoryInputStreamClass">
      <doc xml:space="preserve">#GMemoryInputStream is a class for using arbitrary
memory chunks as input for GIO streaming input operations.

As of GLib 2.34, #GMemoryInputStream implements
#GPollableInputStream.</doc>
      <implements name="PollableInputStream"/>
      <implements name="Seekable"/>
      <constructor name="new" c:identifier="g_memory_input_stream_new">
        <doc xml:space="preserve">Creates a new empty #GMemoryInputStream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GInputStream</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
      </constructor>
      <constructor name="new_from_bytes" c:identifier="g_memory_input_stream_new_from_bytes" version="2.34">
        <doc xml:space="preserve">Creates a new #GMemoryInputStream with data from the given @bytes.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">new #GInputStream read from @bytes</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve">a #GBytes</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_data" c:identifier="g_memory_input_stream_new_from_data">
        <doc xml:space="preserve">Creates a new #GMemoryInputStream with data in memory of a given size.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">new #GInputStream read from @data of @len bytes.</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="full">
            <doc xml:space="preserve">input data</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">length of the data, may be -1 if @data is a nul-terminated string</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">function that is called to free @data, or %NULL</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_bytes" c:identifier="g_memory_input_stream_add_bytes" version="2.34">
        <doc xml:space="preserve">Appends @bytes to data that can be read from the input stream.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GMemoryInputStream</doc>
            <type name="MemoryInputStream" c:type="GMemoryInputStream*"/>
          </instance-parameter>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve">input data</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_data" c:identifier="g_memory_input_stream_add_data">
        <doc xml:space="preserve">Appends @data to data that can be read from the input stream</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GMemoryInputStream</doc>
            <type name="MemoryInputStream" c:type="GMemoryInputStream*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="full">
            <doc xml:space="preserve">input data</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">length of the data, may be -1 if @data is a nul-terminated string</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">function that is called to free @data, or %NULL</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="InputStream" c:type="GInputStream"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="MemoryInputStreamPrivate" c:type="GMemoryInputStreamPrivate*"/>
      </field>
    </class>
    <record name="MemoryInputStreamClass" c:type="GMemoryInputStreamClass" glib:is-gtype-struct-for="MemoryInputStream">
      <field name="parent_class">
        <type name="InputStreamClass" c:type="GInputStreamClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="MemoryInputStreamPrivate" c:type="GMemoryInputStreamPrivate" disguised="1">
    </record>
    <class name="MemoryOutputStream" c:symbol-prefix="memory_output_stream" c:type="GMemoryOutputStream" parent="OutputStream" glib:type-name="GMemoryOutputStream" glib:get-type="g_memory_output_stream_get_type" glib:type-struct="MemoryOutputStreamClass">
      <doc xml:space="preserve">#GMemoryOutputStream is a class for using arbitrary
memory chunks as output for GIO streaming output operations.

As of GLib 2.34, #GMemoryOutputStream trivially implements
#GPollableOutputStream: it always polls as ready.</doc>
      <implements name="PollableOutputStream"/>
      <implements name="Seekable"/>
      <constructor name="new" c:identifier="g_memory_output_stream_new" introspectable="0">
        <doc xml:space="preserve">Creates a new #GMemoryOutputStream.

In most cases this is not the function you want.  See
g_memory_output_stream_new_resizable() instead.

If @data is non-%NULL, the stream will use that for its internal storage.

If @realloc_fn is non-%NULL, it will be used for resizing the internal
storage when necessary and the stream will be considered resizable.
In that case, the stream will start out being (conceptually) empty.
@size is used only as a hint for how big @data is.  Specifically,
seeking to the end of a newly-created stream will seek to zero, not
@size.  Seeking past the end of the stream and then writing will
introduce a zero-filled gap.

If @realloc_fn is %NULL then the stream is fixed-sized.  Seeking to
the end will seek to @size exactly.  Writing past the end will give
an 'out of space' error.  Attempting to seek past the end will fail.
Unlike the resizable case, seeking to an offset within the stream and
writing will preserve the bytes passed in as @data before that point
and will return them as part of g_memory_output_stream_steal_data().
If you intend to seek you should probably therefore ensure that @data
is properly initialised.

It is probably only meaningful to provide @data and @size in the case
that you want a fixed-sized stream.  Put another way: if @realloc_fn
is non-%NULL then it makes most sense to give @data as %NULL and
@size as 0 (allowing #GMemoryOutputStream to do the initial
allocation for itself).

|[&lt;!-- language="C" --&gt;
// a stream that can grow
stream = g_memory_output_stream_new (NULL, 0, realloc, free);

// another stream that can grow
stream2 = g_memory_output_stream_new (NULL, 0, g_realloc, g_free);

// a fixed-size stream
data = malloc (200);
stream3 = g_memory_output_stream_new (data, 200, NULL, free);
]|</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly created #GMemoryOutputStream object.</doc>
          <type name="OutputStream" c:type="GOutputStream*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">pointer to a chunk of memory to use, or %NULL</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">the size of @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="realloc_function" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" destroy="3">
            <doc xml:space="preserve">a function with realloc() semantics (like g_realloc())
    to be called when @data needs to be grown, or %NULL</doc>
            <type name="ReallocFunc" c:type="GReallocFunc"/>
          </parameter>
          <parameter name="destroy_function" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a function to be called on @data when the stream is
    finalized, or %NULL</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_resizable" c:identifier="g_memory_output_stream_new_resizable" version="2.36">
        <doc xml:space="preserve">Creates a new #GMemoryOutputStream, using g_realloc() and g_free()
for memory allocation.</doc>
        <return-value transfer-ownership="full">
          <type name="OutputStream" c:type="GOutputStream*"/>
        </return-value>
      </constructor>
      <method name="get_data" c:identifier="g_memory_output_stream_get_data">
        <doc xml:space="preserve">Gets any loaded data from the @ostream.

Note that the returned pointer may become invalid on the next
write or truncate operation on the stream.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">pointer to the stream's data, or %NULL if the data
   has been stolen</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="ostream" transfer-ownership="none">
            <doc xml:space="preserve">a #GMemoryOutputStream</doc>
            <type name="MemoryOutputStream" c:type="GMemoryOutputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_data_size" c:identifier="g_memory_output_stream_get_data_size" version="2.18">
        <doc xml:space="preserve">Returns the number of bytes from the start up to including the last
byte written in the stream that has not been truncated away.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes written to the stream</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="ostream" transfer-ownership="none">
            <doc xml:space="preserve">a #GMemoryOutputStream</doc>
            <type name="MemoryOutputStream" c:type="GMemoryOutputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_size" c:identifier="g_memory_output_stream_get_size">
        <doc xml:space="preserve">Gets the size of the currently allocated data area (available from
g_memory_output_stream_get_data()).

You probably don't want to use this function on resizable streams.
See g_memory_output_stream_get_data_size() instead.  For resizable
streams the size returned by this function is an implementation
detail and may be change at any time in response to operations on the
stream.

If the stream is fixed-sized (ie: no realloc was passed to
g_memory_output_stream_new()) then this is the maximum size of the
stream and further writes will return %G_IO_ERROR_NO_SPACE.

In any case, if you want the number of bytes currently written to the
stream, use g_memory_output_stream_get_data_size().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes allocated for the data buffer</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="ostream" transfer-ownership="none">
            <doc xml:space="preserve">a #GMemoryOutputStream</doc>
            <type name="MemoryOutputStream" c:type="GMemoryOutputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="steal_as_bytes" c:identifier="g_memory_output_stream_steal_as_bytes" version="2.34">
        <doc xml:space="preserve">Returns data from the @ostream as a #GBytes. @ostream must be
closed before calling this function.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the stream's data</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="ostream" transfer-ownership="none">
            <doc xml:space="preserve">a #GMemoryOutputStream</doc>
            <type name="MemoryOutputStream" c:type="GMemoryOutputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="steal_data" c:identifier="g_memory_output_stream_steal_data" version="2.26">
        <doc xml:space="preserve">Gets any loaded data from the @ostream. Ownership of the data
is transferred to the caller; when no longer needed it must be
freed using the free function set in @ostream's
#GMemoryOutputStream:destroy-function property.

@ostream must be closed before calling this function.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the stream's data, or %NULL if it has previously
   been stolen</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="ostream" transfer-ownership="none">
            <doc xml:space="preserve">a #GMemoryOutputStream</doc>
            <type name="MemoryOutputStream" c:type="GMemoryOutputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="data" version="2.24" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">Pointer to buffer where data will be written.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="data-size" version="2.24" transfer-ownership="none">
        <doc xml:space="preserve">Size of data written to the buffer.</doc>
        <type name="gulong" c:type="gulong"/>
      </property>
      <property name="destroy-function" version="2.24" introspectable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">Function called with the buffer as argument when the stream is destroyed.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="realloc-function" version="2.24" introspectable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">Function with realloc semantics called to enlarge the buffer.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="size" version="2.24" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">Current size of the data buffer.</doc>
        <type name="gulong" c:type="gulong"/>
      </property>
      <field name="parent_instance">
        <type name="OutputStream" c:type="GOutputStream"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="MemoryOutputStreamPrivate" c:type="GMemoryOutputStreamPrivate*"/>
      </field>
    </class>
    <record name="MemoryOutputStreamClass" c:type="GMemoryOutputStreamClass" glib:is-gtype-struct-for="MemoryOutputStream">
      <field name="parent_class">
        <type name="OutputStreamClass" c:type="GOutputStreamClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="MemoryOutputStreamPrivate" c:type="GMemoryOutputStreamPrivate" disguised="1">
    </record>
    <class name="Menu" c:symbol-prefix="menu" c:type="GMenu" version="2.32" parent="MenuModel" glib:type-name="GMenu" glib:get-type="g_menu_get_type">
      <doc xml:space="preserve">#GMenu is a simple implementation of #GMenuModel.
You populate a #GMenu by adding #GMenuItem instances to it.

There are some convenience functions to allow you to directly
add items (avoiding #GMenuItem) for the common cases. To add
a regular item, use g_menu_insert(). To add a section, use
g_menu_insert_section(). To add a submenu, use
g_menu_insert_submenu().</doc>
      <constructor name="new" c:identifier="g_menu_new" version="2.32">
        <doc xml:space="preserve">Creates a new #GMenu.

The new menu has no items.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GMenu</doc>
          <type name="Menu" c:type="GMenu*"/>
        </return-value>
      </constructor>
      <method name="append" c:identifier="g_menu_append" version="2.32">
        <doc xml:space="preserve">Convenience function for appending a normal menu item to the end of
@menu.  Combine g_menu_item_new() and g_menu_insert_item() for a more
flexible alternative.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenu</doc>
            <type name="Menu" c:type="GMenu*"/>
          </instance-parameter>
          <parameter name="label" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the section label, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="detailed_action" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the detailed action string, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_item" c:identifier="g_menu_append_item" version="2.32">
        <doc xml:space="preserve">Appends @item to the end of @menu.

See g_menu_insert_item() for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenu</doc>
            <type name="Menu" c:type="GMenu*"/>
          </instance-parameter>
          <parameter name="item" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuItem to append</doc>
            <type name="MenuItem" c:type="GMenuItem*"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_section" c:identifier="g_menu_append_section" version="2.32">
        <doc xml:space="preserve">Convenience function for appending a section menu item to the end of
@menu.  Combine g_menu_item_new_section() and g_menu_insert_item() for a
more flexible alternative.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenu</doc>
            <type name="Menu" c:type="GMenu*"/>
          </instance-parameter>
          <parameter name="label" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the section label, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="section" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuModel with the items of the section</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_submenu" c:identifier="g_menu_append_submenu" version="2.32">
        <doc xml:space="preserve">Convenience function for appending a submenu menu item to the end of
@menu.  Combine g_menu_item_new_submenu() and g_menu_insert_item() for a
more flexible alternative.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenu</doc>
            <type name="Menu" c:type="GMenu*"/>
          </instance-parameter>
          <parameter name="label" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the section label, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="submenu" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuModel with the items of the submenu</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </parameter>
        </parameters>
      </method>
      <method name="freeze" c:identifier="g_menu_freeze" version="2.32">
        <doc xml:space="preserve">Marks @menu as frozen.

After the menu is frozen, it is an error to attempt to make any
changes to it.  In effect this means that the #GMenu API must no
longer be used.

This function causes g_menu_model_is_mutable() to begin returning
%FALSE, which has some positive performance implications.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenu</doc>
            <type name="Menu" c:type="GMenu*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="insert" c:identifier="g_menu_insert" version="2.32">
        <doc xml:space="preserve">Convenience function for inserting a normal menu item into @menu.
Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
alternative.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenu</doc>
            <type name="Menu" c:type="GMenu*"/>
          </instance-parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">the position at which to insert the item</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="label" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the section label, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="detailed_action" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the detailed action string, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_item" c:identifier="g_menu_insert_item" version="2.32">
        <doc xml:space="preserve">Inserts @item into @menu.

The "insertion" is actually done by copying all of the attribute and
link values of @item and using them to form a new item within @menu.
As such, @item itself is not really inserted, but rather, a menu item
that is exactly the same as the one presently described by @item.

This means that @item is essentially useless after the insertion
occurs.  Any changes you make to it are ignored unless it is inserted
again (at which point its updated values will be copied).

You should probably just free @item once you're done.

There are many convenience functions to take care of common cases.
See g_menu_insert(), g_menu_insert_section() and
g_menu_insert_submenu() as well as "prepend" and "append" variants of
each of these functions.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenu</doc>
            <type name="Menu" c:type="GMenu*"/>
          </instance-parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">the position at which to insert the item</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="item" transfer-ownership="none">
            <doc xml:space="preserve">the #GMenuItem to insert</doc>
            <type name="MenuItem" c:type="GMenuItem*"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_section" c:identifier="g_menu_insert_section" version="2.32">
        <doc xml:space="preserve">Convenience function for inserting a section menu item into @menu.
Combine g_menu_item_new_section() and g_menu_insert_item() for a more
flexible alternative.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenu</doc>
            <type name="Menu" c:type="GMenu*"/>
          </instance-parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">the position at which to insert the item</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="label" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the section label, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="section" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuModel with the items of the section</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_submenu" c:identifier="g_menu_insert_submenu" version="2.32">
        <doc xml:space="preserve">Convenience function for inserting a submenu menu item into @menu.
Combine g_menu_item_new_submenu() and g_menu_insert_item() for a more
flexible alternative.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenu</doc>
            <type name="Menu" c:type="GMenu*"/>
          </instance-parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">the position at which to insert the item</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="label" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the section label, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="submenu" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuModel with the items of the submenu</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepend" c:identifier="g_menu_prepend" version="2.32">
        <doc xml:space="preserve">Convenience function for prepending a normal menu item to the start
of @menu.  Combine g_menu_item_new() and g_menu_insert_item() for a more
flexible alternative.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenu</doc>
            <type name="Menu" c:type="GMenu*"/>
          </instance-parameter>
          <parameter name="label" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the section label, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="detailed_action" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the detailed action string, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepend_item" c:identifier="g_menu_prepend_item" version="2.32">
        <doc xml:space="preserve">Prepends @item to the start of @menu.

See g_menu_insert_item() for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenu</doc>
            <type name="Menu" c:type="GMenu*"/>
          </instance-parameter>
          <parameter name="item" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuItem to prepend</doc>
            <type name="MenuItem" c:type="GMenuItem*"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepend_section" c:identifier="g_menu_prepend_section" version="2.32">
        <doc xml:space="preserve">Convenience function for prepending a section menu item to the start
of @menu.  Combine g_menu_item_new_section() and g_menu_insert_item() for
a more flexible alternative.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenu</doc>
            <type name="Menu" c:type="GMenu*"/>
          </instance-parameter>
          <parameter name="label" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the section label, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="section" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuModel with the items of the section</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepend_submenu" c:identifier="g_menu_prepend_submenu" version="2.32">
        <doc xml:space="preserve">Convenience function for prepending a submenu menu item to the start
of @menu.  Combine g_menu_item_new_submenu() and g_menu_insert_item() for
a more flexible alternative.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenu</doc>
            <type name="Menu" c:type="GMenu*"/>
          </instance-parameter>
          <parameter name="label" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the section label, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="submenu" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuModel with the items of the submenu</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="g_menu_remove" version="2.32">
        <doc xml:space="preserve">Removes an item from the menu.

@position gives the index of the item to remove.

It is an error if position is not in range the range from 0 to one
less than the number of items in the menu.

It is not possible to remove items by identity since items are added
to the menu simply by copying their links and attributes (ie:
identity of the item itself is not preserved).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenu</doc>
            <type name="Menu" c:type="GMenu*"/>
          </instance-parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">the position of the item to remove</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_all" c:identifier="g_menu_remove_all" version="2.38">
        <doc xml:space="preserve">Removes all items in the menu.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenu</doc>
            <type name="Menu" c:type="GMenu*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="MenuAttributeIter" c:symbol-prefix="menu_attribute_iter" c:type="GMenuAttributeIter" version="2.32" parent="GObject.Object" abstract="1" glib:type-name="GMenuAttributeIter" glib:get-type="g_menu_attribute_iter_get_type" glib:type-struct="MenuAttributeIterClass">
      <doc xml:space="preserve">#GMenuAttributeIter is an opaque structure type.  You must access it
using the functions below.</doc>
      <virtual-method name="get_next" invoker="get_next" version="2.32">
        <doc xml:space="preserve">This function combines g_menu_attribute_iter_next() with
g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value().

First the iterator is advanced to the next (possibly first) attribute.
If that fails, then %FALSE is returned and there are no other
effects.

If successful, @name and @value are set to the name and value of the
attribute that has just been advanced to.  At this point,
g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value() will
return the same values again.

The value returned in @name remains valid for as long as the iterator
remains at the current position.  The value returned in @value must
be unreffed using g_variant_unref() when it is no longer in use.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, or %FALSE if there is no additional
    attribute</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuAttributeIter</doc>
            <type name="MenuAttributeIter" c:type="GMenuAttributeIter*"/>
          </instance-parameter>
          <parameter name="out_name" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1">
            <doc xml:space="preserve">the type of the attribute</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
          <parameter name="value" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the attribute value</doc>
            <type name="GLib.Variant" c:type="GVariant**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_name" c:identifier="g_menu_attribute_iter_get_name" version="2.32">
        <doc xml:space="preserve">Gets the name of the attribute at the current iterator position, as
a string.

The iterator is not advanced.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of the attribute</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuAttributeIter</doc>
            <type name="MenuAttributeIter" c:type="GMenuAttributeIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_next" c:identifier="g_menu_attribute_iter_get_next" version="2.32">
        <doc xml:space="preserve">This function combines g_menu_attribute_iter_next() with
g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value().

First the iterator is advanced to the next (possibly first) attribute.
If that fails, then %FALSE is returned and there are no other
effects.

If successful, @name and @value are set to the name and value of the
attribute that has just been advanced to.  At this point,
g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value() will
return the same values again.

The value returned in @name remains valid for as long as the iterator
remains at the current position.  The value returned in @value must
be unreffed using g_variant_unref() when it is no longer in use.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, or %FALSE if there is no additional
    attribute</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuAttributeIter</doc>
            <type name="MenuAttributeIter" c:type="GMenuAttributeIter*"/>
          </instance-parameter>
          <parameter name="out_name" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1">
            <doc xml:space="preserve">the type of the attribute</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
          <parameter name="value" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the attribute value</doc>
            <type name="GLib.Variant" c:type="GVariant**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_value" c:identifier="g_menu_attribute_iter_get_value" version="2.32">
        <doc xml:space="preserve">Gets the value of the attribute at the current iterator position.

The iterator is not advanced.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the value of the current attribute</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuAttributeIter</doc>
            <type name="MenuAttributeIter" c:type="GMenuAttributeIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="next" c:identifier="g_menu_attribute_iter_next" version="2.32">
        <doc xml:space="preserve">Attempts to advance the iterator to the next (possibly first)
attribute.

%TRUE is returned on success, or %FALSE if there are no more
attributes.

You must call this function when you first acquire the iterator
to advance it to the first attribute (and determine if the first
attribute exists at all).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, or %FALSE when there are no more attributes</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuAttributeIter</doc>
            <type name="MenuAttributeIter" c:type="GMenuAttributeIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="MenuAttributeIterPrivate" c:type="GMenuAttributeIterPrivate*"/>
      </field>
    </class>
    <record name="MenuAttributeIterClass" c:type="GMenuAttributeIterClass" glib:is-gtype-struct-for="MenuAttributeIter">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="get_next">
        <callback name="get_next">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, or %FALSE if there is no additional
    attribute</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">a #GMenuAttributeIter</doc>
              <type name="MenuAttributeIter" c:type="GMenuAttributeIter*"/>
            </parameter>
            <parameter name="out_name" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1">
              <doc xml:space="preserve">the type of the attribute</doc>
              <type name="utf8" c:type="const gchar**"/>
            </parameter>
            <parameter name="value" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
              <doc xml:space="preserve">the attribute value</doc>
              <type name="GLib.Variant" c:type="GVariant**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="MenuAttributeIterPrivate" c:type="GMenuAttributeIterPrivate" disguised="1">
    </record>
    <class name="MenuItem" c:symbol-prefix="menu_item" c:type="GMenuItem" version="2.32" parent="GObject.Object" glib:type-name="GMenuItem" glib:get-type="g_menu_item_get_type">
      <doc xml:space="preserve">#GMenuItem is an opaque structure type.  You must access it using the
functions below.</doc>
      <constructor name="new" c:identifier="g_menu_item_new" version="2.32">
        <doc xml:space="preserve">Creates a new #GMenuItem.

If @label is non-%NULL it is used to set the "label" attribute of the
new item.

If @detailed_action is non-%NULL it is used to set the "action" and
possibly the "target" attribute of the new item.  See
g_menu_item_set_detailed_action() for more information.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GMenuItem</doc>
          <type name="MenuItem" c:type="GMenuItem*"/>
        </return-value>
        <parameters>
          <parameter name="label" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the section label, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="detailed_action" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the detailed action string, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_model" c:identifier="g_menu_item_new_from_model" version="2.34">
        <doc xml:space="preserve">Creates a #GMenuItem as an exact copy of an existing menu item in a
#GMenuModel.

@item_index must be valid (ie: be sure to call
g_menu_model_get_n_items() first).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GMenuItem.</doc>
          <type name="MenuItem" c:type="GMenuItem*"/>
        </return-value>
        <parameters>
          <parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuModel</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </parameter>
          <parameter name="item_index" transfer-ownership="none">
            <doc xml:space="preserve">the index of an item in @model</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_section" c:identifier="g_menu_item_new_section" version="2.32">
        <doc xml:space="preserve">Creates a new #GMenuItem representing a section.

This is a convenience API around g_menu_item_new() and
g_menu_item_set_section().

The effect of having one menu appear as a section of another is
exactly as it sounds: the items from @section become a direct part of
the menu that @menu_item is added to.

Visual separation is typically displayed between two non-empty
sections.  If @label is non-%NULL then it will be encorporated into
this visual indication.  This allows for labeled subsections of a
menu.

As a simple example, consider a typical "Edit" menu from a simple
program.  It probably contains an "Undo" and "Redo" item, followed by
a separator, followed by "Cut", "Copy" and "Paste".

This would be accomplished by creating three #GMenu instances.  The
first would be populated with the "Undo" and "Redo" items, and the
second with the "Cut", "Copy" and "Paste" items.  The first and
second menus would then be added as submenus of the third.  In XML
format, this would look something like the following:
|[
&lt;menu id='edit-menu'&gt;
  &lt;section&gt;
    &lt;item label='Undo'/&gt;
    &lt;item label='Redo'/&gt;
  &lt;/section&gt;
  &lt;section&gt;
    &lt;item label='Cut'/&gt;
    &lt;item label='Copy'/&gt;
    &lt;item label='Paste'/&gt;
  &lt;/section&gt;
&lt;/menu&gt;
]|

The following example is exactly equivalent.  It is more illustrative
of the exact relationship between the menus and items (keeping in
mind that the 'link' element defines a new menu that is linked to the
containing one).  The style of the second example is more verbose and
difficult to read (and therefore not recommended except for the
purpose of understanding what is really going on).
|[
&lt;menu id='edit-menu'&gt;
  &lt;item&gt;
    &lt;link name='section'&gt;
      &lt;item label='Undo'/&gt;
      &lt;item label='Redo'/&gt;
    &lt;/link&gt;
  &lt;/item&gt;
  &lt;item&gt;
    &lt;link name='section'&gt;
      &lt;item label='Cut'/&gt;
      &lt;item label='Copy'/&gt;
      &lt;item label='Paste'/&gt;
    &lt;/link&gt;
  &lt;/item&gt;
&lt;/menu&gt;
]|</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GMenuItem</doc>
          <type name="MenuItem" c:type="GMenuItem*"/>
        </return-value>
        <parameters>
          <parameter name="label" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the section label, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="section" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuModel with the items of the section</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_submenu" c:identifier="g_menu_item_new_submenu" version="2.32">
        <doc xml:space="preserve">Creates a new #GMenuItem representing a submenu.

This is a convenience API around g_menu_item_new() and
g_menu_item_set_submenu().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GMenuItem</doc>
          <type name="MenuItem" c:type="GMenuItem*"/>
        </return-value>
        <parameters>
          <parameter name="label" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the section label, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="submenu" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuModel with the items of the submenu</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_attribute" c:identifier="g_menu_item_get_attribute" version="2.34" introspectable="0">
        <doc xml:space="preserve">Queries the named @attribute on @menu_item.

If the attribute exists and matches the #GVariantType corresponding
to @format_string then @format_string is used to deconstruct the
value into the positional parameters and %TRUE is returned.

If the attribute does not exist, or it does exist but has the wrong
type, then the positional parameters are ignored and %FALSE is
returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the named attribute was found with the expected
    type</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu_item" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuItem</doc>
            <type name="MenuItem" c:type="GMenuItem*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">the attribute name to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="format_string" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">positional parameters, as per @format_string</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_value" c:identifier="g_menu_item_get_attribute_value" version="2.34">
        <doc xml:space="preserve">Queries the named @attribute on @menu_item.

If @expected_type is specified and the attribute does not have this
type, %NULL is returned.  %NULL is also returned if the attribute
simply does not exist.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the attribute value, or %NULL</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu_item" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuItem</doc>
            <type name="MenuItem" c:type="GMenuItem*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">the attribute name to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="expected_type" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the expected type of the attribute</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_link" c:identifier="g_menu_item_get_link" version="2.34">
        <doc xml:space="preserve">Queries the named @link on @menu_item.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the link, or %NULL</doc>
          <type name="MenuModel" c:type="GMenuModel*"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu_item" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuItem</doc>
            <type name="MenuItem" c:type="GMenuItem*"/>
          </instance-parameter>
          <parameter name="link" transfer-ownership="none">
            <doc xml:space="preserve">the link name to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_action_and_target" c:identifier="g_menu_item_set_action_and_target" version="2.32" introspectable="0">
        <doc xml:space="preserve">Sets or unsets the "action" and "target" attributes of @menu_item.

If @action is %NULL then both the "action" and "target" attributes
are unset (and @format_string is ignored along with the positional
parameters).

If @action is non-%NULL then the "action" attribute is set.
@format_string is then inspected.  If it is non-%NULL then the proper
position parameters are collected to create a #GVariant instance to
use as the target value.  If it is %NULL then the positional
parameters are ignored and the "target" attribute is unset.

See also g_menu_item_set_action_and_target_value() for an equivalent
call that directly accepts a #GVariant.  See
g_menu_item_set_detailed_action() for a more convenient version that
works with string-typed targets.

See also g_menu_item_set_action_and_target_value() for a
description of the semantics of the action and target attributes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu_item" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuItem</doc>
            <type name="MenuItem" c:type="GMenuItem*"/>
          </instance-parameter>
          <parameter name="action" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the name of the action for this item</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="format_string" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a GVariant format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">positional parameters, as per @format_string</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="set_action_and_target_value" c:identifier="g_menu_item_set_action_and_target_value" version="2.32">
        <doc xml:space="preserve">Sets or unsets the "action" and "target" attributes of @menu_item.

If @action is %NULL then both the "action" and "target" attributes
are unset (and @target_value is ignored).

If @action is non-%NULL then the "action" attribute is set.  The
"target" attribute is then set to the value of @target_value if it is
non-%NULL or unset otherwise.

Normal menu items (ie: not submenu, section or other custom item
types) are expected to have the "action" attribute set to identify
the action that they are associated with.  The state type of the
action help to determine the disposition of the menu item.  See
#GAction and #GActionGroup for an overview of actions.

In general, clicking on the menu item will result in activation of
the named action with the "target" attribute given as the parameter
to the action invocation.  If the "target" attribute is not set then
the action is invoked with no parameter.

If the action has no state then the menu item is usually drawn as a
plain menu item (ie: with no additional decoration).

If the action has a boolean state then the menu item is usually drawn
as a toggle menu item (ie: with a checkmark or equivalent
indication).  The item should be marked as 'toggled' or 'checked'
when the boolean state is %TRUE.

If the action has a string state then the menu item is usually drawn
as a radio menu item (ie: with a radio bullet or equivalent
indication).  The item should be marked as 'selected' when the string
state is equal to the value of the @target property.

See g_menu_item_set_action_and_target() or
g_menu_item_set_detailed_action() for two equivalent calls that are
probably more convenient for most uses.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu_item" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuItem</doc>
            <type name="MenuItem" c:type="GMenuItem*"/>
          </instance-parameter>
          <parameter name="action" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the name of the action for this item</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="target_value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GVariant to use as the action target</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute" c:identifier="g_menu_item_set_attribute" version="2.32" introspectable="0">
        <doc xml:space="preserve">Sets or unsets an attribute on @menu_item.

The attribute to set or unset is specified by @attribute. This
can be one of the standard attribute names %G_MENU_ATTRIBUTE_LABEL,
%G_MENU_ATTRIBUTE_ACTION, %G_MENU_ATTRIBUTE_TARGET, or a custom
attribute name.
Attribute names are restricted to lowercase characters, numbers
and '-'. Furthermore, the names must begin with a lowercase character,
must not end with a '-', and must not contain consecutive dashes.

If @format_string is non-%NULL then the proper position parameters
are collected to create a #GVariant instance to use as the attribute
value.  If it is %NULL then the positional parameterrs are ignored
and the named attribute is unset.

See also g_menu_item_set_attribute_value() for an equivalent call
that directly accepts a #GVariant.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu_item" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuItem</doc>
            <type name="MenuItem" c:type="GMenuItem*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">the attribute to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="format_string" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GVariant format string, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">positional parameters, as per @format_string</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_value" c:identifier="g_menu_item_set_attribute_value" version="2.32">
        <doc xml:space="preserve">Sets or unsets an attribute on @menu_item.

The attribute to set or unset is specified by @attribute. This
can be one of the standard attribute names %G_MENU_ATTRIBUTE_LABEL,
%G_MENU_ATTRIBUTE_ACTION, %G_MENU_ATTRIBUTE_TARGET, or a custom
attribute name.
Attribute names are restricted to lowercase characters, numbers
and '-'. Furthermore, the names must begin with a lowercase character,
must not end with a '-', and must not contain consecutive dashes.

must consist only of lowercase
ASCII characters, digits and '-'.

If @value is non-%NULL then it is used as the new value for the
attribute.  If @value is %NULL then the attribute is unset. If
the @value #GVariant is floating, it is consumed.

See also g_menu_item_set_attribute() for a more convenient way to do
the same.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu_item" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuItem</doc>
            <type name="MenuItem" c:type="GMenuItem*"/>
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">the attribute to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GVariant to use as the value, or %NULL</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_detailed_action" c:identifier="g_menu_item_set_detailed_action" version="2.32">
        <doc xml:space="preserve">Sets the "action" and possibly the "target" attribute of @menu_item.

The format of @detailed_action is the same format parsed by
g_action_parse_detailed_name().

See g_menu_item_set_action_and_target() or
g_menu_item_set_action_and_target_value() for more flexible (but
slightly less convenient) alternatives.

See also g_menu_item_set_action_and_target_value() for a description of
the semantics of the action and target attributes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu_item" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuItem</doc>
            <type name="MenuItem" c:type="GMenuItem*"/>
          </instance-parameter>
          <parameter name="detailed_action" transfer-ownership="none">
            <doc xml:space="preserve">the "detailed" action string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_icon" c:identifier="g_menu_item_set_icon" version="2.38">
        <doc xml:space="preserve">Sets (or unsets) the icon on @menu_item.

This call is the same as calling g_icon_serialize() and using the
result as the value to g_menu_item_set_attribute_value() for
%G_MENU_ATTRIBUTE_ICON.

This API is only intended for use with "noun" menu items; things like
bookmarks or applications in an "Open With" menu.  Don't use it on
menu items corresponding to verbs (eg: stock icons for 'Save' or
'Quit').

If @icon is %NULL then the icon is unset.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu_item" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuItem</doc>
            <type name="MenuItem" c:type="GMenuItem*"/>
          </instance-parameter>
          <parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">a #GIcon, or %NULL</doc>
            <type name="Icon" c:type="GIcon*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_label" c:identifier="g_menu_item_set_label" version="2.32">
        <doc xml:space="preserve">Sets or unsets the "label" attribute of @menu_item.

If @label is non-%NULL it is used as the label for the menu item.  If
it is %NULL then the label attribute is unset.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu_item" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuItem</doc>
            <type name="MenuItem" c:type="GMenuItem*"/>
          </instance-parameter>
          <parameter name="label" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the label to set, or %NULL to unset</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_link" c:identifier="g_menu_item_set_link" version="2.32">
        <doc xml:space="preserve">Creates a link from @menu_item to @model if non-%NULL, or unsets it.

Links are used to establish a relationship between a particular menu
item and another menu.  For example, %G_MENU_LINK_SUBMENU is used to
associate a submenu with a particular menu item, and %G_MENU_LINK_SECTION
is used to create a section. Other types of link can be used, but there
is no guarantee that clients will be able to make sense of them.
Link types are restricted to lowercase characters, numbers
and '-'. Furthermore, the names must begin with a lowercase character,
must not end with a '-', and must not contain consecutive dashes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu_item" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuItem</doc>
            <type name="MenuItem" c:type="GMenuItem*"/>
          </instance-parameter>
          <parameter name="link" transfer-ownership="none">
            <doc xml:space="preserve">type of link to establish or unset</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="model" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the #GMenuModel to link to (or %NULL to unset)</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_section" c:identifier="g_menu_item_set_section" version="2.32">
        <doc xml:space="preserve">Sets or unsets the "section" link of @menu_item to @section.

The effect of having one menu appear as a section of another is
exactly as it sounds: the items from @section become a direct part of
the menu that @menu_item is added to.  See g_menu_item_new_section()
for more information about what it means for a menu item to be a
section.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu_item" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuItem</doc>
            <type name="MenuItem" c:type="GMenuItem*"/>
          </instance-parameter>
          <parameter name="section" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMenuModel, or %NULL</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_submenu" c:identifier="g_menu_item_set_submenu" version="2.32">
        <doc xml:space="preserve">Sets or unsets the "submenu" link of @menu_item to @submenu.

If @submenu is non-%NULL, it is linked to.  If it is %NULL then the
link is unset.

The effect of having one menu appear as a submenu of another is
exactly as it sounds.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="menu_item" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuItem</doc>
            <type name="MenuItem" c:type="GMenuItem*"/>
          </instance-parameter>
          <parameter name="submenu" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMenuModel, or %NULL</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <class name="MenuLinkIter" c:symbol-prefix="menu_link_iter" c:type="GMenuLinkIter" version="2.32" parent="GObject.Object" abstract="1" glib:type-name="GMenuLinkIter" glib:get-type="g_menu_link_iter_get_type" glib:type-struct="MenuLinkIterClass">
      <doc xml:space="preserve">#GMenuLinkIter is an opaque structure type.  You must access it using
the functions below.</doc>
      <virtual-method name="get_next" invoker="get_next" version="2.32">
        <doc xml:space="preserve">This function combines g_menu_link_iter_next() with
g_menu_link_iter_get_name() and g_menu_link_iter_get_value().

First the iterator is advanced to the next (possibly first) link.
If that fails, then %FALSE is returned and there are no other effects.

If successful, @out_link and @value are set to the name and #GMenuModel
of the link that has just been advanced to.  At this point,
g_menu_link_iter_get_name() and g_menu_link_iter_get_value() will return the
same values again.

The value returned in @out_link remains valid for as long as the iterator
remains at the current position.  The value returned in @value must
be unreffed using g_object_unref() when it is no longer in use.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, or %FALSE if there is no additional link</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuLinkIter</doc>
            <type name="MenuLinkIter" c:type="GMenuLinkIter*"/>
          </instance-parameter>
          <parameter name="out_link" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1">
            <doc xml:space="preserve">the name of the link</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
          <parameter name="value" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the linked #GMenuModel</doc>
            <type name="MenuModel" c:type="GMenuModel**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_name" c:identifier="g_menu_link_iter_get_name" version="2.32">
        <doc xml:space="preserve">Gets the name of the link at the current iterator position.

The iterator is not advanced.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type of the link</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuLinkIter</doc>
            <type name="MenuLinkIter" c:type="GMenuLinkIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_next" c:identifier="g_menu_link_iter_get_next" version="2.32">
        <doc xml:space="preserve">This function combines g_menu_link_iter_next() with
g_menu_link_iter_get_name() and g_menu_link_iter_get_value().

First the iterator is advanced to the next (possibly first) link.
If that fails, then %FALSE is returned and there are no other effects.

If successful, @out_link and @value are set to the name and #GMenuModel
of the link that has just been advanced to.  At this point,
g_menu_link_iter_get_name() and g_menu_link_iter_get_value() will return the
same values again.

The value returned in @out_link remains valid for as long as the iterator
remains at the current position.  The value returned in @value must
be unreffed using g_object_unref() when it is no longer in use.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, or %FALSE if there is no additional link</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuLinkIter</doc>
            <type name="MenuLinkIter" c:type="GMenuLinkIter*"/>
          </instance-parameter>
          <parameter name="out_link" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1">
            <doc xml:space="preserve">the name of the link</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
          <parameter name="value" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the linked #GMenuModel</doc>
            <type name="MenuModel" c:type="GMenuModel**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_value" c:identifier="g_menu_link_iter_get_value" version="2.32">
        <doc xml:space="preserve">Gets the linked #GMenuModel at the current iterator position.

The iterator is not advanced.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the #GMenuModel that is linked to</doc>
          <type name="MenuModel" c:type="GMenuModel*"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuLinkIter</doc>
            <type name="MenuLinkIter" c:type="GMenuLinkIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="next" c:identifier="g_menu_link_iter_next" version="2.32">
        <doc xml:space="preserve">Attempts to advance the iterator to the next (possibly first)
link.

%TRUE is returned on success, or %FALSE if there are no more links.

You must call this function when you first acquire the iterator to
advance it to the first link (and determine if the first link exists
at all).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, or %FALSE when there are no more links</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuLinkIter</doc>
            <type name="MenuLinkIter" c:type="GMenuLinkIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="MenuLinkIterPrivate" c:type="GMenuLinkIterPrivate*"/>
      </field>
    </class>
    <record name="MenuLinkIterClass" c:type="GMenuLinkIterClass" glib:is-gtype-struct-for="MenuLinkIter">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="get_next">
        <callback name="get_next">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, or %FALSE if there is no additional link</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">a #GMenuLinkIter</doc>
              <type name="MenuLinkIter" c:type="GMenuLinkIter*"/>
            </parameter>
            <parameter name="out_link" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1">
              <doc xml:space="preserve">the name of the link</doc>
              <type name="utf8" c:type="const gchar**"/>
            </parameter>
            <parameter name="value" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
              <doc xml:space="preserve">the linked #GMenuModel</doc>
              <type name="MenuModel" c:type="GMenuModel**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="MenuLinkIterPrivate" c:type="GMenuLinkIterPrivate" disguised="1">
    </record>
    <class name="MenuModel" c:symbol-prefix="menu_model" c:type="GMenuModel" version="2.32" parent="GObject.Object" abstract="1" glib:type-name="GMenuModel" glib:get-type="g_menu_model_get_type" glib:type-struct="MenuModelClass">
      <doc xml:space="preserve">#GMenuModel represents the contents of a menu -- an ordered list of
menu items. The items are associated with actions, which can be
activated through them. Items can be grouped in sections, and may
have submenus associated with them. Both items and sections usually
have some representation data, such as labels or icons. The type of
the associated action (ie whether it is stateful, and what kind of
state it has) can influence the representation of the item.

The conceptual model of menus in #GMenuModel is hierarchical:
sections and submenus are again represented by #GMenuModels.
Menus themselves do not define their own roles. Rather, the role
of a particular #GMenuModel is defined by the item that references
it (or, in the case of the 'root' menu, is defined by the context
in which it is used).

As an example, consider the visible portions of this menu:

## An example menu # {#menu-example}

![](menu-example.png)

There are 8 "menus" visible in the screenshot: one menubar, two
submenus and 5 sections:

- the toplevel menubar (containing 4 items)
- the View submenu (containing 3 sections)
- the first section of the View submenu (containing 2 items)
- the second section of the View submenu (containing 1 item)
- the final section of the View submenu (containing 1 item)
- the Highlight Mode submenu (containing 2 sections)
- the Sources section (containing 2 items)
- the Markup section (containing 2 items)

The [example][menu-model] illustrates the conceptual connection between
these 8 menus. Each large block in the figure represents a menu and the
smaller blocks within the large block represent items in that menu. Some
items contain references to other menus.

## A menu example # {#menu-model}

![](menu-model.png)

Notice that the separators visible in the [example][menu-example]
appear nowhere in the [menu model][menu-model]. This is because
separators are not explicitly represented in the menu model. Instead,
a separator is inserted between any two non-empty sections of a menu.
Section items can have labels just like any other item. In that case,
a display system may show a section header instead of a separator.

The motivation for this abstract model of application controls is
that modern user interfaces tend to make these controls available
outside the application. Examples include global menus, jumplists,
dash boards, etc. To support such uses, it is necessary to 'export'
information about actions and their representation in menus, which
is exactly what the [GActionGroup exporter][gio-GActionGroup-exporter]
and the [GMenuModel exporter][gio-GMenuModel-exporter] do for
#GActionGroup and #GMenuModel. The client-side counterparts to
make use of the exported information are #GDBusActionGroup and
#GDBusMenuModel.

The API of #GMenuModel is very generic, with iterators for the
attributes and links of an item, see g_menu_model_iterate_item_attributes()
and g_menu_model_iterate_item_links(). The 'standard' attributes and
link types have predefined names: %G_MENU_ATTRIBUTE_LABEL,
%G_MENU_ATTRIBUTE_ACTION, %G_MENU_ATTRIBUTE_TARGET, %G_MENU_LINK_SECTION
and %G_MENU_LINK_SUBMENU.

Items in a #GMenuModel represent active controls if they refer to
an action that can get activated when the user interacts with the
menu item. The reference to the action is encoded by the string id
in the %G_MENU_ATTRIBUTE_ACTION attribute. An action id uniquely
identifies an action in an action group. Which action group(s) provide
actions depends on the context in which the menu model is used.
E.g. when the model is exported as the application menu of a
#GtkApplication, actions can be application-wide or window-specific
(and thus come from two different action groups). By convention, the
application-wide actions have names that start with "app.", while the
names of window-specific actions start with "win.".

While a wide variety of stateful actions is possible, the following
is the minimum that is expected to be supported by all users of exported
menu information:
- an action with no parameter type and no state
- an action with no parameter type and boolean state
- an action with string parameter type and string state

## Stateless

A stateless action typically corresponds to an ordinary menu item.

Selecting such a menu item will activate the action (with no parameter).

## Boolean State

An action with a boolean state will most typically be used with a "toggle"
or "switch" menu item. The state can be set directly, but activating the
action (with no parameter) results in the state being toggled.

Selecting a toggle menu item will activate the action. The menu item should
be rendered as "checked" when the state is true.

## String Parameter and State

Actions with string parameters and state will most typically be used to
represent an enumerated choice over the items available for a group of
radio menu items. Activating the action with a string parameter is
equivalent to setting that parameter as the state.

Radio menu items, in addition to being associated with the action, will
have a target value. Selecting that menu item will result in activation
of the action with the target value as the parameter. The menu item should
be rendered as "selected" when the state of the action is equal to the
target value of the menu item.</doc>
      <virtual-method name="get_item_attribute_value" invoker="get_item_attribute_value" version="2.32">
        <doc xml:space="preserve">Queries the item at position @item_index in @model for the attribute
specified by @attribute.

If @expected_type is non-%NULL then it specifies the expected type of
the attribute.  If it is %NULL then any type will be accepted.

If the attribute exists and matches @expected_type (or if the
expected type is unspecified) then the value is returned.

If the attribute does not exist, or does not match the expected type
then %NULL is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the value of the attribute</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuModel</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </instance-parameter>
          <parameter name="item_index" transfer-ownership="none">
            <doc xml:space="preserve">the index of the item</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">the attribute to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="expected_type" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the expected type of the attribute, or
    %NULL</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_item_attributes">
        <doc xml:space="preserve">Gets all the attributes associated with the item in the menu model.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">the #GMenuModel to query</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </instance-parameter>
          <parameter name="item_index" transfer-ownership="none">
            <doc xml:space="preserve">The #GMenuItem to query</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="attributes" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">Attributes on the item</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="utf8"/>
              <type name="GLib.Variant"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_item_link" invoker="get_item_link" version="2.32">
        <doc xml:space="preserve">Queries the item at position @item_index in @model for the link
specified by @link.

If the link exists, the linked #GMenuModel is returned.  If the link
does not exist, %NULL is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the linked #GMenuModel, or %NULL</doc>
          <type name="MenuModel" c:type="GMenuModel*"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuModel</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </instance-parameter>
          <parameter name="item_index" transfer-ownership="none">
            <doc xml:space="preserve">the index of the item</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="link" transfer-ownership="none">
            <doc xml:space="preserve">the link to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_item_links">
        <doc xml:space="preserve">Gets all the links associated with the item in the menu model.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">the #GMenuModel to query</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </instance-parameter>
          <parameter name="item_index" transfer-ownership="none">
            <doc xml:space="preserve">The #GMenuItem to query</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="links" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">Links from the item</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="utf8"/>
              <type name="MenuModel"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_n_items" invoker="get_n_items" version="2.32">
        <doc xml:space="preserve">Query the number of items in @model.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of items</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuModel</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_mutable" invoker="is_mutable" version="2.32">
        <doc xml:space="preserve">Queries if @model is mutable.

An immutable #GMenuModel will never emit the #GMenuModel::items-changed
signal. Consumers of the model may make optimisations accordingly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the model is mutable (ie: "items-changed" may be
    emitted).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuModel</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="iterate_item_attributes" invoker="iterate_item_attributes" version="2.32">
        <doc xml:space="preserve">Creates a #GMenuAttributeIter to iterate over the attributes of
the item at position @item_index in @model.

You must free the iterator with g_object_unref() when you are done.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GMenuAttributeIter</doc>
          <type name="MenuAttributeIter" c:type="GMenuAttributeIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuModel</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </instance-parameter>
          <parameter name="item_index" transfer-ownership="none">
            <doc xml:space="preserve">the index of the item</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="iterate_item_links" invoker="iterate_item_links" version="2.32">
        <doc xml:space="preserve">Creates a #GMenuLinkIter to iterate over the links of the item at
position @item_index in @model.

You must free the iterator with g_object_unref() when you are done.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GMenuLinkIter</doc>
          <type name="MenuLinkIter" c:type="GMenuLinkIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuModel</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </instance-parameter>
          <parameter name="item_index" transfer-ownership="none">
            <doc xml:space="preserve">the index of the item</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_item_attribute" c:identifier="g_menu_model_get_item_attribute" version="2.32" introspectable="0">
        <doc xml:space="preserve">Queries item at position @item_index in @model for the attribute
specified by @attribute.

If the attribute exists and matches the #GVariantType corresponding
to @format_string then @format_string is used to deconstruct the
value into the positional parameters and %TRUE is returned.

If the attribute does not exist, or it does exist but has the wrong
type, then the positional parameters are ignored and %FALSE is
returned.

This function is a mix of g_menu_model_get_item_attribute_value() and
g_variant_get(), followed by a g_variant_unref().  As such,
@format_string must make a complete copy of the data (since the
#GVariant may go away after the call to g_variant_unref()).  In
particular, no '&amp;' characters are allowed in @format_string.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the named attribute was found with the expected
    type</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuModel</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </instance-parameter>
          <parameter name="item_index" transfer-ownership="none">
            <doc xml:space="preserve">the index of the item</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">the attribute to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="format_string" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">positional parameters, as per @format_string</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="get_item_attribute_value" c:identifier="g_menu_model_get_item_attribute_value" version="2.32">
        <doc xml:space="preserve">Queries the item at position @item_index in @model for the attribute
specified by @attribute.

If @expected_type is non-%NULL then it specifies the expected type of
the attribute.  If it is %NULL then any type will be accepted.

If the attribute exists and matches @expected_type (or if the
expected type is unspecified) then the value is returned.

If the attribute does not exist, or does not match the expected type
then %NULL is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the value of the attribute</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuModel</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </instance-parameter>
          <parameter name="item_index" transfer-ownership="none">
            <doc xml:space="preserve">the index of the item</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve">the attribute to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="expected_type" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the expected type of the attribute, or
    %NULL</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_item_link" c:identifier="g_menu_model_get_item_link" version="2.32">
        <doc xml:space="preserve">Queries the item at position @item_index in @model for the link
specified by @link.

If the link exists, the linked #GMenuModel is returned.  If the link
does not exist, %NULL is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the linked #GMenuModel, or %NULL</doc>
          <type name="MenuModel" c:type="GMenuModel*"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuModel</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </instance-parameter>
          <parameter name="item_index" transfer-ownership="none">
            <doc xml:space="preserve">the index of the item</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="link" transfer-ownership="none">
            <doc xml:space="preserve">the link to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_n_items" c:identifier="g_menu_model_get_n_items" version="2.32">
        <doc xml:space="preserve">Query the number of items in @model.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of items</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuModel</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_mutable" c:identifier="g_menu_model_is_mutable" version="2.32">
        <doc xml:space="preserve">Queries if @model is mutable.

An immutable #GMenuModel will never emit the #GMenuModel::items-changed
signal. Consumers of the model may make optimisations accordingly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the model is mutable (ie: "items-changed" may be
    emitted).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuModel</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="items_changed" c:identifier="g_menu_model_items_changed" version="2.32">
        <doc xml:space="preserve">Requests emission of the #GMenuModel::items-changed signal on @model.

This function should never be called except by #GMenuModel
subclasses.  Any other calls to this function will very likely lead
to a violation of the interface of the model.

The implementation should update its internal representation of the
menu before emitting the signal.  The implementation should further
expect to receive queries about the new state of the menu (and
particularly added menu items) while signal handlers are running.

The implementation must dispatch this call directly from a mainloop
entry and not in response to calls -- particularly those from the
#GMenuModel API.  Said another way: the menu must not change while
user code is running without returning to the mainloop.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuModel</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </instance-parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">the position of the change</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:space="preserve">the number of items removed</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="added" transfer-ownership="none">
            <doc xml:space="preserve">the number of items added</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="iterate_item_attributes" c:identifier="g_menu_model_iterate_item_attributes" version="2.32">
        <doc xml:space="preserve">Creates a #GMenuAttributeIter to iterate over the attributes of
the item at position @item_index in @model.

You must free the iterator with g_object_unref() when you are done.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GMenuAttributeIter</doc>
          <type name="MenuAttributeIter" c:type="GMenuAttributeIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuModel</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </instance-parameter>
          <parameter name="item_index" transfer-ownership="none">
            <doc xml:space="preserve">the index of the item</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="iterate_item_links" c:identifier="g_menu_model_iterate_item_links" version="2.32">
        <doc xml:space="preserve">Creates a #GMenuLinkIter to iterate over the links of the item at
position @item_index in @model.

You must free the iterator with g_object_unref() when you are done.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GMenuLinkIter</doc>
          <type name="MenuLinkIter" c:type="GMenuLinkIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">a #GMenuModel</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </instance-parameter>
          <parameter name="item_index" transfer-ownership="none">
            <doc xml:space="preserve">the index of the item</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="MenuModelPrivate" c:type="GMenuModelPrivate*"/>
      </field>
      <glib:signal name="items-changed" when="last">
        <doc xml:space="preserve">Emitted when a change has occured to the menu.

The only changes that can occur to a menu is that items are removed
or added.  Items may not change (except by being removed and added
back in the same location).  This signal is capable of describing
both of those changes (at the same time).

The signal means that starting at the index @position, @removed
items were removed and @added items were added in their place.  If
@removed is zero then only items were added.  If @added is zero
then only items were removed.

As an example, if the menu contains items a, b, c, d (in that
order) and the signal (2, 1, 3) occurs then the new composition of
the menu will be a, b, _, _, _, d (with each _ representing some
new item).

Signal handlers may query the model (particularly the added items)
and expect to see the results of the modification that is being
reported.  The signal is emitted after the modification.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">the position of the change</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:space="preserve">the number of items removed</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="added" transfer-ownership="none">
            <doc xml:space="preserve">the number of items added</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="MenuModelClass" c:type="GMenuModelClass" glib:is-gtype-struct-for="MenuModel">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="is_mutable">
        <callback name="is_mutable">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the model is mutable (ie: "items-changed" may be
    emitted).</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="model" transfer-ownership="none">
              <doc xml:space="preserve">a #GMenuModel</doc>
              <type name="MenuModel" c:type="GMenuModel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_n_items">
        <callback name="get_n_items">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the number of items</doc>
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="model" transfer-ownership="none">
              <doc xml:space="preserve">a #GMenuModel</doc>
              <type name="MenuModel" c:type="GMenuModel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_item_attributes">
        <callback name="get_item_attributes">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="model" transfer-ownership="none">
              <doc xml:space="preserve">the #GMenuModel to query</doc>
              <type name="MenuModel" c:type="GMenuModel*"/>
            </parameter>
            <parameter name="item_index" transfer-ownership="none">
              <doc xml:space="preserve">The #GMenuItem to query</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="attributes" direction="out" caller-allocates="0" transfer-ownership="full">
              <doc xml:space="preserve">Attributes on the item</doc>
              <type name="GLib.HashTable" c:type="GHashTable**">
                <type name="utf8"/>
                <type name="GLib.Variant"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="iterate_item_attributes">
        <callback name="iterate_item_attributes">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a new #GMenuAttributeIter</doc>
            <type name="MenuAttributeIter" c:type="GMenuAttributeIter*"/>
          </return-value>
          <parameters>
            <parameter name="model" transfer-ownership="none">
              <doc xml:space="preserve">a #GMenuModel</doc>
              <type name="MenuModel" c:type="GMenuModel*"/>
            </parameter>
            <parameter name="item_index" transfer-ownership="none">
              <doc xml:space="preserve">the index of the item</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_item_attribute_value">
        <callback name="get_item_attribute_value">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the value of the attribute</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </return-value>
          <parameters>
            <parameter name="model" transfer-ownership="none">
              <doc xml:space="preserve">a #GMenuModel</doc>
              <type name="MenuModel" c:type="GMenuModel*"/>
            </parameter>
            <parameter name="item_index" transfer-ownership="none">
              <doc xml:space="preserve">the index of the item</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="attribute" transfer-ownership="none">
              <doc xml:space="preserve">the attribute to query</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="expected_type" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">the expected type of the attribute, or
    %NULL</doc>
              <type name="GLib.VariantType" c:type="const GVariantType*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_item_links">
        <callback name="get_item_links">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="model" transfer-ownership="none">
              <doc xml:space="preserve">the #GMenuModel to query</doc>
              <type name="MenuModel" c:type="GMenuModel*"/>
            </parameter>
            <parameter name="item_index" transfer-ownership="none">
              <doc xml:space="preserve">The #GMenuItem to query</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="links" direction="out" caller-allocates="0" transfer-ownership="full">
              <doc xml:space="preserve">Links from the item</doc>
              <type name="GLib.HashTable" c:type="GHashTable**">
                <type name="utf8"/>
                <type name="MenuModel"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="iterate_item_links">
        <callback name="iterate_item_links">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a new #GMenuLinkIter</doc>
            <type name="MenuLinkIter" c:type="GMenuLinkIter*"/>
          </return-value>
          <parameters>
            <parameter name="model" transfer-ownership="none">
              <doc xml:space="preserve">a #GMenuModel</doc>
              <type name="MenuModel" c:type="GMenuModel*"/>
            </parameter>
            <parameter name="item_index" transfer-ownership="none">
              <doc xml:space="preserve">the index of the item</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_item_link">
        <callback name="get_item_link">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the linked #GMenuModel, or %NULL</doc>
            <type name="MenuModel" c:type="GMenuModel*"/>
          </return-value>
          <parameters>
            <parameter name="model" transfer-ownership="none">
              <doc xml:space="preserve">a #GMenuModel</doc>
              <type name="MenuModel" c:type="GMenuModel*"/>
            </parameter>
            <parameter name="item_index" transfer-ownership="none">
              <doc xml:space="preserve">the index of the item</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="link" transfer-ownership="none">
              <doc xml:space="preserve">the link to query</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="MenuModelPrivate" c:type="GMenuModelPrivate" disguised="1">
    </record>
    <interface name="Mount" c:symbol-prefix="mount" c:type="GMount" glib:type-name="GMount" glib:get-type="g_mount_get_type" glib:type-struct="MountIface">
      <doc xml:space="preserve">The #GMount interface represents user-visible mounts. Note, when
porting from GnomeVFS, #GMount is the moral equivalent of #GnomeVFSVolume.

#GMount is a "mounted" filesystem that you can access. Mounted is in
quotes because it's not the same as a unix mount, it might be a gvfs
mount, but you can still access the files on it if you use GIO. Might or
might not be related to a volume object.

Unmounting a #GMount instance is an asynchronous operation. For
more information about asynchronous operations, see #GAsyncResult
and #GTask. To unmount a #GMount instance, first call
g_mount_unmount_with_operation() with (at least) the #GMount instance and a
#GAsyncReadyCallback.  The callback will be fired when the
operation has resolved (either with success or failure), and a
#GAsyncResult structure will be passed to the callback.  That
callback should then call g_mount_unmount_with_operation_finish() with the #GMount
and the #GAsyncResult data to see if the operation was completed
successfully.  If an @error is present when g_mount_unmount_with_operation_finish()
is called, then it will be filled with any error information.</doc>
      <virtual-method name="can_eject" invoker="can_eject">
        <doc xml:space="preserve">Checks if @mount can be ejected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @mount can be ejected.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="can_unmount" invoker="can_unmount">
        <doc xml:space="preserve">Checks if @mount can be unmounted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @mount can be unmounted.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject" invoker="eject" deprecated="1" deprecated-version="2.22">
        <doc xml:space="preserve">Ejects a mount. This is an asynchronous operation, and is
finished by calling g_mount_eject_finish() with the @mount
and #GAsyncResult data returned in the @callback.</doc>
        <doc-deprecated xml:space="preserve">Use g_mount_eject_with_operation() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the unmount if required for eject</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_finish" invoker="eject_finish" deprecated="1" deprecated-version="2.22" throws="1">
        <doc xml:space="preserve">Finishes ejecting a mount. If any errors occurred during the operation,
@error will be set to contain the errors and %FALSE will be returned.</doc>
        <doc-deprecated xml:space="preserve">Use g_mount_eject_with_operation_finish() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the mount was successfully ejected. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_with_operation" invoker="eject_with_operation" version="2.22">
        <doc xml:space="preserve">Ejects a mount. This is an asynchronous operation, and is
finished by calling g_mount_eject_with_operation_finish() with the @mount
and #GAsyncResult data returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the unmount if required for eject</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation or %NULL to avoid
    user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_with_operation_finish" invoker="eject_with_operation_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes ejecting a mount. If any errors occurred during the operation,
@error will be set to contain the errors and %FALSE will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the mount was successfully ejected. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_default_location" invoker="get_default_location">
        <doc xml:space="preserve">Gets the default location of @mount. The default location of the given
@mount is a path that reflects the main entry point for the user (e.g.
the home directory, or the root of the volume).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFile.
     The returned object should be unreffed with
     g_object_unref() when no longer needed.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_drive" invoker="get_drive">
        <doc xml:space="preserve">Gets the drive for the @mount.

This is a convenience method for getting the #GVolume and then
using that object to get the #GDrive.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #GDrive or %NULL if @mount is not
     associated with a volume or a drive.
     The returned object should be unreffed with
     g_object_unref() when no longer needed.</doc>
          <type name="Drive" c:type="GDrive*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_icon" invoker="get_icon">
        <doc xml:space="preserve">Gets the icon for @mount.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GIcon.
     The returned object should be unreffed with
     g_object_unref() when no longer needed.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_name" invoker="get_name">
        <doc xml:space="preserve">Gets the name of @mount.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the name for the given @mount.
    The returned string should be freed with g_free()
    when no longer needed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_root" invoker="get_root">
        <doc xml:space="preserve">Gets the root directory on @mount.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFile.
     The returned object should be unreffed with
     g_object_unref() when no longer needed.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_sort_key" invoker="get_sort_key" version="2.32">
        <doc xml:space="preserve">Gets the sort key for @mount, if any.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">Sorting key for @mount or %NULL if no such key is available.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">A #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_symbolic_icon" invoker="get_symbolic_icon" version="2.34">
        <doc xml:space="preserve">Gets the symbolic icon for @mount.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GIcon.
     The returned object should be unreffed with
     g_object_unref() when no longer needed.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_uuid" invoker="get_uuid">
        <doc xml:space="preserve">Gets the UUID for the @mount. The reference is typically based on
the file system UUID for the mount in question and should be
considered an opaque string. Returns %NULL if there is no UUID
available.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the UUID for @mount or %NULL if no UUID
    can be computed.
    The returned string should be freed with g_free()
    when no longer needed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_volume" invoker="get_volume">
        <doc xml:space="preserve">Gets the volume for the @mount.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #GVolume or %NULL if @mount is not
     associated with a volume.
     The returned object should be unreffed with
     g_object_unref() when no longer needed.</doc>
          <type name="Volume" c:type="GVolume*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="guess_content_type" invoker="guess_content_type" version="2.18">
        <doc xml:space="preserve">Tries to guess the type of content stored on @mount. Returns one or
more textual identifiers of well-known content types (typically
prefixed with "x-content/"), e.g. x-content/image-dcf for camera
memory cards. See the
[shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
specification for more on x-content types.

This is an asynchronous operation (see
g_mount_guess_content_type_sync() for the synchronous version), and
is finished by calling g_mount_guess_content_type_finish() with the
@mount and #GAsyncResult data returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="force_rescan" transfer-ownership="none">
            <doc xml:space="preserve">Whether to force a rescan of the content.
    Otherwise a cached result will be used if available</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">user data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="guess_content_type_finish" invoker="guess_content_type_finish" version="2.18" throws="1">
        <doc xml:space="preserve">Finishes guessing content types of @mount. If any errors occurred
during the operation, @error will be set to contain the errors and
%FALSE will be returned. In particular, you may get an
%G_IO_ERROR_NOT_SUPPORTED if the mount does not support content
guessing.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a %NULL-terminated array of content types or %NULL on error.
    Caller should free this array with g_strfreev() when done with it.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="guess_content_type_sync" invoker="guess_content_type_sync" version="2.18" throws="1">
        <doc xml:space="preserve">Tries to guess the type of content stored on @mount. Returns one or
more textual identifiers of well-known content types (typically
prefixed with "x-content/"), e.g. x-content/image-dcf for camera
memory cards. See the
[shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
specification for more on x-content types.

This is an synchronous operation and as such may block doing IO;
see g_mount_guess_content_type() for the asynchronous version.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a %NULL-terminated array of content types or %NULL on error.
    Caller should free this array with g_strfreev() when done with it.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="force_rescan" transfer-ownership="none">
            <doc xml:space="preserve">Whether to force a rescan of the content.
    Otherwise a cached result will be used if available</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="pre_unmount">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remount" invoker="remount">
        <doc xml:space="preserve">Remounts a mount. This is an asynchronous operation, and is
finished by calling g_mount_remount_finish() with the @mount
and #GAsyncResults data returned in the @callback.

Remounting is useful when some setting affecting the operation
of the volume has been changed, as these may need a remount to
take affect. While this is semantically equivalent with unmounting
and then remounting not all backends might need to actually be
unmounted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the operation</doc>
            <type name="MountMountFlags" c:type="GMountMountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation or %NULL to avoid
    user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remount_finish" invoker="remount_finish" throws="1">
        <doc xml:space="preserve">Finishes remounting a mount. If any errors occurred during the operation,
@error will be set to contain the errors and %FALSE will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the mount was successfully remounted. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unmount" invoker="unmount" deprecated="1" deprecated-version="2.22">
        <doc xml:space="preserve">Unmounts a mount. This is an asynchronous operation, and is
finished by calling g_mount_unmount_finish() with the @mount
and #GAsyncResult data returned in the @callback.</doc>
        <doc-deprecated xml:space="preserve">Use g_mount_unmount_with_operation() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unmount_finish" invoker="unmount_finish" deprecated="1" deprecated-version="2.22" throws="1">
        <doc xml:space="preserve">Finishes unmounting a mount. If any errors occurred during the operation,
@error will be set to contain the errors and %FALSE will be returned.</doc>
        <doc-deprecated xml:space="preserve">Use g_mount_unmount_with_operation_finish() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the mount was successfully unmounted. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unmount_with_operation" invoker="unmount_with_operation" version="2.22">
        <doc xml:space="preserve">Unmounts a mount. This is an asynchronous operation, and is
finished by calling g_mount_unmount_with_operation_finish() with the @mount
and #GAsyncResult data returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation or %NULL to avoid
    user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unmount_with_operation_finish" invoker="unmount_with_operation_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes unmounting a mount. If any errors occurred during the operation,
@error will be set to contain the errors and %FALSE will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the mount was successfully unmounted. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unmounted">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="can_eject" c:identifier="g_mount_can_eject">
        <doc xml:space="preserve">Checks if @mount can be ejected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @mount can be ejected.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="can_unmount" c:identifier="g_mount_can_unmount">
        <doc xml:space="preserve">Checks if @mount can be unmounted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @mount can be unmounted.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="eject" c:identifier="g_mount_eject" deprecated="1" deprecated-version="2.22">
        <doc xml:space="preserve">Ejects a mount. This is an asynchronous operation, and is
finished by calling g_mount_eject_finish() with the @mount
and #GAsyncResult data returned in the @callback.</doc>
        <doc-deprecated xml:space="preserve">Use g_mount_eject_with_operation() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the unmount if required for eject</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="eject_finish" c:identifier="g_mount_eject_finish" deprecated="1" deprecated-version="2.22" throws="1">
        <doc xml:space="preserve">Finishes ejecting a mount. If any errors occurred during the operation,
@error will be set to contain the errors and %FALSE will be returned.</doc>
        <doc-deprecated xml:space="preserve">Use g_mount_eject_with_operation_finish() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the mount was successfully ejected. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="eject_with_operation" c:identifier="g_mount_eject_with_operation" version="2.22">
        <doc xml:space="preserve">Ejects a mount. This is an asynchronous operation, and is
finished by calling g_mount_eject_with_operation_finish() with the @mount
and #GAsyncResult data returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the unmount if required for eject</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation or %NULL to avoid
    user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="eject_with_operation_finish" c:identifier="g_mount_eject_with_operation_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes ejecting a mount. If any errors occurred during the operation,
@error will be set to contain the errors and %FALSE will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the mount was successfully ejected. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_default_location" c:identifier="g_mount_get_default_location">
        <doc xml:space="preserve">Gets the default location of @mount. The default location of the given
@mount is a path that reflects the main entry point for the user (e.g.
the home directory, or the root of the volume).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFile.
     The returned object should be unreffed with
     g_object_unref() when no longer needed.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_drive" c:identifier="g_mount_get_drive">
        <doc xml:space="preserve">Gets the drive for the @mount.

This is a convenience method for getting the #GVolume and then
using that object to get the #GDrive.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #GDrive or %NULL if @mount is not
     associated with a volume or a drive.
     The returned object should be unreffed with
     g_object_unref() when no longer needed.</doc>
          <type name="Drive" c:type="GDrive*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_icon" c:identifier="g_mount_get_icon">
        <doc xml:space="preserve">Gets the icon for @mount.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GIcon.
     The returned object should be unreffed with
     g_object_unref() when no longer needed.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="g_mount_get_name">
        <doc xml:space="preserve">Gets the name of @mount.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the name for the given @mount.
    The returned string should be freed with g_free()
    when no longer needed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_root" c:identifier="g_mount_get_root">
        <doc xml:space="preserve">Gets the root directory on @mount.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFile.
     The returned object should be unreffed with
     g_object_unref() when no longer needed.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sort_key" c:identifier="g_mount_get_sort_key" version="2.32">
        <doc xml:space="preserve">Gets the sort key for @mount, if any.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">Sorting key for @mount or %NULL if no such key is available.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">A #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_symbolic_icon" c:identifier="g_mount_get_symbolic_icon" version="2.34">
        <doc xml:space="preserve">Gets the symbolic icon for @mount.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GIcon.
     The returned object should be unreffed with
     g_object_unref() when no longer needed.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uuid" c:identifier="g_mount_get_uuid">
        <doc xml:space="preserve">Gets the UUID for the @mount. The reference is typically based on
the file system UUID for the mount in question and should be
considered an opaque string. Returns %NULL if there is no UUID
available.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the UUID for @mount or %NULL if no UUID
    can be computed.
    The returned string should be freed with g_free()
    when no longer needed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_volume" c:identifier="g_mount_get_volume">
        <doc xml:space="preserve">Gets the volume for the @mount.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #GVolume or %NULL if @mount is not
     associated with a volume.
     The returned object should be unreffed with
     g_object_unref() when no longer needed.</doc>
          <type name="Volume" c:type="GVolume*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="guess_content_type" c:identifier="g_mount_guess_content_type" version="2.18">
        <doc xml:space="preserve">Tries to guess the type of content stored on @mount. Returns one or
more textual identifiers of well-known content types (typically
prefixed with "x-content/"), e.g. x-content/image-dcf for camera
memory cards. See the
[shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
specification for more on x-content types.

This is an asynchronous operation (see
g_mount_guess_content_type_sync() for the synchronous version), and
is finished by calling g_mount_guess_content_type_finish() with the
@mount and #GAsyncResult data returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="force_rescan" transfer-ownership="none">
            <doc xml:space="preserve">Whether to force a rescan of the content.
    Otherwise a cached result will be used if available</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="guess_content_type_finish" c:identifier="g_mount_guess_content_type_finish" version="2.18" throws="1">
        <doc xml:space="preserve">Finishes guessing content types of @mount. If any errors occurred
during the operation, @error will be set to contain the errors and
%FALSE will be returned. In particular, you may get an
%G_IO_ERROR_NOT_SUPPORTED if the mount does not support content
guessing.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a %NULL-terminated array of content types or %NULL on error.
    Caller should free this array with g_strfreev() when done with it.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="guess_content_type_sync" c:identifier="g_mount_guess_content_type_sync" version="2.18" throws="1">
        <doc xml:space="preserve">Tries to guess the type of content stored on @mount. Returns one or
more textual identifiers of well-known content types (typically
prefixed with "x-content/"), e.g. x-content/image-dcf for camera
memory cards. See the
[shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
specification for more on x-content types.

This is an synchronous operation and as such may block doing IO;
see g_mount_guess_content_type() for the asynchronous version.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a %NULL-terminated array of content types or %NULL on error.
    Caller should free this array with g_strfreev() when done with it.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="force_rescan" transfer-ownership="none">
            <doc xml:space="preserve">Whether to force a rescan of the content.
    Otherwise a cached result will be used if available</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_shadowed" c:identifier="g_mount_is_shadowed" version="2.20">
        <doc xml:space="preserve">Determines if @mount is shadowed. Applications or libraries should
avoid displaying @mount in the user interface if it is shadowed.

A mount is said to be shadowed if there exists one or more user
visible objects (currently #GMount objects) with a root that is
inside the root of @mount.

One application of shadow mounts is when exposing a single file
system that is used to address several logical volumes. In this
situation, a #GVolumeMonitor implementation would create two
#GVolume objects (for example, one for the camera functionality of
the device and one for a SD card reader on the device) with
activation URIs `gphoto2://[usb:001,002]/store1/`
and `gphoto2://[usb:001,002]/store2/`. When the
underlying mount (with root
`gphoto2://[usb:001,002]/`) is mounted, said
#GVolumeMonitor implementation would create two #GMount objects
(each with their root matching the corresponding volume activation
root) that would shadow the original mount.

The proxy monitor in GVfs 2.26 and later, automatically creates and
manage shadow mounts (and shadows the underlying mount) if the
activation root on a #GVolume is set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @mount is shadowed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">A #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remount" c:identifier="g_mount_remount">
        <doc xml:space="preserve">Remounts a mount. This is an asynchronous operation, and is
finished by calling g_mount_remount_finish() with the @mount
and #GAsyncResults data returned in the @callback.

Remounting is useful when some setting affecting the operation
of the volume has been changed, as these may need a remount to
take affect. While this is semantically equivalent with unmounting
and then remounting not all backends might need to actually be
unmounted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the operation</doc>
            <type name="MountMountFlags" c:type="GMountMountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation or %NULL to avoid
    user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remount_finish" c:identifier="g_mount_remount_finish" throws="1">
        <doc xml:space="preserve">Finishes remounting a mount. If any errors occurred during the operation,
@error will be set to contain the errors and %FALSE will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the mount was successfully remounted. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="shadow" c:identifier="g_mount_shadow" version="2.20">
        <doc xml:space="preserve">Increments the shadow count on @mount. Usually used by
#GVolumeMonitor implementations when creating a shadow mount for
@mount, see g_mount_is_shadowed() for more information. The caller
will need to emit the #GMount::changed signal on @mount manually.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">A #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unmount" c:identifier="g_mount_unmount" deprecated="1" deprecated-version="2.22">
        <doc xml:space="preserve">Unmounts a mount. This is an asynchronous operation, and is
finished by calling g_mount_unmount_finish() with the @mount
and #GAsyncResult data returned in the @callback.</doc>
        <doc-deprecated xml:space="preserve">Use g_mount_unmount_with_operation() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unmount_finish" c:identifier="g_mount_unmount_finish" deprecated="1" deprecated-version="2.22" throws="1">
        <doc xml:space="preserve">Finishes unmounting a mount. If any errors occurred during the operation,
@error will be set to contain the errors and %FALSE will be returned.</doc>
        <doc-deprecated xml:space="preserve">Use g_mount_unmount_with_operation_finish() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the mount was successfully unmounted. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unmount_with_operation" c:identifier="g_mount_unmount_with_operation" version="2.22">
        <doc xml:space="preserve">Unmounts a mount. This is an asynchronous operation, and is
finished by calling g_mount_unmount_with_operation_finish() with the @mount
and #GAsyncResult data returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation or %NULL to avoid
    user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unmount_with_operation_finish" c:identifier="g_mount_unmount_with_operation_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes unmounting a mount. If any errors occurred during the operation,
@error will be set to contain the errors and %FALSE will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the mount was successfully unmounted. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unshadow" c:identifier="g_mount_unshadow" version="2.20">
        <doc xml:space="preserve">Decrements the shadow count on @mount. Usually used by
#GVolumeMonitor implementations when destroying a shadow mount for
@mount, see g_mount_is_shadowed() for more information. The caller
will need to emit the #GMount::changed signal on @mount manually.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">A #GMount.</doc>
            <type name="Mount" c:type="GMount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <glib:signal name="changed" when="last">
        <doc xml:space="preserve">Emitted when the mount has been changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="pre-unmount" when="last" version="2.22">
        <doc xml:space="preserve">This signal may be emitted when the #GMount is about to be
unmounted.

This signal depends on the backend and is only emitted if
GIO was used to unmount.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="unmounted" when="last">
        <doc xml:space="preserve">This signal is emitted when the #GMount have been
unmounted. If the recipient is holding references to the
object they should release them so the object can be
finalized.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </interface>
    <record name="MountIface" c:type="GMountIface" glib:is-gtype-struct-for="Mount">
      <doc xml:space="preserve">Interface for implementing operations for mounts.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="changed">
        <callback name="changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unmounted">
        <callback name="unmounted">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_root">
        <callback name="get_root">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFile.
     The returned object should be unreffed with
     g_object_unref() when no longer needed.</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <doc xml:space="preserve">a #GMount.</doc>
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_name">
        <callback name="get_name">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the name for the given @mount.
    The returned string should be freed with g_free()
    when no longer needed.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <doc xml:space="preserve">a #GMount.</doc>
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_icon">
        <callback name="get_icon">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GIcon.
     The returned object should be unreffed with
     g_object_unref() when no longer needed.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <doc xml:space="preserve">a #GMount.</doc>
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_uuid">
        <callback name="get_uuid">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">the UUID for @mount or %NULL if no UUID
    can be computed.
    The returned string should be freed with g_free()
    when no longer needed.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <doc xml:space="preserve">a #GMount.</doc>
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_volume">
        <callback name="get_volume">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">a #GVolume or %NULL if @mount is not
     associated with a volume.
     The returned object should be unreffed with
     g_object_unref() when no longer needed.</doc>
            <type name="Volume" c:type="GVolume*"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <doc xml:space="preserve">a #GMount.</doc>
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_drive">
        <callback name="get_drive">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">a #GDrive or %NULL if @mount is not
     associated with a volume or a drive.
     The returned object should be unreffed with
     g_object_unref() when no longer needed.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <doc xml:space="preserve">a #GMount.</doc>
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_unmount">
        <callback name="can_unmount">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the @mount can be unmounted.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <doc xml:space="preserve">a #GMount.</doc>
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_eject">
        <callback name="can_eject">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the @mount can be ejected.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <doc xml:space="preserve">a #GMount.</doc>
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unmount">
        <callback name="unmount">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <doc xml:space="preserve">a #GMount.</doc>
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags affecting the operation</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">user data passed to @callback.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unmount_finish">
        <callback name="unmount_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the mount was successfully unmounted. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <doc xml:space="preserve">a #GMount.</doc>
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject">
        <callback name="eject">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <doc xml:space="preserve">a #GMount.</doc>
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags affecting the unmount if required for eject</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">user data passed to @callback.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_finish">
        <callback name="eject_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the mount was successfully ejected. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <doc xml:space="preserve">a #GMount.</doc>
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remount">
        <callback name="remount">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <doc xml:space="preserve">a #GMount.</doc>
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags affecting the operation</doc>
              <type name="MountMountFlags" c:type="GMountMountFlags"/>
            </parameter>
            <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GMountOperation or %NULL to avoid
    user interaction.</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">user data passed to @callback.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remount_finish">
        <callback name="remount_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the mount was successfully remounted. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <doc xml:space="preserve">a #GMount.</doc>
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="guess_content_type">
        <callback name="guess_content_type">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <doc xml:space="preserve">a #GMount</doc>
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="force_rescan" transfer-ownership="none">
              <doc xml:space="preserve">Whether to force a rescan of the content.
    Otherwise a cached result will be used if available</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">a #GAsyncReadyCallback</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">user data passed to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="guess_content_type_finish">
        <callback name="guess_content_type_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a %NULL-terminated array of content types or %NULL on error.
    Caller should free this array with g_strfreev() when done with it.</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <doc xml:space="preserve">a #GMount</doc>
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="guess_content_type_sync">
        <callback name="guess_content_type_sync" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a %NULL-terminated array of content types or %NULL on error.
    Caller should free this array with g_strfreev() when done with it.</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <doc xml:space="preserve">a #GMount</doc>
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="force_rescan" transfer-ownership="none">
              <doc xml:space="preserve">Whether to force a rescan of the content.
    Otherwise a cached result will be used if available</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="pre_unmount">
        <callback name="pre_unmount">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unmount_with_operation">
        <callback name="unmount_with_operation">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <doc xml:space="preserve">a #GMount.</doc>
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags affecting the operation</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GMountOperation or %NULL to avoid
    user interaction.</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">user data passed to @callback.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unmount_with_operation_finish">
        <callback name="unmount_with_operation_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the mount was successfully unmounted. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <doc xml:space="preserve">a #GMount.</doc>
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_with_operation">
        <callback name="eject_with_operation">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <doc xml:space="preserve">a #GMount.</doc>
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags affecting the unmount if required for eject</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GMountOperation or %NULL to avoid
    user interaction.</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">user data passed to @callback.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_with_operation_finish">
        <callback name="eject_with_operation_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the mount was successfully ejected. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <doc xml:space="preserve">a #GMount.</doc>
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_default_location">
        <callback name="get_default_location">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFile.
     The returned object should be unreffed with
     g_object_unref() when no longer needed.</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <doc xml:space="preserve">a #GMount.</doc>
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_sort_key">
        <callback name="get_sort_key">
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve">Sorting key for @mount or %NULL if no such key is available.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <doc xml:space="preserve">A #GMount.</doc>
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_symbolic_icon">
        <callback name="get_symbolic_icon">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GIcon.
     The returned object should be unreffed with
     g_object_unref() when no longer needed.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <doc xml:space="preserve">a #GMount.</doc>
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <bitfield name="MountMountFlags" glib:type-name="GMountMountFlags" glib:get-type="g_mount_mount_flags_get_type" c:type="GMountMountFlags">
      <doc xml:space="preserve">Flags used when mounting a mount.</doc>
      <member name="none" value="0" c:identifier="G_MOUNT_MOUNT_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
    </bitfield>
    <class name="MountOperation" c:symbol-prefix="mount_operation" c:type="GMountOperation" parent="GObject.Object" glib:type-name="GMountOperation" glib:get-type="g_mount_operation_get_type" glib:type-struct="MountOperationClass">
      <doc xml:space="preserve">#GMountOperation provides a mechanism for interacting with the user.
It can be used for authenticating mountable operations, such as loop
mounting files, hard drive partitions or server locations. It can
also be used to ask the user questions or show a list of applications
preventing unmount or eject operations from completing.

Note that #GMountOperation is used for more than just #GMount
objects &#x2013; for example it is also used in g_drive_start() and
g_drive_stop().

Users should instantiate a subclass of this that implements all the
various callbacks to show the required dialogs, such as
#GtkMountOperation. If no user interaction is desired (for example
when automounting filesystems at login time), usually %NULL can be
passed, see each method taking a #GMountOperation for details.

The term &#x2018;TCRYPT&#x2019; is used to mean &#x2018;compatible with TrueCrypt and VeraCrypt&#x2019;.
[TrueCrypt](https://en.wikipedia.org/wiki/TrueCrypt) is a discontinued system for
encrypting file containers, partitions or whole disks, typically used with Windows.
[VeraCrypt](https://www.veracrypt.fr/) is a maintained fork of TrueCrypt with various
improvements and auditing fixes.</doc>
      <constructor name="new" c:identifier="g_mount_operation_new">
        <doc xml:space="preserve">Creates a new mount operation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GMountOperation.</doc>
          <type name="MountOperation" c:type="GMountOperation*"/>
        </return-value>
      </constructor>
      <virtual-method name="aborted">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <type name="MountOperation" c:type="GMountOperation*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="ask_password">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <type name="MountOperation" c:type="GMountOperation*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="default_user" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="default_domain" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="AskPasswordFlags" c:type="GAskPasswordFlags"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="ask_question">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <type name="MountOperation" c:type="GMountOperation*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="choices" transfer-ownership="none">
            <array c:type="const char**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="reply" invoker="reply">
        <doc xml:space="preserve">Emits the #GMountOperation::reply signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <doc xml:space="preserve">a #GMountOperation</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GMountOperationResult</doc>
            <type name="MountOperationResult" c:type="GMountOperationResult"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="show_processes" version="2.22">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <type name="MountOperation" c:type="GMountOperation*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="processes" transfer-ownership="none">
            <array name="GLib.Array" c:type="GArray*">
              <type name="GLib.Pid"/>
            </array>
          </parameter>
          <parameter name="choices" transfer-ownership="none">
            <array c:type="const gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="show_unmount_progress">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <type name="MountOperation" c:type="GMountOperation*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="time_left" transfer-ownership="none">
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="bytes_left" transfer-ownership="none">
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_anonymous" c:identifier="g_mount_operation_get_anonymous">
        <doc xml:space="preserve">Check to see whether the mount operation is being used
for an anonymous user.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if mount operation is anonymous.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <doc xml:space="preserve">a #GMountOperation.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_choice" c:identifier="g_mount_operation_get_choice">
        <doc xml:space="preserve">Gets a choice from the mount operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an integer containing an index of the user's choice from
the choice's list, or %0.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <doc xml:space="preserve">a #GMountOperation.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_domain" c:identifier="g_mount_operation_get_domain">
        <doc xml:space="preserve">Gets the domain of the mount operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string set to the domain.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <doc xml:space="preserve">a #GMountOperation.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_tcrypt_hidden_volume" c:identifier="g_mount_operation_get_is_tcrypt_hidden_volume" version="2.58">
        <doc xml:space="preserve">Check to see whether the mount operation is being used
for a TCRYPT hidden volume.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if mount operation is for hidden volume.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <doc xml:space="preserve">a #GMountOperation.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_tcrypt_system_volume" c:identifier="g_mount_operation_get_is_tcrypt_system_volume" version="2.58">
        <doc xml:space="preserve">Check to see whether the mount operation is being used
for a TCRYPT system volume.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if mount operation is for system volume.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <doc xml:space="preserve">a #GMountOperation.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password" c:identifier="g_mount_operation_get_password">
        <doc xml:space="preserve">Gets a password from the mount operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string containing the password within @op.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <doc xml:space="preserve">a #GMountOperation.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password_save" c:identifier="g_mount_operation_get_password_save">
        <doc xml:space="preserve">Gets the state of saving passwords for the mount operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GPasswordSave flag.</doc>
          <type name="PasswordSave" c:type="GPasswordSave"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <doc xml:space="preserve">a #GMountOperation.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pim" c:identifier="g_mount_operation_get_pim" version="2.58">
        <doc xml:space="preserve">Gets a PIM from the mount operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The VeraCrypt PIM within @op.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <doc xml:space="preserve">a #GMountOperation.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_username" c:identifier="g_mount_operation_get_username">
        <doc xml:space="preserve">Get the user name from the mount operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string containing the user name.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <doc xml:space="preserve">a #GMountOperation.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reply" c:identifier="g_mount_operation_reply">
        <doc xml:space="preserve">Emits the #GMountOperation::reply signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <doc xml:space="preserve">a #GMountOperation</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GMountOperationResult</doc>
            <type name="MountOperationResult" c:type="GMountOperationResult"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_anonymous" c:identifier="g_mount_operation_set_anonymous">
        <doc xml:space="preserve">Sets the mount operation to use an anonymous user if @anonymous is %TRUE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <doc xml:space="preserve">a #GMountOperation.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </instance-parameter>
          <parameter name="anonymous" transfer-ownership="none">
            <doc xml:space="preserve">boolean value.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_choice" c:identifier="g_mount_operation_set_choice">
        <doc xml:space="preserve">Sets a default choice for the mount operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <doc xml:space="preserve">a #GMountOperation.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </instance-parameter>
          <parameter name="choice" transfer-ownership="none">
            <doc xml:space="preserve">an integer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_domain" c:identifier="g_mount_operation_set_domain">
        <doc xml:space="preserve">Sets the mount operation's domain.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <doc xml:space="preserve">a #GMountOperation.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </instance-parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">the domain to set.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_is_tcrypt_hidden_volume" c:identifier="g_mount_operation_set_is_tcrypt_hidden_volume" version="2.58">
        <doc xml:space="preserve">Sets the mount operation to use a hidden volume if @hidden_volume is %TRUE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <doc xml:space="preserve">a #GMountOperation.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </instance-parameter>
          <parameter name="hidden_volume" transfer-ownership="none">
            <doc xml:space="preserve">boolean value.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_is_tcrypt_system_volume" c:identifier="g_mount_operation_set_is_tcrypt_system_volume" version="2.58">
        <doc xml:space="preserve">Sets the mount operation to use a system volume if @system_volume is %TRUE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <doc xml:space="preserve">a #GMountOperation.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </instance-parameter>
          <parameter name="system_volume" transfer-ownership="none">
            <doc xml:space="preserve">boolean value.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_password" c:identifier="g_mount_operation_set_password">
        <doc xml:space="preserve">Sets the mount operation's password to @password.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <doc xml:space="preserve">a #GMountOperation.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </instance-parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">password to set.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_password_save" c:identifier="g_mount_operation_set_password_save">
        <doc xml:space="preserve">Sets the state of saving passwords for the mount operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <doc xml:space="preserve">a #GMountOperation.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </instance-parameter>
          <parameter name="save" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GPasswordSave flags.</doc>
            <type name="PasswordSave" c:type="GPasswordSave"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pim" c:identifier="g_mount_operation_set_pim" version="2.58">
        <doc xml:space="preserve">Sets the mount operation's PIM to @pim.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <doc xml:space="preserve">a #GMountOperation.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </instance-parameter>
          <parameter name="pim" transfer-ownership="none">
            <doc xml:space="preserve">an unsigned integer.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_username" c:identifier="g_mount_operation_set_username">
        <doc xml:space="preserve">Sets the user name within @op to @username.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <doc xml:space="preserve">a #GMountOperation.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </instance-parameter>
          <parameter name="username" transfer-ownership="none">
            <doc xml:space="preserve">input username.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="anonymous" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether to use an anonymous user when authenticating.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="choice" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The index of the user's choice when a question is asked during the
mount operation. See the #GMountOperation::ask-question signal.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="domain" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The domain to use for the mount operation.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="is-tcrypt-hidden-volume" version="2.58" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether the device to be unlocked is a TCRYPT hidden volume.
See https://www.veracrypt.fr/en/Hidden%20Volume.html.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="is-tcrypt-system-volume" version="2.58" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether the device to be unlocked is a TCRYPT system volume.
In this context, a system volume is a volume with a bootloader
and operating system installed. This is only supported for Windows
operating systems. For further documentation, see
https://www.veracrypt.fr/en/System%20Encryption.html.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="password" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The password that is used for authentication when carrying out
the mount operation.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="password-save" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Determines if and how the password information should be saved.</doc>
        <type name="PasswordSave"/>
      </property>
      <property name="pim" version="2.58" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The VeraCrypt PIM value, when unlocking a VeraCrypt volume. See
https://www.veracrypt.fr/en/Personal%20Iterations%20Multiplier%20(PIM).html.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="username" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The user name that is used for authentication when carrying out
the mount operation.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="MountOperationPrivate" c:type="GMountOperationPrivate*"/>
      </field>
      <glib:signal name="aborted" when="last" version="2.20">
        <doc xml:space="preserve">Emitted by the backend when e.g. a device becomes unavailable
while a mount operation is in progress.

Implementations of GMountOperation should handle this signal
by dismissing open password dialogs.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="ask-password" when="last">
        <doc xml:space="preserve">Emitted when a mount operation asks the user for a password.

If the message contains a line break, the first line should be
presented as a heading. For example, it may be used as the
primary text in a #GtkMessageDialog.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">string containing a message to display to the user.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="default_user" transfer-ownership="none">
            <doc xml:space="preserve">string containing the default user name.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="default_domain" transfer-ownership="none">
            <doc xml:space="preserve">string containing the default domain.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GAskPasswordFlags.</doc>
            <type name="AskPasswordFlags"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="ask-question" when="last">
        <doc xml:space="preserve">Emitted when asking the user a question and gives a list of
choices for the user to choose from.

If the message contains a line break, the first line should be
presented as a heading. For example, it may be used as the
primary text in a #GtkMessageDialog.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">string containing a message to display to the user.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="choices" transfer-ownership="none">
            <doc xml:space="preserve">an array of strings for each possible choice.</doc>
            <array>
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="reply" when="last">
        <doc xml:space="preserve">Emitted when the user has replied to the mount operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GMountOperationResult indicating how the request was handled</doc>
            <type name="MountOperationResult"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="show-processes" when="last" version="2.22">
        <doc xml:space="preserve">Emitted when one or more processes are blocking an operation
e.g. unmounting/ejecting a #GMount or stopping a #GDrive.

Note that this signal may be emitted several times to update the
list of blocking processes as processes close files. The
application should only respond with g_mount_operation_reply() to
the latest signal (setting #GMountOperation:choice to the choice
the user made).

If the message contains a line break, the first line should be
presented as a heading. For example, it may be used as the
primary text in a #GtkMessageDialog.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">string containing a message to display to the user.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="processes" transfer-ownership="none">
            <doc xml:space="preserve">an array of #GPid for processes
  blocking the operation.</doc>
            <array name="GLib.Array">
              <type name="GLib.Pid"/>
            </array>
          </parameter>
          <parameter name="choices" transfer-ownership="none">
            <doc xml:space="preserve">an array of strings for each possible choice.</doc>
            <array>
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="show-unmount-progress" when="last" version="2.34">
        <doc xml:space="preserve">Emitted when an unmount operation has been busy for more than some time
(typically 1.5 seconds).

When unmounting or ejecting a volume, the kernel might need to flush
pending data in its buffers to the volume stable storage, and this operation
can take a considerable amount of time. This signal may be emitted several
times as long as the unmount operation is outstanding, and then one
last time when the operation is completed, with @bytes_left set to zero.

Implementations of GMountOperation should handle this signal by
showing an UI notification, and then dismiss it, or show another notification
of completion, when @bytes_left reaches zero.

If the message contains a line break, the first line should be
presented as a heading. For example, it may be used as the
primary text in a #GtkMessageDialog.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">string containing a mesage to display to the user</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="time_left" transfer-ownership="none">
            <doc xml:space="preserve">the estimated time left before the operation completes,
    in microseconds, or -1</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="bytes_left" transfer-ownership="none">
            <doc xml:space="preserve">the amount of bytes to be written before the operation
    completes (or -1 if such amount is not known), or zero if the operation
    is completed</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="MountOperationClass" c:type="GMountOperationClass" glib:is-gtype-struct-for="MountOperation">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="ask_password">
        <callback name="ask_password">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="op" transfer-ownership="none">
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="default_user" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="default_domain" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <type name="AskPasswordFlags" c:type="GAskPasswordFlags"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="ask_question">
        <callback name="ask_question">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="op" transfer-ownership="none">
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="choices" transfer-ownership="none">
              <array c:type="const char**">
                <type name="utf8"/>
              </array>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reply">
        <callback name="reply">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="op" transfer-ownership="none">
              <doc xml:space="preserve">a #GMountOperation</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GMountOperationResult</doc>
              <type name="MountOperationResult" c:type="GMountOperationResult"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="aborted">
        <callback name="aborted">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="op" transfer-ownership="none">
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="show_processes">
        <callback name="show_processes">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="op" transfer-ownership="none">
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="processes" transfer-ownership="none">
              <array name="GLib.Array" c:type="GArray*">
                <type name="GLib.Pid"/>
              </array>
            </parameter>
            <parameter name="choices" transfer-ownership="none">
              <array c:type="const gchar**">
                <type name="utf8"/>
              </array>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="show_unmount_progress">
        <callback name="show_unmount_progress">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="op" transfer-ownership="none">
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="time_left" transfer-ownership="none">
              <type name="gint64" c:type="gint64"/>
            </parameter>
            <parameter name="bytes_left" transfer-ownership="none">
              <type name="gint64" c:type="gint64"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved6" introspectable="0">
        <callback name="_g_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved7" introspectable="0">
        <callback name="_g_reserved7">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved8" introspectable="0">
        <callback name="_g_reserved8">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved9" introspectable="0">
        <callback name="_g_reserved9">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="MountOperationPrivate" c:type="GMountOperationPrivate" disguised="1">
    </record>
    <enumeration name="MountOperationResult" glib:type-name="GMountOperationResult" glib:get-type="g_mount_operation_result_get_type" c:type="GMountOperationResult">
      <doc xml:space="preserve">#GMountOperationResult is returned as a result when a request for
information is send by the mounting operation.</doc>
      <member name="handled" value="0" c:identifier="G_MOUNT_OPERATION_HANDLED" glib:nick="handled">
        <doc xml:space="preserve">The request was fulfilled and the
    user specified data is now available</doc>
      </member>
      <member name="aborted" value="1" c:identifier="G_MOUNT_OPERATION_ABORTED" glib:nick="aborted">
        <doc xml:space="preserve">The user requested the mount operation
    to be aborted</doc>
      </member>
      <member name="unhandled" value="2" c:identifier="G_MOUNT_OPERATION_UNHANDLED" glib:nick="unhandled">
        <doc xml:space="preserve">The request was unhandled (i.e. not
    implemented)</doc>
      </member>
    </enumeration>
    <bitfield name="MountUnmountFlags" glib:type-name="GMountUnmountFlags" glib:get-type="g_mount_unmount_flags_get_type" c:type="GMountUnmountFlags">
      <doc xml:space="preserve">Flags used when an unmounting a mount.</doc>
      <member name="none" value="0" c:identifier="G_MOUNT_UNMOUNT_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
      <member name="force" value="1" c:identifier="G_MOUNT_UNMOUNT_FORCE" glib:nick="force">
        <doc xml:space="preserve">Unmount even if there are outstanding
 file operations on the mount.</doc>
      </member>
    </bitfield>
    <constant name="NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME" value="gio-native-volume-monitor" c:type="G_NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="NETWORK_MONITOR_EXTENSION_POINT_NAME" value="gio-network-monitor" c:type="G_NETWORK_MONITOR_EXTENSION_POINT_NAME" version="2.30">
      <doc xml:space="preserve">Extension point for network status monitoring functionality.
See [Extending GIO][extending-gio].</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <record name="NativeSocketAddress" c:type="GNativeSocketAddress" disguised="1">
      <doc xml:space="preserve">An socket address of some unknown native type.</doc>
    </record>
    <class name="NativeVolumeMonitor" c:symbol-prefix="native_volume_monitor" c:type="GNativeVolumeMonitor" parent="VolumeMonitor" abstract="1" glib:type-name="GNativeVolumeMonitor" glib:get-type="g_native_volume_monitor_get_type" glib:type-struct="NativeVolumeMonitorClass">
      <field name="parent_instance">
        <type name="VolumeMonitor" c:type="GVolumeMonitor"/>
      </field>
    </class>
    <record name="NativeVolumeMonitorClass" c:type="GNativeVolumeMonitorClass" glib:is-gtype-struct-for="NativeVolumeMonitor">
      <field name="parent_class">
        <type name="VolumeMonitorClass" c:type="GVolumeMonitorClass"/>
      </field>
      <field name="get_mount_for_mount_path" introspectable="0">
        <callback name="get_mount_for_mount_path" introspectable="0">
          <return-value>
            <type name="Mount" c:type="GMount*"/>
          </return-value>
          <parameters>
            <parameter name="mount_path" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="NetworkAddress" c:symbol-prefix="network_address" c:type="GNetworkAddress" parent="GObject.Object" glib:type-name="GNetworkAddress" glib:get-type="g_network_address_get_type" glib:type-struct="NetworkAddressClass">
      <doc xml:space="preserve">#GNetworkAddress provides an easy way to resolve a hostname and
then attempt to connect to that host, handling the possibility of
multiple IP addresses and multiple address families.

See #GSocketConnectable for and example of using the connectable
interface.</doc>
      <implements name="SocketConnectable"/>
      <constructor name="new" c:identifier="g_network_address_new" version="2.22">
        <doc xml:space="preserve">Creates a new #GSocketConnectable for connecting to the given
@hostname and @port.

Note that depending on the configuration of the machine, a
@hostname of `localhost` may refer to the IPv4 loopback address
only, or to both IPv4 and IPv6; use
g_network_address_new_loopback() to create a #GNetworkAddress that
is guaranteed to resolve to both addresses.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #GNetworkAddress</doc>
          <type name="NetworkAddress" c:type="GSocketConnectable*"/>
        </return-value>
        <parameters>
          <parameter name="hostname" transfer-ownership="none">
            <doc xml:space="preserve">the hostname</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">the port</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_loopback" c:identifier="g_network_address_new_loopback" version="2.44">
        <doc xml:space="preserve">Creates a new #GSocketConnectable for connecting to the local host
over a loopback connection to the given @port. This is intended for
use in connecting to local services which may be running on IPv4 or
IPv6.

The connectable will return IPv4 and IPv6 loopback addresses,
regardless of how the host resolves `localhost`. By contrast,
g_network_address_new() will often only return an IPv4 address when
resolving `localhost`, and an IPv6 address for `localhost6`.

g_network_address_get_hostname() will always return `localhost` for
#GNetworkAddresses created with this constructor.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #GNetworkAddress</doc>
          <type name="NetworkAddress" c:type="GSocketConnectable*"/>
        </return-value>
        <parameters>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">the port</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="parse" c:identifier="g_network_address_parse" version="2.22" throws="1">
        <doc xml:space="preserve">Creates a new #GSocketConnectable for connecting to the given
@hostname and @port. May fail and return %NULL in case
parsing @host_and_port fails.

@host_and_port may be in any of a number of recognised formats; an IPv6
address, an IPv4 address, or a domain name (in which case a DNS
lookup is performed). Quoting with [] is supported for all address
types. A port override may be specified in the usual way with a
colon.

If no port is specified in @host_and_port then @default_port will be
used as the port number to connect to.

In general, @host_and_port is expected to be provided by the user
(allowing them to give the hostname, and a port override if necessary)
and @default_port is expected to be provided by the application.

(The port component of @host_and_port can also be specified as a
service name rather than as a numeric port, but this functionality
is deprecated, because it depends on the contents of /etc/services,
which is generally quite sparse on platforms other than Linux.)</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new
  #GNetworkAddress, or %NULL on error</doc>
          <type name="NetworkAddress" c:type="GSocketConnectable*"/>
        </return-value>
        <parameters>
          <parameter name="host_and_port" transfer-ownership="none">
            <doc xml:space="preserve">the hostname and optionally a port</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="default_port" transfer-ownership="none">
            <doc xml:space="preserve">the default port if not in @host_and_port</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
        </parameters>
      </function>
      <function name="parse_uri" c:identifier="g_network_address_parse_uri" version="2.26" throws="1">
        <doc xml:space="preserve">Creates a new #GSocketConnectable for connecting to the given
@uri. May fail and return %NULL in case parsing @uri fails.

Using this rather than g_network_address_new() or
g_network_address_parse() allows #GSocketClient to determine
when to use application-specific proxy protocols.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new
  #GNetworkAddress, or %NULL on error</doc>
          <type name="NetworkAddress" c:type="GSocketConnectable*"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">the hostname and optionally a port</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="default_port" transfer-ownership="none">
            <doc xml:space="preserve">The default port if none is found in the URI</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_hostname" c:identifier="g_network_address_get_hostname" version="2.22">
        <doc xml:space="preserve">Gets @addr's hostname. This might be either UTF-8 or ASCII-encoded,
depending on what @addr was created with.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@addr's hostname</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #GNetworkAddress</doc>
            <type name="NetworkAddress" c:type="GNetworkAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_port" c:identifier="g_network_address_get_port" version="2.22">
        <doc xml:space="preserve">Gets @addr's port number</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@addr's port (which may be 0)</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #GNetworkAddress</doc>
            <type name="NetworkAddress" c:type="GNetworkAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_scheme" c:identifier="g_network_address_get_scheme" version="2.26">
        <doc xml:space="preserve">Gets @addr's scheme</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@addr's scheme (%NULL if not built from URI)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #GNetworkAddress</doc>
            <type name="NetworkAddress" c:type="GNetworkAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="hostname" writable="1" construct-only="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="port" writable="1" construct-only="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="scheme" writable="1" construct-only="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="NetworkAddressPrivate" c:type="GNetworkAddressPrivate*"/>
      </field>
    </class>
    <record name="NetworkAddressClass" c:type="GNetworkAddressClass" glib:is-gtype-struct-for="NetworkAddress">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="NetworkAddressPrivate" c:type="GNetworkAddressPrivate" disguised="1">
    </record>
    <enumeration name="NetworkConnectivity" version="2.44" glib:type-name="GNetworkConnectivity" glib:get-type="g_network_connectivity_get_type" c:type="GNetworkConnectivity">
      <doc xml:space="preserve">The host's network connectivity state, as reported by #GNetworkMonitor.</doc>
      <member name="local" value="1" c:identifier="G_NETWORK_CONNECTIVITY_LOCAL" glib:nick="local">
        <doc xml:space="preserve">The host is not configured with a
  route to the Internet; it may or may not be connected to a local
  network.</doc>
      </member>
      <member name="limited" value="2" c:identifier="G_NETWORK_CONNECTIVITY_LIMITED" glib:nick="limited">
        <doc xml:space="preserve">The host is connected to a network, but
  does not appear to be able to reach the full Internet, perhaps
  due to upstream network problems.</doc>
      </member>
      <member name="portal" value="3" c:identifier="G_NETWORK_CONNECTIVITY_PORTAL" glib:nick="portal">
        <doc xml:space="preserve">The host is behind a captive portal and
  cannot reach the full Internet.</doc>
      </member>
      <member name="full" value="4" c:identifier="G_NETWORK_CONNECTIVITY_FULL" glib:nick="full">
        <doc xml:space="preserve">The host is connected to a network, and
  appears to be able to reach the full Internet.</doc>
      </member>
    </enumeration>
    <interface name="NetworkMonitor" c:symbol-prefix="network_monitor" c:type="GNetworkMonitor" version="2.32" glib:type-name="GNetworkMonitor" glib:get-type="g_network_monitor_get_type" glib:type-struct="NetworkMonitorInterface">
      <doc xml:space="preserve">#GNetworkMonitor provides an easy-to-use cross-platform API
for monitoring network connectivity. On Linux, the available
implementations are based on the kernel's netlink interface and
on NetworkManager.

There is also an implementation for use inside Flatpak sandboxes.</doc>
      <prerequisite name="Initable"/>
      <function name="get_default" c:identifier="g_network_monitor_get_default" version="2.32">
        <doc xml:space="preserve">Gets the default #GNetworkMonitor for the system.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GNetworkMonitor</doc>
          <type name="NetworkMonitor" c:type="GNetworkMonitor*"/>
        </return-value>
      </function>
      <virtual-method name="can_reach" invoker="can_reach" version="2.32" throws="1">
        <doc xml:space="preserve">Attempts to determine whether or not the host pointed to by
@connectable can be reached, without actually trying to connect to
it.

This may return %TRUE even when #GNetworkMonitor:network-available
is %FALSE, if, for example, @monitor can determine that
@connectable refers to a host on a local network.

If @monitor believes that an attempt to connect to @connectable
will succeed, it will return %TRUE. Otherwise, it will return
%FALSE and set @error to an appropriate error (such as
%G_IO_ERROR_HOST_UNREACHABLE).

Note that although this does not attempt to connect to
@connectable, it may still block for a brief period of time (eg,
trying to do multicast DNS on the local network), so if you do not
want to block, you should use g_network_monitor_can_reach_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @connectable is reachable, %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="monitor" transfer-ownership="none">
            <doc xml:space="preserve">a #GNetworkMonitor</doc>
            <type name="NetworkMonitor" c:type="GNetworkMonitor*"/>
          </instance-parameter>
          <parameter name="connectable" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketConnectable</doc>
            <type name="SocketConnectable" c:type="GSocketConnectable*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="can_reach_async" invoker="can_reach_async">
        <doc xml:space="preserve">Asynchronously attempts to determine whether or not the host
pointed to by @connectable can be reached, without actually
trying to connect to it.

For more details, see g_network_monitor_can_reach().

When the operation is finished, @callback will be called.
You can then call g_network_monitor_can_reach_finish()
to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="monitor" transfer-ownership="none">
            <doc xml:space="preserve">a #GNetworkMonitor</doc>
            <type name="NetworkMonitor" c:type="GNetworkMonitor*"/>
          </instance-parameter>
          <parameter name="connectable" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketConnectable</doc>
            <type name="SocketConnectable" c:type="GSocketConnectable*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the
    request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="can_reach_finish" invoker="can_reach_finish" throws="1">
        <doc xml:space="preserve">Finishes an async network connectivity test.
See g_network_monitor_can_reach_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if network is reachable, %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="monitor" transfer-ownership="none">
            <doc xml:space="preserve">a #GNetworkMonitor</doc>
            <type name="NetworkMonitor" c:type="GNetworkMonitor*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="network_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="monitor" transfer-ownership="none">
            <type name="NetworkMonitor" c:type="GNetworkMonitor*"/>
          </instance-parameter>
          <parameter name="network_available" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="can_reach" c:identifier="g_network_monitor_can_reach" version="2.32" throws="1">
        <doc xml:space="preserve">Attempts to determine whether or not the host pointed to by
@connectable can be reached, without actually trying to connect to
it.

This may return %TRUE even when #GNetworkMonitor:network-available
is %FALSE, if, for example, @monitor can determine that
@connectable refers to a host on a local network.

If @monitor believes that an attempt to connect to @connectable
will succeed, it will return %TRUE. Otherwise, it will return
%FALSE and set @error to an appropriate error (such as
%G_IO_ERROR_HOST_UNREACHABLE).

Note that although this does not attempt to connect to
@connectable, it may still block for a brief period of time (eg,
trying to do multicast DNS on the local network), so if you do not
want to block, you should use g_network_monitor_can_reach_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @connectable is reachable, %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="monitor" transfer-ownership="none">
            <doc xml:space="preserve">a #GNetworkMonitor</doc>
            <type name="NetworkMonitor" c:type="GNetworkMonitor*"/>
          </instance-parameter>
          <parameter name="connectable" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketConnectable</doc>
            <type name="SocketConnectable" c:type="GSocketConnectable*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_reach_async" c:identifier="g_network_monitor_can_reach_async">
        <doc xml:space="preserve">Asynchronously attempts to determine whether or not the host
pointed to by @connectable can be reached, without actually
trying to connect to it.

For more details, see g_network_monitor_can_reach().

When the operation is finished, @callback will be called.
You can then call g_network_monitor_can_reach_finish()
to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="monitor" transfer-ownership="none">
            <doc xml:space="preserve">a #GNetworkMonitor</doc>
            <type name="NetworkMonitor" c:type="GNetworkMonitor*"/>
          </instance-parameter>
          <parameter name="connectable" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketConnectable</doc>
            <type name="SocketConnectable" c:type="GSocketConnectable*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the
    request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_reach_finish" c:identifier="g_network_monitor_can_reach_finish" throws="1">
        <doc xml:space="preserve">Finishes an async network connectivity test.
See g_network_monitor_can_reach_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if network is reachable, %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="monitor" transfer-ownership="none">
            <doc xml:space="preserve">a #GNetworkMonitor</doc>
            <type name="NetworkMonitor" c:type="GNetworkMonitor*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_connectivity" c:identifier="g_network_monitor_get_connectivity" version="2.44">
        <doc xml:space="preserve">Gets a more detailed networking state than
g_network_monitor_get_network_available().

If #GNetworkMonitor:network-available is %FALSE, then the
connectivity state will be %G_NETWORK_CONNECTIVITY_LOCAL.

If #GNetworkMonitor:network-available is %TRUE, then the
connectivity state will be %G_NETWORK_CONNECTIVITY_FULL (if there
is full Internet connectivity), %G_NETWORK_CONNECTIVITY_LIMITED (if
the host has a default route, but appears to be unable to actually
reach the full Internet), or %G_NETWORK_CONNECTIVITY_PORTAL (if the
host is trapped behind a "captive portal" that requires some sort
of login or acknowledgement before allowing full Internet access).

Note that in the case of %G_NETWORK_CONNECTIVITY_LIMITED and
%G_NETWORK_CONNECTIVITY_PORTAL, it is possible that some sites are
reachable but others are not. In this case, applications can
attempt to connect to remote servers, but should gracefully fall
back to their "offline" behavior if the connection attempt fails.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the network connectivity state</doc>
          <type name="NetworkConnectivity" c:type="GNetworkConnectivity"/>
        </return-value>
        <parameters>
          <instance-parameter name="monitor" transfer-ownership="none">
            <doc xml:space="preserve">the #GNetworkMonitor</doc>
            <type name="NetworkMonitor" c:type="GNetworkMonitor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_network_available" c:identifier="g_network_monitor_get_network_available" version="2.32">
        <doc xml:space="preserve">Checks if the network is available. "Available" here means that the
system has a default route available for at least one of IPv4 or
IPv6. It does not necessarily imply that the public Internet is
reachable. See #GNetworkMonitor:network-available for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the network is available</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="monitor" transfer-ownership="none">
            <doc xml:space="preserve">the #GNetworkMonitor</doc>
            <type name="NetworkMonitor" c:type="GNetworkMonitor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_network_metered" c:identifier="g_network_monitor_get_network_metered" version="2.46">
        <doc xml:space="preserve">Checks if the network is metered.
See #GNetworkMonitor:network-metered for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the connection is metered</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="monitor" transfer-ownership="none">
            <doc xml:space="preserve">the #GNetworkMonitor</doc>
            <type name="NetworkMonitor" c:type="GNetworkMonitor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="connectivity" version="2.44" transfer-ownership="none">
        <doc xml:space="preserve">More detailed information about the host's network connectivity.
See g_network_monitor_get_connectivity() and
#GNetworkConnectivity for more details.</doc>
        <type name="NetworkConnectivity"/>
      </property>
      <property name="network-available" version="2.32" transfer-ownership="none">
        <doc xml:space="preserve">Whether the network is considered available. That is, whether the
system has a default route for at least one of IPv4 or IPv6.

Real-world networks are of course much more complicated than
this; the machine may be connected to a wifi hotspot that
requires payment before allowing traffic through, or may be
connected to a functioning router that has lost its own upstream
connectivity. Some hosts might only be accessible when a VPN is
active. Other hosts might only be accessible when the VPN is
not active. Thus, it is best to use g_network_monitor_can_reach()
or g_network_monitor_can_reach_async() to test for reachability
on a host-by-host basis. (On the other hand, when the property is
%FALSE, the application can reasonably expect that no remote
hosts at all are reachable, and should indicate this to the user
in its UI.)

See also #GNetworkMonitor::network-changed.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="network-metered" version="2.46" transfer-ownership="none">
        <doc xml:space="preserve">Whether the network is considered metered. That is, whether the
system has traffic flowing through the default connection that is
subject to limitations set by service providers. For example, traffic
might be billed by the amount of data transmitted, or there might be a
quota on the amount of traffic per month. This is typical with tethered
connections (3G and 4G) and in such situations, bandwidth intensive
applications may wish to avoid network activity where possible if it will
cost the user money or use up their limited quota.

If more information is required about specific devices then the
system network management API should be used instead (for example,
NetworkManager or ConnMan).

If this information is not available then no networks will be
marked as metered.

See also #GNetworkMonitor:network-available.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <glib:signal name="network-changed" when="last" version="2.32">
        <doc xml:space="preserve">Emitted when the network configuration changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="network_available" transfer-ownership="none">
            <doc xml:space="preserve">the current value of #GNetworkMonitor:network-available</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </glib:signal>
    </interface>
    <record name="NetworkMonitorInterface" c:type="GNetworkMonitorInterface" glib:is-gtype-struct-for="NetworkMonitor" version="2.32">
      <doc xml:space="preserve">The virtual function table for #GNetworkMonitor.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="network_changed">
        <callback name="network_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="monitor" transfer-ownership="none">
              <type name="NetworkMonitor" c:type="GNetworkMonitor*"/>
            </parameter>
            <parameter name="network_available" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_reach">
        <callback name="can_reach" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @connectable is reachable, %FALSE if not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="monitor" transfer-ownership="none">
              <doc xml:space="preserve">a #GNetworkMonitor</doc>
              <type name="NetworkMonitor" c:type="GNetworkMonitor*"/>
            </parameter>
            <parameter name="connectable" transfer-ownership="none">
              <doc xml:space="preserve">a #GSocketConnectable</doc>
              <type name="SocketConnectable" c:type="GSocketConnectable*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_reach_async">
        <callback name="can_reach_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="monitor" transfer-ownership="none">
              <doc xml:space="preserve">a #GNetworkMonitor</doc>
              <type name="NetworkMonitor" c:type="GNetworkMonitor*"/>
            </parameter>
            <parameter name="connectable" transfer-ownership="none">
              <doc xml:space="preserve">a #GSocketConnectable</doc>
              <type name="SocketConnectable" c:type="GSocketConnectable*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call when the
    request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_reach_finish">
        <callback name="can_reach_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if network is reachable, %FALSE if not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="monitor" transfer-ownership="none">
              <doc xml:space="preserve">a #GNetworkMonitor</doc>
              <type name="NetworkMonitor" c:type="GNetworkMonitor*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="NetworkService" c:symbol-prefix="network_service" c:type="GNetworkService" parent="GObject.Object" glib:type-name="GNetworkService" glib:get-type="g_network_service_get_type" glib:type-struct="NetworkServiceClass">
      <doc xml:space="preserve">Like #GNetworkAddress does with hostnames, #GNetworkService
provides an easy way to resolve a SRV record, and then attempt to
connect to one of the hosts that implements that service, handling
service priority/weighting, multiple IP addresses, and multiple
address families.

See #GSrvTarget for more information about SRV records, and see
#GSocketConnectable for and example of using the connectable
interface.</doc>
      <implements name="SocketConnectable"/>
      <constructor name="new" c:identifier="g_network_service_new" version="2.22">
        <doc xml:space="preserve">Creates a new #GNetworkService representing the given @service,
@protocol, and @domain. This will initially be unresolved; use the
#GSocketConnectable interface to resolve it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GNetworkService</doc>
          <type name="NetworkService" c:type="GSocketConnectable*"/>
        </return-value>
        <parameters>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">the service type to look up (eg, "ldap")</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:space="preserve">the networking protocol to use for @service (eg, "tcp")</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">the DNS domain to look up the service in</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_domain" c:identifier="g_network_service_get_domain" version="2.22">
        <doc xml:space="preserve">Gets the domain that @srv serves. This might be either UTF-8 or
ASCII-encoded, depending on what @srv was created with.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@srv's domain name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="srv" transfer-ownership="none">
            <doc xml:space="preserve">a #GNetworkService</doc>
            <type name="NetworkService" c:type="GNetworkService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_protocol" c:identifier="g_network_service_get_protocol" version="2.22">
        <doc xml:space="preserve">Gets @srv's protocol name (eg, "tcp").</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@srv's protocol name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="srv" transfer-ownership="none">
            <doc xml:space="preserve">a #GNetworkService</doc>
            <type name="NetworkService" c:type="GNetworkService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_scheme" c:identifier="g_network_service_get_scheme" version="2.26">
        <doc xml:space="preserve">Get's the URI scheme used to resolve proxies. By default, the service name
is used as scheme.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@srv's scheme name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="srv" transfer-ownership="none">
            <doc xml:space="preserve">a #GNetworkService</doc>
            <type name="NetworkService" c:type="GNetworkService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_service" c:identifier="g_network_service_get_service" version="2.22">
        <doc xml:space="preserve">Gets @srv's service name (eg, "ldap").</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@srv's service name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="srv" transfer-ownership="none">
            <doc xml:space="preserve">a #GNetworkService</doc>
            <type name="NetworkService" c:type="GNetworkService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_scheme" c:identifier="g_network_service_set_scheme" version="2.26">
        <doc xml:space="preserve">Set's the URI scheme used to resolve proxies. By default, the service name
is used as scheme.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="srv" transfer-ownership="none">
            <doc xml:space="preserve">a #GNetworkService</doc>
            <type name="NetworkService" c:type="GNetworkService*"/>
          </instance-parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:space="preserve">a URI scheme</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="domain" writable="1" construct-only="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="protocol" writable="1" construct-only="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="scheme" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="service" writable="1" construct-only="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="NetworkServicePrivate" c:type="GNetworkServicePrivate*"/>
      </field>
    </class>
    <record name="NetworkServiceClass" c:type="GNetworkServiceClass" glib:is-gtype-struct-for="NetworkService">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="NetworkServicePrivate" c:type="GNetworkServicePrivate" disguised="1">
    </record>
    <class name="Notification" c:symbol-prefix="notification" c:type="GNotification" version="2.40" parent="GObject.Object" glib:type-name="GNotification" glib:get-type="g_notification_get_type">
      <doc xml:space="preserve">#GNotification is a mechanism for creating a notification to be shown
to the user -- typically as a pop-up notification presented by the
desktop environment shell.

The key difference between #GNotification and other similar APIs is
that, if supported by the desktop environment, notifications sent
with #GNotification will persist after the application has exited,
and even across system reboots.

Since the user may click on a notification while the application is
not running, applications using #GNotification should be able to be
started as a D-Bus service, using #GApplication.

User interaction with a notification (either the default action, or
buttons) must be associated with actions on the application (ie:
"app." actions).  It is not possible to route user interaction
through the notification itself, because the object will not exist if
the application is autostarted as a result of a notification being
clicked.

A notification can be sent with g_application_send_notification().</doc>
      <constructor name="new" c:identifier="g_notification_new" version="2.40">
        <doc xml:space="preserve">Creates a new #GNotification with @title as its title.

After populating @notification with more details, it can be sent to
the desktop shell with g_application_send_notification(). Changing
any properties after this call will not have any effect until
resending @notification.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GNotification instance</doc>
          <type name="Notification" c:type="GNotification*"/>
        </return-value>
        <parameters>
          <parameter name="title" transfer-ownership="none">
            <doc xml:space="preserve">the title of the notification</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_button" c:identifier="g_notification_add_button" version="2.40">
        <doc xml:space="preserve">Adds a button to @notification that activates the action in
@detailed_action when clicked. That action must be an
application-wide action (starting with "app."). If @detailed_action
contains a target, the action will be activated with that target as
its parameter.

See g_action_parse_detailed_name() for a description of the format
for @detailed_action.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="notification" transfer-ownership="none">
            <doc xml:space="preserve">a #GNotification</doc>
            <type name="Notification" c:type="GNotification*"/>
          </instance-parameter>
          <parameter name="label" transfer-ownership="none">
            <doc xml:space="preserve">label of the button</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="detailed_action" transfer-ownership="none">
            <doc xml:space="preserve">a detailed action name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_button_with_target" c:identifier="g_notification_add_button_with_target" shadowed-by="add_button_with_target_value" version="2.40" introspectable="0">
        <doc xml:space="preserve">Adds a button to @notification that activates @action when clicked.
@action must be an application-wide action (it must start with "app.").

If @target_format is given, it is used to collect remaining
positional parameters into a #GVariant instance, similar to
g_variant_new(). @action will be activated with that #GVariant as its
parameter.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="notification" transfer-ownership="none">
            <doc xml:space="preserve">a #GNotification</doc>
            <type name="Notification" c:type="GNotification*"/>
          </instance-parameter>
          <parameter name="label" transfer-ownership="none">
            <doc xml:space="preserve">label of the button</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve">an action name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="target_format" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GVariant format string, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">positional parameters, as determined by @target_format</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="add_button_with_target_value" c:identifier="g_notification_add_button_with_target_value" shadows="add_button_with_target" version="2.40">
        <doc xml:space="preserve">Adds a button to @notification that activates @action when clicked.
@action must be an application-wide action (it must start with "app.").

If @target is non-%NULL, @action will be activated with @target as
its parameter.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="notification" transfer-ownership="none">
            <doc xml:space="preserve">a #GNotification</doc>
            <type name="Notification" c:type="GNotification*"/>
          </instance-parameter>
          <parameter name="label" transfer-ownership="none">
            <doc xml:space="preserve">label of the button</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve">an action name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GVariant to use as @action's parameter, or %NULL</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_body" c:identifier="g_notification_set_body" version="2.40">
        <doc xml:space="preserve">Sets the body of @notification to @body.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="notification" transfer-ownership="none">
            <doc xml:space="preserve">a #GNotification</doc>
            <type name="Notification" c:type="GNotification*"/>
          </instance-parameter>
          <parameter name="body" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the new body for @notification, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_default_action" c:identifier="g_notification_set_default_action" version="2.40">
        <doc xml:space="preserve">Sets the default action of @notification to @detailed_action. This
action is activated when the notification is clicked on.

The action in @detailed_action must be an application-wide action (it
must start with "app."). If @detailed_action contains a target, the
given action will be activated with that target as its parameter.
See g_action_parse_detailed_name() for a description of the format
for @detailed_action.

When no default action is set, the application that the notification
was sent on is activated.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="notification" transfer-ownership="none">
            <doc xml:space="preserve">a #GNotification</doc>
            <type name="Notification" c:type="GNotification*"/>
          </instance-parameter>
          <parameter name="detailed_action" transfer-ownership="none">
            <doc xml:space="preserve">a detailed action name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_default_action_and_target" c:identifier="g_notification_set_default_action_and_target" shadowed-by="set_default_action_and_target_value" version="2.40" introspectable="0">
        <doc xml:space="preserve">Sets the default action of @notification to @action. This action is
activated when the notification is clicked on. It must be an
application-wide action (it must start with "app.").

If @target_format is given, it is used to collect remaining
positional parameters into a #GVariant instance, similar to
g_variant_new(). @action will be activated with that #GVariant as its
parameter.

When no default action is set, the application that the notification
was sent on is activated.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="notification" transfer-ownership="none">
            <doc xml:space="preserve">a #GNotification</doc>
            <type name="Notification" c:type="GNotification*"/>
          </instance-parameter>
          <parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve">an action name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="target_format" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GVariant format string, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">positional parameters, as determined by @target_format</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="set_default_action_and_target_value" c:identifier="g_notification_set_default_action_and_target_value" shadows="set_default_action_and_target" version="2.40">
        <doc xml:space="preserve">Sets the default action of @notification to @action. This action is
activated when the notification is clicked on. It must be an
application-wide action (start with "app.").

If @target is non-%NULL, @action will be activated with @target as
its parameter.

When no default action is set, the application that the notification
was sent on is activated.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="notification" transfer-ownership="none">
            <doc xml:space="preserve">a #GNotification</doc>
            <type name="Notification" c:type="GNotification*"/>
          </instance-parameter>
          <parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve">an action name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GVariant to use as @action's parameter, or %NULL</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_icon" c:identifier="g_notification_set_icon" version="2.40">
        <doc xml:space="preserve">Sets the icon of @notification to @icon.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="notification" transfer-ownership="none">
            <doc xml:space="preserve">a #GNotification</doc>
            <type name="Notification" c:type="GNotification*"/>
          </instance-parameter>
          <parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">the icon to be shown in @notification, as a #GIcon</doc>
            <type name="Icon" c:type="GIcon*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_priority" c:identifier="g_notification_set_priority">
        <doc xml:space="preserve">Sets the priority of @notification to @priority. See
#GNotificationPriority for possible values.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="notification" transfer-ownership="none">
            <doc xml:space="preserve">a #GNotification</doc>
            <type name="Notification" c:type="GNotification*"/>
          </instance-parameter>
          <parameter name="priority" transfer-ownership="none">
            <doc xml:space="preserve">a #GNotificationPriority</doc>
            <type name="NotificationPriority" c:type="GNotificationPriority"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_title" c:identifier="g_notification_set_title" version="2.40">
        <doc xml:space="preserve">Sets the title of @notification to @title.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="notification" transfer-ownership="none">
            <doc xml:space="preserve">a #GNotification</doc>
            <type name="Notification" c:type="GNotification*"/>
          </instance-parameter>
          <parameter name="title" transfer-ownership="none">
            <doc xml:space="preserve">the new title for @notification</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_urgent" c:identifier="g_notification_set_urgent" version="2.40" deprecated="1" deprecated-version="2.42">
        <doc xml:space="preserve">Deprecated in favor of g_notification_set_priority().</doc>
        <doc-deprecated xml:space="preserve">Since 2.42, this has been deprecated in favour of
   g_notification_set_priority().</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="notification" transfer-ownership="none">
            <doc xml:space="preserve">a #GNotification</doc>
            <type name="Notification" c:type="GNotification*"/>
          </instance-parameter>
          <parameter name="urgent" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @notification is urgent</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="NotificationPriority" version="2.42" glib:type-name="GNotificationPriority" glib:get-type="g_notification_priority_get_type" c:type="GNotificationPriority">
      <doc xml:space="preserve">Priority levels for #GNotifications.</doc>
      <member name="normal" value="0" c:identifier="G_NOTIFICATION_PRIORITY_NORMAL" glib:nick="normal">
        <doc xml:space="preserve">the default priority, to be used for the
  majority of notifications (for example email messages, software updates,
  completed download/sync operations)</doc>
      </member>
      <member name="low" value="1" c:identifier="G_NOTIFICATION_PRIORITY_LOW" glib:nick="low">
        <doc xml:space="preserve">for notifications that do not require
  immediate attention - typically used for contextual background
  information, such as contact birthdays or local weather</doc>
      </member>
      <member name="high" value="2" c:identifier="G_NOTIFICATION_PRIORITY_HIGH" glib:nick="high">
        <doc xml:space="preserve">for events that require more attention,
  usually because responses are time-sensitive (for example chat and SMS
  messages or alarms)</doc>
      </member>
      <member name="urgent" value="3" c:identifier="G_NOTIFICATION_PRIORITY_URGENT" glib:nick="urgent">
        <doc xml:space="preserve">for urgent notifications, or notifications
  that require a response in a short space of time (for example phone calls
  or emergency warnings)</doc>
      </member>
    </enumeration>
    <record name="OutputMessage" c:type="GOutputMessage" version="2.44">
      <doc xml:space="preserve">Structure used for scatter/gather data output when sending multiple
messages or packets in one go. You generally pass in an array of
#GOutputVectors and the operation will use all the buffers as if they
were one buffer.

If @address is %NULL then the message is sent to the default receiver
(as previously set by g_socket_connect()).</doc>
      <field name="address" writable="1">
        <doc xml:space="preserve">a #GSocketAddress, or %NULL</doc>
        <type name="SocketAddress" c:type="GSocketAddress*"/>
      </field>
      <field name="vectors" writable="1">
        <doc xml:space="preserve">pointer to an array of output vectors</doc>
        <type name="OutputVector" c:type="GOutputVector*"/>
      </field>
      <field name="num_vectors" writable="1">
        <doc xml:space="preserve">the number of output vectors pointed to by @vectors.</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="bytes_sent" writable="1">
        <doc xml:space="preserve">initialize to 0. Will be set to the number of bytes
    that have been sent</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="control_messages" writable="1">
        <doc xml:space="preserve">a pointer
  to an array of #GSocketControlMessages, or %NULL.</doc>
        <array length="5" zero-terminated="0" c:type="GSocketControlMessage**">
          <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
        </array>
      </field>
      <field name="num_control_messages" writable="1">
        <doc xml:space="preserve">number of elements in @control_messages.</doc>
        <type name="guint" c:type="guint"/>
      </field>
    </record>
    <class name="OutputStream" c:symbol-prefix="output_stream" c:type="GOutputStream" parent="GObject.Object" abstract="1" glib:type-name="GOutputStream" glib:get-type="g_output_stream_get_type" glib:type-struct="OutputStreamClass">
      <doc xml:space="preserve">#GOutputStream has functions to write to a stream (g_output_stream_write()),
to close a stream (g_output_stream_close()) and to flush pending writes
(g_output_stream_flush()).

To copy the content of an input stream to an output stream without
manually handling the reads and writes, use g_output_stream_splice().

See the documentation for #GIOStream for details of thread safety of
streaming APIs.

All of these functions have async variants too.</doc>
      <virtual-method name="close_async" invoker="close_async">
        <doc xml:space="preserve">Requests an asynchronous close of the stream, releasing resources
related to it. When the operation is finished @callback will be
called. You can then call g_output_stream_close_finish() to get
the result of the operation.

For behaviour details see g_output_stream_close().

The asynchronous methods have a default fallback that uses threads
to implement asynchronicity, so they are optional for inheriting
classes. However, if you override one you must override all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">A #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the io priority of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="close_finish" invoker="close_finish" throws="1">
        <doc xml:space="preserve">Closes an output stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if stream was successfully closed, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="close_fn" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="flush" invoker="flush" throws="1">
        <doc xml:space="preserve">Forces a write of all user-space buffered data for the given
@stream. Will block during the operation. Closing the stream will
implicitly cause a flush.

This function is optional for inherited classes.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="flush_async" invoker="flush_async">
        <doc xml:space="preserve">Forces an asynchronous write of all user-space buffered data for
the given @stream.
For behaviour details see g_output_stream_flush().

When the operation is finished @callback will be
called. You can then call g_output_stream_flush_finish() to get the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the io priority of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="flush_finish" invoker="flush_finish" throws="1">
        <doc xml:space="preserve">Finishes flushing an output stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if flush operation succeeded, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="splice" invoker="splice" throws="1">
        <doc xml:space="preserve">Splices an input stream into an output stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #gssize containing the size of the data spliced, or
    -1 if an error occurred. Note that if the number of bytes
    spliced is greater than %G_MAXSSIZE, then that will be
    returned, and there is no way to determine the actual number
    of bytes spliced.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GOutputStreamSpliceFlags.</doc>
            <type name="OutputStreamSpliceFlags" c:type="GOutputStreamSpliceFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="splice_async" invoker="splice_async">
        <doc xml:space="preserve">Splices a stream asynchronously.
When the operation is finished @callback will be called.
You can then call g_output_stream_splice_finish() to get the
result of the operation.

For the synchronous, blocking version of this function, see
g_output_stream_splice().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GOutputStreamSpliceFlags.</doc>
            <type name="OutputStreamSpliceFlags" c:type="GOutputStreamSpliceFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the io priority of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">a #GAsyncReadyCallback.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
            <doc xml:space="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="splice_finish" invoker="splice_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous stream splice operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #gssize of the number of bytes spliced. Note that if the
    number of bytes spliced is greater than %G_MAXSSIZE, then that
    will be returned, and there is no way to determine the actual
    number of bytes spliced.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="write_async" invoker="write_async">
        <doc xml:space="preserve">Request an asynchronous write of @count bytes from @buffer into
the stream. When the operation is finished @callback will be called.
You can then call g_output_stream_write_finish() to get the result of the
operation.

During an async request no other sync and async calls are allowed,
and will result in %G_IO_ERROR_PENDING errors.

A value of @count larger than %G_MAXSSIZE will cause a
%G_IO_ERROR_INVALID_ARGUMENT error.

On success, the number of bytes written will be passed to the
@callback. It is not an error if this is not the same as the
requested size, as it can happen e.g. on a partial I/O error,
but generally we try to write as many bytes as requested.

You are guaranteed that this method will never fail with
%G_IO_ERROR_WOULD_BLOCK - if @stream can't accept more data, the
method will just wait until this changes.

Any outstanding I/O request with higher priority (lower numerical
value) will be executed before an outstanding request with lower
priority. Default priority is %G_PRIORITY_DEFAULT.

The asynchronous methods have a default fallback that uses threads
to implement asynchronicity, so they are optional for inheriting
classes. However, if you override one you must override all.

For the synchronous, blocking version of this function, see
g_output_stream_write().

Note that no copy of @buffer will be made, so it must stay valid
until @callback is called. See g_output_stream_write_bytes_async()
for a #GBytes version that will automatically hold a reference to
the contents (without copying) for the duration of the call.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">A #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the buffer containing the data to write.</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes to write</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the io priority of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="write_finish" invoker="write_finish" throws="1">
        <doc xml:space="preserve">Finishes a stream write operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #gssize containing the number of bytes written to the stream.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="write_fn" invoker="write" throws="1">
        <doc xml:space="preserve">Tries to write @count bytes from @buffer into the stream. Will block
during the operation.

If count is 0, returns 0 and does nothing. A value of @count
larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.

On success, the number of bytes written to the stream is returned.
It is not an error if this is not the same as the requested size, as it
can happen e.g. on a partial I/O error, or if there is not enough
storage in the stream. All writes block until at least one byte
is written or an error occurs; 0 is never returned (unless
@count is 0).

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.

On error -1 is returned and @error is set accordingly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Number of bytes written, or -1 on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the buffer containing the data to write.</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes to write</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="clear_pending" c:identifier="g_output_stream_clear_pending">
        <doc xml:space="preserve">Clears the pending flag on @stream.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">output stream</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="close" c:identifier="g_output_stream_close" throws="1">
        <doc xml:space="preserve">Closes the stream, releasing resources related to it.

Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
Closing a stream multiple times will not return an error.

Closing a stream will automatically flush any outstanding buffers in the
stream.

Streams will be automatically closed when the last reference
is dropped, but you might want to call this function to make sure
resources are released as early as possible.

Some streams might keep the backing store of the stream (e.g. a file descriptor)
open after the stream is closed. See the documentation for the individual
stream for details.

On failure the first error that happened will be reported, but the close
operation will finish as much as possible. A stream that failed to
close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
is important to check and report the error to the user, otherwise
there might be a loss of data as all data might not be written.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
Cancelling a close will still leave the stream closed, but there some streams
can use a faster close that doesn't block to e.g. check errors. On
cancellation (as with any error) there is no guarantee that all written
data will reach the target.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">A #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_async" c:identifier="g_output_stream_close_async">
        <doc xml:space="preserve">Requests an asynchronous close of the stream, releasing resources
related to it. When the operation is finished @callback will be
called. You can then call g_output_stream_close_finish() to get
the result of the operation.

For behaviour details see g_output_stream_close().

The asynchronous methods have a default fallback that uses threads
to implement asynchronicity, so they are optional for inheriting
classes. However, if you override one you must override all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">A #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the io priority of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_finish" c:identifier="g_output_stream_close_finish" throws="1">
        <doc xml:space="preserve">Closes an output stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if stream was successfully closed, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="flush" c:identifier="g_output_stream_flush" throws="1">
        <doc xml:space="preserve">Forces a write of all user-space buffered data for the given
@stream. Will block during the operation. Closing the stream will
implicitly cause a flush.

This function is optional for inherited classes.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="flush_async" c:identifier="g_output_stream_flush_async">
        <doc xml:space="preserve">Forces an asynchronous write of all user-space buffered data for
the given @stream.
For behaviour details see g_output_stream_flush().

When the operation is finished @callback will be
called. You can then call g_output_stream_flush_finish() to get the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the io priority of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="flush_finish" c:identifier="g_output_stream_flush_finish" throws="1">
        <doc xml:space="preserve">Finishes flushing an output stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if flush operation succeeded, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_pending" c:identifier="g_output_stream_has_pending">
        <doc xml:space="preserve">Checks if an output stream has pending actions.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @stream has pending actions.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_closed" c:identifier="g_output_stream_is_closed">
        <doc xml:space="preserve">Checks if an output stream has already been closed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @stream is closed. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_closing" c:identifier="g_output_stream_is_closing" version="2.24">
        <doc xml:space="preserve">Checks if an output stream is being closed. This can be
used inside e.g. a flush implementation to see if the
flush (or other i/o operation) is called from within
the closing operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @stream is being closed. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="printf" c:identifier="g_output_stream_printf" version="2.40" introspectable="0">
        <doc xml:space="preserve">This is a utility function around g_output_stream_write_all(). It
uses g_strdup_vprintf() to turn @format and @... into a string that
is then written to @stream.

See the documentation of g_output_stream_write_all() about the
behavior of the actual write operation.

Note that partial writes cannot be properly checked with this
function due to the variable length of the written string, if you
need precise control over partial write failures, you need to
create you own printf()-like wrapper around g_output_stream_write()
or g_output_stream_write_all().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if there was an error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">location to store the number of bytes that was
    written to the stream</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">location to store the error occurring, or %NULL to ignore</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the format string. See the printf() documentation</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the parameters to insert into the format string</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pending" c:identifier="g_output_stream_set_pending" throws="1">
        <doc xml:space="preserve">Sets @stream to have actions pending. If the pending flag is
already set or @stream is closed, it will return %FALSE and set
@error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if pending was previously unset and is now set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="splice" c:identifier="g_output_stream_splice" throws="1">
        <doc xml:space="preserve">Splices an input stream into an output stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #gssize containing the size of the data spliced, or
    -1 if an error occurred. Note that if the number of bytes
    spliced is greater than %G_MAXSSIZE, then that will be
    returned, and there is no way to determine the actual number
    of bytes spliced.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GOutputStreamSpliceFlags.</doc>
            <type name="OutputStreamSpliceFlags" c:type="GOutputStreamSpliceFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="splice_async" c:identifier="g_output_stream_splice_async">
        <doc xml:space="preserve">Splices a stream asynchronously.
When the operation is finished @callback will be called.
You can then call g_output_stream_splice_finish() to get the
result of the operation.

For the synchronous, blocking version of this function, see
g_output_stream_splice().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GOutputStreamSpliceFlags.</doc>
            <type name="OutputStreamSpliceFlags" c:type="GOutputStreamSpliceFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the io priority of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">a #GAsyncReadyCallback.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="splice_finish" c:identifier="g_output_stream_splice_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous stream splice operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #gssize of the number of bytes spliced. Note that if the
    number of bytes spliced is greater than %G_MAXSSIZE, then that
    will be returned, and there is no way to determine the actual
    number of bytes spliced.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="vprintf" c:identifier="g_output_stream_vprintf" version="2.40" introspectable="0">
        <doc xml:space="preserve">This is a utility function around g_output_stream_write_all(). It
uses g_strdup_vprintf() to turn @format and @args into a string that
is then written to @stream.

See the documentation of g_output_stream_write_all() about the
behavior of the actual write operation.

Note that partial writes cannot be properly checked with this
function due to the variable length of the written string, if you
need precise control over partial write failures, you need to
create you own printf()-like wrapper around g_output_stream_write()
or g_output_stream_write_all().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if there was an error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">location to store the number of bytes that was
    written to the stream</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">location to store the error occurring, or %NULL to ignore</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the format string. See the printf() documentation</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">the parameters to insert into the format string</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="write" c:identifier="g_output_stream_write" throws="1">
        <doc xml:space="preserve">Tries to write @count bytes from @buffer into the stream. Will block
during the operation.

If count is 0, returns 0 and does nothing. A value of @count
larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.

On success, the number of bytes written to the stream is returned.
It is not an error if this is not the same as the requested size, as it
can happen e.g. on a partial I/O error, or if there is not enough
storage in the stream. All writes block until at least one byte
is written or an error occurs; 0 is never returned (unless
@count is 0).

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.

On error -1 is returned and @error is set accordingly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Number of bytes written, or -1 on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">the buffer containing the data to write.</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes to write</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_all" c:identifier="g_output_stream_write_all" throws="1">
        <doc xml:space="preserve">Tries to write @count bytes from @buffer into the stream. Will block
during the operation.

This function is similar to g_output_stream_write(), except it tries to
write as many bytes as requested, only stopping on an error.

On a successful write of @count bytes, %TRUE is returned, and @bytes_written
is set to @count.

If there is an error during the operation %FALSE is returned and @error
is set to indicate the error status.

As a special exception to the normal conventions for functions that
use #GError, if this function returns %FALSE (and sets @error) then
@bytes_written will be set to the number of bytes that were
successfully written before the error was encountered.  This
functionality is only available from C.  If you need it from another
language then you must write your own loop around
g_output_stream_write().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if there was an error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">the buffer containing the data to write.</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes to write</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">location to store the number of bytes that was
    written to the stream</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_all_async" c:identifier="g_output_stream_write_all_async" version="2.44">
        <doc xml:space="preserve">Request an asynchronous write of @count bytes from @buffer into
the stream. When the operation is finished @callback will be called.
You can then call g_output_stream_write_all_finish() to get the result of the
operation.

This is the asynchronous version of g_output_stream_write_all().

Call g_output_stream_write_all_finish() to collect the result.

Any outstanding I/O request with higher priority (lower numerical
value) will be executed before an outstanding request with lower
priority. Default priority is %G_PRIORITY_DEFAULT.

Note that no copy of @buffer will be made, so it must stay valid
until @callback is called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">A #GOutputStream</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">the buffer containing the data to write</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes to write</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the io priority of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_all_finish" c:identifier="g_output_stream_write_all_finish" version="2.44" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous stream write operation started with
g_output_stream_write_all_async().

As a special exception to the normal conventions for functions that
use #GError, if this function returns %FALSE (and sets @error) then
@bytes_written will be set to the number of bytes that were
successfully written before the error was encountered.  This
functionality is only available from C.  If you need it from another
language then you must write your own loop around
g_output_stream_write_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if there was an error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">location to store the number of bytes that was written to the stream</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_async" c:identifier="g_output_stream_write_async">
        <doc xml:space="preserve">Request an asynchronous write of @count bytes from @buffer into
the stream. When the operation is finished @callback will be called.
You can then call g_output_stream_write_finish() to get the result of the
operation.

During an async request no other sync and async calls are allowed,
and will result in %G_IO_ERROR_PENDING errors.

A value of @count larger than %G_MAXSSIZE will cause a
%G_IO_ERROR_INVALID_ARGUMENT error.

On success, the number of bytes written will be passed to the
@callback. It is not an error if this is not the same as the
requested size, as it can happen e.g. on a partial I/O error,
but generally we try to write as many bytes as requested.

You are guaranteed that this method will never fail with
%G_IO_ERROR_WOULD_BLOCK - if @stream can't accept more data, the
method will just wait until this changes.

Any outstanding I/O request with higher priority (lower numerical
value) will be executed before an outstanding request with lower
priority. Default priority is %G_PRIORITY_DEFAULT.

The asynchronous methods have a default fallback that uses threads
to implement asynchronicity, so they are optional for inheriting
classes. However, if you override one you must override all.

For the synchronous, blocking version of this function, see
g_output_stream_write().

Note that no copy of @buffer will be made, so it must stay valid
until @callback is called. See g_output_stream_write_bytes_async()
for a #GBytes version that will automatically hold a reference to
the contents (without copying) for the duration of the call.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">A #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">the buffer containing the data to write.</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes to write</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the io priority of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_bytes" c:identifier="g_output_stream_write_bytes" throws="1">
        <doc xml:space="preserve">A wrapper function for g_output_stream_write() which takes a
#GBytes as input.  This can be more convenient for use by language
bindings or in other cases where the refcounted nature of #GBytes
is helpful over a bare pointer interface.

However, note that this function may still perform partial writes,
just like g_output_stream_write().  If that occurs, to continue
writing, you will need to create a new #GBytes containing just the
remaining bytes, using g_bytes_new_from_bytes(). Passing the same
#GBytes instance multiple times potentially can result in duplicated
data in the output stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Number of bytes written, or -1 on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve">the #GBytes to write</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_bytes_async" c:identifier="g_output_stream_write_bytes_async">
        <doc xml:space="preserve">This function is similar to g_output_stream_write_async(), but
takes a #GBytes as input.  Due to the refcounted nature of #GBytes,
this allows the stream to avoid taking a copy of the data.

However, note that this function may still perform partial writes,
just like g_output_stream_write_async(). If that occurs, to continue
writing, you will need to create a new #GBytes containing just the
remaining bytes, using g_bytes_new_from_bytes(). Passing the same
#GBytes instance multiple times potentially can result in duplicated
data in the output stream.

For the synchronous, blocking version of this function, see
g_output_stream_write_bytes().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">A #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve">The bytes to write</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the io priority of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_bytes_finish" c:identifier="g_output_stream_write_bytes_finish" throws="1">
        <doc xml:space="preserve">Finishes a stream write-from-#GBytes operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #gssize containing the number of bytes written to the stream.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_finish" c:identifier="g_output_stream_write_finish" throws="1">
        <doc xml:space="preserve">Finishes a stream write operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #gssize containing the number of bytes written to the stream.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="OutputStreamPrivate" c:type="GOutputStreamPrivate*"/>
      </field>
    </class>
    <record name="OutputStreamClass" c:type="GOutputStreamClass" glib:is-gtype-struct-for="OutputStream">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="write_fn">
        <callback name="write_fn" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Number of bytes written, or -1 on error</doc>
            <type name="gssize" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">the buffer containing the data to write.</doc>
              <array length="2" zero-terminated="0" c:type="void*">
                <type name="guint8"/>
              </array>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <doc xml:space="preserve">the number of bytes to write</doc>
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional cancellable object</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="splice">
        <callback name="splice" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">a #gssize containing the size of the data spliced, or
    -1 if an error occurred. Note that if the number of bytes
    spliced is greater than %G_MAXSSIZE, then that will be
    returned, and there is no way to determine the actual number
    of bytes spliced.</doc>
            <type name="gssize" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="source" transfer-ownership="none">
              <doc xml:space="preserve">a #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">a set of #GOutputStreamSpliceFlags.</doc>
              <type name="OutputStreamSpliceFlags" c:type="GOutputStreamSpliceFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="flush">
        <callback name="flush" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional cancellable object</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_fn">
        <callback name="close_fn" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="write_async">
        <callback name="write_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">A #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">the buffer containing the data to write.</doc>
              <array length="2" zero-terminated="0" c:type="void*">
                <type name="guint8"/>
              </array>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <doc xml:space="preserve">the number of bytes to write</doc>
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the io priority of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
              <doc xml:space="preserve">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="write_finish">
        <callback name="write_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">a #gssize containing the number of bytes written to the stream.</doc>
            <type name="gssize" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="splice_async">
        <callback name="splice_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="source" transfer-ownership="none">
              <doc xml:space="preserve">a #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">a set of #GOutputStreamSpliceFlags.</doc>
              <type name="OutputStreamSpliceFlags" c:type="GOutputStreamSpliceFlags"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the io priority of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
              <doc xml:space="preserve">a #GAsyncReadyCallback.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6">
              <doc xml:space="preserve">user data passed to @callback.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="splice_finish">
        <callback name="splice_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">a #gssize of the number of bytes spliced. Note that if the
    number of bytes spliced is greater than %G_MAXSSIZE, then that
    will be returned, and there is no way to determine the actual
    number of bytes spliced.</doc>
            <type name="gssize" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="flush_async">
        <callback name="flush_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the io priority of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="flush_finish">
        <callback name="flush_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if flush operation succeeded, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_async">
        <callback name="close_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">A #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the io priority of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional cancellable object</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_finish">
        <callback name="close_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if stream was successfully closed, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved6" introspectable="0">
        <callback name="_g_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved7" introspectable="0">
        <callback name="_g_reserved7">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved8" introspectable="0">
        <callback name="_g_reserved8">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="OutputStreamPrivate" c:type="GOutputStreamPrivate" disguised="1">
    </record>
    <bitfield name="OutputStreamSpliceFlags" glib:type-name="GOutputStreamSpliceFlags" glib:get-type="g_output_stream_splice_flags_get_type" c:type="GOutputStreamSpliceFlags">
      <doc xml:space="preserve">GOutputStreamSpliceFlags determine how streams should be spliced.</doc>
      <member name="none" value="0" c:identifier="G_OUTPUT_STREAM_SPLICE_NONE" glib:nick="none">
        <doc xml:space="preserve">Do not close either stream.</doc>
      </member>
      <member name="close_source" value="1" c:identifier="G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE" glib:nick="close-source">
        <doc xml:space="preserve">Close the source stream after
    the splice.</doc>
      </member>
      <member name="close_target" value="2" c:identifier="G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET" glib:nick="close-target">
        <doc xml:space="preserve">Close the target stream after
    the splice.</doc>
      </member>
    </bitfield>
    <record name="OutputVector" c:type="GOutputVector" version="2.22">
      <doc xml:space="preserve">Structure used for scatter/gather data output.
You generally pass in an array of #GOutputVectors
and the operation will use all the buffers as if they were
one buffer.</doc>
      <field name="buffer" writable="1">
        <doc xml:space="preserve">Pointer to a buffer of data to read.</doc>
        <type name="gpointer" c:type="gconstpointer"/>
      </field>
      <field name="size" writable="1">
        <doc xml:space="preserve">the size of @buffer.</doc>
        <type name="gsize" c:type="gsize"/>
      </field>
    </record>
    <constant name="PROXY_EXTENSION_POINT_NAME" value="gio-proxy" c:type="G_PROXY_EXTENSION_POINT_NAME" version="2.26">
      <doc xml:space="preserve">Extension point for proxy functionality.
See [Extending GIO][extending-gio].</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROXY_RESOLVER_EXTENSION_POINT_NAME" value="gio-proxy-resolver" c:type="G_PROXY_RESOLVER_EXTENSION_POINT_NAME">
      <doc xml:space="preserve">Extension point for proxy resolving functionality.
See [Extending GIO][extending-gio].</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="PasswordSave" glib:type-name="GPasswordSave" glib:get-type="g_password_save_get_type" c:type="GPasswordSave">
      <doc xml:space="preserve">#GPasswordSave is used to indicate the lifespan of a saved password.

#Gvfs stores passwords in the Gnome keyring when this flag allows it
to, and later retrieves it again from there.</doc>
      <member name="never" value="0" c:identifier="G_PASSWORD_SAVE_NEVER" glib:nick="never">
        <doc xml:space="preserve">never save a password.</doc>
      </member>
      <member name="for_session" value="1" c:identifier="G_PASSWORD_SAVE_FOR_SESSION" glib:nick="for-session">
        <doc xml:space="preserve">save a password for the session.</doc>
      </member>
      <member name="permanently" value="2" c:identifier="G_PASSWORD_SAVE_PERMANENTLY" glib:nick="permanently">
        <doc xml:space="preserve">save a password permanently.</doc>
      </member>
    </enumeration>
    <class name="Permission" c:symbol-prefix="permission" c:type="GPermission" parent="GObject.Object" abstract="1" glib:type-name="GPermission" glib:get-type="g_permission_get_type" glib:type-struct="PermissionClass">
      <doc xml:space="preserve">A #GPermission represents the status of the caller's permission to
perform a certain action.

You can query if the action is currently allowed and if it is
possible to acquire the permission so that the action will be allowed
in the future.

There is also an API to actually acquire the permission and one to
release it.

As an example, a #GPermission might represent the ability for the
user to write to a #GSettings object.  This #GPermission object could
then be used to decide if it is appropriate to show a "Click here to
unlock" button in a dialog and to provide the mechanism to invoke
when that button is clicked.</doc>
      <virtual-method name="acquire" invoker="acquire" version="2.26" throws="1">
        <doc xml:space="preserve">Attempts to acquire the permission represented by @permission.

The precise method by which this happens depends on the permission
and the underlying authentication mechanism.  A simple example is
that a dialog may appear asking the user to enter their password.

You should check with g_permission_get_can_acquire() before calling
this function.

If the permission is acquired then %TRUE is returned.  Otherwise,
%FALSE is returned and @error is set appropriately.

This call is blocking, likely for a very long time (in the case that
user interaction is required).  See g_permission_acquire_async() for
the non-blocking version.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the permission was successfully acquired</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="permission" transfer-ownership="none">
            <doc xml:space="preserve">a #GPermission instance</doc>
            <type name="Permission" c:type="GPermission*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="acquire_async" invoker="acquire_async" version="2.26">
        <doc xml:space="preserve">Attempts to acquire the permission represented by @permission.

This is the first half of the asynchronous version of
g_permission_acquire().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="permission" transfer-ownership="none">
            <doc xml:space="preserve">a #GPermission instance</doc>
            <type name="Permission" c:type="GPermission*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">the #GAsyncReadyCallback to call when done</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
            <doc xml:space="preserve">the user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="acquire_finish" invoker="acquire_finish" version="2.26" throws="1">
        <doc xml:space="preserve">Collects the result of attempting to acquire the permission
represented by @permission.

This is the second half of the asynchronous version of
g_permission_acquire().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the permission was successfully acquired</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="permission" transfer-ownership="none">
            <doc xml:space="preserve">a #GPermission instance</doc>
            <type name="Permission" c:type="GPermission*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult given to the #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="release" invoker="release" version="2.26" throws="1">
        <doc xml:space="preserve">Attempts to release the permission represented by @permission.

The precise method by which this happens depends on the permission
and the underlying authentication mechanism.  In most cases the
permission will be dropped immediately without further action.

You should check with g_permission_get_can_release() before calling
this function.

If the permission is released then %TRUE is returned.  Otherwise,
%FALSE is returned and @error is set appropriately.

This call is blocking, likely for a very long time (in the case that
user interaction is required).  See g_permission_release_async() for
the non-blocking version.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the permission was successfully released</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="permission" transfer-ownership="none">
            <doc xml:space="preserve">a #GPermission instance</doc>
            <type name="Permission" c:type="GPermission*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="release_async" invoker="release_async" version="2.26">
        <doc xml:space="preserve">Attempts to release the permission represented by @permission.

This is the first half of the asynchronous version of
g_permission_release().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="permission" transfer-ownership="none">
            <doc xml:space="preserve">a #GPermission instance</doc>
            <type name="Permission" c:type="GPermission*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">the #GAsyncReadyCallback to call when done</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
            <doc xml:space="preserve">the user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="release_finish" invoker="release_finish" version="2.26" throws="1">
        <doc xml:space="preserve">Collects the result of attempting to release the permission
represented by @permission.

This is the second half of the asynchronous version of
g_permission_release().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the permission was successfully released</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="permission" transfer-ownership="none">
            <doc xml:space="preserve">a #GPermission instance</doc>
            <type name="Permission" c:type="GPermission*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult given to the #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="acquire" c:identifier="g_permission_acquire" version="2.26" throws="1">
        <doc xml:space="preserve">Attempts to acquire the permission represented by @permission.

The precise method by which this happens depends on the permission
and the underlying authentication mechanism.  A simple example is
that a dialog may appear asking the user to enter their password.

You should check with g_permission_get_can_acquire() before calling
this function.

If the permission is acquired then %TRUE is returned.  Otherwise,
%FALSE is returned and @error is set appropriately.

This call is blocking, likely for a very long time (in the case that
user interaction is required).  See g_permission_acquire_async() for
the non-blocking version.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the permission was successfully acquired</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="permission" transfer-ownership="none">
            <doc xml:space="preserve">a #GPermission instance</doc>
            <type name="Permission" c:type="GPermission*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="acquire_async" c:identifier="g_permission_acquire_async" version="2.26">
        <doc xml:space="preserve">Attempts to acquire the permission represented by @permission.

This is the first half of the asynchronous version of
g_permission_acquire().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="permission" transfer-ownership="none">
            <doc xml:space="preserve">a #GPermission instance</doc>
            <type name="Permission" c:type="GPermission*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">the #GAsyncReadyCallback to call when done</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="acquire_finish" c:identifier="g_permission_acquire_finish" version="2.26" throws="1">
        <doc xml:space="preserve">Collects the result of attempting to acquire the permission
represented by @permission.

This is the second half of the asynchronous version of
g_permission_acquire().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the permission was successfully acquired</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="permission" transfer-ownership="none">
            <doc xml:space="preserve">a #GPermission instance</doc>
            <type name="Permission" c:type="GPermission*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult given to the #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_allowed" c:identifier="g_permission_get_allowed" version="2.26">
        <doc xml:space="preserve">Gets the value of the 'allowed' property.  This property is %TRUE if
the caller currently has permission to perform the action that
@permission represents the permission to perform.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the 'allowed' property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="permission" transfer-ownership="none">
            <doc xml:space="preserve">a #GPermission instance</doc>
            <type name="Permission" c:type="GPermission*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_can_acquire" c:identifier="g_permission_get_can_acquire" version="2.26">
        <doc xml:space="preserve">Gets the value of the 'can-acquire' property.  This property is %TRUE
if it is generally possible to acquire the permission by calling
g_permission_acquire().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the 'can-acquire' property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="permission" transfer-ownership="none">
            <doc xml:space="preserve">a #GPermission instance</doc>
            <type name="Permission" c:type="GPermission*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_can_release" c:identifier="g_permission_get_can_release" version="2.26">
        <doc xml:space="preserve">Gets the value of the 'can-release' property.  This property is %TRUE
if it is generally possible to release the permission by calling
g_permission_release().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the 'can-release' property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="permission" transfer-ownership="none">
            <doc xml:space="preserve">a #GPermission instance</doc>
            <type name="Permission" c:type="GPermission*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="impl_update" c:identifier="g_permission_impl_update" version="2.26">
        <doc xml:space="preserve">This function is called by the #GPermission implementation to update
the properties of the permission.  You should never call this
function except from a #GPermission implementation.

GObject notify signals are generated, as appropriate.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="permission" transfer-ownership="none">
            <doc xml:space="preserve">a #GPermission instance</doc>
            <type name="Permission" c:type="GPermission*"/>
          </instance-parameter>
          <parameter name="allowed" transfer-ownership="none">
            <doc xml:space="preserve">the new value for the 'allowed' property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="can_acquire" transfer-ownership="none">
            <doc xml:space="preserve">the new value for the 'can-acquire' property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="can_release" transfer-ownership="none">
            <doc xml:space="preserve">the new value for the 'can-release' property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="release" c:identifier="g_permission_release" version="2.26" throws="1">
        <doc xml:space="preserve">Attempts to release the permission represented by @permission.

The precise method by which this happens depends on the permission
and the underlying authentication mechanism.  In most cases the
permission will be dropped immediately without further action.

You should check with g_permission_get_can_release() before calling
this function.

If the permission is released then %TRUE is returned.  Otherwise,
%FALSE is returned and @error is set appropriately.

This call is blocking, likely for a very long time (in the case that
user interaction is required).  See g_permission_release_async() for
the non-blocking version.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the permission was successfully released</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="permission" transfer-ownership="none">
            <doc xml:space="preserve">a #GPermission instance</doc>
            <type name="Permission" c:type="GPermission*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="release_async" c:identifier="g_permission_release_async" version="2.26">
        <doc xml:space="preserve">Attempts to release the permission represented by @permission.

This is the first half of the asynchronous version of
g_permission_release().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="permission" transfer-ownership="none">
            <doc xml:space="preserve">a #GPermission instance</doc>
            <type name="Permission" c:type="GPermission*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">the #GAsyncReadyCallback to call when done</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="release_finish" c:identifier="g_permission_release_finish" version="2.26" throws="1">
        <doc xml:space="preserve">Collects the result of attempting to release the permission
represented by @permission.

This is the second half of the asynchronous version of
g_permission_release().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the permission was successfully released</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="permission" transfer-ownership="none">
            <doc xml:space="preserve">a #GPermission instance</doc>
            <type name="Permission" c:type="GPermission*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult given to the #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="allowed" transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the caller currently has permission to perform the action that
@permission represents the permission to perform.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="can-acquire" transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if it is generally possible to acquire the permission by calling
g_permission_acquire().</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="can-release" transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if it is generally possible to release the permission by calling
g_permission_release().</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="PermissionPrivate" c:type="GPermissionPrivate*"/>
      </field>
    </class>
    <record name="PermissionClass" c:type="GPermissionClass" glib:is-gtype-struct-for="Permission">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="acquire">
        <callback name="acquire" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the permission was successfully acquired</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="permission" transfer-ownership="none">
              <doc xml:space="preserve">a #GPermission instance</doc>
              <type name="Permission" c:type="GPermission*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="acquire_async">
        <callback name="acquire_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="permission" transfer-ownership="none">
              <doc xml:space="preserve">a #GPermission instance</doc>
              <type name="Permission" c:type="GPermission*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
              <doc xml:space="preserve">the #GAsyncReadyCallback to call when done</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
              <doc xml:space="preserve">the user data to pass to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="acquire_finish">
        <callback name="acquire_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the permission was successfully acquired</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="permission" transfer-ownership="none">
              <doc xml:space="preserve">a #GPermission instance</doc>
              <type name="Permission" c:type="GPermission*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">the #GAsyncResult given to the #GAsyncReadyCallback</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="release">
        <callback name="release" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the permission was successfully released</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="permission" transfer-ownership="none">
              <doc xml:space="preserve">a #GPermission instance</doc>
              <type name="Permission" c:type="GPermission*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="release_async">
        <callback name="release_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="permission" transfer-ownership="none">
              <doc xml:space="preserve">a #GPermission instance</doc>
              <type name="Permission" c:type="GPermission*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
              <doc xml:space="preserve">the #GAsyncReadyCallback to call when done</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
              <doc xml:space="preserve">the user data to pass to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="release_finish">
        <callback name="release_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the permission was successfully released</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="permission" transfer-ownership="none">
              <doc xml:space="preserve">a #GPermission instance</doc>
              <type name="Permission" c:type="GPermission*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">the #GAsyncResult given to the #GAsyncReadyCallback</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="16">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="PermissionPrivate" c:type="GPermissionPrivate" disguised="1">
    </record>
    <interface name="PollableInputStream" c:symbol-prefix="pollable_input_stream" c:type="GPollableInputStream" version="2.28" glib:type-name="GPollableInputStream" glib:get-type="g_pollable_input_stream_get_type" glib:type-struct="PollableInputStreamInterface">
      <doc xml:space="preserve">#GPollableInputStream is implemented by #GInputStreams that
can be polled for readiness to read. This can be used when
interfacing with a non-GIO API that expects
UNIX-file-descriptor-style asynchronous I/O rather than GIO-style.</doc>
      <prerequisite name="InputStream"/>
      <virtual-method name="can_poll" invoker="can_poll" version="2.28">
        <doc xml:space="preserve">Checks if @stream is actually pollable. Some classes may implement
#GPollableInputStream but have only certain instances of that class
be pollable. If this method returns %FALSE, then the behavior of
other #GPollableInputStream methods is undefined.

For any given stream, the value returned by this method is constant;
a stream cannot switch from pollable to non-pollable or vice versa.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @stream is pollable, %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GPollableInputStream.</doc>
            <type name="PollableInputStream" c:type="GPollableInputStream*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_source" invoker="create_source" version="2.28">
        <doc xml:space="preserve">Creates a #GSource that triggers when @stream can be read, or
@cancellable is triggered or an error occurs. The callback on the
source is of the #GPollableSourceFunc type.

As with g_pollable_input_stream_is_readable(), it is possible that
the stream may not actually be readable even after the source
triggers, so you should use g_pollable_input_stream_read_nonblocking()
rather than g_input_stream_read() from the callback.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSource</doc>
          <type name="GLib.Source" c:type="GSource*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GPollableInputStream.</doc>
            <type name="PollableInputStream" c:type="GPollableInputStream*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_readable" invoker="is_readable" version="2.28">
        <doc xml:space="preserve">Checks if @stream can be read.

Note that some stream types may not be able to implement this 100%
reliably, and it is possible that a call to g_input_stream_read()
after this returns %TRUE would still block. To guarantee
non-blocking behavior, you should always use
g_pollable_input_stream_read_nonblocking(), which will return a
%G_IO_ERROR_WOULD_BLOCK error rather than blocking.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @stream is readable, %FALSE if not. If an error
  has occurred on @stream, this will result in
  g_pollable_input_stream_is_readable() returning %TRUE, and the
  next attempt to read will return the error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GPollableInputStream.</doc>
            <type name="PollableInputStream" c:type="GPollableInputStream*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read_nonblocking" invoker="read_nonblocking" throws="1">
        <doc xml:space="preserve">Attempts to read up to @count bytes from @stream into @buffer, as
with g_input_stream_read(). If @stream is not currently readable,
this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
use g_pollable_input_stream_create_source() to create a #GSource
that will be triggered when @stream is readable.

Note that since this method never blocks, you cannot actually
use @cancellable to cancel it. However, it will return an error
if @cancellable has already been cancelled when you call, which
may happen if you call this method after a source triggers due
to having been cancelled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes read, or -1 on error (including
  %G_IO_ERROR_WOULD_BLOCK).</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GPollableInputStream</doc>
            <type name="PollableInputStream" c:type="GPollableInputStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a buffer to
    read data into (which should be at least @count bytes long).</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes you want to read</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="can_poll" c:identifier="g_pollable_input_stream_can_poll" version="2.28">
        <doc xml:space="preserve">Checks if @stream is actually pollable. Some classes may implement
#GPollableInputStream but have only certain instances of that class
be pollable. If this method returns %FALSE, then the behavior of
other #GPollableInputStream methods is undefined.

For any given stream, the value returned by this method is constant;
a stream cannot switch from pollable to non-pollable or vice versa.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @stream is pollable, %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GPollableInputStream.</doc>
            <type name="PollableInputStream" c:type="GPollableInputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="create_source" c:identifier="g_pollable_input_stream_create_source" version="2.28">
        <doc xml:space="preserve">Creates a #GSource that triggers when @stream can be read, or
@cancellable is triggered or an error occurs. The callback on the
source is of the #GPollableSourceFunc type.

As with g_pollable_input_stream_is_readable(), it is possible that
the stream may not actually be readable even after the source
triggers, so you should use g_pollable_input_stream_read_nonblocking()
rather than g_input_stream_read() from the callback.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSource</doc>
          <type name="GLib.Source" c:type="GSource*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GPollableInputStream.</doc>
            <type name="PollableInputStream" c:type="GPollableInputStream*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_readable" c:identifier="g_pollable_input_stream_is_readable" version="2.28">
        <doc xml:space="preserve">Checks if @stream can be read.

Note that some stream types may not be able to implement this 100%
reliably, and it is possible that a call to g_input_stream_read()
after this returns %TRUE would still block. To guarantee
non-blocking behavior, you should always use
g_pollable_input_stream_read_nonblocking(), which will return a
%G_IO_ERROR_WOULD_BLOCK error rather than blocking.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @stream is readable, %FALSE if not. If an error
  has occurred on @stream, this will result in
  g_pollable_input_stream_is_readable() returning %TRUE, and the
  next attempt to read will return the error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GPollableInputStream.</doc>
            <type name="PollableInputStream" c:type="GPollableInputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="read_nonblocking" c:identifier="g_pollable_input_stream_read_nonblocking" throws="1">
        <doc xml:space="preserve">Attempts to read up to @count bytes from @stream into @buffer, as
with g_input_stream_read(). If @stream is not currently readable,
this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
use g_pollable_input_stream_create_source() to create a #GSource
that will be triggered when @stream is readable.

Note that since this method never blocks, you cannot actually
use @cancellable to cancel it. However, it will return an error
if @cancellable has already been cancelled when you call, which
may happen if you call this method after a source triggers due
to having been cancelled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes read, or -1 on error (including
  %G_IO_ERROR_WOULD_BLOCK).</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GPollableInputStream</doc>
            <type name="PollableInputStream" c:type="GPollableInputStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a buffer to
    read data into (which should be at least @count bytes long).</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes you want to read</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="PollableInputStreamInterface" c:type="GPollableInputStreamInterface" glib:is-gtype-struct-for="PollableInputStream" version="2.28">
      <doc xml:space="preserve">The interface for pollable input streams.

The default implementation of @can_poll always returns %TRUE.

The default implementation of @read_nonblocking calls
g_pollable_input_stream_is_readable(), and then calls
g_input_stream_read() if it returns %TRUE. This means you only need
to override it if it is possible that your @is_readable
implementation may return %TRUE when the stream is not actually
readable.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="can_poll">
        <callback name="can_poll">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @stream is pollable, %FALSE if not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GPollableInputStream.</doc>
              <type name="PollableInputStream" c:type="GPollableInputStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_readable">
        <callback name="is_readable">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @stream is readable, %FALSE if not. If an error
  has occurred on @stream, this will result in
  g_pollable_input_stream_is_readable() returning %TRUE, and the
  next attempt to read will return the error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GPollableInputStream.</doc>
              <type name="PollableInputStream" c:type="GPollableInputStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_source">
        <callback name="create_source">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a new #GSource</doc>
            <type name="GLib.Source" c:type="GSource*"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GPollableInputStream.</doc>
              <type name="PollableInputStream" c:type="GPollableInputStream*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="read_nonblocking">
        <callback name="read_nonblocking" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes read, or -1 on error (including
  %G_IO_ERROR_WOULD_BLOCK).</doc>
            <type name="gssize" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GPollableInputStream</doc>
              <type name="PollableInputStream" c:type="GPollableInputStream*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a buffer to
    read data into (which should be at least @count bytes long).</doc>
              <array length="2" zero-terminated="0" c:type="void*">
                <type name="guint8"/>
              </array>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <doc xml:space="preserve">the number of bytes you want to read</doc>
              <type name="gsize" c:type="gsize"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <interface name="PollableOutputStream" c:symbol-prefix="pollable_output_stream" c:type="GPollableOutputStream" version="2.28" glib:type-name="GPollableOutputStream" glib:get-type="g_pollable_output_stream_get_type" glib:type-struct="PollableOutputStreamInterface">
      <doc xml:space="preserve">#GPollableOutputStream is implemented by #GOutputStreams that
can be polled for readiness to write. This can be used when
interfacing with a non-GIO API that expects
UNIX-file-descriptor-style asynchronous I/O rather than GIO-style.</doc>
      <prerequisite name="OutputStream"/>
      <virtual-method name="can_poll" invoker="can_poll" version="2.28">
        <doc xml:space="preserve">Checks if @stream is actually pollable. Some classes may implement
#GPollableOutputStream but have only certain instances of that
class be pollable. If this method returns %FALSE, then the behavior
of other #GPollableOutputStream methods is undefined.

For any given stream, the value returned by this method is constant;
a stream cannot switch from pollable to non-pollable or vice versa.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @stream is pollable, %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GPollableOutputStream.</doc>
            <type name="PollableOutputStream" c:type="GPollableOutputStream*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_source" invoker="create_source" version="2.28">
        <doc xml:space="preserve">Creates a #GSource that triggers when @stream can be written, or
@cancellable is triggered or an error occurs. The callback on the
source is of the #GPollableSourceFunc type.

As with g_pollable_output_stream_is_writable(), it is possible that
the stream may not actually be writable even after the source
triggers, so you should use g_pollable_output_stream_write_nonblocking()
rather than g_output_stream_write() from the callback.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSource</doc>
          <type name="GLib.Source" c:type="GSource*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GPollableOutputStream.</doc>
            <type name="PollableOutputStream" c:type="GPollableOutputStream*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_writable" invoker="is_writable" version="2.28">
        <doc xml:space="preserve">Checks if @stream can be written.

Note that some stream types may not be able to implement this 100%
reliably, and it is possible that a call to g_output_stream_write()
after this returns %TRUE would still block. To guarantee
non-blocking behavior, you should always use
g_pollable_output_stream_write_nonblocking(), which will return a
%G_IO_ERROR_WOULD_BLOCK error rather than blocking.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @stream is writable, %FALSE if not. If an error
  has occurred on @stream, this will result in
  g_pollable_output_stream_is_writable() returning %TRUE, and the
  next attempt to write will return the error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GPollableOutputStream.</doc>
            <type name="PollableOutputStream" c:type="GPollableOutputStream*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="write_nonblocking" invoker="write_nonblocking" throws="1">
        <doc xml:space="preserve">Attempts to write up to @count bytes from @buffer to @stream, as
with g_output_stream_write(). If @stream is not currently writable,
this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
use g_pollable_output_stream_create_source() to create a #GSource
that will be triggered when @stream is writable.

Note that since this method never blocks, you cannot actually
use @cancellable to cancel it. However, it will return an error
if @cancellable has already been cancelled when you call, which
may happen if you call this method after a source triggers due
to having been cancelled.

Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
transports like D/TLS require that you send the same @buffer and @count.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes written, or -1 on error (including
  %G_IO_ERROR_WOULD_BLOCK).</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GPollableOutputStream</doc>
            <type name="PollableOutputStream" c:type="GPollableOutputStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a buffer to write
    data from</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes you want to write</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="can_poll" c:identifier="g_pollable_output_stream_can_poll" version="2.28">
        <doc xml:space="preserve">Checks if @stream is actually pollable. Some classes may implement
#GPollableOutputStream but have only certain instances of that
class be pollable. If this method returns %FALSE, then the behavior
of other #GPollableOutputStream methods is undefined.

For any given stream, the value returned by this method is constant;
a stream cannot switch from pollable to non-pollable or vice versa.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @stream is pollable, %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GPollableOutputStream.</doc>
            <type name="PollableOutputStream" c:type="GPollableOutputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="create_source" c:identifier="g_pollable_output_stream_create_source" version="2.28">
        <doc xml:space="preserve">Creates a #GSource that triggers when @stream can be written, or
@cancellable is triggered or an error occurs. The callback on the
source is of the #GPollableSourceFunc type.

As with g_pollable_output_stream_is_writable(), it is possible that
the stream may not actually be writable even after the source
triggers, so you should use g_pollable_output_stream_write_nonblocking()
rather than g_output_stream_write() from the callback.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSource</doc>
          <type name="GLib.Source" c:type="GSource*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GPollableOutputStream.</doc>
            <type name="PollableOutputStream" c:type="GPollableOutputStream*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_writable" c:identifier="g_pollable_output_stream_is_writable" version="2.28">
        <doc xml:space="preserve">Checks if @stream can be written.

Note that some stream types may not be able to implement this 100%
reliably, and it is possible that a call to g_output_stream_write()
after this returns %TRUE would still block. To guarantee
non-blocking behavior, you should always use
g_pollable_output_stream_write_nonblocking(), which will return a
%G_IO_ERROR_WOULD_BLOCK error rather than blocking.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @stream is writable, %FALSE if not. If an error
  has occurred on @stream, this will result in
  g_pollable_output_stream_is_writable() returning %TRUE, and the
  next attempt to write will return the error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GPollableOutputStream.</doc>
            <type name="PollableOutputStream" c:type="GPollableOutputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="write_nonblocking" c:identifier="g_pollable_output_stream_write_nonblocking" throws="1">
        <doc xml:space="preserve">Attempts to write up to @count bytes from @buffer to @stream, as
with g_output_stream_write(). If @stream is not currently writable,
this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
use g_pollable_output_stream_create_source() to create a #GSource
that will be triggered when @stream is writable.

Note that since this method never blocks, you cannot actually
use @cancellable to cancel it. However, it will return an error
if @cancellable has already been cancelled when you call, which
may happen if you call this method after a source triggers due
to having been cancelled.

Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
transports like D/TLS require that you send the same @buffer and @count.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes written, or -1 on error (including
  %G_IO_ERROR_WOULD_BLOCK).</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GPollableOutputStream</doc>
            <type name="PollableOutputStream" c:type="GPollableOutputStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a buffer to write
    data from</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes you want to write</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="PollableOutputStreamInterface" c:type="GPollableOutputStreamInterface" glib:is-gtype-struct-for="PollableOutputStream" version="2.28">
      <doc xml:space="preserve">The interface for pollable output streams.

The default implementation of @can_poll always returns %TRUE.

The default implementation of @write_nonblocking calls
g_pollable_output_stream_is_writable(), and then calls
g_output_stream_write() if it returns %TRUE. This means you only
need to override it if it is possible that your @is_writable
implementation may return %TRUE when the stream is not actually
writable.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="can_poll">
        <callback name="can_poll">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @stream is pollable, %FALSE if not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GPollableOutputStream.</doc>
              <type name="PollableOutputStream" c:type="GPollableOutputStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_writable">
        <callback name="is_writable">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @stream is writable, %FALSE if not. If an error
  has occurred on @stream, this will result in
  g_pollable_output_stream_is_writable() returning %TRUE, and the
  next attempt to write will return the error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GPollableOutputStream.</doc>
              <type name="PollableOutputStream" c:type="GPollableOutputStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_source">
        <callback name="create_source">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a new #GSource</doc>
            <type name="GLib.Source" c:type="GSource*"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GPollableOutputStream.</doc>
              <type name="PollableOutputStream" c:type="GPollableOutputStream*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="write_nonblocking">
        <callback name="write_nonblocking" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes written, or -1 on error (including
  %G_IO_ERROR_WOULD_BLOCK).</doc>
            <type name="gssize" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GPollableOutputStream</doc>
              <type name="PollableOutputStream" c:type="GPollableOutputStream*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a buffer to write
    data from</doc>
              <array length="2" zero-terminated="0" c:type="void*">
                <type name="guint8"/>
              </array>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <doc xml:space="preserve">the number of bytes you want to write</doc>
              <type name="gsize" c:type="gsize"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <callback name="PollableSourceFunc" c:type="GPollableSourceFunc" version="2.28">
      <doc xml:space="preserve">This is the function type of the callback used for the #GSource
returned by g_pollable_input_stream_create_source() and
g_pollable_output_stream_create_source().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">it should return %FALSE if the source should be removed.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pollable_stream" transfer-ownership="none">
          <doc xml:space="preserve">the #GPollableInputStream or #GPollableOutputStream</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="1">
          <doc xml:space="preserve">data passed in by the user.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="PropertyAction" c:symbol-prefix="property_action" c:type="GPropertyAction" version="2.38" parent="GObject.Object" glib:type-name="GPropertyAction" glib:get-type="g_property_action_get_type">
      <doc xml:space="preserve">A #GPropertyAction is a way to get a #GAction with a state value
reflecting and controlling the value of a #GObject property.

The state of the action will correspond to the value of the property.
Changing it will change the property (assuming the requested value
matches the requirements as specified in the #GParamSpec).

Only the most common types are presently supported.  Booleans are
mapped to booleans, strings to strings, signed/unsigned integers to
int32/uint32 and floats and doubles to doubles.

If the property is an enum then the state will be string-typed and
conversion will automatically be performed between the enum value and
"nick" string as per the #GEnumValue table.

Flags types are not currently supported.

Properties of object types, boxed types and pointer types are not
supported and probably never will be.

Properties of #GVariant types are not currently supported.

If the property is boolean-valued then the action will have a NULL
parameter type, and activating the action (with no parameter) will
toggle the value of the property.

In all other cases, the parameter type will correspond to the type of
the property.

The general idea here is to reduce the number of locations where a
particular piece of state is kept (and therefore has to be synchronised
between). #GPropertyAction does not have a separate state that is kept
in sync with the property value -- its state is the property value.

For example, it might be useful to create a #GAction corresponding to
the "visible-child-name" property of a #GtkStack so that the current
page can be switched from a menu.  The active radio indication in the
menu is then directly determined from the active page of the
#GtkStack.

An anti-example would be binding the "active-id" property on a
#GtkComboBox.  This is because the state of the combobox itself is
probably uninteresting and is actually being used to control
something else.

Another anti-example would be to bind to the "visible-child-name"
property of a #GtkStack if this value is actually stored in
#GSettings.  In that case, the real source of the value is
#GSettings.  If you want a #GAction to control a setting stored in
#GSettings, see g_settings_create_action() instead, and possibly
combine its use with g_settings_bind().</doc>
      <implements name="Action"/>
      <constructor name="new" c:identifier="g_property_action_new" version="2.38">
        <doc xml:space="preserve">Creates a #GAction corresponding to the value of property
@property_name on @object.

The property must be existent and readable and writable (and not
construct-only).

This function takes a reference on @object and doesn't release it
until the action is destroyed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GPropertyAction</doc>
          <type name="PropertyAction" c:type="GPropertyAction*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action to create</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">the object that has the property
  to wrap</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the property</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="enabled" version="2.38" transfer-ownership="none">
        <doc xml:space="preserve">If @action is currently enabled.

If the action is disabled then calls to g_action_activate() and
g_action_change_state() have no effect.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="invert-boolean" version="2.46" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, the state of the action will be the negation of the
property value, provided the property is boolean.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="name" version="2.38" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The name of the action.  This is mostly meaningful for identifying
the action once it has been added to a #GActionMap.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="object" version="2.38" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The object to wrap a property on.

The object must be a non-%NULL #GObject with properties.</doc>
        <type name="GObject.Object"/>
      </property>
      <property name="parameter-type" version="2.38" transfer-ownership="none">
        <doc xml:space="preserve">The type of the parameter that must be given when activating the
action.</doc>
        <type name="GLib.VariantType"/>
      </property>
      <property name="property-name" version="2.38" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The name of the property to wrap on the object.

The property must exist on the passed-in object and it must be
readable and writable (and not construct-only).</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="state" version="2.38" transfer-ownership="none">
        <doc xml:space="preserve">The state of the action, or %NULL if the action is stateless.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="state-type" version="2.38" transfer-ownership="none">
        <doc xml:space="preserve">The #GVariantType of the state that the action has, or %NULL if the
action is stateless.</doc>
        <type name="GLib.VariantType"/>
      </property>
    </class>
    <interface name="Proxy" c:symbol-prefix="proxy" c:type="GProxy" version="2.26" glib:type-name="GProxy" glib:get-type="g_proxy_get_type" glib:type-struct="ProxyInterface">
      <doc xml:space="preserve">A #GProxy handles connecting to a remote host via a given type of
proxy server. It is implemented by the 'gio-proxy' extension point.
The extensions are named after their proxy protocol name. As an
example, a SOCKS5 proxy implementation can be retrieved with the
name 'socks5' using the function
g_io_extension_point_get_extension_by_name().</doc>
      <function name="get_default_for_protocol" c:identifier="g_proxy_get_default_for_protocol" version="2.26">
        <doc xml:space="preserve">Lookup "gio-proxy" extension point for a proxy implementation that supports
specified protocol.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">return a #GProxy or NULL if protocol
              is not supported.</doc>
          <type name="Proxy" c:type="GProxy*"/>
        </return-value>
        <parameters>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:space="preserve">the proxy protocol name (e.g. http, socks, etc)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="connect" invoker="connect" version="2.26" throws="1">
        <doc xml:space="preserve">Given @connection to communicate with a proxy (eg, a
#GSocketConnection that is connected to the proxy server), this
does the necessary handshake to connect to @proxy_address, and if
required, wraps the #GIOStream to handle proxy payload.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GIOStream that will replace @connection. This might
              be the same as @connection, in which case a reference
              will be added.</doc>
          <type name="IOStream" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxy</doc>
            <type name="Proxy" c:type="GProxy*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </parameter>
          <parameter name="proxy_address" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxyAddress</doc>
            <type name="ProxyAddress" c:type="GProxyAddress*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="connect_async" invoker="connect_async" version="2.26">
        <doc xml:space="preserve">Asynchronous version of g_proxy_connect().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxy</doc>
            <type name="Proxy" c:type="GProxy*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </parameter>
          <parameter name="proxy_address" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxyAddress</doc>
            <type name="ProxyAddress" c:type="GProxyAddress*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">callback data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="connect_finish" invoker="connect_finish" version="2.26" throws="1">
        <doc xml:space="preserve">See g_proxy_connect().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GIOStream.</doc>
          <type name="IOStream" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxy</doc>
            <type name="Proxy" c:type="GProxy*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="supports_hostname" invoker="supports_hostname" version="2.26">
        <doc xml:space="preserve">Some proxy protocols expect to be passed a hostname, which they
will resolve to an IP address themselves. Others, like SOCKS4, do
not allow this. This function will return %FALSE if @proxy is
implementing such a protocol. When %FALSE is returned, the caller
should resolve the destination hostname first, and then pass a
#GProxyAddress containing the stringified IP address to
g_proxy_connect() or g_proxy_connect_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if hostname resolution is supported.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxy</doc>
            <type name="Proxy" c:type="GProxy*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="connect" c:identifier="g_proxy_connect" version="2.26" throws="1">
        <doc xml:space="preserve">Given @connection to communicate with a proxy (eg, a
#GSocketConnection that is connected to the proxy server), this
does the necessary handshake to connect to @proxy_address, and if
required, wraps the #GIOStream to handle proxy payload.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GIOStream that will replace @connection. This might
              be the same as @connection, in which case a reference
              will be added.</doc>
          <type name="IOStream" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxy</doc>
            <type name="Proxy" c:type="GProxy*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </parameter>
          <parameter name="proxy_address" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxyAddress</doc>
            <type name="ProxyAddress" c:type="GProxyAddress*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_async" c:identifier="g_proxy_connect_async" version="2.26">
        <doc xml:space="preserve">Asynchronous version of g_proxy_connect().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxy</doc>
            <type name="Proxy" c:type="GProxy*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </parameter>
          <parameter name="proxy_address" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxyAddress</doc>
            <type name="ProxyAddress" c:type="GProxyAddress*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">callback data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_finish" c:identifier="g_proxy_connect_finish" version="2.26" throws="1">
        <doc xml:space="preserve">See g_proxy_connect().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GIOStream.</doc>
          <type name="IOStream" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxy</doc>
            <type name="Proxy" c:type="GProxy*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_hostname" c:identifier="g_proxy_supports_hostname" version="2.26">
        <doc xml:space="preserve">Some proxy protocols expect to be passed a hostname, which they
will resolve to an IP address themselves. Others, like SOCKS4, do
not allow this. This function will return %FALSE if @proxy is
implementing such a protocol. When %FALSE is returned, the caller
should resolve the destination hostname first, and then pass a
#GProxyAddress containing the stringified IP address to
g_proxy_connect() or g_proxy_connect_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if hostname resolution is supported.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxy</doc>
            <type name="Proxy" c:type="GProxy*"/>
          </instance-parameter>
        </parameters>
      </method>
    </interface>
    <class name="ProxyAddress" c:symbol-prefix="proxy_address" c:type="GProxyAddress" version="2.26" parent="InetSocketAddress" glib:type-name="GProxyAddress" glib:get-type="g_proxy_address_get_type" glib:type-struct="ProxyAddressClass">
      <doc xml:space="preserve">Support for proxied #GInetSocketAddress.</doc>
      <implements name="SocketConnectable"/>
      <constructor name="new" c:identifier="g_proxy_address_new" version="2.26">
        <doc xml:space="preserve">Creates a new #GProxyAddress for @inetaddr with @protocol that should
tunnel through @dest_hostname and @dest_port.

(Note that this method doesn't set the #GProxyAddress:uri or
#GProxyAddress:destination-protocol fields; use g_object_new()
directly if you want to set those.)</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GProxyAddress</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <parameter name="inetaddr" transfer-ownership="none">
            <doc xml:space="preserve">The proxy server #GInetAddress.</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">The proxy server port.</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:space="preserve">The proxy protocol to support, in lower case (e.g. socks, http).</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="dest_hostname" transfer-ownership="none">
            <doc xml:space="preserve">The destination hostname the proxy should tunnel to.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="dest_port" transfer-ownership="none">
            <doc xml:space="preserve">The destination port to tunnel to.</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
          <parameter name="username" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The username to authenticate to the proxy server
    (or %NULL).</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The password to authenticate to the proxy server
    (or %NULL).</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_destination_hostname" c:identifier="g_proxy_address_get_destination_hostname" version="2.26">
        <doc xml:space="preserve">Gets @proxy's destination hostname; that is, the name of the host
that will be connected to via the proxy, not the name of the proxy
itself.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the @proxy's destination hostname</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxyAddress</doc>
            <type name="ProxyAddress" c:type="GProxyAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_destination_port" c:identifier="g_proxy_address_get_destination_port" version="2.26">
        <doc xml:space="preserve">Gets @proxy's destination port; that is, the port on the
destination host that will be connected to via the proxy, not the
port number of the proxy itself.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the @proxy's destination port</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxyAddress</doc>
            <type name="ProxyAddress" c:type="GProxyAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_destination_protocol" c:identifier="g_proxy_address_get_destination_protocol" version="2.34">
        <doc xml:space="preserve">Gets the protocol that is being spoken to the destination
server; eg, "http" or "ftp".</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the @proxy's destination protocol</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxyAddress</doc>
            <type name="ProxyAddress" c:type="GProxyAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password" c:identifier="g_proxy_address_get_password" version="2.26">
        <doc xml:space="preserve">Gets @proxy's password.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the @proxy's password</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxyAddress</doc>
            <type name="ProxyAddress" c:type="GProxyAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_protocol" c:identifier="g_proxy_address_get_protocol" version="2.26">
        <doc xml:space="preserve">Gets @proxy's protocol. eg, "socks" or "http"</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the @proxy's protocol</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxyAddress</doc>
            <type name="ProxyAddress" c:type="GProxyAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uri" c:identifier="g_proxy_address_get_uri" version="2.34">
        <doc xml:space="preserve">Gets the proxy URI that @proxy was constructed from.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the @proxy's URI, or %NULL if unknown</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxyAddress</doc>
            <type name="ProxyAddress" c:type="GProxyAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_username" c:identifier="g_proxy_address_get_username" version="2.26">
        <doc xml:space="preserve">Gets @proxy's username.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the @proxy's username</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxyAddress</doc>
            <type name="ProxyAddress" c:type="GProxyAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="destination-hostname" writable="1" construct-only="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="destination-port" writable="1" construct-only="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="destination-protocol" version="2.34" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The protocol being spoke to the destination host, or %NULL if
the #GProxyAddress doesn't know.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="password" writable="1" construct-only="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="protocol" writable="1" construct-only="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="uri" version="2.34" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The URI string that the proxy was constructed from (or %NULL
if the creator didn't specify this).</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="username" writable="1" construct-only="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance">
        <type name="InetSocketAddress" c:type="GInetSocketAddress"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ProxyAddressPrivate" c:type="GProxyAddressPrivate*"/>
      </field>
    </class>
    <record name="ProxyAddressClass" c:type="GProxyAddressClass" glib:is-gtype-struct-for="ProxyAddress" version="2.26">
      <doc xml:space="preserve">Class structure for #GProxyAddress.</doc>
      <field name="parent_class">
        <type name="InetSocketAddressClass" c:type="GInetSocketAddressClass"/>
      </field>
    </record>
    <class name="ProxyAddressEnumerator" c:symbol-prefix="proxy_address_enumerator" c:type="GProxyAddressEnumerator" parent="SocketAddressEnumerator" glib:type-name="GProxyAddressEnumerator" glib:get-type="g_proxy_address_enumerator_get_type" glib:type-struct="ProxyAddressEnumeratorClass">
      <doc xml:space="preserve">A subclass of #GSocketAddressEnumerator that takes another address
enumerator and wraps its results in #GProxyAddresses as
directed by the default #GProxyResolver.</doc>
      <property name="connectable" writable="1" construct-only="1" transfer-ownership="none">
        <type name="SocketConnectable"/>
      </property>
      <property name="default-port" version="2.38" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The default port to use if #GProxyAddressEnumerator:uri does not
specify one.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="proxy-resolver" version="2.36" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">The proxy resolver to use.</doc>
        <type name="ProxyResolver"/>
      </property>
      <property name="uri" writable="1" construct-only="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance">
        <type name="SocketAddressEnumerator" c:type="GSocketAddressEnumerator"/>
      </field>
      <field name="priv">
        <type name="ProxyAddressEnumeratorPrivate" c:type="GProxyAddressEnumeratorPrivate*"/>
      </field>
    </class>
    <record name="ProxyAddressEnumeratorClass" c:type="GProxyAddressEnumeratorClass" glib:is-gtype-struct-for="ProxyAddressEnumerator">
      <field name="parent_class">
        <type name="SocketAddressEnumeratorClass" c:type="GSocketAddressEnumeratorClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved6" introspectable="0">
        <callback name="_g_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved7" introspectable="0">
        <callback name="_g_reserved7">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="ProxyAddressEnumeratorPrivate" c:type="GProxyAddressEnumeratorPrivate" disguised="1">
    </record>
    <record name="ProxyAddressPrivate" c:type="GProxyAddressPrivate" disguised="1">
    </record>
    <record name="ProxyInterface" c:type="GProxyInterface" glib:is-gtype-struct-for="Proxy" version="2.26">
      <doc xml:space="preserve">Provides an interface for handling proxy connection and payload.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="connect">
        <callback name="connect" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GIOStream that will replace @connection. This might
              be the same as @connection, in which case a reference
              will be added.</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </return-value>
          <parameters>
            <parameter name="proxy" transfer-ownership="none">
              <doc xml:space="preserve">a #GProxy</doc>
              <type name="Proxy" c:type="GProxy*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">a #GIOStream</doc>
              <type name="IOStream" c:type="GIOStream*"/>
            </parameter>
            <parameter name="proxy_address" transfer-ownership="none">
              <doc xml:space="preserve">a #GProxyAddress</doc>
              <type name="ProxyAddress" c:type="GProxyAddress*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="connect_async">
        <callback name="connect_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="proxy" transfer-ownership="none">
              <doc xml:space="preserve">a #GProxy</doc>
              <type name="Proxy" c:type="GProxy*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">a #GIOStream</doc>
              <type name="IOStream" c:type="GIOStream*"/>
            </parameter>
            <parameter name="proxy_address" transfer-ownership="none">
              <doc xml:space="preserve">a #GProxyAddress</doc>
              <type name="ProxyAddress" c:type="GProxyAddress*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">a #GAsyncReadyCallback</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">callback data</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="connect_finish">
        <callback name="connect_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GIOStream.</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </return-value>
          <parameters>
            <parameter name="proxy" transfer-ownership="none">
              <doc xml:space="preserve">a #GProxy</doc>
              <type name="Proxy" c:type="GProxy*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="supports_hostname">
        <callback name="supports_hostname">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if hostname resolution is supported.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="proxy" transfer-ownership="none">
              <doc xml:space="preserve">a #GProxy</doc>
              <type name="Proxy" c:type="GProxy*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <interface name="ProxyResolver" c:symbol-prefix="proxy_resolver" c:type="GProxyResolver" version="2.26" glib:type-name="GProxyResolver" glib:get-type="g_proxy_resolver_get_type" glib:type-struct="ProxyResolverInterface">
      <doc xml:space="preserve">#GProxyResolver provides synchronous and asynchronous network proxy
resolution. #GProxyResolver is used within #GSocketClient through
the method g_socket_connectable_proxy_enumerate().

Implementations of #GProxyResolver based on libproxy and GNOME settings can
be found in glib-networking. GIO comes with an implementation for use inside
Flatpak portals.</doc>
      <function name="get_default" c:identifier="g_proxy_resolver_get_default" version="2.26">
        <doc xml:space="preserve">Gets the default #GProxyResolver for the system.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the default #GProxyResolver.</doc>
          <type name="ProxyResolver" c:type="GProxyResolver*"/>
        </return-value>
      </function>
      <virtual-method name="is_supported" invoker="is_supported" version="2.26">
        <doc xml:space="preserve">Checks if @resolver can be used on this system. (This is used
internally; g_proxy_resolver_get_default() will only return a proxy
resolver that returns %TRUE for this method.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @resolver is supported.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxyResolver</doc>
            <type name="ProxyResolver" c:type="GProxyResolver*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup" invoker="lookup" version="2.26" throws="1">
        <doc xml:space="preserve">Looks into the system proxy configuration to determine what proxy,
if any, to use to connect to @uri. The returned proxy URIs are of
the form `&lt;protocol&gt;://[user[:password]@]host:port` or
`direct://`, where &lt;protocol&gt; could be http, rtsp, socks
or other proxying protocol.

If you don't know what network protocol is being used on the
socket, you should use `none` as the URI protocol.
In this case, the resolver might still return a generic proxy type
(such as SOCKS), but would not return protocol-specific proxy types
(such as http).

`direct://` is used when no proxy is needed.
Direct connection should not be attempted unless it is part of the
returned array of proxies.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A
              NULL-terminated array of proxy URIs. Must be freed
              with g_strfreev().</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxyResolver</doc>
            <type name="ProxyResolver" c:type="GProxyResolver*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a URI representing the destination to connect to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_async" invoker="lookup_async" version="2.26">
        <doc xml:space="preserve">Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxyResolver</doc>
            <type name="ProxyResolver" c:type="GProxyResolver*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a URI representing the destination to connect to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">callback to call after resolution completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_finish" invoker="lookup_finish" version="2.26" throws="1">
        <doc xml:space="preserve">Call this function to obtain the array of proxy URIs when
g_proxy_resolver_lookup_async() is complete. See
g_proxy_resolver_lookup() for more details.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A
              NULL-terminated array of proxy URIs. Must be freed
              with g_strfreev().</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxyResolver</doc>
            <type name="ProxyResolver" c:type="GProxyResolver*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="is_supported" c:identifier="g_proxy_resolver_is_supported" version="2.26">
        <doc xml:space="preserve">Checks if @resolver can be used on this system. (This is used
internally; g_proxy_resolver_get_default() will only return a proxy
resolver that returns %TRUE for this method.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @resolver is supported.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxyResolver</doc>
            <type name="ProxyResolver" c:type="GProxyResolver*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="lookup" c:identifier="g_proxy_resolver_lookup" version="2.26" throws="1">
        <doc xml:space="preserve">Looks into the system proxy configuration to determine what proxy,
if any, to use to connect to @uri. The returned proxy URIs are of
the form `&lt;protocol&gt;://[user[:password]@]host:port` or
`direct://`, where &lt;protocol&gt; could be http, rtsp, socks
or other proxying protocol.

If you don't know what network protocol is being used on the
socket, you should use `none` as the URI protocol.
In this case, the resolver might still return a generic proxy type
(such as SOCKS), but would not return protocol-specific proxy types
(such as http).

`direct://` is used when no proxy is needed.
Direct connection should not be attempted unless it is part of the
returned array of proxies.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A
              NULL-terminated array of proxy URIs. Must be freed
              with g_strfreev().</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxyResolver</doc>
            <type name="ProxyResolver" c:type="GProxyResolver*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a URI representing the destination to connect to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_async" c:identifier="g_proxy_resolver_lookup_async" version="2.26">
        <doc xml:space="preserve">Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxyResolver</doc>
            <type name="ProxyResolver" c:type="GProxyResolver*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a URI representing the destination to connect to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">callback to call after resolution completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_finish" c:identifier="g_proxy_resolver_lookup_finish" version="2.26" throws="1">
        <doc xml:space="preserve">Call this function to obtain the array of proxy URIs when
g_proxy_resolver_lookup_async() is complete. See
g_proxy_resolver_lookup() for more details.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A
              NULL-terminated array of proxy URIs. Must be freed
              with g_strfreev().</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxyResolver</doc>
            <type name="ProxyResolver" c:type="GProxyResolver*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="ProxyResolverInterface" c:type="GProxyResolverInterface" glib:is-gtype-struct-for="ProxyResolver">
      <doc xml:space="preserve">The virtual function table for #GProxyResolver.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="is_supported">
        <callback name="is_supported">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @resolver is supported.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <doc xml:space="preserve">a #GProxyResolver</doc>
              <type name="ProxyResolver" c:type="GProxyResolver*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup">
        <callback name="lookup" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A
              NULL-terminated array of proxy URIs. Must be freed
              with g_strfreev().</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <doc xml:space="preserve">a #GProxyResolver</doc>
              <type name="ProxyResolver" c:type="GProxyResolver*"/>
            </parameter>
            <parameter name="uri" transfer-ownership="none">
              <doc xml:space="preserve">a URI representing the destination to connect to</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_async">
        <callback name="lookup_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <doc xml:space="preserve">a #GProxyResolver</doc>
              <type name="ProxyResolver" c:type="GProxyResolver*"/>
            </parameter>
            <parameter name="uri" transfer-ownership="none">
              <doc xml:space="preserve">a URI representing the destination to connect to</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">callback to call after resolution completes</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">data for @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_finish">
        <callback name="lookup_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A
              NULL-terminated array of proxy URIs. Must be freed
              with g_strfreev().</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <doc xml:space="preserve">a #GProxyResolver</doc>
              <type name="ProxyResolver" c:type="GProxyResolver*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">the result passed to your #GAsyncReadyCallback</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <callback name="ReallocFunc" c:type="GReallocFunc">
      <doc xml:space="preserve">Changes the size of the memory block pointed to by @data to
@size bytes.

The function should have the same semantics as realloc().</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">a pointer to the reallocated memory</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">memory block to reallocate</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve">size to reallocate @data to</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </callback>
    <interface name="RemoteActionGroup" c:symbol-prefix="remote_action_group" c:type="GRemoteActionGroup" glib:type-name="GRemoteActionGroup" glib:get-type="g_remote_action_group_get_type" glib:type-struct="RemoteActionGroupInterface">
      <doc xml:space="preserve">The GRemoteActionGroup interface is implemented by #GActionGroup
instances that either transmit action invocations to other processes
or receive action invocations in the local process from other
processes.

The interface has `_full` variants of the two
methods on #GActionGroup used to activate actions:
g_action_group_activate_action() and
g_action_group_change_action_state(). These variants allow a
"platform data" #GVariant to be specified: a dictionary providing
context for the action invocation (for example: timestamps, startup
notification IDs, etc).

#GDBusActionGroup implements #GRemoteActionGroup.  This provides a
mechanism to send platform data for action invocations over D-Bus.

Additionally, g_dbus_connection_export_action_group() will check if
the exported #GActionGroup implements #GRemoteActionGroup and use the
`_full` variants of the calls if available.  This
provides a mechanism by which to receive platform data for action
invocations that arrive by way of D-Bus.</doc>
      <prerequisite name="ActionGroup"/>
      <virtual-method name="activate_action_full" invoker="activate_action_full" version="2.32">
        <doc xml:space="preserve">Activates the remote action.

This is the same as g_action_group_activate_action() except that it
allows for provision of "platform data" to be sent along with the
activation request.  This typically contains details such as the user
interaction timestamp or startup notification information.

@platform_data must be non-%NULL and must have the type
%G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="remote" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusActionGroup</doc>
            <type name="RemoteActionGroup" c:type="GRemoteActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action to activate</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="parameter" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the optional parameter to the activation</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="platform_data" transfer-ownership="none">
            <doc xml:space="preserve">the platform data to send</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="change_action_state_full" invoker="change_action_state_full" version="2.32">
        <doc xml:space="preserve">Changes the state of a remote action.

This is the same as g_action_group_change_action_state() except that
it allows for provision of "platform data" to be sent along with the
state change request.  This typically contains details such as the
user interaction timestamp or startup notification information.

@platform_data must be non-%NULL and must have the type
%G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="remote" transfer-ownership="none">
            <doc xml:space="preserve">a #GRemoteActionGroup</doc>
            <type name="RemoteActionGroup" c:type="GRemoteActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action to change the state of</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the new requested value for the state</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="platform_data" transfer-ownership="none">
            <doc xml:space="preserve">the platform data to send</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="activate_action_full" c:identifier="g_remote_action_group_activate_action_full" version="2.32">
        <doc xml:space="preserve">Activates the remote action.

This is the same as g_action_group_activate_action() except that it
allows for provision of "platform data" to be sent along with the
activation request.  This typically contains details such as the user
interaction timestamp or startup notification information.

@platform_data must be non-%NULL and must have the type
%G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="remote" transfer-ownership="none">
            <doc xml:space="preserve">a #GDBusActionGroup</doc>
            <type name="RemoteActionGroup" c:type="GRemoteActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action to activate</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="parameter" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the optional parameter to the activation</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="platform_data" transfer-ownership="none">
            <doc xml:space="preserve">the platform data to send</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="change_action_state_full" c:identifier="g_remote_action_group_change_action_state_full" version="2.32">
        <doc xml:space="preserve">Changes the state of a remote action.

This is the same as g_action_group_change_action_state() except that
it allows for provision of "platform data" to be sent along with the
state change request.  This typically contains details such as the
user interaction timestamp or startup notification information.

@platform_data must be non-%NULL and must have the type
%G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="remote" transfer-ownership="none">
            <doc xml:space="preserve">a #GRemoteActionGroup</doc>
            <type name="RemoteActionGroup" c:type="GRemoteActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action to change the state of</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the new requested value for the state</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="platform_data" transfer-ownership="none">
            <doc xml:space="preserve">the platform data to send</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="RemoteActionGroupInterface" c:type="GRemoteActionGroupInterface" glib:is-gtype-struct-for="RemoteActionGroup" version="2.32">
      <doc xml:space="preserve">The virtual function table for #GRemoteActionGroup.</doc>
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="activate_action_full">
        <callback name="activate_action_full">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="remote" transfer-ownership="none">
              <doc xml:space="preserve">a #GDBusActionGroup</doc>
              <type name="RemoteActionGroup" c:type="GRemoteActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve">the name of the action to activate</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="parameter" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">the optional parameter to the activation</doc>
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
            <parameter name="platform_data" transfer-ownership="none">
              <doc xml:space="preserve">the platform data to send</doc>
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="change_action_state_full">
        <callback name="change_action_state_full">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="remote" transfer-ownership="none">
              <doc xml:space="preserve">a #GRemoteActionGroup</doc>
              <type name="RemoteActionGroup" c:type="GRemoteActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve">the name of the action to change the state of</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <doc xml:space="preserve">the new requested value for the state</doc>
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
            <parameter name="platform_data" transfer-ownership="none">
              <doc xml:space="preserve">the platform data to send</doc>
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="Resolver" c:symbol-prefix="resolver" c:type="GResolver" parent="GObject.Object" abstract="1" glib:type-name="GResolver" glib:get-type="g_resolver_get_type" glib:type-struct="ResolverClass">
      <doc xml:space="preserve">#GResolver provides cancellable synchronous and asynchronous DNS
resolution, for hostnames (g_resolver_lookup_by_address(),
g_resolver_lookup_by_name() and their async variants) and SRV
(service) records (g_resolver_lookup_service()).

#GNetworkAddress and #GNetworkService provide wrappers around
#GResolver functionality that also implement #GSocketConnectable,
making it easy to connect to a remote host/service.</doc>
      <function name="free_addresses" c:identifier="g_resolver_free_addresses" version="2.22" introspectable="0">
        <doc xml:space="preserve">Frees @addresses (which should be the return value from
g_resolver_lookup_by_name() or g_resolver_lookup_by_name_finish()).
(This is a convenience method; you can also simply free the results
by hand.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="addresses" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of #GInetAddress</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="free_targets" c:identifier="g_resolver_free_targets" version="2.22" introspectable="0">
        <doc xml:space="preserve">Frees @targets (which should be the return value from
g_resolver_lookup_service() or g_resolver_lookup_service_finish()).
(This is a convenience method; you can also simply free the
results by hand.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="targets" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of #GSrvTarget</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="get_default" c:identifier="g_resolver_get_default" version="2.22">
        <doc xml:space="preserve">Gets the default #GResolver. You should unref it when you are done
with it. #GResolver may use its reference count as a hint about how
many threads it should allocate for concurrent DNS resolutions.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the default #GResolver.</doc>
          <type name="Resolver" c:type="GResolver*"/>
        </return-value>
      </function>
      <virtual-method name="lookup_by_address" invoker="lookup_by_address" version="2.22" throws="1">
        <doc xml:space="preserve">Synchronously reverse-resolves @address to determine its
associated hostname.

If the DNS resolution fails, @error (if non-%NULL) will be set to
a value from #GResolverError.

If @cancellable is non-%NULL, it can be used to cancel the
operation, in which case @error (if non-%NULL) will be set to
%G_IO_ERROR_CANCELLED.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a hostname (either ASCII-only, or in ASCII-encoded
    form), or %NULL on error.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GResolver</doc>
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the address to reverse-resolve</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_by_address_async" invoker="lookup_by_address_async" version="2.22">
        <doc xml:space="preserve">Begins asynchronously reverse-resolving @address to determine its
associated hostname, and eventually calls @callback, which must
call g_resolver_lookup_by_address_finish() to get the final result.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GResolver</doc>
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the address to reverse-resolve</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">callback to call after resolution completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_by_address_finish" invoker="lookup_by_address_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Retrieves the result of a previous call to
g_resolver_lookup_by_address_async().

If the DNS resolution failed, @error (if non-%NULL) will be set to
a value from #GResolverError. If the operation was cancelled,
@error will be set to %G_IO_ERROR_CANCELLED.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a hostname (either ASCII-only, or in ASCII-encoded
form), or %NULL on error.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GResolver</doc>
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_by_name" invoker="lookup_by_name" version="2.22" throws="1">
        <doc xml:space="preserve">Synchronously resolves @hostname to determine its associated IP
address(es). @hostname may be an ASCII-only or UTF-8 hostname, or
the textual form of an IP address (in which case this just becomes
a wrapper around g_inet_address_new_from_string()).

On success, g_resolver_lookup_by_name() will return a non-empty #GList of
#GInetAddress, sorted in order of preference and guaranteed to not
contain duplicates. That is, if using the result to connect to
@hostname, you should attempt to connect to the first address
first, then the second if the first fails, etc. If you are using
the result to listen on a socket, it is appropriate to add each
result using e.g. g_socket_listener_add_address().

If the DNS resolution fails, @error (if non-%NULL) will be set to a
value from #GResolverError and %NULL will be returned.

If @cancellable is non-%NULL, it can be used to cancel the
operation, in which case @error (if non-%NULL) will be set to
%G_IO_ERROR_CANCELLED.

If you are planning to connect to a socket on the resolved IP
address, it may be easier to create a #GNetworkAddress and use its
#GSocketConnectable interface.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a non-empty #GList
of #GInetAddress, or %NULL on error. You
must unref each of the addresses and free the list when you are
done with it. (You can use g_resolver_free_addresses() to do this.)</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="InetAddress"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GResolver</doc>
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
          <parameter name="hostname" transfer-ownership="none">
            <doc xml:space="preserve">the hostname to look up</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_by_name_async" invoker="lookup_by_name_async" version="2.22">
        <doc xml:space="preserve">Begins asynchronously resolving @hostname to determine its
associated IP address(es), and eventually calls @callback, which
must call g_resolver_lookup_by_name_finish() to get the result.
See g_resolver_lookup_by_name() for more details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GResolver</doc>
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
          <parameter name="hostname" transfer-ownership="none">
            <doc xml:space="preserve">the hostname to look up the address of</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">callback to call after resolution completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_by_name_finish" invoker="lookup_by_name_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Retrieves the result of a call to
g_resolver_lookup_by_name_async().

If the DNS resolution failed, @error (if non-%NULL) will be set to
a value from #GResolverError. If the operation was cancelled,
@error will be set to %G_IO_ERROR_CANCELLED.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GList
of #GInetAddress, or %NULL on error. See g_resolver_lookup_by_name()
for more details.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="InetAddress"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GResolver</doc>
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_records" invoker="lookup_records" version="2.34" throws="1">
        <doc xml:space="preserve">Synchronously performs a DNS record lookup for the given @rrname and returns
a list of records as #GVariant tuples. See #GResolverRecordType for
information on what the records contain for each @record_type.

If the DNS resolution fails, @error (if non-%NULL) will be set to
a value from #GResolverError and %NULL will be returned.

If @cancellable is non-%NULL, it can be used to cancel the
operation, in which case @error (if non-%NULL) will be set to
%G_IO_ERROR_CANCELLED.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a non-empty #GList of
#GVariant, or %NULL on error. You must free each of the records and the list
when you are done with it. (You can use g_list_free_full() with
g_variant_unref() to do this.)</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="GLib.Variant"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GResolver</doc>
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
          <parameter name="rrname" transfer-ownership="none">
            <doc xml:space="preserve">the DNS name to lookup the record for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="record_type" transfer-ownership="none">
            <doc xml:space="preserve">the type of DNS record to lookup</doc>
            <type name="ResolverRecordType" c:type="GResolverRecordType"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_records_async" invoker="lookup_records_async" version="2.34">
        <doc xml:space="preserve">Begins asynchronously performing a DNS lookup for the given
@rrname, and eventually calls @callback, which must call
g_resolver_lookup_records_finish() to get the final result. See
g_resolver_lookup_records() for more details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GResolver</doc>
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
          <parameter name="rrname" transfer-ownership="none">
            <doc xml:space="preserve">the DNS name to lookup the record for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="record_type" transfer-ownership="none">
            <doc xml:space="preserve">the type of DNS record to lookup</doc>
            <type name="ResolverRecordType" c:type="GResolverRecordType"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">callback to call after resolution completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_records_finish" invoker="lookup_records_finish" version="2.34" throws="1">
        <doc xml:space="preserve">Retrieves the result of a previous call to
g_resolver_lookup_records_async(). Returns a non-empty list of records as
#GVariant tuples. See #GResolverRecordType for information on what the
records contain.

If the DNS resolution failed, @error (if non-%NULL) will be set to
a value from #GResolverError. If the operation was cancelled,
@error will be set to %G_IO_ERROR_CANCELLED.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a non-empty #GList of
#GVariant, or %NULL on error. You must free each of the records and the list
when you are done with it. (You can use g_list_free_full() with
g_variant_unref() to do this.)</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="GLib.Variant"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GResolver</doc>
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_service" introspectable="0" throws="1">
        <return-value>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
          <parameter name="rrname" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_service_async">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
          <parameter name="rrname" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_service_finish" invoker="lookup_service_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Retrieves the result of a previous call to
g_resolver_lookup_service_async().

If the DNS resolution failed, @error (if non-%NULL) will be set to
a value from #GResolverError. If the operation was cancelled,
@error will be set to %G_IO_ERROR_CANCELLED.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a non-empty #GList of
#GSrvTarget, or %NULL on error. See g_resolver_lookup_service() for more
details.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="SrvTarget"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GResolver</doc>
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="reload">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="lookup_by_address" c:identifier="g_resolver_lookup_by_address" version="2.22" throws="1">
        <doc xml:space="preserve">Synchronously reverse-resolves @address to determine its
associated hostname.

If the DNS resolution fails, @error (if non-%NULL) will be set to
a value from #GResolverError.

If @cancellable is non-%NULL, it can be used to cancel the
operation, in which case @error (if non-%NULL) will be set to
%G_IO_ERROR_CANCELLED.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a hostname (either ASCII-only, or in ASCII-encoded
    form), or %NULL on error.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GResolver</doc>
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the address to reverse-resolve</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_by_address_async" c:identifier="g_resolver_lookup_by_address_async" version="2.22">
        <doc xml:space="preserve">Begins asynchronously reverse-resolving @address to determine its
associated hostname, and eventually calls @callback, which must
call g_resolver_lookup_by_address_finish() to get the final result.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GResolver</doc>
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the address to reverse-resolve</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">callback to call after resolution completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_by_address_finish" c:identifier="g_resolver_lookup_by_address_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Retrieves the result of a previous call to
g_resolver_lookup_by_address_async().

If the DNS resolution failed, @error (if non-%NULL) will be set to
a value from #GResolverError. If the operation was cancelled,
@error will be set to %G_IO_ERROR_CANCELLED.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a hostname (either ASCII-only, or in ASCII-encoded
form), or %NULL on error.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GResolver</doc>
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_by_name" c:identifier="g_resolver_lookup_by_name" version="2.22" throws="1">
        <doc xml:space="preserve">Synchronously resolves @hostname to determine its associated IP
address(es). @hostname may be an ASCII-only or UTF-8 hostname, or
the textual form of an IP address (in which case this just becomes
a wrapper around g_inet_address_new_from_string()).

On success, g_resolver_lookup_by_name() will return a non-empty #GList of
#GInetAddress, sorted in order of preference and guaranteed to not
contain duplicates. That is, if using the result to connect to
@hostname, you should attempt to connect to the first address
first, then the second if the first fails, etc. If you are using
the result to listen on a socket, it is appropriate to add each
result using e.g. g_socket_listener_add_address().

If the DNS resolution fails, @error (if non-%NULL) will be set to a
value from #GResolverError and %NULL will be returned.

If @cancellable is non-%NULL, it can be used to cancel the
operation, in which case @error (if non-%NULL) will be set to
%G_IO_ERROR_CANCELLED.

If you are planning to connect to a socket on the resolved IP
address, it may be easier to create a #GNetworkAddress and use its
#GSocketConnectable interface.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a non-empty #GList
of #GInetAddress, or %NULL on error. You
must unref each of the addresses and free the list when you are
done with it. (You can use g_resolver_free_addresses() to do this.)</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="InetAddress"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GResolver</doc>
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
          <parameter name="hostname" transfer-ownership="none">
            <doc xml:space="preserve">the hostname to look up</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_by_name_async" c:identifier="g_resolver_lookup_by_name_async" version="2.22">
        <doc xml:space="preserve">Begins asynchronously resolving @hostname to determine its
associated IP address(es), and eventually calls @callback, which
must call g_resolver_lookup_by_name_finish() to get the result.
See g_resolver_lookup_by_name() for more details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GResolver</doc>
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
          <parameter name="hostname" transfer-ownership="none">
            <doc xml:space="preserve">the hostname to look up the address of</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">callback to call after resolution completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_by_name_finish" c:identifier="g_resolver_lookup_by_name_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Retrieves the result of a call to
g_resolver_lookup_by_name_async().

If the DNS resolution failed, @error (if non-%NULL) will be set to
a value from #GResolverError. If the operation was cancelled,
@error will be set to %G_IO_ERROR_CANCELLED.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GList
of #GInetAddress, or %NULL on error. See g_resolver_lookup_by_name()
for more details.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="InetAddress"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GResolver</doc>
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_records" c:identifier="g_resolver_lookup_records" version="2.34" throws="1">
        <doc xml:space="preserve">Synchronously performs a DNS record lookup for the given @rrname and returns
a list of records as #GVariant tuples. See #GResolverRecordType for
information on what the records contain for each @record_type.

If the DNS resolution fails, @error (if non-%NULL) will be set to
a value from #GResolverError and %NULL will be returned.

If @cancellable is non-%NULL, it can be used to cancel the
operation, in which case @error (if non-%NULL) will be set to
%G_IO_ERROR_CANCELLED.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a non-empty #GList of
#GVariant, or %NULL on error. You must free each of the records and the list
when you are done with it. (You can use g_list_free_full() with
g_variant_unref() to do this.)</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="GLib.Variant"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GResolver</doc>
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
          <parameter name="rrname" transfer-ownership="none">
            <doc xml:space="preserve">the DNS name to lookup the record for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="record_type" transfer-ownership="none">
            <doc xml:space="preserve">the type of DNS record to lookup</doc>
            <type name="ResolverRecordType" c:type="GResolverRecordType"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_records_async" c:identifier="g_resolver_lookup_records_async" version="2.34">
        <doc xml:space="preserve">Begins asynchronously performing a DNS lookup for the given
@rrname, and eventually calls @callback, which must call
g_resolver_lookup_records_finish() to get the final result. See
g_resolver_lookup_records() for more details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GResolver</doc>
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
          <parameter name="rrname" transfer-ownership="none">
            <doc xml:space="preserve">the DNS name to lookup the record for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="record_type" transfer-ownership="none">
            <doc xml:space="preserve">the type of DNS record to lookup</doc>
            <type name="ResolverRecordType" c:type="GResolverRecordType"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">callback to call after resolution completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_records_finish" c:identifier="g_resolver_lookup_records_finish" version="2.34" throws="1">
        <doc xml:space="preserve">Retrieves the result of a previous call to
g_resolver_lookup_records_async(). Returns a non-empty list of records as
#GVariant tuples. See #GResolverRecordType for information on what the
records contain.

If the DNS resolution failed, @error (if non-%NULL) will be set to
a value from #GResolverError. If the operation was cancelled,
@error will be set to %G_IO_ERROR_CANCELLED.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a non-empty #GList of
#GVariant, or %NULL on error. You must free each of the records and the list
when you are done with it. (You can use g_list_free_full() with
g_variant_unref() to do this.)</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="GLib.Variant"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GResolver</doc>
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_service" c:identifier="g_resolver_lookup_service" version="2.22" throws="1">
        <doc xml:space="preserve">Synchronously performs a DNS SRV lookup for the given @service and
@protocol in the given @domain and returns an array of #GSrvTarget.
@domain may be an ASCII-only or UTF-8 hostname. Note also that the
@service and @protocol arguments do not include the leading underscore
that appears in the actual DNS entry.

On success, g_resolver_lookup_service() will return a non-empty #GList of
#GSrvTarget, sorted in order of preference. (That is, you should
attempt to connect to the first target first, then the second if
the first fails, etc.)

If the DNS resolution fails, @error (if non-%NULL) will be set to
a value from #GResolverError and %NULL will be returned.

If @cancellable is non-%NULL, it can be used to cancel the
operation, in which case @error (if non-%NULL) will be set to
%G_IO_ERROR_CANCELLED.

If you are planning to connect to the service, it is usually easier
to create a #GNetworkService and use its #GSocketConnectable
interface.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a non-empty #GList of
#GSrvTarget, or %NULL on error. You must free each of the targets and the
list when you are done with it. (You can use g_resolver_free_targets() to do
this.)</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="SrvTarget"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GResolver</doc>
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">the service type to look up (eg, "ldap")</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:space="preserve">the networking protocol to use for @service (eg, "tcp")</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">the DNS domain to look up the service in</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_service_async" c:identifier="g_resolver_lookup_service_async" version="2.22">
        <doc xml:space="preserve">Begins asynchronously performing a DNS SRV lookup for the given
@service and @protocol in the given @domain, and eventually calls
@callback, which must call g_resolver_lookup_service_finish() to
get the final result. See g_resolver_lookup_service() for more
details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GResolver</doc>
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">the service type to look up (eg, "ldap")</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:space="preserve">the networking protocol to use for @service (eg, "tcp")</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">the DNS domain to look up the service in</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">callback to call after resolution completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_service_finish" c:identifier="g_resolver_lookup_service_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Retrieves the result of a previous call to
g_resolver_lookup_service_async().

If the DNS resolution failed, @error (if non-%NULL) will be set to
a value from #GResolverError. If the operation was cancelled,
@error will be set to %G_IO_ERROR_CANCELLED.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a non-empty #GList of
#GSrvTarget, or %NULL on error. See g_resolver_lookup_service() for more
details.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="SrvTarget"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GResolver</doc>
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_default" c:identifier="g_resolver_set_default" version="2.22">
        <doc xml:space="preserve">Sets @resolver to be the application's default resolver (reffing
@resolver, and unreffing the previous default resolver, if any).
Future calls to g_resolver_get_default() will return this resolver.

This can be used if an application wants to perform any sort of DNS
caching or "pinning"; it can implement its own #GResolver that
calls the original default resolver for DNS operations, and
implements its own cache policies on top of that, and then set
itself as the default resolver for all later code to use.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">the new default #GResolver</doc>
            <type name="Resolver" c:type="GResolver*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="ResolverPrivate" c:type="GResolverPrivate*"/>
      </field>
      <glib:signal name="reload" when="last">
        <doc xml:space="preserve">Emitted when the resolver notices that the system resolver
configuration has changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="ResolverClass" c:type="GResolverClass" glib:is-gtype-struct-for="Resolver">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="reload">
        <callback name="reload">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <type name="Resolver" c:type="GResolver*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_by_name">
        <callback name="lookup_by_name" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a non-empty #GList
of #GInetAddress, or %NULL on error. You
must unref each of the addresses and free the list when you are
done with it. (You can use g_resolver_free_addresses() to do this.)</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="InetAddress"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <doc xml:space="preserve">a #GResolver</doc>
              <type name="Resolver" c:type="GResolver*"/>
            </parameter>
            <parameter name="hostname" transfer-ownership="none">
              <doc xml:space="preserve">the hostname to look up</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_by_name_async">
        <callback name="lookup_by_name_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <doc xml:space="preserve">a #GResolver</doc>
              <type name="Resolver" c:type="GResolver*"/>
            </parameter>
            <parameter name="hostname" transfer-ownership="none">
              <doc xml:space="preserve">the hostname to look up the address of</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">callback to call after resolution completes</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">data for @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_by_name_finish">
        <callback name="lookup_by_name_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GList
of #GInetAddress, or %NULL on error. See g_resolver_lookup_by_name()
for more details.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="InetAddress"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <doc xml:space="preserve">a #GResolver</doc>
              <type name="Resolver" c:type="GResolver*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">the result passed to your #GAsyncReadyCallback</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_by_address">
        <callback name="lookup_by_address" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a hostname (either ASCII-only, or in ASCII-encoded
    form), or %NULL on error.</doc>
            <type name="utf8" c:type="gchar*"/>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <doc xml:space="preserve">a #GResolver</doc>
              <type name="Resolver" c:type="GResolver*"/>
            </parameter>
            <parameter name="address" transfer-ownership="none">
              <doc xml:space="preserve">the address to reverse-resolve</doc>
              <type name="InetAddress" c:type="GInetAddress*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_by_address_async">
        <callback name="lookup_by_address_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <doc xml:space="preserve">a #GResolver</doc>
              <type name="Resolver" c:type="GResolver*"/>
            </parameter>
            <parameter name="address" transfer-ownership="none">
              <doc xml:space="preserve">the address to reverse-resolve</doc>
              <type name="InetAddress" c:type="GInetAddress*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">callback to call after resolution completes</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">data for @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_by_address_finish">
        <callback name="lookup_by_address_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a hostname (either ASCII-only, or in ASCII-encoded
form), or %NULL on error.</doc>
            <type name="utf8" c:type="gchar*"/>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <doc xml:space="preserve">a #GResolver</doc>
              <type name="Resolver" c:type="GResolver*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">the result passed to your #GAsyncReadyCallback</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_service" introspectable="0">
        <callback name="lookup_service" introspectable="0" throws="1">
          <return-value>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <type name="Resolver" c:type="GResolver*"/>
            </parameter>
            <parameter name="rrname" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_service_async">
        <callback name="lookup_service_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <type name="Resolver" c:type="GResolver*"/>
            </parameter>
            <parameter name="rrname" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_service_finish">
        <callback name="lookup_service_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a non-empty #GList of
#GSrvTarget, or %NULL on error. See g_resolver_lookup_service() for more
details.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="SrvTarget"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <doc xml:space="preserve">a #GResolver</doc>
              <type name="Resolver" c:type="GResolver*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">the result passed to your #GAsyncReadyCallback</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_records">
        <callback name="lookup_records" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a non-empty #GList of
#GVariant, or %NULL on error. You must free each of the records and the list
when you are done with it. (You can use g_list_free_full() with
g_variant_unref() to do this.)</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="GLib.Variant"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <doc xml:space="preserve">a #GResolver</doc>
              <type name="Resolver" c:type="GResolver*"/>
            </parameter>
            <parameter name="rrname" transfer-ownership="none">
              <doc xml:space="preserve">the DNS name to lookup the record for</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="record_type" transfer-ownership="none">
              <doc xml:space="preserve">the type of DNS record to lookup</doc>
              <type name="ResolverRecordType" c:type="GResolverRecordType"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_records_async">
        <callback name="lookup_records_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <doc xml:space="preserve">a #GResolver</doc>
              <type name="Resolver" c:type="GResolver*"/>
            </parameter>
            <parameter name="rrname" transfer-ownership="none">
              <doc xml:space="preserve">the DNS name to lookup the record for</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="record_type" transfer-ownership="none">
              <doc xml:space="preserve">the type of DNS record to lookup</doc>
              <type name="ResolverRecordType" c:type="GResolverRecordType"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">callback to call after resolution completes</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">data for @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_records_finish">
        <callback name="lookup_records_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a non-empty #GList of
#GVariant, or %NULL on error. You must free each of the records and the list
when you are done with it. (You can use g_list_free_full() with
g_variant_unref() to do this.)</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="GLib.Variant"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <doc xml:space="preserve">a #GResolver</doc>
              <type name="Resolver" c:type="GResolver*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">the result passed to your #GAsyncReadyCallback</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved6" introspectable="0">
        <callback name="_g_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="ResolverError" version="2.22" glib:type-name="GResolverError" glib:get-type="g_resolver_error_get_type" c:type="GResolverError" glib:error-domain="g-resolver-error-quark">
      <doc xml:space="preserve">An error code used with %G_RESOLVER_ERROR in a #GError returned
from a #GResolver routine.</doc>
      <member name="not_found" value="0" c:identifier="G_RESOLVER_ERROR_NOT_FOUND" glib:nick="not-found">
        <doc xml:space="preserve">the requested name/address/service was not
    found</doc>
      </member>
      <member name="temporary_failure" value="1" c:identifier="G_RESOLVER_ERROR_TEMPORARY_FAILURE" glib:nick="temporary-failure">
        <doc xml:space="preserve">the requested information could not
    be looked up due to a network error or similar problem</doc>
      </member>
      <member name="internal" value="2" c:identifier="G_RESOLVER_ERROR_INTERNAL" glib:nick="internal">
        <doc xml:space="preserve">unknown error</doc>
      </member>
      <function name="quark" c:identifier="g_resolver_error_quark" version="2.22">
        <doc xml:space="preserve">Gets the #GResolver Error Quark.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GQuark.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <record name="ResolverPrivate" c:type="GResolverPrivate" disguised="1">
    </record>
    <enumeration name="ResolverRecordType" version="2.34" glib:type-name="GResolverRecordType" glib:get-type="g_resolver_record_type_get_type" c:type="GResolverRecordType">
      <doc xml:space="preserve">The type of record that g_resolver_lookup_records() or
g_resolver_lookup_records_async() should retrieve. The records are returned
as lists of #GVariant tuples. Each record type has different values in
the variant tuples returned.

%G_RESOLVER_RECORD_SRV records are returned as variants with the signature
'(qqqs)', containing a guint16 with the priority, a guint16 with the
weight, a guint16 with the port, and a string of the hostname.

%G_RESOLVER_RECORD_MX records are returned as variants with the signature
'(qs)', representing a guint16 with the preference, and a string containing
the mail exchanger hostname.

%G_RESOLVER_RECORD_TXT records are returned as variants with the signature
'(as)', representing an array of the strings in the text record.

%G_RESOLVER_RECORD_SOA records are returned as variants with the signature
'(ssuuuuu)', representing a string containing the primary name server, a
string containing the administrator, the serial as a guint32, the refresh
interval as guint32, the retry interval as a guint32, the expire timeout
as a guint32, and the ttl as a guint32.

%G_RESOLVER_RECORD_NS records are returned as variants with the signature
'(s)', representing a string of the hostname of the name server.</doc>
      <member name="srv" value="1" c:identifier="G_RESOLVER_RECORD_SRV" glib:nick="srv">
        <doc xml:space="preserve">lookup DNS SRV records for a domain</doc>
      </member>
      <member name="mx" value="2" c:identifier="G_RESOLVER_RECORD_MX" glib:nick="mx">
        <doc xml:space="preserve">lookup DNS MX records for a domain</doc>
      </member>
      <member name="txt" value="3" c:identifier="G_RESOLVER_RECORD_TXT" glib:nick="txt">
        <doc xml:space="preserve">lookup DNS TXT records for a name</doc>
      </member>
      <member name="soa" value="4" c:identifier="G_RESOLVER_RECORD_SOA" glib:nick="soa">
        <doc xml:space="preserve">lookup DNS SOA records for a zone</doc>
      </member>
      <member name="ns" value="5" c:identifier="G_RESOLVER_RECORD_NS" glib:nick="ns">
        <doc xml:space="preserve">lookup DNS NS records for a domain</doc>
      </member>
    </enumeration>
    <record name="Resource" c:type="GResource" version="2.32" glib:type-name="GResource" glib:get-type="g_resource_get_type" c:symbol-prefix="resource">
      <doc xml:space="preserve">Applications and libraries often contain binary or textual data that is
really part of the application, rather than user data. For instance
#GtkBuilder .ui files, splashscreen images, GMenu markup XML, CSS files,
icons, etc. These are often shipped as files in `$datadir/appname`, or
manually included as literal strings in the code.

The #GResource API and the [glib-compile-resources][glib-compile-resources] program
provide a convenient and efficient alternative to this which has some nice properties. You
maintain the files as normal files, so its easy to edit them, but during the build the files
are combined into a binary bundle that is linked into the executable. This means that loading
the resource files are efficient (as they are already in memory, shared with other instances) and
simple (no need to check for things like I/O errors or locate the files in the filesystem). It
also makes it easier to create relocatable applications.

Resource files can also be marked as compressed. Such files will be included in the resource bundle
in a compressed form, but will be automatically uncompressed when the resource is used. This
is very useful e.g. for larger text files that are parsed once (or rarely) and then thrown away.

Resource files can also be marked to be preprocessed, by setting the value of the
`preprocess` attribute to a comma-separated list of preprocessing options.
The only options currently supported are:

`xml-stripblanks` which will use the xmllint command
to strip ignorable whitespace from the XML file. For this to work,
the `XMLLINT` environment variable must be set to the full path to
the xmllint executable, or xmllint must be in the `PATH`; otherwise
the preprocessing step is skipped.

`to-pixdata` which will use the gdk-pixbuf-pixdata command to convert
images to the GdkPixdata format, which allows you to create pixbufs directly using the data inside
the resource file, rather than an (uncompressed) copy if it. For this, the gdk-pixbuf-pixdata
program must be in the PATH, or the `GDK_PIXBUF_PIXDATA` environment variable must be
set to the full path to the gdk-pixbuf-pixdata executable; otherwise the resource compiler will
abort.

Resource files will be exported in the GResource namespace using the
combination of the given `prefix` and the filename from the `file` element.
The `alias` attribute can be used to alter the filename to expose them at a
different location in the resource namespace. Typically, this is used to
include files from a different source directory without exposing the source
directory in the resource namespace, as in the example below.

Resource bundles are created by the [glib-compile-resources][glib-compile-resources] program
which takes an XML file that describes the bundle, and a set of files that the XML references. These
are combined into a binary resource bundle.

An example resource description:
|[
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;gresources&gt;
  &lt;gresource prefix="/org/gtk/Example"&gt;
    &lt;file&gt;data/splashscreen.png&lt;/file&gt;
    &lt;file compressed="true"&gt;dialog.ui&lt;/file&gt;
    &lt;file preprocess="xml-stripblanks"&gt;menumarkup.xml&lt;/file&gt;
    &lt;file alias="example.css"&gt;data/example.css&lt;/file&gt;
  &lt;/gresource&gt;
&lt;/gresources&gt;
]|

This will create a resource bundle with the following files:
|[
/org/gtk/Example/data/splashscreen.png
/org/gtk/Example/dialog.ui
/org/gtk/Example/menumarkup.xml
/org/gtk/Example/example.css
]|

Note that all resources in the process share the same namespace, so use Java-style
path prefixes (like in the above example) to avoid conflicts.

You can then use [glib-compile-resources][glib-compile-resources] to compile the XML to a
binary bundle that you can load with g_resource_load(). However, its more common to use the --generate-source and
--generate-header arguments to create a source file and header to link directly into your application.
This will generate `get_resource()`, `register_resource()` and
`unregister_resource()` functions, prefixed by the `--c-name` argument passed
to [glib-compile-resources][glib-compile-resources]. `get_resource()` returns
the generated #GResource object. The register and unregister functions
register the resource so its files can be accessed using
g_resources_lookup_data().

Once a #GResource has been created and registered all the data in it can be accessed globally in the process by
using API calls like g_resources_open_stream() to stream the data or g_resources_lookup_data() to get a direct pointer
to the data. You can also use URIs like "resource:///org/gtk/Example/data/splashscreen.png" with #GFile to access
the resource data.

Some higher-level APIs, such as #GtkApplication, will automatically load
resources from certain well-known paths in the resource namespace as a
convenience. See the documentation for those APIs for details.

There are two forms of the generated source, the default version uses the compiler support for constructor
and destructor functions (where available) to automatically create and register the #GResource on startup
or library load time. If you pass `--manual-register`, two functions to register/unregister the resource are created
instead. This requires an explicit initialization call in your application/library, but it works on all platforms,
even on the minor ones where constructors are not supported. (Constructor support is available for at least Win32, Mac OS and Linux.)

Note that resource data can point directly into the data segment of e.g. a library, so if you are unloading libraries
during runtime you need to be very careful with keeping around pointers to data from a resource, as this goes away
when the library is unloaded. However, in practice this is not generally a problem, since most resource accesses
are for your own resources, and resource data is often used once, during parsing, and then released.

When debugging a program or testing a change to an installed version, it is often useful to be able to
replace resources in the program or library, without recompiling, for debugging or quick hacking and testing
purposes. Since GLib 2.50, it is possible to use the `G_RESOURCE_OVERLAYS` environment variable to selectively overlay
resources with replacements from the filesystem.  It is a colon-separated list of substitutions to perform
during resource lookups.

A substitution has the form

|[
   /org/gtk/libgtk=/home/desrt/gtk-overlay
]|

The part before the `=` is the resource subpath for which the overlay applies.  The part after is a
filesystem path which contains files and subdirectories as you would like to be loaded as resources with the
equivalent names.

In the example above, if an application tried to load a resource with the resource path
`/org/gtk/libgtk/ui/gtkdialog.ui` then GResource would check the filesystem path
`/home/desrt/gtk-overlay/ui/gtkdialog.ui`.  If a file was found there, it would be used instead.  This is an
overlay, not an outright replacement, which means that if a file is not found at that path, the built-in
version will be used instead.  Whiteouts are not currently supported.

Substitutions must start with a slash, and must not contain a trailing slash before the '='.  The path after
the slash should ideally be absolute, but this is not strictly required.  It is possible to overlay the
location of a single resource with an individual file.</doc>
      <constructor name="new_from_data" c:identifier="g_resource_new_from_data" version="2.32" throws="1">
        <doc xml:space="preserve">Creates a GResource from a reference to the binary resource bundle.
This will keep a reference to @data while the resource lives, so
the data should not be modified or freed.

If you want to use this resource in the global resource namespace you need
to register it with g_resources_register().

Note: @data must be backed by memory that is at least pointer aligned.
Otherwise this function will internally create a copy of the memory since
GLib 2.56, or in older versions fail and exit the process.

If @data is empty or corrupt, %G_RESOURCE_ERROR_INTERNAL will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GResource, or %NULL on error</doc>
          <type name="Resource" c:type="GResource*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">A #GBytes</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="_register" c:identifier="g_resources_register" moved-to="resources_register" version="2.32">
        <doc xml:space="preserve">Registers the resource with the process-global set of resources.
Once a resource is registered the files in it can be accessed
with the global resource lookup functions like g_resources_lookup_data().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="resource" transfer-ownership="none">
            <doc xml:space="preserve">A #GResource</doc>
            <type name="Resource" c:type="GResource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="_unregister" c:identifier="g_resources_unregister" moved-to="resources_unregister" version="2.32">
        <doc xml:space="preserve">Unregisters the resource from the process-global set of resources.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="resource" transfer-ownership="none">
            <doc xml:space="preserve">A #GResource</doc>
            <type name="Resource" c:type="GResource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="enumerate_children" c:identifier="g_resource_enumerate_children" version="2.32" throws="1">
        <doc xml:space="preserve">Returns all the names of children at the specified @path in the resource.
The return result is a %NULL terminated list of strings which should
be released with g_strfreev().

If @path is invalid or does not exist in the #GResource,
%G_RESOURCE_ERROR_NOT_FOUND will be returned.

@lookup_flags controls the behaviour of the lookup.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an array of constant strings</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="resource" transfer-ownership="none">
            <doc xml:space="preserve">A #GResource</doc>
            <type name="Resource" c:type="GResource*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">A pathname inside the resource</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="lookup_flags" transfer-ownership="none">
            <doc xml:space="preserve">A #GResourceLookupFlags</doc>
            <type name="ResourceLookupFlags" c:type="GResourceLookupFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_info" c:identifier="g_resource_get_info" version="2.32" throws="1">
        <doc xml:space="preserve">Looks for a file at the specified @path in the resource and
if found returns information about it.

@lookup_flags controls the behaviour of the lookup.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the file was found. %FALSE if there were errors</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="resource" transfer-ownership="none">
            <doc xml:space="preserve">A #GResource</doc>
            <type name="Resource" c:type="GResource*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">A pathname inside the resource</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="lookup_flags" transfer-ownership="none">
            <doc xml:space="preserve">A #GResourceLookupFlags</doc>
            <type name="ResourceLookupFlags" c:type="GResourceLookupFlags"/>
          </parameter>
          <parameter name="size" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a location to place the length of the contents of the file,
   or %NULL if the length is not needed</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="flags" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a location to place the flags about the file,
   or %NULL if the length is not needed</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_data" c:identifier="g_resource_lookup_data" version="2.32" throws="1">
        <doc xml:space="preserve">Looks for a file at the specified @path in the resource and
returns a #GBytes that lets you directly access the data in
memory.

The data is always followed by a zero byte, so you
can safely use the data as a C string. However, that byte
is not included in the size of the GBytes.

For uncompressed resource files this is a pointer directly into
the resource bundle, which is typically in some readonly data section
in the program binary. For compressed files we allocate memory on
the heap and automatically uncompress the data.

@lookup_flags controls the behaviour of the lookup.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GBytes or %NULL on error.
    Free the returned object with g_bytes_unref()</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="resource" transfer-ownership="none">
            <doc xml:space="preserve">A #GResource</doc>
            <type name="Resource" c:type="GResource*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">A pathname inside the resource</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="lookup_flags" transfer-ownership="none">
            <doc xml:space="preserve">A #GResourceLookupFlags</doc>
            <type name="ResourceLookupFlags" c:type="GResourceLookupFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="open_stream" c:identifier="g_resource_open_stream" version="2.32" throws="1">
        <doc xml:space="preserve">Looks for a file at the specified @path in the resource and
returns a #GInputStream that lets you read the data.

@lookup_flags controls the behaviour of the lookup.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GInputStream or %NULL on error.
    Free the returned object with g_object_unref()</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="resource" transfer-ownership="none">
            <doc xml:space="preserve">A #GResource</doc>
            <type name="Resource" c:type="GResource*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">A pathname inside the resource</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="lookup_flags" transfer-ownership="none">
            <doc xml:space="preserve">A #GResourceLookupFlags</doc>
            <type name="ResourceLookupFlags" c:type="GResourceLookupFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_resource_ref" version="2.32">
        <doc xml:space="preserve">Atomically increments the reference count of @resource by one. This
function is MT-safe and may be called from any thread.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The passed in #GResource</doc>
          <type name="Resource" c:type="GResource*"/>
        </return-value>
        <parameters>
          <instance-parameter name="resource" transfer-ownership="none">
            <doc xml:space="preserve">A #GResource</doc>
            <type name="Resource" c:type="GResource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_resource_unref" version="2.32">
        <doc xml:space="preserve">Atomically decrements the reference count of @resource by one. If the
reference count drops to 0, all memory allocated by the resource is
released. This function is MT-safe and may be called from any
thread.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="resource" transfer-ownership="none">
            <doc xml:space="preserve">A #GResource</doc>
            <type name="Resource" c:type="GResource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="load" c:identifier="g_resource_load" version="2.32" throws="1">
        <doc xml:space="preserve">Loads a binary resource bundle and creates a #GResource representation of it, allowing
you to query it for data.

If you want to use this resource in the global resource namespace you need
to register it with g_resources_register().

If @filename is empty or the data in it is corrupt,
%G_RESOURCE_ERROR_INTERNAL will be returned. If @filename doesn&#x2019;t exist, or
there is an error in reading it, an error from g_mapped_file_new() will be
returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GResource, or %NULL on error</doc>
          <type name="Resource" c:type="GResource*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">the path of a filename to load, in the GLib filename encoding</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="ResourceError" version="2.32" glib:type-name="GResourceError" glib:get-type="g_resource_error_get_type" c:type="GResourceError" glib:error-domain="g-resource-error-quark">
      <doc xml:space="preserve">An error code used with %G_RESOURCE_ERROR in a #GError returned
from a #GResource routine.</doc>
      <member name="not_found" value="0" c:identifier="G_RESOURCE_ERROR_NOT_FOUND" glib:nick="not-found">
        <doc xml:space="preserve">no file was found at the requested path</doc>
      </member>
      <member name="internal" value="1" c:identifier="G_RESOURCE_ERROR_INTERNAL" glib:nick="internal">
        <doc xml:space="preserve">unknown error</doc>
      </member>
      <function name="quark" c:identifier="g_resource_error_quark" version="2.32">
        <doc xml:space="preserve">Gets the #GResource Error Quark.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GQuark</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <bitfield name="ResourceFlags" version="2.32" glib:type-name="GResourceFlags" glib:get-type="g_resource_flags_get_type" c:type="GResourceFlags">
      <doc xml:space="preserve">GResourceFlags give information about a particular file inside a resource
bundle.</doc>
      <member name="none" value="0" c:identifier="G_RESOURCE_FLAGS_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
      <member name="compressed" value="1" c:identifier="G_RESOURCE_FLAGS_COMPRESSED" glib:nick="compressed">
        <doc xml:space="preserve">The file is compressed.</doc>
      </member>
    </bitfield>
    <bitfield name="ResourceLookupFlags" version="2.32" glib:type-name="GResourceLookupFlags" glib:get-type="g_resource_lookup_flags_get_type" c:type="GResourceLookupFlags">
      <doc xml:space="preserve">GResourceLookupFlags determine how resource path lookups are handled.</doc>
      <member name="none" value="0" c:identifier="G_RESOURCE_LOOKUP_FLAGS_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
    </bitfield>
    <constant name="SETTINGS_BACKEND_EXTENSION_POINT_NAME" value="gsettings-backend" c:type="G_SETTINGS_BACKEND_EXTENSION_POINT_NAME">
      <doc xml:space="preserve">Extension point for #GSettingsBackend functionality.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <interface name="Seekable" c:symbol-prefix="seekable" c:type="GSeekable" glib:type-name="GSeekable" glib:get-type="g_seekable_get_type" glib:type-struct="SeekableIface">
      <doc xml:space="preserve">#GSeekable is implemented by streams (implementations of
#GInputStream or #GOutputStream) that support seeking.

Seekable streams largely fall into two categories: resizable and
fixed-size.

#GSeekable on fixed-sized streams is approximately the same as POSIX
lseek() on a block device (for example: attmepting to seek past the
end of the device is an error).  Fixed streams typically cannot be
truncated.

#GSeekable on resizable streams is approximately the same as POSIX
lseek() on a normal file.  Seeking past the end and writing data will
usually cause the stream to resize by introducing zero bytes.</doc>
      <virtual-method name="can_seek" invoker="can_seek">
        <doc xml:space="preserve">Tests if the stream supports the #GSeekableIface.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @seekable can be seeked. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="seekable" transfer-ownership="none">
            <doc xml:space="preserve">a #GSeekable.</doc>
            <type name="Seekable" c:type="GSeekable*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="can_truncate" invoker="can_truncate">
        <doc xml:space="preserve">Tests if the length of the stream can be adjusted with
g_seekable_truncate().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the stream can be truncated, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="seekable" transfer-ownership="none">
            <doc xml:space="preserve">a #GSeekable.</doc>
            <type name="Seekable" c:type="GSeekable*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="seek" invoker="seek" throws="1">
        <doc xml:space="preserve">Seeks in the stream by the given @offset, modified by @type.

Attempting to seek past the end of the stream will have different
results depending on if the stream is fixed-sized or resizable.  If
the stream is resizable then seeking past the end and then writing
will result in zeros filling the empty space.  Seeking past the end
of a resizable stream and reading will result in EOF.  Seeking past
the end of a fixed-sized stream will fail.

Any operation that would result in a negative offset will fail.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if successful. If an error
    has occurred, this function will return %FALSE and set @error
    appropriately if present.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="seekable" transfer-ownership="none">
            <doc xml:space="preserve">a #GSeekable.</doc>
            <type name="Seekable" c:type="GSeekable*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">a #goffset.</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a #GSeekType.</doc>
            <type name="GLib.SeekType" c:type="GSeekType"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="tell" invoker="tell">
        <doc xml:space="preserve">Tells the current position within the stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the offset from the beginning of the buffer.</doc>
          <type name="gint64" c:type="goffset"/>
        </return-value>
        <parameters>
          <instance-parameter name="seekable" transfer-ownership="none">
            <doc xml:space="preserve">a #GSeekable.</doc>
            <type name="Seekable" c:type="GSeekable*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="truncate_fn" invoker="truncate" throws="1">
        <doc xml:space="preserve">Sets the length of the stream to @offset. If the stream was previously
larger than @offset, the extra data is discarded. If the stream was
previouly shorter than @offset, it is extended with NUL ('\0') bytes.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if successful. If an error
    has occurred, this function will return %FALSE and set @error
    appropriately if present.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="seekable" transfer-ownership="none">
            <doc xml:space="preserve">a #GSeekable.</doc>
            <type name="Seekable" c:type="GSeekable*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">new length for @seekable, in bytes.</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="can_seek" c:identifier="g_seekable_can_seek">
        <doc xml:space="preserve">Tests if the stream supports the #GSeekableIface.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @seekable can be seeked. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="seekable" transfer-ownership="none">
            <doc xml:space="preserve">a #GSeekable.</doc>
            <type name="Seekable" c:type="GSeekable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="can_truncate" c:identifier="g_seekable_can_truncate">
        <doc xml:space="preserve">Tests if the length of the stream can be adjusted with
g_seekable_truncate().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the stream can be truncated, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="seekable" transfer-ownership="none">
            <doc xml:space="preserve">a #GSeekable.</doc>
            <type name="Seekable" c:type="GSeekable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="seek" c:identifier="g_seekable_seek" throws="1">
        <doc xml:space="preserve">Seeks in the stream by the given @offset, modified by @type.

Attempting to seek past the end of the stream will have different
results depending on if the stream is fixed-sized or resizable.  If
the stream is resizable then seeking past the end and then writing
will result in zeros filling the empty space.  Seeking past the end
of a resizable stream and reading will result in EOF.  Seeking past
the end of a fixed-sized stream will fail.

Any operation that would result in a negative offset will fail.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if successful. If an error
    has occurred, this function will return %FALSE and set @error
    appropriately if present.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="seekable" transfer-ownership="none">
            <doc xml:space="preserve">a #GSeekable.</doc>
            <type name="Seekable" c:type="GSeekable*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">a #goffset.</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a #GSeekType.</doc>
            <type name="GLib.SeekType" c:type="GSeekType"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="tell" c:identifier="g_seekable_tell">
        <doc xml:space="preserve">Tells the current position within the stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the offset from the beginning of the buffer.</doc>
          <type name="gint64" c:type="goffset"/>
        </return-value>
        <parameters>
          <instance-parameter name="seekable" transfer-ownership="none">
            <doc xml:space="preserve">a #GSeekable.</doc>
            <type name="Seekable" c:type="GSeekable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="truncate" c:identifier="g_seekable_truncate" throws="1">
        <doc xml:space="preserve">Sets the length of the stream to @offset. If the stream was previously
larger than @offset, the extra data is discarded. If the stream was
previouly shorter than @offset, it is extended with NUL ('\0') bytes.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if successful. If an error
    has occurred, this function will return %FALSE and set @error
    appropriately if present.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="seekable" transfer-ownership="none">
            <doc xml:space="preserve">a #GSeekable.</doc>
            <type name="Seekable" c:type="GSeekable*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">new length for @seekable, in bytes.</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="SeekableIface" c:type="GSeekableIface" glib:is-gtype-struct-for="Seekable">
      <doc xml:space="preserve">Provides an interface for implementing seekable functionality on I/O Streams.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="tell">
        <callback name="tell">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the offset from the beginning of the buffer.</doc>
            <type name="gint64" c:type="goffset"/>
          </return-value>
          <parameters>
            <parameter name="seekable" transfer-ownership="none">
              <doc xml:space="preserve">a #GSeekable.</doc>
              <type name="Seekable" c:type="GSeekable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_seek">
        <callback name="can_seek">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @seekable can be seeked. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="seekable" transfer-ownership="none">
              <doc xml:space="preserve">a #GSeekable.</doc>
              <type name="Seekable" c:type="GSeekable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="seek">
        <callback name="seek" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if successful. If an error
    has occurred, this function will return %FALSE and set @error
    appropriately if present.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="seekable" transfer-ownership="none">
              <doc xml:space="preserve">a #GSeekable.</doc>
              <type name="Seekable" c:type="GSeekable*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <doc xml:space="preserve">a #goffset.</doc>
              <type name="gint64" c:type="goffset"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <doc xml:space="preserve">a #GSeekType.</doc>
              <type name="GLib.SeekType" c:type="GSeekType"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_truncate">
        <callback name="can_truncate">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the stream can be truncated, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="seekable" transfer-ownership="none">
              <doc xml:space="preserve">a #GSeekable.</doc>
              <type name="Seekable" c:type="GSeekable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="truncate_fn">
        <callback name="truncate_fn" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if successful. If an error
    has occurred, this function will return %FALSE and set @error
    appropriately if present.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="seekable" transfer-ownership="none">
              <doc xml:space="preserve">a #GSeekable.</doc>
              <type name="Seekable" c:type="GSeekable*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <doc xml:space="preserve">new length for @seekable, in bytes.</doc>
              <type name="gint64" c:type="goffset"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="Settings" c:symbol-prefix="settings" c:type="GSettings" parent="GObject.Object" glib:type-name="GSettings" glib:get-type="g_settings_get_type" glib:type-struct="SettingsClass">
      <doc xml:space="preserve">The #GSettings class provides a convenient API for storing and retrieving
application settings.

Reads and writes can be considered to be non-blocking.  Reading
settings with #GSettings is typically extremely fast: on
approximately the same order of magnitude (but slower than) a
#GHashTable lookup.  Writing settings is also extremely fast in terms
of time to return to your application, but can be extremely expensive
for other threads and other processes.  Many settings backends
(including dconf) have lazy initialisation which means in the common
case of the user using their computer without modifying any settings
a lot of work can be avoided.  For dconf, the D-Bus service doesn't
even need to be started in this case.  For this reason, you should
only ever modify #GSettings keys in response to explicit user action.
Particular care should be paid to ensure that modifications are not
made during startup -- for example, when setting the initial value
of preferences widgets.  The built-in g_settings_bind() functionality
is careful not to write settings in response to notify signals as a
result of modifications that it makes to widgets.

When creating a GSettings instance, you have to specify a schema
that describes the keys in your settings and their types and default
values, as well as some other information.

Normally, a schema has a fixed path that determines where the settings
are stored in the conceptual global tree of settings. However, schemas
can also be '[relocatable][gsettings-relocatable]', i.e. not equipped with
a fixed path. This is
useful e.g. when the schema describes an 'account', and you want to be
able to store a arbitrary number of accounts.

Paths must start with and end with a forward slash character ('/')
and must not contain two sequential slash characters.  Paths should
be chosen based on a domain name associated with the program or
library to which the settings belong.  Examples of paths are
"/org/gtk/settings/file-chooser/" and "/ca/desrt/dconf-editor/".
Paths should not start with "/apps/", "/desktop/" or "/system/" as
they often did in GConf.

Unlike other configuration systems (like GConf), GSettings does not
restrict keys to basic types like strings and numbers. GSettings stores
values as #GVariant, and allows any #GVariantType for keys. Key names
are restricted to lowercase characters, numbers and '-'. Furthermore,
the names must begin with a lowercase character, must not end
with a '-', and must not contain consecutive dashes.

Similar to GConf, the default values in GSettings schemas can be
localized, but the localized values are stored in gettext catalogs
and looked up with the domain that is specified in the
`gettext-domain` attribute of the &lt;schemalist&gt; or &lt;schema&gt;
elements and the category that is specified in the `l10n` attribute of
the &lt;default&gt; element. The string which is translated includes all text in
the &lt;default&gt; element, including any surrounding quotation marks.

The `l10n` attribute must be set to `messages` or `time`, and sets the
[locale category for
translation](https://www.gnu.org/software/gettext/manual/html_node/Aspects.html#index-locale-categories-1).
The `messages` category should be used by default; use `time` for
translatable date or time formats. A translation comment can be added as an
XML comment immediately above the &lt;default&gt; element &#x2014; it is recommended to
add these comments to aid translators understand the meaning and
implications of the default value. An optional translation `context`
attribute can be set on the &lt;default&gt; element to disambiguate multiple
defaults which use the same string.

For example:
|[
 &lt;!-- Translators: A list of words which are not allowed to be typed, in
      GVariant serialization syntax.
      See: https://developer.gnome.org/glib/stable/gvariant-text.html --&gt;
 &lt;default l10n='messages' context='Banned words'&gt;['bad', 'words']&lt;/default&gt;
]|

Translations of default values must remain syntactically valid serialized
#GVariants (e.g. retaining any surrounding quotation marks) or runtime
errors will occur.

GSettings uses schemas in a compact binary form that is created
by the [glib-compile-schemas][glib-compile-schemas]
utility. The input is a schema description in an XML format.

A DTD for the gschema XML format can be found here:
[gschema.dtd](https://git.gnome.org/browse/glib/tree/gio/gschema.dtd)

The [glib-compile-schemas][glib-compile-schemas] tool expects schema
files to have the extension `.gschema.xml`.

At runtime, schemas are identified by their id (as specified in the
id attribute of the &lt;schema&gt; element). The convention for schema
ids is to use a dotted name, similar in style to a D-Bus bus name,
e.g. "org.gnome.SessionManager". In particular, if the settings are
for a specific service that owns a D-Bus bus name, the D-Bus bus name
and schema id should match. For schemas which deal with settings not
associated with one named application, the id should not use
StudlyCaps, e.g. "org.gnome.font-rendering".

In addition to #GVariant types, keys can have types that have
enumerated types. These can be described by a &lt;choice&gt;,
&lt;enum&gt; or &lt;flags&gt; element, as seen in the
[example][schema-enumerated]. The underlying type of such a key
is string, but you can use g_settings_get_enum(), g_settings_set_enum(),
g_settings_get_flags(), g_settings_set_flags() access the numeric values
corresponding to the string value of enum and flags keys.

An example for default value:
|[
&lt;schemalist&gt;
  &lt;schema id="org.gtk.Test" path="/org/gtk/Test/" gettext-domain="test"&gt;

    &lt;key name="greeting" type="s"&gt;
      &lt;default l10n="messages"&gt;"Hello, earthlings"&lt;/default&gt;
      &lt;summary&gt;A greeting&lt;/summary&gt;
      &lt;description&gt;
        Greeting of the invading martians
      &lt;/description&gt;
    &lt;/key&gt;

    &lt;key name="box" type="(ii)"&gt;
      &lt;default&gt;(20,30)&lt;/default&gt;
    &lt;/key&gt;

  &lt;/schema&gt;
&lt;/schemalist&gt;
]|

An example for ranges, choices and enumerated types:
|[
&lt;schemalist&gt;

  &lt;enum id="org.gtk.Test.myenum"&gt;
    &lt;value nick="first" value="1"/&gt;
    &lt;value nick="second" value="2"/&gt;
  &lt;/enum&gt;

  &lt;flags id="org.gtk.Test.myflags"&gt;
    &lt;value nick="flag1" value="1"/&gt;
    &lt;value nick="flag2" value="2"/&gt;
    &lt;value nick="flag3" value="4"/&gt;
  &lt;/flags&gt;

  &lt;schema id="org.gtk.Test"&gt;

    &lt;key name="key-with-range" type="i"&gt;
      &lt;range min="1" max="100"/&gt;
      &lt;default&gt;10&lt;/default&gt;
    &lt;/key&gt;

    &lt;key name="key-with-choices" type="s"&gt;
      &lt;choices&gt;
        &lt;choice value='Elisabeth'/&gt;
        &lt;choice value='Annabeth'/&gt;
        &lt;choice value='Joe'/&gt;
      &lt;/choices&gt;
      &lt;aliases&gt;
        &lt;alias value='Anna' target='Annabeth'/&gt;
        &lt;alias value='Beth' target='Elisabeth'/&gt;
      &lt;/aliases&gt;
      &lt;default&gt;'Joe'&lt;/default&gt;
    &lt;/key&gt;

    &lt;key name='enumerated-key' enum='org.gtk.Test.myenum'&gt;
      &lt;default&gt;'first'&lt;/default&gt;
    &lt;/key&gt;

    &lt;key name='flags-key' flags='org.gtk.Test.myflags'&gt;
      &lt;default&gt;["flag1","flag2"]&lt;/default&gt;
    &lt;/key&gt;
  &lt;/schema&gt;
&lt;/schemalist&gt;
]|

## Vendor overrides

Default values are defined in the schemas that get installed by
an application. Sometimes, it is necessary for a vendor or distributor
to adjust these defaults. Since patching the XML source for the schema
is inconvenient and error-prone,
[glib-compile-schemas][glib-compile-schemas] reads so-called vendor
override' files. These are keyfiles in the same directory as the XML
schema sources which can override default values. The schema id serves
as the group name in the key file, and the values are expected in
serialized GVariant form, as in the following example:
|[
    [org.gtk.Example]
    key1='string'
    key2=1.5
]|

glib-compile-schemas expects schema files to have the extension
`.gschema.override`.

## Binding

A very convenient feature of GSettings lets you bind #GObject properties
directly to settings, using g_settings_bind(). Once a GObject property
has been bound to a setting, changes on either side are automatically
propagated to the other side. GSettings handles details like mapping
between GObject and GVariant types, and preventing infinite cycles.

This makes it very easy to hook up a preferences dialog to the
underlying settings. To make this even more convenient, GSettings
looks for a boolean property with the name "sensitivity" and
automatically binds it to the writability of the bound setting.
If this 'magic' gets in the way, it can be suppressed with the
#G_SETTINGS_BIND_NO_SENSITIVITY flag.

## Relocatable schemas # {#gsettings-relocatable}

A relocatable schema is one with no `path` attribute specified on its
&lt;schema&gt; element. By using g_settings_new_with_path(), a #GSettings object
can be instantiated for a relocatable schema, assigning a path to the
instance. Paths passed to g_settings_new_with_path() will typically be
constructed dynamically from a constant prefix plus some form of instance
identifier; but they must still be valid GSettings paths. Paths could also
be constant and used with a globally installed schema originating from a
dependency library.

For example, a relocatable schema could be used to store geometry information
for different windows in an application. If the schema ID was
`org.foo.MyApp.Window`, it could be instantiated for paths
`/org/foo/MyApp/main/`, `/org/foo/MyApp/document-1/`,
`/org/foo/MyApp/document-2/`, etc. If any of the paths are well-known
they can be specified as &lt;child&gt; elements in the parent schema, e.g.:
|[
&lt;schema id="org.foo.MyApp" path="/org/foo/MyApp/"&gt;
  &lt;child name="main" schema="org.foo.MyApp.Window"/&gt;
&lt;/schema&gt;
]|

## Build system integration # {#gsettings-build-system}

GSettings comes with autotools integration to simplify compiling and
installing schemas. To add GSettings support to an application, add the
following to your `configure.ac`:
|[
GLIB_GSETTINGS
]|

In the appropriate `Makefile.am`, use the following snippet to compile and
install the named schema:
|[
gsettings_SCHEMAS = org.foo.MyApp.gschema.xml
EXTRA_DIST = $(gsettings_SCHEMAS)

@GSETTINGS_RULES@
]|

No changes are needed to the build system to mark a schema XML file for
translation. Assuming it sets the `gettext-domain` attribute, a schema may
be marked for translation by adding it to `POTFILES.in`, assuming gettext
0.19 is in use (the preferred method for translation):
|[
data/org.foo.MyApp.gschema.xml
]|

Alternatively, if intltool 0.50.1 is in use:
|[
[type: gettext/gsettings]data/org.foo.MyApp.gschema.xml
]|

GSettings will use gettext to look up translations for the &lt;summary&gt; and
&lt;description&gt; elements, and also any &lt;default&gt; elements which have a `l10n`
attribute set. Translations must not be included in the `.gschema.xml` file
by the build system, for example by using intltool XML rules with a
`.gschema.xml.in` template.

If an enumerated type defined in a C header file is to be used in a GSettings
schema, it can either be defined manually using an &lt;enum&gt; element in the
schema XML, or it can be extracted automatically from the C header. This
approach is preferred, as it ensures the two representations are always
synchronised. To do so, add the following to the relevant `Makefile.am`:
|[
gsettings_ENUM_NAMESPACE = org.foo.MyApp
gsettings_ENUM_FILES = my-app-enums.h my-app-misc.h
]|

`gsettings_ENUM_NAMESPACE` specifies the schema namespace for the enum files,
which are specified in `gsettings_ENUM_FILES`. This will generate a
`org.foo.MyApp.enums.xml` file containing the extracted enums, which will be
automatically included in the schema compilation, install and uninstall
rules. It should not be committed to version control or included in
`EXTRA_DIST`.</doc>
      <constructor name="new" c:identifier="g_settings_new" version="2.26">
        <doc xml:space="preserve">Creates a new #GSettings object with the schema specified by
@schema_id.

Signals on the newly created #GSettings object will be dispatched
via the thread-default #GMainContext in effect at the time of the
call to g_settings_new().  The new #GSettings will hold a reference
on the context.  See g_main_context_push_thread_default().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSettings object</doc>
          <type name="Settings" c:type="GSettings*"/>
        </return-value>
        <parameters>
          <parameter name="schema_id" transfer-ownership="none">
            <doc xml:space="preserve">the id of the schema</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_full" c:identifier="g_settings_new_full" version="2.32">
        <doc xml:space="preserve">Creates a new #GSettings object with a given schema, backend and
path.

It should be extremely rare that you ever want to use this function.
It is made available for advanced use-cases (such as plugin systems
that want to provide access to schemas loaded from custom locations,
etc).

At the most basic level, a #GSettings object is a pure composition of
4 things: a #GSettingsSchema, a #GSettingsBackend, a path within that
backend, and a #GMainContext to which signals are dispatched.

This constructor therefore gives you full control over constructing
#GSettings instances.  The first 3 parameters are given directly as
@schema, @backend and @path, and the main context is taken from the
thread-default (as per g_settings_new()).

If @backend is %NULL then the default backend is used.

If @path is %NULL then the path from the schema is used.  It is an
error if @path is %NULL and the schema has no path of its own or if
@path is non-%NULL and not equal to the path that the schema does
have.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSettings object</doc>
          <type name="Settings" c:type="GSettings*"/>
        </return-value>
        <parameters>
          <parameter name="schema" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsSchema</doc>
            <type name="SettingsSchema" c:type="GSettingsSchema*"/>
          </parameter>
          <parameter name="backend" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GSettingsBackend</doc>
            <type name="SettingsBackend" c:type="GSettingsBackend*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the path to use</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_backend" c:identifier="g_settings_new_with_backend" version="2.26">
        <doc xml:space="preserve">Creates a new #GSettings object with the schema specified by
@schema_id and a given #GSettingsBackend.

Creating a #GSettings object with a different backend allows accessing
settings from a database other than the usual one. For example, it may make
sense to pass a backend corresponding to the "defaults" settings database on
the system to get a settings object that modifies the system default
settings instead of the settings for this user.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSettings object</doc>
          <type name="Settings" c:type="GSettings*"/>
        </return-value>
        <parameters>
          <parameter name="schema_id" transfer-ownership="none">
            <doc xml:space="preserve">the id of the schema</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="backend" transfer-ownership="none">
            <doc xml:space="preserve">the #GSettingsBackend to use</doc>
            <type name="SettingsBackend" c:type="GSettingsBackend*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_backend_and_path" c:identifier="g_settings_new_with_backend_and_path" version="2.26">
        <doc xml:space="preserve">Creates a new #GSettings object with the schema specified by
@schema_id and a given #GSettingsBackend and path.

This is a mix of g_settings_new_with_backend() and
g_settings_new_with_path().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSettings object</doc>
          <type name="Settings" c:type="GSettings*"/>
        </return-value>
        <parameters>
          <parameter name="schema_id" transfer-ownership="none">
            <doc xml:space="preserve">the id of the schema</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="backend" transfer-ownership="none">
            <doc xml:space="preserve">the #GSettingsBackend to use</doc>
            <type name="SettingsBackend" c:type="GSettingsBackend*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path to use</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_path" c:identifier="g_settings_new_with_path" version="2.26">
        <doc xml:space="preserve">Creates a new #GSettings object with the relocatable schema specified
by @schema_id and a given path.

You only need to do this if you want to directly create a settings
object with a schema that doesn't have a specified path of its own.
That's quite rare.

It is a programmer error to call this function for a schema that
has an explicitly specified path.

It is a programmer error if @path is not a valid path.  A valid path
begins and ends with '/' and does not contain two consecutive '/'
characters.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSettings object</doc>
          <type name="Settings" c:type="GSettings*"/>
        </return-value>
        <parameters>
          <parameter name="schema_id" transfer-ownership="none">
            <doc xml:space="preserve">the id of the schema</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path to use</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="list_relocatable_schemas" c:identifier="g_settings_list_relocatable_schemas" version="2.28" deprecated="1" deprecated-version="2.40">
        <doc xml:space="preserve">Deprecated.</doc>
        <doc-deprecated xml:space="preserve">Use g_settings_schema_source_list_schemas() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a list of relocatable
  #GSettings schemas that are available.  The list must not be
  modified or freed.</doc>
          <array c:type="const gchar* const*">
            <type name="utf8"/>
          </array>
        </return-value>
      </function>
      <function name="list_schemas" c:identifier="g_settings_list_schemas" version="2.26" deprecated="1" deprecated-version="2.40">
        <doc xml:space="preserve">Deprecated.</doc>
        <doc-deprecated xml:space="preserve">Use g_settings_schema_source_list_schemas() instead.
If you used g_settings_list_schemas() to check for the presence of
a particular schema, use g_settings_schema_source_lookup() instead
of your whole loop.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a list of #GSettings
  schemas that are available.  The list must not be modified or
  freed.</doc>
          <array c:type="const gchar* const*">
            <type name="utf8"/>
          </array>
        </return-value>
      </function>
      <function name="sync" c:identifier="g_settings_sync">
        <doc xml:space="preserve">Ensures that all pending operations are complete for the default backend.

Writes made to a #GSettings are handled asynchronously.  For this
reason, it is very unlikely that the changes have it to disk by the
time g_settings_set() returns.

This call will block until all of the writes have made it to the
backend.  Since the mainloop is not running, no change notifications
will be dispatched during this call (but some may be queued by the
time the call is done).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="unbind" c:identifier="g_settings_unbind" version="2.26">
        <doc xml:space="preserve">Removes an existing binding for @property on @object.

Note that bindings are automatically removed when the
object is finalized, so it is rarely necessary to call this
function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">the object</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
          <parameter name="property" transfer-ownership="none">
            <doc xml:space="preserve">the property whose binding is removed</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="change_event">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="keys" transfer-ownership="none">
            <type name="GLib.Quark" c:type="const GQuark*"/>
          </parameter>
          <parameter name="n_keys" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="writable_change_event">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="writable_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="apply" c:identifier="g_settings_apply">
        <doc xml:space="preserve">Applies any changes that have been made to the settings.  This
function does nothing unless @settings is in 'delay-apply' mode;
see g_settings_delay().  In the normal case settings are always
applied immediately.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings instance</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="bind" c:identifier="g_settings_bind" version="2.26">
        <doc xml:space="preserve">Create a binding between the @key in the @settings object
and the property @property of @object.

The binding uses the default GIO mapping functions to map
between the settings and property values. These functions
handle booleans, numeric types and string types in a
straightforward way. Use g_settings_bind_with_mapping() if
you need a custom mapping, or map between types that are not
supported by the default mapping functions.

Unless the @flags include %G_SETTINGS_BIND_NO_SENSITIVITY, this
function also establishes a binding between the writability of
@key and the "sensitive" property of @object (if @object has
a boolean property by that name). See g_settings_bind_writable()
for more details about writable bindings.

Note that the lifecycle of the binding is tied to @object,
and that you can have only one binding per object property.
If you bind the same property twice on the same object, the second
binding overrides the first one.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to bind</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
          <parameter name="property" transfer-ownership="none">
            <doc xml:space="preserve">the name of the property to bind</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags for the binding</doc>
            <type name="SettingsBindFlags" c:type="GSettingsBindFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind_with_mapping" c:identifier="g_settings_bind_with_mapping" version="2.26" introspectable="0">
        <doc xml:space="preserve">Create a binding between the @key in the @settings object
and the property @property of @object.

The binding uses the provided mapping functions to map between
settings and property values.

Note that the lifecycle of the binding is tied to @object,
and that you can have only one binding per object property.
If you bind the same property twice on the same object, the second
binding overrides the first one.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to bind</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
          <parameter name="property" transfer-ownership="none">
            <doc xml:space="preserve">the name of the property to bind</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags for the binding</doc>
            <type name="SettingsBindFlags" c:type="GSettingsBindFlags"/>
          </parameter>
          <parameter name="get_mapping" transfer-ownership="none">
            <doc xml:space="preserve">a function that gets called to convert values
    from @settings to @object, or %NULL to use the default GIO mapping</doc>
            <type name="SettingsBindGetMapping" c:type="GSettingsBindGetMapping"/>
          </parameter>
          <parameter name="set_mapping" transfer-ownership="none" scope="notified" closure="6" destroy="7">
            <doc xml:space="preserve">a function that gets called to convert values
    from @object to @settings, or %NULL to use the default GIO mapping</doc>
            <type name="SettingsBindSetMapping" c:type="GSettingsBindSetMapping"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data that gets passed to @get_mapping and @set_mapping</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">#GDestroyNotify function for @user_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind_writable" c:identifier="g_settings_bind_writable" version="2.26">
        <doc xml:space="preserve">Create a binding between the writability of @key in the
@settings object and the property @property of @object.
The property must be boolean; "sensitive" or "visible"
properties of widgets are the most likely candidates.

Writable bindings are always uni-directional; changes of the
writability of the setting will be propagated to the object
property, not the other way.

When the @inverted argument is %TRUE, the binding inverts the
value as it passes from the setting to the object, i.e. @property
will be set to %TRUE if the key is not writable.

Note that the lifecycle of the binding is tied to @object,
and that you can have only one binding per object property.
If you bind the same property twice on the same object, the second
binding overrides the first one.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to bind</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
          <parameter name="property" transfer-ownership="none">
            <doc xml:space="preserve">the name of a boolean property to bind</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="inverted" transfer-ownership="none">
            <doc xml:space="preserve">whether to 'invert' the value</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_action" c:identifier="g_settings_create_action" version="2.32">
        <doc xml:space="preserve">Creates a #GAction corresponding to a given #GSettings key.

The action has the same name as the key.

The value of the key becomes the state of the action and the action
is enabled when the key is writable.  Changing the state of the
action results in the key being written to.  Changes to the value or
writability of the key cause appropriate change notifications to be
emitted for the action.

For boolean-valued keys, action activations take no parameter and
result in the toggling of the value.  For all other types,
activations take the new value for the key (which must have the
correct type).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GAction</doc>
          <type name="Action" c:type="GAction*"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the name of a key in @settings</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delay" c:identifier="g_settings_delay" version="2.26">
        <doc xml:space="preserve">Changes the #GSettings object into 'delay-apply' mode. In this
mode, changes to @settings are not immediately propagated to the
backend, but kept locally until g_settings_apply() is called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="g_settings_get" version="2.26" introspectable="0">
        <doc xml:space="preserve">Gets the value that is stored at @key in @settings.

A convenience function that combines g_settings_get_value() with
g_variant_get().

It is a programmer error to give a @key that isn't contained in the
schema for @settings or for the #GVariantType of @format to mismatch
the type given in the schema.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to get the value for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">arguments as per @format</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="get_boolean" c:identifier="g_settings_get_boolean" version="2.26">
        <doc xml:space="preserve">Gets the value that is stored at @key in @settings.

A convenience variant of g_settings_get() for booleans.

It is a programmer error to give a @key that isn't specified as
having a boolean type in the schema for @settings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a boolean</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to get the value for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_child" c:identifier="g_settings_get_child" version="2.26">
        <doc xml:space="preserve">Creates a child settings object which has a base path of
`base-path/@name`, where `base-path` is the base path of
@settings.

The schema for the child settings object must have been declared
in the schema of @settings using a &lt;child&gt; element.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a 'child' settings object</doc>
          <type name="Settings" c:type="GSettings*"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the child schema</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_default_value" c:identifier="g_settings_get_default_value" version="2.40">
        <doc xml:space="preserve">Gets the "default value" of a key.

This is the value that would be read if g_settings_reset() were to be
called on the key.

Note that this may be a different value than returned by
g_settings_schema_key_get_default_value() if the system administrator
has provided a default value.

Comparing the return values of g_settings_get_default_value() and
g_settings_get_value() is not sufficient for determining if a value
has been set because the user may have explicitly set the value to
something that happens to be equal to the default.  The difference
here is that if the default changes in the future, the user's key
will still be set.

This function may be useful for adding an indication to a UI of what
the default value was before the user set it.

It is a programmer error to give a @key that isn't contained in the
schema for @settings.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the default value</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to get the default value for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_double" c:identifier="g_settings_get_double" version="2.26">
        <doc xml:space="preserve">Gets the value that is stored at @key in @settings.

A convenience variant of g_settings_get() for doubles.

It is a programmer error to give a @key that isn't specified as
having a 'double' type in the schema for @settings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a double</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to get the value for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_enum" c:identifier="g_settings_get_enum" version="2.26">
        <doc xml:space="preserve">Gets the value that is stored in @settings for @key and converts it
to the enum value that it represents.

In order to use this function the type of the value must be a string
and it must be marked in the schema file as an enumerated type.

It is a programmer error to give a @key that isn't contained in the
schema for @settings or is not marked as an enumerated type.

If the value stored in the configuration database is not a valid
value for the enumerated type then this function will return the
default value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the enum value</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to get the value for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="g_settings_get_flags" version="2.26">
        <doc xml:space="preserve">Gets the value that is stored in @settings for @key and converts it
to the flags value that it represents.

In order to use this function the type of the value must be an array
of strings and it must be marked in the schema file as an flags type.

It is a programmer error to give a @key that isn't contained in the
schema for @settings or is not marked as a flags type.

If the value stored in the configuration database is not a valid
value for the flags type then this function will return the default
value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the flags value</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to get the value for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_has_unapplied" c:identifier="g_settings_get_has_unapplied" version="2.26">
        <doc xml:space="preserve">Returns whether the #GSettings object has any unapplied
changes.  This can only be the case if it is in 'delayed-apply' mode.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @settings has unapplied changes</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_int" c:identifier="g_settings_get_int" version="2.26">
        <doc xml:space="preserve">Gets the value that is stored at @key in @settings.

A convenience variant of g_settings_get() for 32-bit integers.

It is a programmer error to give a @key that isn't specified as
having a int32 type in the schema for @settings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an integer</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to get the value for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int64" c:identifier="g_settings_get_int64" version="2.50">
        <doc xml:space="preserve">Gets the value that is stored at @key in @settings.

A convenience variant of g_settings_get() for 64-bit integers.

It is a programmer error to give a @key that isn't specified as
having a int64 type in the schema for @settings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a 64-bit integer</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to get the value for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_mapped" c:identifier="g_settings_get_mapped">
        <doc xml:space="preserve">Gets the value that is stored at @key in @settings, subject to
application-level validation/mapping.

You should use this function when the application needs to perform
some processing on the value of the key (for example, parsing).  The
@mapping function performs that processing.  If the function
indicates that the processing was unsuccessful (due to a parse error,
for example) then the mapping is tried again with another value.

This allows a robust 'fall back to defaults' behaviour to be
implemented somewhat automatically.

The first value that is tried is the user's setting for the key.  If
the mapping function fails to map this value, other values may be
tried in an unspecified order (system or site defaults, translated
schema default values, untranslated schema default values, etc).

If the mapping function fails for all possible values, one additional
attempt is made: the mapping function is called with a %NULL value.
If the mapping function still indicates failure at this point then
the application will be aborted.

The result parameter for the @mapping function is pointed to a
#gpointer which is initially set to %NULL.  The same pointer is given
to each invocation of @mapping.  The final value of that #gpointer is
what is returned by this function.  %NULL is valid; it is returned
just as any other value would be.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the result, which may be %NULL</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to get the value for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="mapping" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the function to map the value in the
          settings database to the value used by the application</doc>
            <type name="SettingsGetMapping" c:type="GSettingsGetMapping"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data for @mapping</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_range" c:identifier="g_settings_get_range" version="2.28" deprecated="1" deprecated-version="2.40">
        <doc xml:space="preserve">Queries the range of a key.</doc>
        <doc-deprecated xml:space="preserve">Use g_settings_schema_key_get_range() instead.</doc-deprecated>
        <return-value transfer-ownership="full">
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to query the range of</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_string" c:identifier="g_settings_get_string" version="2.26">
        <doc xml:space="preserve">Gets the value that is stored at @key in @settings.

A convenience variant of g_settings_get() for strings.

It is a programmer error to give a @key that isn't specified as
having a string type in the schema for @settings.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocated string</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to get the value for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_strv" c:identifier="g_settings_get_strv" version="2.26">
        <doc xml:space="preserve">A convenience variant of g_settings_get() for string arrays.

It is a programmer error to give a @key that isn't specified as
having an array of strings type in the schema for @settings.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a
newly-allocated, %NULL-terminated array of strings, the value that
is stored at @key in @settings.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to get the value for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint" c:identifier="g_settings_get_uint" version="2.30">
        <doc xml:space="preserve">Gets the value that is stored at @key in @settings.

A convenience variant of g_settings_get() for 32-bit unsigned
integers.

It is a programmer error to give a @key that isn't specified as
having a uint32 type in the schema for @settings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an unsigned integer</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to get the value for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint64" c:identifier="g_settings_get_uint64" version="2.50">
        <doc xml:space="preserve">Gets the value that is stored at @key in @settings.

A convenience variant of g_settings_get() for 64-bit unsigned
integers.

It is a programmer error to give a @key that isn't specified as
having a uint64 type in the schema for @settings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a 64-bit unsigned integer</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to get the value for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_user_value" c:identifier="g_settings_get_user_value" version="2.40">
        <doc xml:space="preserve">Checks the "user value" of a key, if there is one.

The user value of a key is the last value that was set by the user.

After calling g_settings_reset() this function should always return
%NULL (assuming something is not wrong with the system
configuration).

It is possible that g_settings_get_value() will return a different
value than this function.  This can happen in the case that the user
set a value for a key that was subsequently locked down by the system
administrator -- this function will return the user's old value.

This function may be useful for adding a "reset" option to a UI or
for providing indication that a particular value has been changed.

It is a programmer error to give a @key that isn't contained in the
schema for @settings.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the user's value, if set</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to get the user value for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_value" c:identifier="g_settings_get_value" version="2.26">
        <doc xml:space="preserve">Gets the value that is stored in @settings for @key.

It is a programmer error to give a @key that isn't contained in the
schema for @settings.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GVariant</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to get the value for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_writable" c:identifier="g_settings_is_writable" version="2.26">
        <doc xml:space="preserve">Finds out if a key can be written or not</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the key @name is writable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_children" c:identifier="g_settings_list_children">
        <doc xml:space="preserve">Gets the list of children on @settings.

The list is exactly the list of strings for which it is not an error
to call g_settings_get_child().

For GSettings objects that are lists, this value can change at any
time. Note that there is a race condition here: you may
request a child after listing it only for it to have been destroyed
in the meantime.  For this reason, g_settings_get_child() may return
%NULL even for a child that was listed by this function.

For GSettings objects that are not lists, you should probably not be
calling this function from "normal" code (since you should already
know what children are in your schema).  This function may still be
useful there for introspection reasons, however.

You should free the return value with g_strfreev() when you are done
with it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a list of the children on @settings</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="list_keys" c:identifier="g_settings_list_keys">
        <doc xml:space="preserve">Introspects the list of keys on @settings.

You should probably not be calling this function from "normal" code
(since you should already know what keys are in your schema).  This
function is intended for introspection reasons.

You should free the return value with g_strfreev() when you are done
with it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a list of the keys on @settings</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="range_check" c:identifier="g_settings_range_check" version="2.28" deprecated="1" deprecated-version="2.40">
        <doc xml:space="preserve">Checks if the given @value is of the correct type and within the
permitted range for @key.</doc>
        <doc-deprecated xml:space="preserve">Use g_settings_schema_key_range_check() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @value is valid for @key</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to check</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value to check</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reset" c:identifier="g_settings_reset">
        <doc xml:space="preserve">Resets @key to its default value.

This call resets the key, as much as possible, to its default value.
That might the value specified in the schema or the one set by the
administrator.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the name of a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="revert" c:identifier="g_settings_revert">
        <doc xml:space="preserve">Reverts all non-applied changes to the settings.  This function
does nothing unless @settings is in 'delay-apply' mode; see
g_settings_delay().  In the normal case settings are always applied
immediately.

Change notifications will be emitted for affected keys.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings instance</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="g_settings_set" version="2.26" introspectable="0">
        <doc xml:space="preserve">Sets @key in @settings to @value.

A convenience function that combines g_settings_set_value() with
g_variant_new().

It is a programmer error to give a @key that isn't contained in the
schema for @settings or for the #GVariantType of @format to mismatch
the type given in the schema.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if setting the key succeeded,
    %FALSE if the key was not writable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the name of the key to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">arguments as per @format</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="set_boolean" c:identifier="g_settings_set_boolean" version="2.26">
        <doc xml:space="preserve">Sets @key in @settings to @value.

A convenience variant of g_settings_set() for booleans.

It is a programmer error to give a @key that isn't specified as
having a boolean type in the schema for @settings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if setting the key succeeded,
    %FALSE if the key was not writable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the name of the key to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value to set it to</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_double" c:identifier="g_settings_set_double" version="2.26">
        <doc xml:space="preserve">Sets @key in @settings to @value.

A convenience variant of g_settings_set() for doubles.

It is a programmer error to give a @key that isn't specified as
having a 'double' type in the schema for @settings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if setting the key succeeded,
    %FALSE if the key was not writable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the name of the key to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value to set it to</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_enum" c:identifier="g_settings_set_enum">
        <doc xml:space="preserve">Looks up the enumerated type nick for @value and writes it to @key,
within @settings.

It is a programmer error to give a @key that isn't contained in the
schema for @settings or is not marked as an enumerated type, or for
@value not to be a valid value for the named type.

After performing the write, accessing @key directly with
g_settings_get_string() will return the 'nick' associated with
@value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE, if the set succeeds</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key, within @settings</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">an enumerated value</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flags" c:identifier="g_settings_set_flags">
        <doc xml:space="preserve">Looks up the flags type nicks for the bits specified by @value, puts
them in an array of strings and writes the array to @key, within
@settings.

It is a programmer error to give a @key that isn't contained in the
schema for @settings or is not marked as a flags type, or for @value
to contain any bits that are not value for the named type.

After performing the write, accessing @key directly with
g_settings_get_strv() will return an array of 'nicks'; one for each
bit in @value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE, if the set succeeds</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key, within @settings</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a flags value</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_int" c:identifier="g_settings_set_int" version="2.26">
        <doc xml:space="preserve">Sets @key in @settings to @value.

A convenience variant of g_settings_set() for 32-bit integers.

It is a programmer error to give a @key that isn't specified as
having a int32 type in the schema for @settings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if setting the key succeeded,
    %FALSE if the key was not writable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the name of the key to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value to set it to</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_int64" c:identifier="g_settings_set_int64" version="2.50">
        <doc xml:space="preserve">Sets @key in @settings to @value.

A convenience variant of g_settings_set() for 64-bit integers.

It is a programmer error to give a @key that isn't specified as
having a int64 type in the schema for @settings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if setting the key succeeded,
    %FALSE if the key was not writable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the name of the key to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value to set it to</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_string" c:identifier="g_settings_set_string" version="2.26">
        <doc xml:space="preserve">Sets @key in @settings to @value.

A convenience variant of g_settings_set() for strings.

It is a programmer error to give a @key that isn't specified as
having a string type in the schema for @settings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if setting the key succeeded,
    %FALSE if the key was not writable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the name of the key to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value to set it to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_strv" c:identifier="g_settings_set_strv" version="2.26">
        <doc xml:space="preserve">Sets @key in @settings to @value.

A convenience variant of g_settings_set() for string arrays.  If
@value is %NULL, then @key is set to be the empty array.

It is a programmer error to give a @key that isn't specified as
having an array of strings type in the schema for @settings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if setting the key succeeded,
    %FALSE if the key was not writable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the name of the key to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the value to set it to, or %NULL</doc>
            <array c:type="const gchar* const*">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_uint" c:identifier="g_settings_set_uint" version="2.30">
        <doc xml:space="preserve">Sets @key in @settings to @value.

A convenience variant of g_settings_set() for 32-bit unsigned
integers.

It is a programmer error to give a @key that isn't specified as
having a uint32 type in the schema for @settings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if setting the key succeeded,
    %FALSE if the key was not writable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the name of the key to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value to set it to</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uint64" c:identifier="g_settings_set_uint64" version="2.50">
        <doc xml:space="preserve">Sets @key in @settings to @value.

A convenience variant of g_settings_set() for 64-bit unsigned
integers.

It is a programmer error to give a @key that isn't specified as
having a uint64 type in the schema for @settings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if setting the key succeeded,
    %FALSE if the key was not writable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the name of the key to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value to set it to</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_value" c:identifier="g_settings_set_value" version="2.26">
        <doc xml:space="preserve">Sets @key in @settings to @value.

It is a programmer error to give a @key that isn't contained in the
schema for @settings or for @value to have the incorrect type, per
the schema.

If @value is floating then this function consumes the reference.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if setting the key succeeded,
    %FALSE if the key was not writable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettings object</doc>
            <type name="Settings" c:type="GSettings*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the name of the key to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant of the correct type</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <property name="backend" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The name of the context that the settings are stored in.</doc>
        <type name="SettingsBackend"/>
      </property>
      <property name="delay-apply" version="2.28" transfer-ownership="none">
        <doc xml:space="preserve">Whether the #GSettings object is in 'delay-apply' mode. See
g_settings_delay() for details.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="has-unapplied" transfer-ownership="none">
        <doc xml:space="preserve">If this property is %TRUE, the #GSettings object has outstanding
changes that will be applied when g_settings_apply() is called.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="path" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The path within the backend where the settings are stored.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="schema" deprecated="1" deprecated-version="2.32" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The name of the schema that describes the types of keys
for this #GSettings object.

The type of this property is *not* #GSettingsSchema.
#GSettingsSchema has only existed since version 2.32 and
unfortunately this name was used in previous versions to refer to
the schema ID rather than the schema itself.  Take care to use the
'settings-schema' property if you wish to pass in a
#GSettingsSchema.</doc>
        <doc-deprecated xml:space="preserve">Use the 'schema-id' property instead.  In a future
version, this property may instead refer to a #GSettingsSchema.</doc-deprecated>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="schema-id" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The name of the schema that describes the types of keys
for this #GSettings object.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="settings-schema" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The #GSettingsSchema describing the types of keys for this
#GSettings object.

Ideally, this property would be called 'schema'.  #GSettingsSchema
has only existed since version 2.32, however, and before then the
'schema' property was used to refer to the ID of the schema rather
than the schema itself.  Take care.</doc>
        <type name="SettingsSchema"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="SettingsPrivate" c:type="GSettingsPrivate*"/>
      </field>
      <glib:signal name="change-event" when="last">
        <doc xml:space="preserve">The "change-event" signal is emitted once per change event that
affects this settings object.  You should connect to this signal
only if you are interested in viewing groups of changes before they
are split out into multiple emissions of the "changed" signal.
For most use cases it is more appropriate to use the "changed" signal.

In the event that the change event applies to one or more specified
keys, @keys will be an array of #GQuark of length @n_keys.  In the
event that the change event applies to the #GSettings object as a
whole (ie: potentially every key has been changed) then @keys will
be %NULL and @n_keys will be 0.

The default handler for this signal invokes the "changed" signal
for each affected key.  If any other connected handler returns
%TRUE then this default functionality will be suppressed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE to stop other handlers from being invoked for the
         event. FALSE to propagate the event further.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="keys" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">
       an array of #GQuarks for the changed keys, or %NULL</doc>
            <array length="1" zero-terminated="0" c:type="gpointer">
              <type name="GLib.Quark"/>
            </array>
          </parameter>
          <parameter name="n_keys" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @keys array, or 0</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="changed" when="last" detailed="1">
        <doc xml:space="preserve">The "changed" signal is emitted when a key has potentially changed.
You should call one of the g_settings_get() calls to check the new
value.

This signal supports detailed connections.  You can connect to the
detailed signal "changed::x" in order to only receive callbacks
when key "x" changes.

Note that @settings only emits this signal if you have read @key at
least once while a signal handler was already connected for @key.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the name of the key that changed</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="writable-change-event" when="last">
        <doc xml:space="preserve">The "writable-change-event" signal is emitted once per writability
change event that affects this settings object.  You should connect
to this signal if you are interested in viewing groups of changes
before they are split out into multiple emissions of the
"writable-changed" signal.  For most use cases it is more
appropriate to use the "writable-changed" signal.

In the event that the writability change applies only to a single
key, @key will be set to the #GQuark for that key.  In the event
that the writability change affects the entire settings object,
@key will be 0.

The default handler for this signal invokes the "writable-changed"
and "changed" signals for each affected key.  This is done because
changes in writability might also imply changes in value (if for
example, a new mandatory setting is introduced).  If any other
connected handler returns %TRUE then this default functionality
will be suppressed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE to stop other handlers from being invoked for the
         event. FALSE to propagate the event further.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the quark of the key, or 0</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="writable-changed" when="last" detailed="1">
        <doc xml:space="preserve">The "writable-changed" signal is emitted when the writability of a
key has potentially changed.  You should call
g_settings_is_writable() in order to determine the new status.

This signal supports detailed connections.  You can connect to the
detailed signal "writable-changed::x" in order to only receive
callbacks when the writability of "x" changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <class name="SettingsBackend" c:symbol-prefix="settings_backend" c:type="GSettingsBackend" parent="GObject.Object" abstract="1" glib:type-name="GSettingsBackend" glib:get-type="g_settings_backend_get_type" glib:type-struct="SettingsBackendClass">
      <doc xml:space="preserve">The #GSettingsBackend interface defines a generic interface for
non-strictly-typed data that is stored in a hierarchy. To implement
an alternative storage backend for #GSettings, you need to implement
the #GSettingsBackend interface and then make it implement the
extension point #G_SETTINGS_BACKEND_EXTENSION_POINT_NAME.

The interface defines methods for reading and writing values, a
method for determining if writing of certain values will fail
(lockdown) and a change notification mechanism.

The semantics of the interface are very precisely defined and
implementations must carefully adhere to the expectations of
callers that are documented on each of the interface methods.

Some of the #GSettingsBackend functions accept or return a #GTree.
These trees always have strings as keys and #GVariant as values.
g_settings_backend_create_tree() is a convenience function to create
suitable trees.

The #GSettingsBackend API is exported to allow third-party
implementations, but does not carry the same stability guarantees
as the public GIO API. For this reason, you have to define the
C preprocessor symbol %G_SETTINGS_ENABLE_BACKEND before including
`gio/gsettingsbackend.h`.</doc>
      <function name="flatten_tree" c:identifier="g_settings_backend_flatten_tree" version="2.26">
        <doc xml:space="preserve">Calculate the longest common prefix of all keys in a tree and write
out an array of the key names relative to that prefix and,
optionally, the value to store at each of those keys.

You must free the value returned in @path, @keys and @values using
g_free().  You should not attempt to free or unref the contents of
@keys or @values.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree containing the changes</doc>
            <type name="GLib.Tree" c:type="GTree*"/>
          </parameter>
          <parameter name="path" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">the location to save the path</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="keys" direction="out" caller-allocates="0" transfer-ownership="container">
            <doc xml:space="preserve">the
       location to save the relative keys</doc>
            <array c:type="const gchar***">
              <type name="utf8" c:type="gchar**"/>
            </array>
          </parameter>
          <parameter name="values" direction="out" caller-allocates="0" transfer-ownership="container" optional="1" allow-none="1">
            <doc xml:space="preserve">
         the location to save the values, or %NULL</doc>
            <array c:type="GVariant***">
              <type name="GLib.Variant" c:type="GVariant**"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="get_default" c:identifier="g_settings_backend_get_default" version="2.28">
        <doc xml:space="preserve">Returns the default #GSettingsBackend. It is possible to override
the default by setting the `GSETTINGS_BACKEND` environment variable
to the name of a settings backend.

The user gets a reference to the backend.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the default #GSettingsBackend</doc>
          <type name="SettingsBackend" c:type="GSettingsBackend*"/>
        </return-value>
      </function>
      <virtual-method name="get_permission" introspectable="0">
        <return-value>
          <type name="Permission" c:type="GPermission*"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <type name="SettingsBackend" c:type="GSettingsBackend*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_writable">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <type name="SettingsBackend" c:type="GSettingsBackend*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read">
        <return-value transfer-ownership="full">
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <type name="SettingsBackend" c:type="GSettingsBackend*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="expected_type" transfer-ownership="none">
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </parameter>
          <parameter name="default_value" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read_user_value">
        <return-value transfer-ownership="full">
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <type name="SettingsBackend" c:type="GSettingsBackend*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="expected_type" transfer-ownership="none">
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="reset">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <type name="SettingsBackend" c:type="GSettingsBackend*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="origin_tag" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="subscribe">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <type name="SettingsBackend" c:type="GSettingsBackend*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sync">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <type name="SettingsBackend" c:type="GSettingsBackend*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unsubscribe">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <type name="SettingsBackend" c:type="GSettingsBackend*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="write">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <type name="SettingsBackend" c:type="GSettingsBackend*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="origin_tag" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="write_tree">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <type name="SettingsBackend" c:type="GSettingsBackend*"/>
          </instance-parameter>
          <parameter name="tree" transfer-ownership="none">
            <type name="GLib.Tree" c:type="GTree*"/>
          </parameter>
          <parameter name="origin_tag" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="changed" c:identifier="g_settings_backend_changed" version="2.26">
        <doc xml:space="preserve">Signals that a single key has possibly changed.  Backend
implementations should call this if a key has possibly changed its
value.

@key must be a valid key (ie starting with a slash, not containing
'//', and not ending with a slash).

The implementation must call this function during any call to
g_settings_backend_write(), before the call returns (except in the
case that no keys are actually changed and it cares to detect this
fact).  It may not rely on the existence of a mainloop for
dispatching the signal later.

The implementation may call this function at any other time it likes
in response to other events (such as changes occurring outside of the
program).  These calls may originate from a mainloop or may originate
in response to any other action (including from calls to
g_settings_backend_write()).

In the case that this call is in response to a call to
g_settings_backend_write() then @origin_tag must be set to the same
value that was passed to that call.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsBackend implementation</doc>
            <type name="SettingsBackend" c:type="GSettingsBackend*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the name of the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="origin_tag" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the origin tag</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="changed_tree" c:identifier="g_settings_backend_changed_tree" version="2.26">
        <doc xml:space="preserve">This call is a convenience wrapper.  It gets the list of changes from
@tree, computes the longest common prefix and calls
g_settings_backend_changed().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsBackend implementation</doc>
            <type name="SettingsBackend" c:type="GSettingsBackend*"/>
          </instance-parameter>
          <parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree containing the changes</doc>
            <type name="GLib.Tree" c:type="GTree*"/>
          </parameter>
          <parameter name="origin_tag" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the origin tag</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="keys_changed" c:identifier="g_settings_backend_keys_changed" version="2.26">
        <doc xml:space="preserve">Signals that a list of keys have possibly changed.  Backend
implementations should call this if keys have possibly changed their
values.

@path must be a valid path (ie starting and ending with a slash and
not containing '//').  Each string in @items must form a valid key
name when @path is prefixed to it (ie: each item must not start or
end with '/' and must not contain '//').

The meaning of this signal is that any of the key names resulting
from the contatenation of @path with each item in @items may have
changed.

The same rules for when notifications must occur apply as per
g_settings_backend_changed().  These two calls can be used
interchangeably if exactly one item has changed (although in that
case g_settings_backend_changed() is definitely preferred).

For efficiency reasons, the implementation should strive for @path to
be as long as possible (ie: the longest common prefix of all of the
keys that were changed) but this is not strictly required.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsBackend implementation</doc>
            <type name="SettingsBackend" c:type="GSettingsBackend*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path containing the changes</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="items" transfer-ownership="none">
            <doc xml:space="preserve">the %NULL-terminated list of changed keys</doc>
            <array c:type="const gchar* const*">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="origin_tag" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the origin tag</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="path_changed" c:identifier="g_settings_backend_path_changed" version="2.26">
        <doc xml:space="preserve">Signals that all keys below a given path may have possibly changed.
Backend implementations should call this if an entire path of keys
have possibly changed their values.

@path must be a valid path (ie starting and ending with a slash and
not containing '//').

The meaning of this signal is that any of the key which has a name
starting with @path may have changed.

The same rules for when notifications must occur apply as per
g_settings_backend_changed().  This call might be an appropriate
reasponse to a 'reset' call but implementations are also free to
explicitly list the keys that were affected by that call if they can
easily do so.

For efficiency reasons, the implementation should strive for @path to
be as long as possible (ie: the longest common prefix of all of the
keys that were changed) but this is not strictly required.  As an
example, if this function is called with the path of "/" then every
single key in the application will be notified of a possible change.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsBackend implementation</doc>
            <type name="SettingsBackend" c:type="GSettingsBackend*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path containing the changes</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="origin_tag" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the origin tag</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="path_writable_changed" c:identifier="g_settings_backend_path_writable_changed" version="2.26">
        <doc xml:space="preserve">Signals that the writability of all keys below a given path may have
changed.

Since GSettings performs no locking operations for itself, this call
will always be made in response to external events.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsBackend implementation</doc>
            <type name="SettingsBackend" c:type="GSettingsBackend*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the name of the path</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="writable_changed" c:identifier="g_settings_backend_writable_changed" version="2.26">
        <doc xml:space="preserve">Signals that the writability of a single key has possibly changed.

Since GSettings performs no locking operations for itself, this call
will always be made in response to external events.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsBackend implementation</doc>
            <type name="SettingsBackend" c:type="GSettingsBackend*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the name of the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SettingsBackendPrivate" c:type="GSettingsBackendPrivate*"/>
      </field>
    </class>
    <record name="SettingsBackendClass" c:type="GSettingsBackendClass" glib:is-gtype-struct-for="SettingsBackend">
      <doc xml:space="preserve">Class structure for #GSettingsBackend.</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="read">
        <callback name="read">
          <return-value transfer-ownership="full">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </return-value>
          <parameters>
            <parameter name="backend" transfer-ownership="none">
              <type name="SettingsBackend" c:type="GSettingsBackend*"/>
            </parameter>
            <parameter name="key" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="expected_type" transfer-ownership="none">
              <type name="GLib.VariantType" c:type="const GVariantType*"/>
            </parameter>
            <parameter name="default_value" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_writable">
        <callback name="get_writable">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="backend" transfer-ownership="none">
              <type name="SettingsBackend" c:type="GSettingsBackend*"/>
            </parameter>
            <parameter name="key" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="write">
        <callback name="write">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="backend" transfer-ownership="none">
              <type name="SettingsBackend" c:type="GSettingsBackend*"/>
            </parameter>
            <parameter name="key" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
            <parameter name="origin_tag" transfer-ownership="none" nullable="1" allow-none="1">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="write_tree">
        <callback name="write_tree">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="backend" transfer-ownership="none">
              <type name="SettingsBackend" c:type="GSettingsBackend*"/>
            </parameter>
            <parameter name="tree" transfer-ownership="none">
              <type name="GLib.Tree" c:type="GTree*"/>
            </parameter>
            <parameter name="origin_tag" transfer-ownership="none" nullable="1" allow-none="1">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reset">
        <callback name="reset">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="backend" transfer-ownership="none">
              <type name="SettingsBackend" c:type="GSettingsBackend*"/>
            </parameter>
            <parameter name="key" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="origin_tag" transfer-ownership="none" nullable="1" allow-none="1">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="subscribe">
        <callback name="subscribe">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="backend" transfer-ownership="none">
              <type name="SettingsBackend" c:type="GSettingsBackend*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unsubscribe">
        <callback name="unsubscribe">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="backend" transfer-ownership="none">
              <type name="SettingsBackend" c:type="GSettingsBackend*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sync">
        <callback name="sync">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="backend" transfer-ownership="none">
              <type name="SettingsBackend" c:type="GSettingsBackend*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_permission" introspectable="0">
        <callback name="get_permission" introspectable="0">
          <return-value>
            <type name="Permission" c:type="GPermission*"/>
          </return-value>
          <parameters>
            <parameter name="backend" transfer-ownership="none">
              <type name="SettingsBackend" c:type="GSettingsBackend*"/>
            </parameter>
            <parameter name="path" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="read_user_value">
        <callback name="read_user_value">
          <return-value transfer-ownership="full">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </return-value>
          <parameters>
            <parameter name="backend" transfer-ownership="none">
              <type name="SettingsBackend" c:type="GSettingsBackend*"/>
            </parameter>
            <parameter name="key" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="expected_type" transfer-ownership="none">
              <type name="GLib.VariantType" c:type="const GVariantType*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="23">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="SettingsBackendPrivate" c:type="GSettingsBackendPrivate" disguised="1">
    </record>
    <bitfield name="SettingsBindFlags" glib:type-name="GSettingsBindFlags" glib:get-type="g_settings_bind_flags_get_type" c:type="GSettingsBindFlags">
      <doc xml:space="preserve">Flags used when creating a binding. These flags determine in which
direction the binding works. The default is to synchronize in both
directions.</doc>
      <member name="default" value="0" c:identifier="G_SETTINGS_BIND_DEFAULT" glib:nick="default">
        <doc xml:space="preserve">Equivalent to `G_SETTINGS_BIND_GET|G_SETTINGS_BIND_SET`</doc>
      </member>
      <member name="get" value="1" c:identifier="G_SETTINGS_BIND_GET" glib:nick="get">
        <doc xml:space="preserve">Update the #GObject property when the setting changes.
    It is an error to use this flag if the property is not writable.</doc>
      </member>
      <member name="set" value="2" c:identifier="G_SETTINGS_BIND_SET" glib:nick="set">
        <doc xml:space="preserve">Update the setting when the #GObject property changes.
    It is an error to use this flag if the property is not readable.</doc>
      </member>
      <member name="no_sensitivity" value="4" c:identifier="G_SETTINGS_BIND_NO_SENSITIVITY" glib:nick="no-sensitivity">
        <doc xml:space="preserve">Do not try to bind a "sensitivity" property to the writability of the setting</doc>
      </member>
      <member name="get_no_changes" value="8" c:identifier="G_SETTINGS_BIND_GET_NO_CHANGES" glib:nick="get-no-changes">
        <doc xml:space="preserve">When set in addition to #G_SETTINGS_BIND_GET, set the #GObject property
    value initially from the setting, but do not listen for changes of the setting</doc>
      </member>
      <member name="invert_boolean" value="16" c:identifier="G_SETTINGS_BIND_INVERT_BOOLEAN" glib:nick="invert-boolean">
        <doc xml:space="preserve">When passed to g_settings_bind(), uses a pair of mapping functions that invert
    the boolean value when mapping between the setting and the property.  The setting and property must both
    be booleans.  You cannot pass this flag to g_settings_bind_with_mapping().</doc>
      </member>
    </bitfield>
    <callback name="SettingsBindGetMapping" c:type="GSettingsBindGetMapping">
      <doc xml:space="preserve">The type for the function that is used to convert from #GSettings to
an object property. The @value is already initialized to hold values
of the appropriate type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the conversion succeeded, %FALSE in case of an error</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">return location for the property value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="variant" transfer-ownership="none">
          <doc xml:space="preserve">the #GVariant</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">user data that was specified when the binding was created</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="SettingsBindSetMapping" c:type="GSettingsBindSetMapping">
      <doc xml:space="preserve">The type for the function that is used to convert an object property
value to a #GVariant for storing it in #GSettings.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new #GVariant holding the data from @value,
    or %NULL in case of an error</doc>
        <type name="GLib.Variant" c:type="GVariant*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a #GValue containing the property value to map</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="expected_type" transfer-ownership="none">
          <doc xml:space="preserve">the #GVariantType to create</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">user data that was specified when the binding was created</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="SettingsClass" c:type="GSettingsClass" glib:is-gtype-struct-for="Settings">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="writable_changed">
        <callback name="writable_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="settings" transfer-ownership="none">
              <type name="Settings" c:type="GSettings*"/>
            </parameter>
            <parameter name="key" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="changed">
        <callback name="changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="settings" transfer-ownership="none">
              <type name="Settings" c:type="GSettings*"/>
            </parameter>
            <parameter name="key" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="writable_change_event">
        <callback name="writable_change_event">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="settings" transfer-ownership="none">
              <type name="Settings" c:type="GSettings*"/>
            </parameter>
            <parameter name="key" transfer-ownership="none">
              <type name="GLib.Quark" c:type="GQuark"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="change_event">
        <callback name="change_event">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="settings" transfer-ownership="none">
              <type name="Settings" c:type="GSettings*"/>
            </parameter>
            <parameter name="keys" transfer-ownership="none">
              <type name="GLib.Quark" c:type="const GQuark*"/>
            </parameter>
            <parameter name="n_keys" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="SettingsGetMapping" c:type="GSettingsGetMapping">
      <doc xml:space="preserve">The type of the function that is used to convert from a value stored
in a #GSettings to a value that is useful to the application.

If the value is successfully mapped, the result should be stored at
@result and %TRUE returned.  If mapping fails (for example, if @value
is not in the right format) then %FALSE should be returned.

If @value is %NULL then it means that the mapping function is being
given a "last chance" to successfully return a valid value.  %TRUE
must be returned in this case.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the conversion succeeded, %FALSE in case of an error</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the #GVariant to map, or %NULL</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
        <parameter name="result" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the result of the mapping</doc>
          <type name="gpointer" c:type="gpointer*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">the user data that was passed to
g_settings_get_mapped()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="SettingsPrivate" c:type="GSettingsPrivate" disguised="1">
    </record>
    <record name="SettingsSchema" c:type="GSettingsSchema" version="2.32" glib:type-name="GSettingsSchema" glib:get-type="g_settings_schema_get_type" c:symbol-prefix="settings_schema">
      <doc xml:space="preserve">The #GSettingsSchemaSource and #GSettingsSchema APIs provide a
mechanism for advanced control over the loading of schemas and a
mechanism for introspecting their content.

Plugin loading systems that wish to provide plugins a way to access
settings face the problem of how to make the schemas for these
settings visible to GSettings.  Typically, a plugin will want to ship
the schema along with itself and it won't be installed into the
standard system directories for schemas.

#GSettingsSchemaSource provides a mechanism for dealing with this by
allowing the creation of a new 'schema source' from which schemas can
be acquired.  This schema source can then become part of the metadata
associated with the plugin and queried whenever the plugin requires
access to some settings.

Consider the following example:

|[&lt;!-- language="C" --&gt;
typedef struct
{
   ...
   GSettingsSchemaSource *schema_source;
   ...
} Plugin;

Plugin *
initialise_plugin (const gchar *dir)
{
  Plugin *plugin;

  ...

  plugin-&gt;schema_source =
    g_settings_schema_source_new_from_directory (dir,
      g_settings_schema_source_get_default (), FALSE, NULL);

  ...

  return plugin;
}

...

GSettings *
plugin_get_settings (Plugin      *plugin,
                     const gchar *schema_id)
{
  GSettingsSchema *schema;

  if (schema_id == NULL)
    schema_id = plugin-&gt;identifier;

  schema = g_settings_schema_source_lookup (plugin-&gt;schema_source,
                                            schema_id, FALSE);

  if (schema == NULL)
    {
      ... disable the plugin or abort, etc ...
    }

  return g_settings_new_full (schema, NULL, NULL);
}
]|

The code above shows how hooks should be added to the code that
initialises (or enables) the plugin to create the schema source and
how an API can be added to the plugin system to provide a convenient
way for the plugin to access its settings, using the schemas that it
ships.

From the standpoint of the plugin, it would need to ensure that it
ships a gschemas.compiled file as part of itself, and then simply do
the following:

|[&lt;!-- language="C" --&gt;
{
  GSettings *settings;
  gint some_value;

  settings = plugin_get_settings (self, NULL);
  some_value = g_settings_get_int (settings, "some-value");
  ...
}
]|

It's also possible that the plugin system expects the schema source
files (ie: .gschema.xml files) instead of a gschemas.compiled file.
In that case, the plugin loading system must compile the schemas for
itself before attempting to create the settings source.</doc>
      <method name="get_id" c:identifier="g_settings_schema_get_id">
        <doc xml:space="preserve">Get the ID of @schema.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the ID</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="schema" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsSchema</doc>
            <type name="SettingsSchema" c:type="GSettingsSchema*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_key" c:identifier="g_settings_schema_get_key" version="2.40">
        <doc xml:space="preserve">Gets the key named @name from @schema.

It is a programmer error to request a key that does not exist.  See
g_settings_schema_list_keys().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the #GSettingsSchemaKey for @name</doc>
          <type name="SettingsSchemaKey" c:type="GSettingsSchemaKey*"/>
        </return-value>
        <parameters>
          <instance-parameter name="schema" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsSchema</doc>
            <type name="SettingsSchema" c:type="GSettingsSchema*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_path" c:identifier="g_settings_schema_get_path" version="2.32">
        <doc xml:space="preserve">Gets the path associated with @schema, or %NULL.

Schemas may be single-instance or relocatable.  Single-instance
schemas correspond to exactly one set of keys in the backend
database: those located at the path returned by this function.

Relocatable schemas can be referenced by other schemas and can
threfore describe multiple sets of keys at different locations.  For
relocatable schemas, this function will return %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the path of the schema, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="schema" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsSchema</doc>
            <type name="SettingsSchema" c:type="GSettingsSchema*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_key" c:identifier="g_settings_schema_has_key" version="2.40">
        <doc xml:space="preserve">Checks if @schema has a key named @name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if such a key exists</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="schema" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsSchema</doc>
            <type name="SettingsSchema" c:type="GSettingsSchema*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_children" c:identifier="g_settings_schema_list_children" version="2.44">
        <doc xml:space="preserve">Gets the list of children in @schema.

You should free the return value with g_strfreev() when you are done
with it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a list of the children on @settings</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="schema" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsSchema</doc>
            <type name="SettingsSchema" c:type="GSettingsSchema*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="list_keys" c:identifier="g_settings_schema_list_keys" version="2.46">
        <doc xml:space="preserve">Introspects the list of keys on @schema.

You should probably not be calling this function from "normal" code
(since you should already know what keys are in your schema).  This
function is intended for introspection reasons.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a list of the keys on
  @schema</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="schema" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsSchema</doc>
            <type name="SettingsSchema" c:type="GSettingsSchema*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_settings_schema_ref" version="2.32">
        <doc xml:space="preserve">Increase the reference count of @schema, returning a new reference.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new reference to @schema</doc>
          <type name="SettingsSchema" c:type="GSettingsSchema*"/>
        </return-value>
        <parameters>
          <instance-parameter name="schema" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsSchema</doc>
            <type name="SettingsSchema" c:type="GSettingsSchema*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_settings_schema_unref" version="2.32">
        <doc xml:space="preserve">Decrease the reference count of @schema, possibly freeing it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="schema" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsSchema</doc>
            <type name="SettingsSchema" c:type="GSettingsSchema*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="SettingsSchemaKey" c:type="GSettingsSchemaKey" glib:type-name="GSettingsSchemaKey" glib:get-type="g_settings_schema_key_get_type" c:symbol-prefix="settings_schema_key">
      <doc xml:space="preserve">#GSettingsSchemaKey is an opaque data structure and can only be accessed
using the following functions.</doc>
      <method name="get_default_value" c:identifier="g_settings_schema_key_get_default_value" version="2.40">
        <doc xml:space="preserve">Gets the default value for @key.

Note that this is the default value according to the schema.  System
administrator defaults and lockdown are not visible via this API.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the default value for the key</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsSchemaKey</doc>
            <type name="SettingsSchemaKey" c:type="GSettingsSchemaKey*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_description" c:identifier="g_settings_schema_key_get_description" version="2.34">
        <doc xml:space="preserve">Gets the description for @key.

If no description has been provided in the schema for @key, returns
%NULL.

The description can be one sentence to several paragraphs in length.
Paragraphs are delimited with a double newline.  Descriptions can be
translated and the value returned from this function is is the
current locale.

This function is slow.  The summary and description information for
the schemas is not stored in the compiled schema database so this
function has to parse all of the source XML files in the schema
directory.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the description for @key, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsSchemaKey</doc>
            <type name="SettingsSchemaKey" c:type="GSettingsSchemaKey*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="g_settings_schema_key_get_name" version="2.44">
        <doc xml:space="preserve">Gets the name of @key.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of @key.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsSchemaKey</doc>
            <type name="SettingsSchemaKey" c:type="GSettingsSchemaKey*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_range" c:identifier="g_settings_schema_key_get_range" version="2.40">
        <doc xml:space="preserve">Queries the range of a key.

This function will return a #GVariant that fully describes the range
of values that are valid for @key.

The type of #GVariant returned is `(sv)`. The string describes
the type of range restriction in effect. The type and meaning of
the value contained in the variant depends on the string.

If the string is `'type'` then the variant contains an empty array.
The element type of that empty array is the expected type of value
and all values of that type are valid.

If the string is `'enum'` then the variant contains an array
enumerating the possible values. Each item in the array is
a possible valid value and no other values are valid.

If the string is `'flags'` then the variant contains an array. Each
item in the array is a value that may appear zero or one times in an
array to be used as the value for this key. For example, if the
variant contained the array `['x', 'y']` then the valid values for
the key would be `[]`, `['x']`, `['y']`, `['x', 'y']` and
`['y', 'x']`.

Finally, if the string is `'range'` then the variant contains a pair
of like-typed values -- the minimum and maximum permissible values
for this key.

This information should not be used by normal programs.  It is
considered to be a hint for introspection purposes.  Normal programs
should already know what is permitted by their own schema.  The
format may change in any way in the future -- but particularly, new
forms may be added to the possibilities described above.

You should free the returned value with g_variant_unref() when it is
no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GVariant describing the range</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsSchemaKey</doc>
            <type name="SettingsSchemaKey" c:type="GSettingsSchemaKey*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_summary" c:identifier="g_settings_schema_key_get_summary" version="2.34">
        <doc xml:space="preserve">Gets the summary for @key.

If no summary has been provided in the schema for @key, returns
%NULL.

The summary is a short description of the purpose of the key; usually
one short sentence.  Summaries can be translated and the value
returned from this function is is the current locale.

This function is slow.  The summary and description information for
the schemas is not stored in the compiled schema database so this
function has to parse all of the source XML files in the schema
directory.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the summary for @key, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsSchemaKey</doc>
            <type name="SettingsSchemaKey" c:type="GSettingsSchemaKey*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_value_type" c:identifier="g_settings_schema_key_get_value_type" version="2.40">
        <doc xml:space="preserve">Gets the #GVariantType of @key.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type of @key</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsSchemaKey</doc>
            <type name="SettingsSchemaKey" c:type="GSettingsSchemaKey*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="range_check" c:identifier="g_settings_schema_key_range_check" version="2.40">
        <doc xml:space="preserve">Checks if the given @value is of the correct type and within the
permitted range for @key.

It is a programmer error if @value is not of the correct type -- you
must check for this first.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @value is valid for @key</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsSchemaKey</doc>
            <type name="SettingsSchemaKey" c:type="GSettingsSchemaKey*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value to check</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_settings_schema_key_ref" version="2.40">
        <doc xml:space="preserve">Increase the reference count of @key, returning a new reference.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new reference to @key</doc>
          <type name="SettingsSchemaKey" c:type="GSettingsSchemaKey*"/>
        </return-value>
        <parameters>
          <instance-parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsSchemaKey</doc>
            <type name="SettingsSchemaKey" c:type="GSettingsSchemaKey*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_settings_schema_key_unref" version="2.40">
        <doc xml:space="preserve">Decrease the reference count of @key, possibly freeing it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsSchemaKey</doc>
            <type name="SettingsSchemaKey" c:type="GSettingsSchemaKey*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="SettingsSchemaSource" c:type="GSettingsSchemaSource" version="2.32" glib:type-name="GSettingsSchemaSource" glib:get-type="g_settings_schema_source_get_type" c:symbol-prefix="settings_schema_source">
      <doc xml:space="preserve">This is an opaque structure type.  You may not access it directly.</doc>
      <constructor name="new_from_directory" c:identifier="g_settings_schema_source_new_from_directory" version="2.32" throws="1">
        <doc xml:space="preserve">Attempts to create a new schema source corresponding to the contents
of the given directory.

This function is not required for normal uses of #GSettings but it
may be useful to authors of plugin management systems.

The directory should contain a file called `gschemas.compiled` as
produced by the [glib-compile-schemas][glib-compile-schemas] tool.

If @trusted is %TRUE then `gschemas.compiled` is trusted not to be
corrupted. This assumption has a performance advantage, but can result
in crashes or inconsistent behaviour in the case of a corrupted file.
Generally, you should set @trusted to %TRUE for files installed by the
system and to %FALSE for files in the home directory.

In either case, an empty file or some types of corruption in the file will
result in %G_FILE_ERROR_INVAL being returned.

If @parent is non-%NULL then there are two effects.

First, if g_settings_schema_source_lookup() is called with the
@recursive flag set to %TRUE and the schema can not be found in the
source, the lookup will recurse to the parent.

Second, any references to other schemas specified within this
source (ie: `child` or `extends`) references may be resolved
from the @parent.

For this second reason, except in very unusual situations, the
@parent should probably be given as the default schema source, as
returned by g_settings_schema_source_get_default().</doc>
        <return-value transfer-ownership="full">
          <type name="SettingsSchemaSource" c:type="GSettingsSchemaSource*"/>
        </return-value>
        <parameters>
          <parameter name="directory" transfer-ownership="none">
            <doc xml:space="preserve">the filename of a directory</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
          <parameter name="parent" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GSettingsSchemaSource, or %NULL</doc>
            <type name="SettingsSchemaSource" c:type="GSettingsSchemaSource*"/>
          </parameter>
          <parameter name="trusted" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE, if the directory is trusted</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="list_schemas" c:identifier="g_settings_schema_source_list_schemas" version="2.40">
        <doc xml:space="preserve">Lists the schemas in a given source.

If @recursive is %TRUE then include parent sources.  If %FALSE then
only include the schemas from one source (ie: one directory).  You
probably want %TRUE.

Non-relocatable schemas are those for which you can call
g_settings_new().  Relocatable schemas are those for which you must
use g_settings_new_with_path().

Do not call this function from normal programs.  This is designed for
use by database editors, commandline tools, etc.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsSchemaSource</doc>
            <type name="SettingsSchemaSource" c:type="GSettingsSchemaSource*"/>
          </instance-parameter>
          <parameter name="recursive" transfer-ownership="none">
            <doc xml:space="preserve">if we should recurse</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="non_relocatable" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">the
  list of non-relocatable schemas</doc>
            <array c:type="gchar***">
              <type name="utf8" c:type="gchar**"/>
            </array>
          </parameter>
          <parameter name="relocatable" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">the list
  of relocatable schemas</doc>
            <array c:type="gchar***">
              <type name="utf8" c:type="gchar**"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="lookup" c:identifier="g_settings_schema_source_lookup" version="2.32">
        <doc xml:space="preserve">Looks up a schema with the identifier @schema_id in @source.

This function is not required for normal uses of #GSettings but it
may be useful to authors of plugin management systems or to those who
want to introspect the content of schemas.

If the schema isn't found directly in @source and @recursive is %TRUE
then the parent sources will also be checked.

If the schema isn't found, %NULL is returned.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #GSettingsSchema</doc>
          <type name="SettingsSchema" c:type="GSettingsSchema*"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsSchemaSource</doc>
            <type name="SettingsSchemaSource" c:type="GSettingsSchemaSource*"/>
          </instance-parameter>
          <parameter name="schema_id" transfer-ownership="none">
            <doc xml:space="preserve">a schema ID</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="recursive" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the lookup should be recursive</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_settings_schema_source_ref" version="2.32">
        <doc xml:space="preserve">Increase the reference count of @source, returning a new reference.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new reference to @source</doc>
          <type name="SettingsSchemaSource" c:type="GSettingsSchemaSource*"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsSchemaSource</doc>
            <type name="SettingsSchemaSource" c:type="GSettingsSchemaSource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_settings_schema_source_unref" version="2.32">
        <doc xml:space="preserve">Decrease the reference count of @source, possibly freeing it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a #GSettingsSchemaSource</doc>
            <type name="SettingsSchemaSource" c:type="GSettingsSchemaSource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="get_default" c:identifier="g_settings_schema_source_get_default" version="2.32">
        <doc xml:space="preserve">Gets the default system schema source.

This function is not required for normal uses of #GSettings but it
may be useful to authors of plugin management systems or to those who
want to introspect the content of schemas.

If no schemas are installed, %NULL will be returned.

The returned source may actually consist of multiple schema sources
from different directories, depending on which directories were given
in `XDG_DATA_DIRS` and `GSETTINGS_SCHEMA_DIR`. For this reason, all
lookups performed against the default source should probably be done
recursively.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the default schema source</doc>
          <type name="SettingsSchemaSource" c:type="GSettingsSchemaSource*"/>
        </return-value>
      </function>
    </record>
    <class name="SimpleAction" c:symbol-prefix="simple_action" c:type="GSimpleAction" parent="GObject.Object" glib:type-name="GSimpleAction" glib:get-type="g_simple_action_get_type">
      <doc xml:space="preserve">A #GSimpleAction is the obvious simple implementation of the #GAction
interface. This is the easiest way to create an action for purposes of
adding it to a #GSimpleActionGroup.

See also #GtkAction.</doc>
      <implements name="Action"/>
      <constructor name="new" c:identifier="g_simple_action_new" version="2.28">
        <doc xml:space="preserve">Creates a new action.

The created action is stateless. See g_simple_action_new_stateful() to create
an action that has state.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSimpleAction</doc>
          <type name="SimpleAction" c:type="GSimpleAction*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="parameter_type" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the type of parameter that will be passed to
  handlers for the #GSimpleAction::activate signal, or %NULL for no parameter</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_stateful" c:identifier="g_simple_action_new_stateful" version="2.28">
        <doc xml:space="preserve">Creates a new stateful action.

All future state values must have the same #GVariantType as the initial
@state.

If the @state #GVariant is floating, it is consumed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSimpleAction</doc>
          <type name="SimpleAction" c:type="GSimpleAction*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="parameter_type" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the type of the parameter that will be passed to
  handlers for the #GSimpleAction::activate signal, or %NULL for no parameter</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve">the initial state of the action</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="set_enabled" c:identifier="g_simple_action_set_enabled" version="2.28">
        <doc xml:space="preserve">Sets the action as enabled or not.

An action must be enabled in order to be activated or in order to
have its state changed from outside callers.

This should only be called by the implementor of the action.  Users
of the action should not attempt to modify its enabled flag.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleAction</doc>
            <type name="SimpleAction" c:type="GSimpleAction*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">whether the action is enabled</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_state" c:identifier="g_simple_action_set_state" version="2.30">
        <doc xml:space="preserve">Sets the state of the action.

This directly updates the 'state' property to the given value.

This should only be called by the implementor of the action.  Users
of the action should not attempt to directly modify the 'state'
property.  Instead, they should call g_action_change_state() to
request the change.

If the @value GVariant is floating, it is consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleAction</doc>
            <type name="SimpleAction" c:type="GSimpleAction*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the new #GVariant for the state</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_state_hint" c:identifier="g_simple_action_set_state_hint" version="2.44">
        <doc xml:space="preserve">Sets the state hint for the action.

See g_action_get_state_hint() for more information about
action state hints.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleAction</doc>
            <type name="SimpleAction" c:type="GSimpleAction*"/>
          </instance-parameter>
          <parameter name="state_hint" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GVariant representing the state hint</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <property name="enabled" version="2.28" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">If @action is currently enabled.

If the action is disabled then calls to g_action_activate() and
g_action_change_state() have no effect.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="name" version="2.28" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The name of the action. This is mostly meaningful for identifying
the action once it has been added to a #GSimpleActionGroup.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="parameter-type" version="2.28" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The type of the parameter that must be given when activating the
action.</doc>
        <type name="GLib.VariantType"/>
      </property>
      <property name="state" version="2.28" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">The state of the action, or %NULL if the action is stateless.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="state-type" version="2.28" transfer-ownership="none">
        <doc xml:space="preserve">The #GVariantType of the state that the action has, or %NULL if the
action is stateless.</doc>
        <type name="GLib.VariantType"/>
      </property>
      <glib:signal name="activate" when="last" version="2.28">
        <doc xml:space="preserve">Indicates that the action was just activated.

@parameter will always be of the expected type, i.e. the parameter type
specified when the action was created. If an incorrect type is given when
activating the action, this signal is not emitted.

Since GLib 2.40, if no handler is connected to this signal then the
default behaviour for boolean-stated actions with a %NULL parameter
type is to toggle them via the #GSimpleAction::change-state signal.
For stateful actions where the state type is equal to the parameter
type, the default is to forward them directly to
#GSimpleAction::change-state.  This should allow almost all users
of #GSimpleAction to connect only one handler or the other.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="parameter" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the parameter to the activation, or %NULL if it has
  no parameter</doc>
            <type name="GLib.Variant"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="change-state" when="last" version="2.30">
        <doc xml:space="preserve">Indicates that the action just received a request to change its
state.

@value will always be of the correct state type, i.e. the type of the
initial state passed to g_simple_action_new_stateful(). If an incorrect
type is given when requesting to change the state, this signal is not
emitted.

If no handler is connected to this signal then the default
behaviour is to call g_simple_action_set_state() to set the state
to the requested value. If you connect a signal handler then no
default action is taken. If the state should change then you must
call g_simple_action_set_state() from the handler.

An example of a 'change-state' handler:
|[&lt;!-- language="C" --&gt;
static void
change_volume_state (GSimpleAction *action,
                     GVariant      *value,
                     gpointer       user_data)
{
  gint requested;

  requested = g_variant_get_int32 (value);

  // Volume only goes from 0 to 10
  if (0 &lt;= requested &amp;&amp; requested &lt;= 10)
    g_simple_action_set_state (action, value);
}
]|

The handler need not set the state to the requested value.
It could set it to any value at all, or take some other action.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the requested value for the state</doc>
            <type name="GLib.Variant"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <class name="SimpleActionGroup" c:symbol-prefix="simple_action_group" c:type="GSimpleActionGroup" version="2.28" parent="GObject.Object" glib:type-name="GSimpleActionGroup" glib:get-type="g_simple_action_group_get_type" glib:type-struct="SimpleActionGroupClass">
      <doc xml:space="preserve">#GSimpleActionGroup is a hash table filled with #GAction objects,
implementing the #GActionGroup and #GActionMap interfaces.</doc>
      <implements name="ActionGroup"/>
      <implements name="ActionMap"/>
      <constructor name="new" c:identifier="g_simple_action_group_new" version="2.28">
        <doc xml:space="preserve">Creates a new, empty, #GSimpleActionGroup.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSimpleActionGroup</doc>
          <type name="SimpleActionGroup" c:type="GSimpleActionGroup*"/>
        </return-value>
      </constructor>
      <method name="add_entries" c:identifier="g_simple_action_group_add_entries" version="2.30" deprecated="1" deprecated-version="2.38">
        <doc xml:space="preserve">A convenience function for creating multiple #GSimpleAction instances
and adding them to the action group.</doc>
        <doc-deprecated xml:space="preserve">Use g_action_map_add_action_entries()</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleActionGroup</doc>
            <type name="SimpleActionGroup" c:type="GSimpleActionGroup*"/>
          </instance-parameter>
          <parameter name="entries" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to the first item in
          an array of #GActionEntry structs</doc>
            <array length="1" zero-terminated="0" c:type="const GActionEntry*">
              <type name="ActionEntry" c:type="GActionEntry"/>
            </array>
          </parameter>
          <parameter name="n_entries" transfer-ownership="none">
            <doc xml:space="preserve">the length of @entries, or -1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the user data for signal connections</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert" c:identifier="g_simple_action_group_insert" version="2.28" deprecated="1" deprecated-version="2.38">
        <doc xml:space="preserve">Adds an action to the action group.

If the action group already contains an action with the same name as
@action then the old action is dropped from the group.

The action group takes its own reference on @action.</doc>
        <doc-deprecated xml:space="preserve">Use g_action_map_add_action()</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleActionGroup</doc>
            <type name="SimpleActionGroup" c:type="GSimpleActionGroup*"/>
          </instance-parameter>
          <parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve">a #GAction</doc>
            <type name="Action" c:type="GAction*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup" c:identifier="g_simple_action_group_lookup" version="2.28" deprecated="1" deprecated-version="2.38">
        <doc xml:space="preserve">Looks up the action with the name @action_name in the group.

If no such action exists, returns %NULL.</doc>
        <doc-deprecated xml:space="preserve">Use g_action_map_lookup_action()</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GAction, or %NULL</doc>
          <type name="Action" c:type="GAction*"/>
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleActionGroup</doc>
            <type name="SimpleActionGroup" c:type="GSimpleActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of an action</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="g_simple_action_group_remove" version="2.28" deprecated="1" deprecated-version="2.38">
        <doc xml:space="preserve">Removes the named action from the action group.

If no action of this name is in the group then nothing happens.</doc>
        <doc-deprecated xml:space="preserve">Use g_action_map_remove_action()</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleActionGroup</doc>
            <type name="SimpleActionGroup" c:type="GSimpleActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the action</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SimpleActionGroupPrivate" c:type="GSimpleActionGroupPrivate*"/>
      </field>
    </class>
    <record name="SimpleActionGroupClass" c:type="GSimpleActionGroupClass" glib:is-gtype-struct-for="SimpleActionGroup">
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="12">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="SimpleActionGroupPrivate" c:type="GSimpleActionGroupPrivate" disguised="1">
    </record>
    <class name="SimpleAsyncResult" c:symbol-prefix="simple_async_result" c:type="GSimpleAsyncResult" parent="GObject.Object" glib:type-name="GSimpleAsyncResult" glib:get-type="g_simple_async_result_get_type" glib:type-struct="SimpleAsyncResultClass">
      <doc xml:space="preserve">As of GLib 2.46, #GSimpleAsyncResult is deprecated in favor of
#GTask, which provides a simpler API.

#GSimpleAsyncResult implements #GAsyncResult.

GSimpleAsyncResult handles #GAsyncReadyCallbacks, error
reporting, operation cancellation and the final state of an operation,
completely transparent to the application. Results can be returned
as a pointer e.g. for functions that return data that is collected
asynchronously, a boolean value for checking the success or failure
of an operation, or a #gssize for operations which return the number
of bytes modified by the operation; all of the simple return cases
are covered.

Most of the time, an application will not need to know of the details
of this API; it is handled transparently, and any necessary operations
are handled by #GAsyncResult's interface. However, if implementing a
new GIO module, for writing language bindings, or for complex
applications that need better control of how asynchronous operations
are completed, it is important to understand this functionality.

GSimpleAsyncResults are tagged with the calling function to ensure
that asynchronous functions and their finishing functions are used
together correctly.

To create a new #GSimpleAsyncResult, call g_simple_async_result_new().
If the result needs to be created for a #GError, use
g_simple_async_result_new_from_error() or
g_simple_async_result_new_take_error(). If a #GError is not available
(e.g. the asynchronous operation's doesn't take a #GError argument),
but the result still needs to be created for an error condition, use
g_simple_async_result_new_error() (or g_simple_async_result_set_error_va()
if your application or binding requires passing a variable argument list
directly), and the error can then be propagated through the use of
g_simple_async_result_propagate_error().

An asynchronous operation can be made to ignore a cancellation event by
calling g_simple_async_result_set_handle_cancellation() with a
#GSimpleAsyncResult for the operation and %FALSE. This is useful for
operations that are dangerous to cancel, such as close (which would
cause a leak if cancelled before being run).

GSimpleAsyncResult can integrate into GLib's event loop, #GMainLoop,
or it can use #GThreads.
g_simple_async_result_complete() will finish an I/O task directly
from the point where it is called. g_simple_async_result_complete_in_idle()
will finish it from an idle handler in the
[thread-default main context][g-main-context-push-thread-default]
where the #GSimpleAsyncResult was created.
g_simple_async_result_run_in_thread() will run the job in a
separate thread and then use
g_simple_async_result_complete_in_idle() to deliver the result.

To set the results of an asynchronous function,
g_simple_async_result_set_op_res_gpointer(),
g_simple_async_result_set_op_res_gboolean(), and
g_simple_async_result_set_op_res_gssize()
are provided, setting the operation's result to a gpointer, gboolean, or
gssize, respectively.

Likewise, to get the result of an asynchronous function,
g_simple_async_result_get_op_res_gpointer(),
g_simple_async_result_get_op_res_gboolean(), and
g_simple_async_result_get_op_res_gssize() are
provided, getting the operation's result as a gpointer, gboolean, and
gssize, respectively.

For the details of the requirements implementations must respect, see
#GAsyncResult.  A typical implementation of an asynchronous operation
using GSimpleAsyncResult looks something like this:

|[&lt;!-- language="C" --&gt;
static void
baked_cb (Cake    *cake,
          gpointer user_data)
{
  // In this example, this callback is not given a reference to the cake,
  // so the GSimpleAsyncResult has to take a reference to it.
  GSimpleAsyncResult *result = user_data;

  if (cake == NULL)
    g_simple_async_result_set_error (result,
                                     BAKER_ERRORS,
                                     BAKER_ERROR_NO_FLOUR,
                                     "Go to the supermarket");
  else
    g_simple_async_result_set_op_res_gpointer (result,
                                               g_object_ref (cake),
                                               g_object_unref);


  // In this example, we assume that baked_cb is called as a callback from
  // the mainloop, so it's safe to complete the operation synchronously here.
  // If, however, _baker_prepare_cake () might call its callback without
  // first returning to the mainloop &#x2014; inadvisable, but some APIs do so &#x2014;
  // we would need to use g_simple_async_result_complete_in_idle().
  g_simple_async_result_complete (result);
  g_object_unref (result);
}

void
baker_bake_cake_async (Baker              *self,
                       guint               radius,
                       GAsyncReadyCallback callback,
                       gpointer            user_data)
{
  GSimpleAsyncResult *simple;
  Cake               *cake;

  if (radius &lt; 3)
    {
      g_simple_async_report_error_in_idle (G_OBJECT (self),
                                           callback,
                                           user_data,
                                           BAKER_ERRORS,
                                           BAKER_ERROR_TOO_SMALL,
                                           "%ucm radius cakes are silly",
                                           radius);
      return;
    }

  simple = g_simple_async_result_new (G_OBJECT (self),
                                      callback,
                                      user_data,
                                      baker_bake_cake_async);
  cake = _baker_get_cached_cake (self, radius);

  if (cake != NULL)
    {
      g_simple_async_result_set_op_res_gpointer (simple,
                                                 g_object_ref (cake),
                                                 g_object_unref);
      g_simple_async_result_complete_in_idle (simple);
      g_object_unref (simple);
      // Drop the reference returned by _baker_get_cached_cake();
      // the GSimpleAsyncResult has taken its own reference.
      g_object_unref (cake);
      return;
    }

  _baker_prepare_cake (self, radius, baked_cb, simple);
}

Cake *
baker_bake_cake_finish (Baker        *self,
                        GAsyncResult *result,
                        GError      **error)
{
  GSimpleAsyncResult *simple;
  Cake               *cake;

  g_return_val_if_fail (g_simple_async_result_is_valid (result,
                                                        G_OBJECT (self),
                                                        baker_bake_cake_async),
                        NULL);

  simple = (GSimpleAsyncResult *) result;

  if (g_simple_async_result_propagate_error (simple, error))
    return NULL;

  cake = CAKE (g_simple_async_result_get_op_res_gpointer (simple));
  return g_object_ref (cake);
}
]|</doc>
      <implements name="AsyncResult"/>
      <constructor name="new" c:identifier="g_simple_async_result_new" deprecated="1" deprecated-version="2.46">
        <doc xml:space="preserve">Creates a #GSimpleAsyncResult.

The common convention is to create the #GSimpleAsyncResult in the
function that starts the asynchronous operation and use that same
function as the @source_tag.

If your operation supports cancellation with #GCancellable (which it
probably should) then you should provide the user's cancellable to
g_simple_async_result_set_check_cancellable() immediately after
this function returns.</doc>
        <doc-deprecated xml:space="preserve">Use g_task_new() instead.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSimpleAsyncResult.</doc>
          <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
        </return-value>
        <parameters>
          <parameter name="source_object" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GObject, or %NULL.</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="source_tag" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the asynchronous function.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_error" c:identifier="g_simple_async_result_new_error" introspectable="0" deprecated="1" deprecated-version="2.46">
        <doc xml:space="preserve">Creates a new #GSimpleAsyncResult with a set error.</doc>
        <doc-deprecated xml:space="preserve">Use g_task_new() and g_task_return_new_error() instead.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSimpleAsyncResult.</doc>
          <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
        </return-value>
        <parameters>
          <parameter name="source_object" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GObject, or %NULL.</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #GQuark.</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:space="preserve">an error code.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">a string with format characters.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">a list of values to insert into @format.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_error" c:identifier="g_simple_async_result_new_from_error" deprecated="1" deprecated-version="2.46">
        <doc xml:space="preserve">Creates a #GSimpleAsyncResult from an error condition.</doc>
        <doc-deprecated xml:space="preserve">Use g_task_new() and g_task_return_error() instead.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSimpleAsyncResult.</doc>
          <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
        </return-value>
        <parameters>
          <parameter name="source_object" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GObject, or %NULL.</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">a #GError</doc>
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_take_error" c:identifier="g_simple_async_result_new_take_error" version="2.28" introspectable="0" deprecated="1" deprecated-version="2.46">
        <doc xml:space="preserve">Creates a #GSimpleAsyncResult from an error condition, and takes over the
caller's ownership of @error, so the caller does not need to free it anymore.</doc>
        <doc-deprecated xml:space="preserve">Use g_task_new() and g_task_return_error() instead.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSimpleAsyncResult</doc>
          <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
        </return-value>
        <parameters>
          <parameter name="source_object" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GObject, or %NULL</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">a #GError</doc>
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="is_valid" c:identifier="g_simple_async_result_is_valid" version="2.20" deprecated="1" deprecated-version="2.46">
        <doc xml:space="preserve">Ensures that the data passed to the _finish function of an async
operation is consistent.  Three checks are performed.

First, @result is checked to ensure that it is really a
#GSimpleAsyncResult.  Second, @source is checked to ensure that it
matches the source object of @result.  Third, @source_tag is
checked to ensure that it is equal to the @source_tag argument given
to g_simple_async_result_new() (which, by convention, is a pointer
to the _async function corresponding to the _finish function from
which this function is called).  (Alternatively, if either
@source_tag or @result's source tag is %NULL, then the source tag
check is skipped.)</doc>
        <doc-deprecated xml:space="preserve">Use #GTask and g_task_is_valid() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#TRUE if all checks passed or #FALSE if any failed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult passed to the _finish function.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="source" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the #GObject passed to the _finish function.</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="source_tag" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the asynchronous function.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <method name="complete" c:identifier="g_simple_async_result_complete" deprecated="1" deprecated-version="2.46">
        <doc xml:space="preserve">Completes an asynchronous I/O job immediately. Must be called in
the thread where the asynchronous result was to be delivered, as it
invokes the callback directly. If you are in a different thread use
g_simple_async_result_complete_in_idle().

Calling this function takes a reference to @simple for as long as
is needed to complete the call.</doc>
        <doc-deprecated xml:space="preserve">Use #GTask instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleAsyncResult.</doc>
            <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="complete_in_idle" c:identifier="g_simple_async_result_complete_in_idle" deprecated="1" deprecated-version="2.46">
        <doc xml:space="preserve">Completes an asynchronous function in an idle handler in the
[thread-default main context][g-main-context-push-thread-default]
of the thread that @simple was initially created in
(and re-pushes that context around the invocation of the callback).

Calling this function takes a reference to @simple for as long as
is needed to complete the call.</doc>
        <doc-deprecated xml:space="preserve">Use #GTask instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleAsyncResult.</doc>
            <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_op_res_gboolean" c:identifier="g_simple_async_result_get_op_res_gboolean" deprecated="1" deprecated-version="2.46">
        <doc xml:space="preserve">Gets the operation result boolean from within the asynchronous result.</doc>
        <doc-deprecated xml:space="preserve">Use #GTask and g_task_propagate_boolean() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation's result was %TRUE, %FALSE
    if the operation's result was %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleAsyncResult.</doc>
            <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_op_res_gpointer" c:identifier="g_simple_async_result_get_op_res_gpointer" introspectable="0" deprecated="1" deprecated-version="2.46">
        <doc xml:space="preserve">Gets a pointer result as returned by the asynchronous function.</doc>
        <doc-deprecated xml:space="preserve">Use #GTask and g_task_propagate_pointer() instead.</doc-deprecated>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a pointer from the result.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleAsyncResult.</doc>
            <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_op_res_gssize" c:identifier="g_simple_async_result_get_op_res_gssize" deprecated="1" deprecated-version="2.46">
        <doc xml:space="preserve">Gets a gssize from the asynchronous result.</doc>
        <doc-deprecated xml:space="preserve">Use #GTask and g_task_propagate_int() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a gssize returned from the asynchronous function.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleAsyncResult.</doc>
            <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_source_tag" c:identifier="g_simple_async_result_get_source_tag" introspectable="0" deprecated="1" deprecated-version="2.46.">
        <doc xml:space="preserve">Gets the source tag for the #GSimpleAsyncResult.</doc>
        <doc-deprecated xml:space="preserve">Use #GTask and g_task_get_source_tag() instead.</doc-deprecated>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #gpointer to the source object for the #GSimpleAsyncResult.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleAsyncResult.</doc>
            <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="propagate_error" c:identifier="g_simple_async_result_propagate_error" deprecated="1" deprecated-version="2.46" throws="1">
        <doc xml:space="preserve">Propagates an error from within the simple asynchronous result to
a given destination.

If the #GCancellable given to a prior call to
g_simple_async_result_set_check_cancellable() is cancelled then this
function will return %TRUE with @dest set appropriately.</doc>
        <doc-deprecated xml:space="preserve">Use #GTask instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the error was propagated to @dest. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleAsyncResult.</doc>
            <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="run_in_thread" c:identifier="g_simple_async_result_run_in_thread" introspectable="0" deprecated="1" deprecated-version="2.46">
        <doc xml:space="preserve">Runs the asynchronous job in a separate thread and then calls
g_simple_async_result_complete_in_idle() on @simple to return
the result to the appropriate main loop.

Calling this function takes a reference to @simple for as long as
is needed to run the job and report its completion.</doc>
        <doc-deprecated xml:space="preserve">Use #GTask and g_task_run_in_thread() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleAsyncResult.</doc>
            <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleAsyncThreadFunc.</doc>
            <type name="SimpleAsyncThreadFunc" c:type="GSimpleAsyncThreadFunc"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the io priority of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_check_cancellable" c:identifier="g_simple_async_result_set_check_cancellable" version="2.32" deprecated="1" deprecated-version="2.46">
        <doc xml:space="preserve">Sets a #GCancellable to check before dispatching results.

This function has one very specific purpose: the provided cancellable
is checked at the time of g_simple_async_result_propagate_error() If
it is cancelled, these functions will return an "Operation was
cancelled" error (%G_IO_ERROR_CANCELLED).

Implementors of cancellable asynchronous functions should use this in
order to provide a guarantee to their callers that cancelling an
async operation will reliably result in an error being returned for
that operation (even if a positive result for the operation has
already been sent as an idle to the main context to be dispatched).

The checking described above is done regardless of any call to the
unrelated g_simple_async_result_set_handle_cancellation() function.</doc>
        <doc-deprecated xml:space="preserve">Use #GTask instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleAsyncResult</doc>
            <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
          </instance-parameter>
          <parameter name="check_cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable to check, or %NULL to unset</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_error" c:identifier="g_simple_async_result_set_error" introspectable="0" deprecated="1" deprecated-version="2.46">
        <doc xml:space="preserve">Sets an error within the asynchronous result without a #GError.</doc>
        <doc-deprecated xml:space="preserve">Use #GTask and g_task_return_new_error() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleAsyncResult.</doc>
            <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
          </instance-parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #GQuark (usually #G_IO_ERROR).</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:space="preserve">an error code.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">a formatted error reporting string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">a list of variables to fill in @format.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="set_error_va" c:identifier="g_simple_async_result_set_error_va" introspectable="0" deprecated="1" deprecated-version="2.46">
        <doc xml:space="preserve">Sets an error within the asynchronous result without a #GError.
Unless writing a binding, see g_simple_async_result_set_error().</doc>
        <doc-deprecated xml:space="preserve">Use #GTask and g_task_return_error() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleAsyncResult.</doc>
            <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
          </instance-parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #GQuark (usually #G_IO_ERROR).</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:space="preserve">an error code.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">a formatted error reporting string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">va_list of arguments.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_from_error" c:identifier="g_simple_async_result_set_from_error" deprecated="1" deprecated-version="2.46">
        <doc xml:space="preserve">Sets the result from a #GError.</doc>
        <doc-deprecated xml:space="preserve">Use #GTask and g_task_return_error() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleAsyncResult.</doc>
            <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">#GError.</doc>
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_handle_cancellation" c:identifier="g_simple_async_result_set_handle_cancellation" deprecated="1" deprecated-version="2.46">
        <doc xml:space="preserve">Sets whether to handle cancellation within the asynchronous operation.

This function has nothing to do with
g_simple_async_result_set_check_cancellable().  It only refers to the
#GCancellable passed to g_simple_async_result_run_in_thread().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleAsyncResult.</doc>
            <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
          </instance-parameter>
          <parameter name="handle_cancellation" transfer-ownership="none">
            <doc xml:space="preserve">a #gboolean.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_op_res_gboolean" c:identifier="g_simple_async_result_set_op_res_gboolean" deprecated="1" deprecated-version="2.46">
        <doc xml:space="preserve">Sets the operation result to a boolean within the asynchronous result.</doc>
        <doc-deprecated xml:space="preserve">Use #GTask and g_task_return_boolean() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleAsyncResult.</doc>
            <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
          </instance-parameter>
          <parameter name="op_res" transfer-ownership="none">
            <doc xml:space="preserve">a #gboolean.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_op_res_gpointer" c:identifier="g_simple_async_result_set_op_res_gpointer" introspectable="0" deprecated="1" deprecated-version="2.46">
        <doc xml:space="preserve">Sets the operation result within the asynchronous result to a pointer.</doc>
        <doc-deprecated xml:space="preserve">Use #GTask and g_task_return_pointer() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleAsyncResult.</doc>
            <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
          </instance-parameter>
          <parameter name="op_res" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a pointer result from an asynchronous function.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy_op_res" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">a #GDestroyNotify function.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_op_res_gssize" c:identifier="g_simple_async_result_set_op_res_gssize" deprecated="1" deprecated-version="2.46">
        <doc xml:space="preserve">Sets the operation result within the asynchronous result to
the given @op_res.</doc>
        <doc-deprecated xml:space="preserve">Use #GTask and g_task_return_int() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleAsyncResult.</doc>
            <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
          </instance-parameter>
          <parameter name="op_res" transfer-ownership="none">
            <doc xml:space="preserve">a #gssize.</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_error" c:identifier="g_simple_async_result_take_error" version="2.28" introspectable="0" deprecated="1" deprecated-version="2.46">
        <doc xml:space="preserve">Sets the result from @error, and takes over the caller's ownership
of @error, so the caller does not need to free it any more.</doc>
        <doc-deprecated xml:space="preserve">Use #GTask and g_task_return_error() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleAsyncResult</doc>
            <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">a #GError</doc>
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="SimpleAsyncResultClass" c:type="GSimpleAsyncResultClass" disguised="1" glib:is-gtype-struct-for="SimpleAsyncResult">
    </record>
    <callback name="SimpleAsyncThreadFunc" c:type="GSimpleAsyncThreadFunc">
      <doc xml:space="preserve">Simple thread function that runs an asynchronous operation and
checks for cancellation.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="res" transfer-ownership="none">
          <doc xml:space="preserve">a #GSimpleAsyncResult.</doc>
          <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
        </parameter>
        <parameter name="object" transfer-ownership="none">
          <doc xml:space="preserve">a #GObject.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="SimpleIOStream" c:symbol-prefix="simple_io_stream" c:type="GSimpleIOStream" version="2.44" parent="IOStream" glib:type-name="GSimpleIOStream" glib:get-type="g_simple_io_stream_get_type">
      <doc xml:space="preserve">GSimpleIOStream creates a #GIOStream from an arbitrary #GInputStream and
#GOutputStream. This allows any pair of input and output streams to be used
with #GIOStream methods.

This is useful when you obtained a #GInputStream and a #GOutputStream
by other means, for instance creating them with platform specific methods as
g_unix_input_stream_new() or g_win32_input_stream_new(), and you want
to take advantage of the methods provided by #GIOStream.</doc>
      <constructor name="new" c:identifier="g_simple_io_stream_new" version="2.44">
        <doc xml:space="preserve">Creates a new #GSimpleIOStream wrapping @input_stream and @output_stream.
See also #GIOStream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSimpleIOStream instance.</doc>
          <type name="IOStream" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <parameter name="input_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </parameter>
          <parameter name="output_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="input-stream" version="2.44" writable="1" construct-only="1" transfer-ownership="none">
        <type name="InputStream"/>
      </property>
      <property name="output-stream" version="2.44" writable="1" construct-only="1" transfer-ownership="none">
        <type name="OutputStream"/>
      </property>
    </class>
    <class name="SimplePermission" c:symbol-prefix="simple_permission" c:type="GSimplePermission" parent="Permission" glib:type-name="GSimplePermission" glib:get-type="g_simple_permission_get_type">
      <doc xml:space="preserve">#GSimplePermission is a trivial implementation of #GPermission that
represents a permission that is either always or never allowed.  The
value is given at construction and doesn't change.

Calling request or release will result in errors.</doc>
      <constructor name="new" c:identifier="g_simple_permission_new" version="2.26">
        <doc xml:space="preserve">Creates a new #GPermission instance that represents an action that is
either always or never allowed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the #GSimplePermission, as a #GPermission</doc>
          <type name="Permission" c:type="GPermission*"/>
        </return-value>
        <parameters>
          <parameter name="allowed" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the action is allowed</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
    </class>
    <class name="SimpleProxyResolver" c:symbol-prefix="simple_proxy_resolver" c:type="GSimpleProxyResolver" parent="GObject.Object" glib:type-name="GSimpleProxyResolver" glib:get-type="g_simple_proxy_resolver_get_type" glib:type-struct="SimpleProxyResolverClass">
      <doc xml:space="preserve">#GSimpleProxyResolver is a simple #GProxyResolver implementation
that handles a single default proxy, multiple URI-scheme-specific
proxies, and a list of hosts that proxies should not be used for.

#GSimpleProxyResolver is never the default proxy resolver, but it
can be used as the base class for another proxy resolver
implementation, or it can be created and used manually, such as
with g_socket_client_set_proxy_resolver().</doc>
      <implements name="ProxyResolver"/>
      <function name="new" c:identifier="g_simple_proxy_resolver_new" version="2.36">
        <doc xml:space="preserve">Creates a new #GSimpleProxyResolver. See
#GSimpleProxyResolver:default-proxy and
#GSimpleProxyResolver:ignore-hosts for more details on how the
arguments are interpreted.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSimpleProxyResolver</doc>
          <type name="ProxyResolver" c:type="GProxyResolver*"/>
        </return-value>
        <parameters>
          <parameter name="default_proxy" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the default proxy to use, eg
    "socks://192.168.1.1"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="ignore_hosts" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an optional list of hosts/IP addresses
    to not use a proxy for.</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </function>
      <method name="set_default_proxy" c:identifier="g_simple_proxy_resolver_set_default_proxy" version="2.36">
        <doc xml:space="preserve">Sets the default proxy on @resolver, to be used for any URIs that
don't match #GSimpleProxyResolver:ignore-hosts or a proxy set
via g_simple_proxy_resolver_set_uri_proxy().

If @default_proxy starts with "socks://",
#GSimpleProxyResolver will treat it as referring to all three of
the socks5, socks4a, and socks4 proxy types.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleProxyResolver</doc>
            <type name="SimpleProxyResolver" c:type="GSimpleProxyResolver*"/>
          </instance-parameter>
          <parameter name="default_proxy" transfer-ownership="none">
            <doc xml:space="preserve">the default proxy to use</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ignore_hosts" c:identifier="g_simple_proxy_resolver_set_ignore_hosts" version="2.36">
        <doc xml:space="preserve">Sets the list of ignored hosts.

See #GSimpleProxyResolver:ignore-hosts for more details on how the
@ignore_hosts argument is interpreted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleProxyResolver</doc>
            <type name="SimpleProxyResolver" c:type="GSimpleProxyResolver*"/>
          </instance-parameter>
          <parameter name="ignore_hosts" transfer-ownership="none">
            <doc xml:space="preserve">%NULL-terminated list of hosts/IP addresses
    to not use a proxy for</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uri_proxy" c:identifier="g_simple_proxy_resolver_set_uri_proxy" version="2.36">
        <doc xml:space="preserve">Adds a URI-scheme-specific proxy to @resolver; URIs whose scheme
matches @uri_scheme (and which don't match
#GSimpleProxyResolver:ignore-hosts) will be proxied via @proxy.

As with #GSimpleProxyResolver:default-proxy, if @proxy starts with
"socks://", #GSimpleProxyResolver will treat it
as referring to all three of the socks5, socks4a, and socks4 proxy
types.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GSimpleProxyResolver</doc>
            <type name="SimpleProxyResolver" c:type="GSimpleProxyResolver*"/>
          </instance-parameter>
          <parameter name="uri_scheme" transfer-ownership="none">
            <doc xml:space="preserve">the URI scheme to add a proxy for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">the proxy to use for @uri_scheme</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="default-proxy" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The default proxy URI that will be used for any URI that doesn't
match #GSimpleProxyResolver:ignore-hosts, and doesn't match any
of the schemes set with g_simple_proxy_resolver_set_uri_proxy().

Note that as a special case, if this URI starts with
"socks://", #GSimpleProxyResolver will treat it as referring
to all three of the socks5, socks4a, and socks4 proxy types.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="ignore-hosts" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">A list of hostnames and IP addresses that the resolver should
allow direct connections to.

Entries can be in one of 4 formats:

- A hostname, such as "example.com", ".example.com", or
  "*.example.com", any of which match "example.com" or
  any subdomain of it.

- An IPv4 or IPv6 address, such as "192.168.1.1",
  which matches only that address.

- A hostname or IP address followed by a port, such as
  "example.com:80", which matches whatever the hostname or IP
  address would match, but only for URLs with the (explicitly)
  indicated port. In the case of an IPv6 address, the address
  part must appear in brackets: "[::1]:443"

- An IP address range, given by a base address and prefix length,
  such as "fe80::/10", which matches any address in that range.

Note that when dealing with Unicode hostnames, the matching is
done against the ASCII form of the name.

Also note that hostname exclusions apply only to connections made
to hosts identified by name, and IP address exclusions apply only
to connections made to hosts identified by address. That is, if
example.com has an address of 192.168.1.1, and the :ignore-hosts list
contains only "192.168.1.1", then a connection to "example.com"
(eg, via a #GNetworkAddress) will use the proxy, and a connection to
"192.168.1.1" (eg, via a #GInetSocketAddress) will not.

These rules match the "ignore-hosts"/"noproxy" rules most
commonly used by other applications.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SimpleProxyResolverPrivate" c:type="GSimpleProxyResolverPrivate*"/>
      </field>
    </class>
    <record name="SimpleProxyResolverClass" c:type="GSimpleProxyResolverClass" glib:is-gtype-struct-for="SimpleProxyResolver">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="SimpleProxyResolverPrivate" c:type="GSimpleProxyResolverPrivate" disguised="1">
    </record>
    <class name="Socket" c:symbol-prefix="socket" c:type="GSocket" version="2.22" parent="GObject.Object" glib:type-name="GSocket" glib:get-type="g_socket_get_type" glib:type-struct="SocketClass">
      <doc xml:space="preserve">A #GSocket is a low-level networking primitive. It is a more or less
direct mapping of the BSD socket API in a portable GObject based API.
It supports both the UNIX socket implementations and winsock2 on Windows.

#GSocket is the platform independent base upon which the higher level
network primitives are based. Applications are not typically meant to
use it directly, but rather through classes like #GSocketClient,
#GSocketService and #GSocketConnection. However there may be cases where
direct use of #GSocket is useful.

#GSocket implements the #GInitable interface, so if it is manually constructed
by e.g. g_object_new() you must call g_initable_init() and check the
results before using the object. This is done automatically in
g_socket_new() and g_socket_new_from_fd(), so these functions can return
%NULL.

Sockets operate in two general modes, blocking or non-blocking. When
in blocking mode all operations (which don&#x2019;t take an explicit blocking
parameter) block until the requested operation
is finished or there is an error. In non-blocking mode all calls that
would block return immediately with a %G_IO_ERROR_WOULD_BLOCK error.
To know when a call would successfully run you can call g_socket_condition_check(),
or g_socket_condition_wait(). You can also use g_socket_create_source() and
attach it to a #GMainContext to get callbacks when I/O is possible.
Note that all sockets are always set to non blocking mode in the system, and
blocking mode is emulated in GSocket.

When working in non-blocking mode applications should always be able to
handle getting a %G_IO_ERROR_WOULD_BLOCK error even when some other
function said that I/O was possible. This can easily happen in case
of a race condition in the application, but it can also happen for other
reasons. For instance, on Windows a socket is always seen as writable
until a write returns %G_IO_ERROR_WOULD_BLOCK.

#GSockets can be either connection oriented or datagram based.
For connection oriented types you must first establish a connection by
either connecting to an address or accepting a connection from another
address. For connectionless socket types the target/source address is
specified or received in each I/O operation.

All socket file descriptors are set to be close-on-exec.

Note that creating a #GSocket causes the signal %SIGPIPE to be
ignored for the remainder of the program. If you are writing a
command-line utility that uses #GSocket, you may need to take into
account the fact that your program will not automatically be killed
if it tries to write to %stdout after it has been closed.

Like most other APIs in GLib, #GSocket is not inherently thread safe. To use
a #GSocket concurrently from multiple threads, you must implement your own
locking.</doc>
      <implements name="DatagramBased"/>
      <implements name="Initable"/>
      <constructor name="new" c:identifier="g_socket_new" version="2.22" throws="1">
        <doc xml:space="preserve">Creates a new #GSocket with the defined family, type and protocol.
If @protocol is 0 (%G_SOCKET_PROTOCOL_DEFAULT) the default protocol type
for the family and type is used.

The @protocol is a family and type specific int that specifies what
kind of protocol to use. #GSocketProtocol lists several common ones.
Many families only support one protocol, and use 0 for this, others
support several and using 0 means to use the default protocol for
the family and type.

The protocol id is passed directly to the operating
system, so you can use protocols not listed in #GSocketProtocol if you
know the protocol number used for it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSocket or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="Socket" c:type="GSocket*"/>
        </return-value>
        <parameters>
          <parameter name="family" transfer-ownership="none">
            <doc xml:space="preserve">the socket family to use, e.g. %G_SOCKET_FAMILY_IPV4.</doc>
            <type name="SocketFamily" c:type="GSocketFamily"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the socket type to use.</doc>
            <type name="SocketType" c:type="GSocketType"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:space="preserve">the id of the protocol to use, or 0 for default.</doc>
            <type name="SocketProtocol" c:type="GSocketProtocol"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_fd" c:identifier="g_socket_new_from_fd" version="2.22" throws="1">
        <doc xml:space="preserve">Creates a new #GSocket from a native file descriptor
or winsock SOCKET handle.

This reads all the settings from the file descriptor so that
all properties should work. Note that the file descriptor
will be set to non-blocking mode, independent on the blocking
mode of the #GSocket.

On success, the returned #GSocket takes ownership of @fd. On failure, the
caller must close @fd themselves.

Since GLib 2.46, it is no longer a fatal error to call this on a non-socket
descriptor.  Instead, a GError will be set with code %G_IO_ERROR_FAILED</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSocket or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="Socket" c:type="GSocket*"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:space="preserve">a native socket file descriptor.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="accept" c:identifier="g_socket_accept" version="2.22" throws="1">
        <doc xml:space="preserve">Accept incoming connections on a connection-based socket. This removes
the first outstanding connection request from the listening socket and
creates a #GSocket object for it.

The @socket must be bound to a local address with g_socket_bind() and
must be listening for incoming connections (g_socket_listen()).

If there are no outstanding connections then the operation will block
or return %G_IO_ERROR_WOULD_BLOCK if non-blocking I/O is enabled.
To be notified of an incoming connection, wait for the %G_IO_IN condition.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSocket, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="Socket" c:type="GSocket*"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind" c:identifier="g_socket_bind" version="2.22" throws="1">
        <doc xml:space="preserve">When a socket is created it is attached to an address family, but it
doesn't have an address in this family. g_socket_bind() assigns the
address (sometimes called name) of the socket.

It is generally required to bind to a local address before you can
receive connections. (See g_socket_listen() and g_socket_accept() ).
In certain situations, you may also want to bind a socket that will be
used to initiate connections, though this is not normally required.

If @socket is a TCP socket, then @allow_reuse controls the setting
of the `SO_REUSEADDR` socket option; normally it should be %TRUE for
server sockets (sockets that you will eventually call
g_socket_accept() on), and %FALSE for client sockets. (Failing to
set this flag on a server socket may cause g_socket_bind() to return
%G_IO_ERROR_ADDRESS_IN_USE if the server program is stopped and then
immediately restarted.)

If @socket is a UDP socket, then @allow_reuse determines whether or
not other UDP sockets can be bound to the same address at the same
time. In particular, you can have several UDP sockets bound to the
same address, and they will all receive all of the multicast and
broadcast packets sent to that address. (The behavior of unicast
UDP packets to an address with multiple listeners is not defined.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketAddress specifying the local address.</doc>
            <type name="SocketAddress" c:type="GSocketAddress*"/>
          </parameter>
          <parameter name="allow_reuse" transfer-ownership="none">
            <doc xml:space="preserve">whether to allow reusing this address</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="check_connect_result" c:identifier="g_socket_check_connect_result" version="2.22" throws="1">
        <doc xml:space="preserve">Checks and resets the pending connect error for the socket.
This is used to check for errors when g_socket_connect() is
used in non-blocking mode.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if no error, %FALSE otherwise, setting @error to the error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="close" c:identifier="g_socket_close" version="2.22" throws="1">
        <doc xml:space="preserve">Closes the socket, shutting down any active connection.

Closing a socket does not wait for all outstanding I/O operations
to finish, so the caller should not rely on them to be guaranteed
to complete even if the close returns with no error.

Once the socket is closed, all other operations will return
%G_IO_ERROR_CLOSED. Closing a socket multiple times will not
return an error.

Sockets will be automatically closed when the last reference
is dropped, but you might want to call this function to make sure
resources are released as early as possible.

Beware that due to the way that TCP works, it is possible for
recently-sent data to be lost if either you close a socket while the
%G_IO_IN condition is set, or else if the remote connection tries to
send something to you after you close the socket but before it has
finished reading all of the data you sent. There is no easy generic
way to avoid this problem; the easiest fix is to design the network
protocol such that the client will never send data "out of turn".
Another solution is for the server to half-close the connection by
calling g_socket_shutdown() with only the @shutdown_write flag set,
and then wait for the client to notice this and close its side of the
connection, after which the server can safely call g_socket_close().
(This is what #GTcpConnection does if you call
g_tcp_connection_set_graceful_disconnect(). But of course, this
only works if the client will close its connection after the server
does.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="condition_check" c:identifier="g_socket_condition_check" version="2.22">
        <doc xml:space="preserve">Checks on the readiness of @socket to perform operations.
The operations specified in @condition are checked for and masked
against the currently-satisfied conditions on @socket. The result
is returned.

Note that on Windows, it is possible for an operation to return
%G_IO_ERROR_WOULD_BLOCK even immediately after
g_socket_condition_check() has claimed that the socket is ready for
writing. Rather than calling g_socket_condition_check() and then
writing to the socket if it succeeds, it is generally better to
simply try writing to the socket right away, and try again later if
the initial attempt returns %G_IO_ERROR_WOULD_BLOCK.

It is meaningless to specify %G_IO_ERR or %G_IO_HUP in condition;
these conditions will always be set in the output if they are true.

This call never blocks.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the @GIOCondition mask of the current state</doc>
          <type name="GLib.IOCondition" c:type="GIOCondition"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="condition" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOCondition mask to check</doc>
            <type name="GLib.IOCondition" c:type="GIOCondition"/>
          </parameter>
        </parameters>
      </method>
      <method name="condition_timed_wait" c:identifier="g_socket_condition_timed_wait" version="2.32" throws="1">
        <doc xml:space="preserve">Waits for up to @timeout microseconds for @condition to become true
on @socket. If the condition is met, %TRUE is returned.

If @cancellable is cancelled before the condition is met, or if
@timeout (or the socket's #GSocket:timeout) is reached before the
condition is met, then %FALSE is returned and @error, if non-%NULL,
is set to the appropriate value (%G_IO_ERROR_CANCELLED or
%G_IO_ERROR_TIMED_OUT).

If you don't want a timeout, use g_socket_condition_wait().
(Alternatively, you can pass -1 for @timeout.)

Note that although @timeout is in microseconds for consistency with
other GLib APIs, this function actually only has millisecond
resolution, and the behavior is undefined if @timeout is not an
exact number of milliseconds.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the condition was met, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="condition" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOCondition mask to wait for</doc>
            <type name="GLib.IOCondition" c:type="GIOCondition"/>
          </parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:space="preserve">the maximum time (in microseconds) to wait, or -1</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="condition_wait" c:identifier="g_socket_condition_wait" version="2.22" throws="1">
        <doc xml:space="preserve">Waits for @condition to become true on @socket. When the condition
is met, %TRUE is returned.

If @cancellable is cancelled before the condition is met, or if the
socket has a timeout set and it is reached before the condition is
met, then %FALSE is returned and @error, if non-%NULL, is set to
the appropriate value (%G_IO_ERROR_CANCELLED or
%G_IO_ERROR_TIMED_OUT).

See also g_socket_condition_timed_wait().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the condition was met, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="condition" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOCondition mask to wait for</doc>
            <type name="GLib.IOCondition" c:type="GIOCondition"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect" c:identifier="g_socket_connect" version="2.22" throws="1">
        <doc xml:space="preserve">Connect the socket to the specified remote address.

For connection oriented socket this generally means we attempt to make
a connection to the @address. For a connection-less socket it sets
the default address for g_socket_send() and discards all incoming datagrams
from other sources.

Generally connection oriented sockets can only connect once, but
connection-less sockets can connect multiple times to change the
default address.

If the connect call needs to do network I/O it will block, unless
non-blocking I/O is enabled. Then %G_IO_ERROR_PENDING is returned
and the user can be notified of the connection finishing by waiting
for the G_IO_OUT condition. The result of the connection must then be
checked with g_socket_check_connect_result().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if connected, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketAddress specifying the remote address.</doc>
            <type name="SocketAddress" c:type="GSocketAddress*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connection_factory_create_connection" c:identifier="g_socket_connection_factory_create_connection" version="2.22">
        <doc xml:space="preserve">Creates a #GSocketConnection subclass of the right type for
@socket.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSocketConnection</doc>
          <type name="SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="create_source" c:identifier="g_socket_create_source" version="2.22" introspectable="0">
        <doc xml:space="preserve">Creates a #GSource that can be attached to a %GMainContext to monitor
for the availability of the specified @condition on the socket. The #GSource
keeps a reference to the @socket.

The callback on the source is of the #GSocketSourceFunc type.

It is meaningless to specify %G_IO_ERR or %G_IO_HUP in @condition;
these conditions will always be reported output if they are true.

@cancellable if not %NULL can be used to cancel the source, which will
cause the source to trigger, reporting the current condition (which
is likely 0 unless cancellation happened at the same time as a
condition change). You can check for this in the callback using
g_cancellable_is_cancelled().

If @socket has a timeout set, and it is reached before @condition
occurs, the source will then trigger anyway, reporting %G_IO_IN or
%G_IO_OUT depending on @condition. However, @socket will have been
marked as having had a timeout, and so the next #GSocket I/O method
you call will then fail with a %G_IO_ERROR_TIMED_OUT.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated %GSource, free with g_source_unref().</doc>
          <type name="GLib.Source" c:type="GSource*"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="condition" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOCondition mask to monitor</doc>
            <type name="GLib.IOCondition" c:type="GIOCondition"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_available_bytes" c:identifier="g_socket_get_available_bytes" version="2.32">
        <doc xml:space="preserve">Get the amount of data pending in the OS input buffer, without blocking.

If @socket is a UDP or SCTP socket, this will return the size of
just the next packet, even if additional packets are buffered after
that one.

Note that on Windows, this function is rather inefficient in the
UDP case, and so if you know any plausible upper bound on the size
of the incoming packet, it is better to just do a
g_socket_receive() with a buffer of that size, rather than calling
g_socket_get_available_bytes() first and then doing a receive of
exactly the right size.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes that can be read from the socket
without blocking or truncating, or -1 on error.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_blocking" c:identifier="g_socket_get_blocking" version="2.22">
        <doc xml:space="preserve">Gets the blocking mode of the socket. For details on blocking I/O,
see g_socket_set_blocking().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if blocking I/O is used, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_broadcast" c:identifier="g_socket_get_broadcast" version="2.32">
        <doc xml:space="preserve">Gets the broadcast setting on @socket; if %TRUE,
it is possible to send packets to broadcast
addresses.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the broadcast setting on @socket</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_credentials" c:identifier="g_socket_get_credentials" version="2.26" throws="1">
        <doc xml:space="preserve">Returns the credentials of the foreign process connected to this
socket, if any (e.g. it is only supported for %G_SOCKET_FAMILY_UNIX
sockets).

If this operation isn't supported on the OS, the method fails with
the %G_IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented
by reading the %SO_PEERCRED option on the underlying socket.

Other ways to obtain credentials from a foreign peer includes the
#GUnixCredentialsMessage type and
g_unix_connection_send_credentials() /
g_unix_connection_receive_credentials() functions.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">%NULL if @error is set, otherwise a #GCredentials object
that must be freed with g_object_unref().</doc>
          <type name="Credentials" c:type="GCredentials*"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_family" c:identifier="g_socket_get_family" version="2.22">
        <doc xml:space="preserve">Gets the socket family of the socket.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GSocketFamily</doc>
          <type name="SocketFamily" c:type="GSocketFamily"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_fd" c:identifier="g_socket_get_fd" version="2.22">
        <doc xml:space="preserve">Returns the underlying OS socket object. On unix this
is a socket file descriptor, and on Windows this is
a Winsock2 SOCKET handle. This may be useful for
doing platform specific or otherwise unusual operations
on the socket.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the file descriptor of the socket.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_keepalive" c:identifier="g_socket_get_keepalive" version="2.22">
        <doc xml:space="preserve">Gets the keepalive mode of the socket. For details on this,
see g_socket_set_keepalive().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if keepalive is active, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_listen_backlog" c:identifier="g_socket_get_listen_backlog" version="2.22">
        <doc xml:space="preserve">Gets the listen backlog setting of the socket. For details on this,
see g_socket_set_listen_backlog().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the maximum number of pending connections.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_local_address" c:identifier="g_socket_get_local_address" version="2.22" throws="1">
        <doc xml:space="preserve">Try to get the local address of a bound socket. This is only
useful if the socket has been bound to a local address,
either explicitly or implicitly when connecting.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSocketAddress or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_multicast_loopback" c:identifier="g_socket_get_multicast_loopback" version="2.32">
        <doc xml:space="preserve">Gets the multicast loopback setting on @socket; if %TRUE (the
default), outgoing multicast packets will be looped back to
multicast listeners on the same host.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the multicast loopback setting on @socket</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_multicast_ttl" c:identifier="g_socket_get_multicast_ttl" version="2.32">
        <doc xml:space="preserve">Gets the multicast time-to-live setting on @socket; see
g_socket_set_multicast_ttl() for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the multicast time-to-live setting on @socket</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_option" c:identifier="g_socket_get_option" version="2.36" throws="1">
        <doc xml:space="preserve">Gets the value of an integer-valued option on @socket, as with
getsockopt(). (If you need to fetch a  non-integer-valued option,
you will need to call getsockopt() directly.)

The [&lt;gio/gnetworking.h&gt;][gio-gnetworking.h]
header pulls in system headers that will define most of the
standard/portable socket options. For unusual socket protocols or
platform-dependent options, you may need to include additional
headers.

Note that even for socket options that are a single byte in size,
@value is still a pointer to a #gint variable, not a #guchar;
g_socket_get_option() will handle the conversion internally.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">success or failure. On failure, @error will be set, and
  the system error value (`errno` or WSAGetLastError()) will still
  be set to the result of the getsockopt() call.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve">the "API level" of the option (eg, `SOL_SOCKET`)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="optname" transfer-ownership="none">
            <doc xml:space="preserve">the "name" of the option (eg, `SO_BROADCAST`)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="value" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the option value</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_protocol" c:identifier="g_socket_get_protocol" version="2.22">
        <doc xml:space="preserve">Gets the socket protocol id the socket was created with.
In case the protocol is unknown, -1 is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a protocol id, or -1 if unknown</doc>
          <type name="SocketProtocol" c:type="GSocketProtocol"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_remote_address" c:identifier="g_socket_get_remote_address" version="2.22" throws="1">
        <doc xml:space="preserve">Try to get the remote address of a connected socket. This is only
useful for connection oriented sockets that have been connected.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSocketAddress or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_socket_type" c:identifier="g_socket_get_socket_type" version="2.22">
        <doc xml:space="preserve">Gets the socket type of the socket.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GSocketType</doc>
          <type name="SocketType" c:type="GSocketType"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_timeout" c:identifier="g_socket_get_timeout" version="2.26">
        <doc xml:space="preserve">Gets the timeout setting of the socket. For details on this, see
g_socket_set_timeout().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the timeout in seconds</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ttl" c:identifier="g_socket_get_ttl" version="2.32">
        <doc xml:space="preserve">Gets the unicast time-to-live setting on @socket; see
g_socket_set_ttl() for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the time-to-live setting on @socket</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_closed" c:identifier="g_socket_is_closed" version="2.22">
        <doc xml:space="preserve">Checks whether a socket is closed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if socket is closed, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_connected" c:identifier="g_socket_is_connected" version="2.22">
        <doc xml:space="preserve">Check whether the socket is connected. This is only useful for
connection-oriented sockets.

If using g_socket_shutdown(), this function will return %TRUE until the
socket has been shut down for reading and writing. If you do a non-blocking
connect, this function will not return %TRUE until after you call
g_socket_check_connect_result().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if socket is connected, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="join_multicast_group" c:identifier="g_socket_join_multicast_group" version="2.32" throws="1">
        <doc xml:space="preserve">Registers @socket to receive multicast messages sent to @group.
@socket must be a %G_SOCKET_TYPE_DATAGRAM socket, and must have
been bound to an appropriate interface and port with
g_socket_bind().

If @iface is %NULL, the system will automatically pick an interface
to bind to based on @group.

If @source_specific is %TRUE, source-specific multicast as defined
in RFC 4604 is used. Note that on older platforms this may fail
with a %G_IO_ERROR_NOT_SUPPORTED error.

To bind to a given source-specific multicast address, use
g_socket_join_multicast_group_ssm() instead.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddress specifying the group address to join.</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </parameter>
          <parameter name="source_specific" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if source-specific multicast should be used</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="iface" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Name of the interface to use, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="join_multicast_group_ssm" c:identifier="g_socket_join_multicast_group_ssm" version="2.56" throws="1">
        <doc xml:space="preserve">Registers @socket to receive multicast messages sent to @group.
@socket must be a %G_SOCKET_TYPE_DATAGRAM socket, and must have
been bound to an appropriate interface and port with
g_socket_bind().

If @iface is %NULL, the system will automatically pick an interface
to bind to based on @group.

If @source_specific is not %NULL, use source-specific multicast as
defined in RFC 4604. Note that on older platforms this may fail
with a %G_IO_ERROR_NOT_SUPPORTED error.

Note that this function can be called multiple times for the same
@group with different @source_specific in order to receive multicast
packets from more than one source.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddress specifying the group address to join.</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </parameter>
          <parameter name="source_specific" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GInetAddress specifying the
source-specific multicast address or %NULL to ignore.</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </parameter>
          <parameter name="iface" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Name of the interface to use, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="leave_multicast_group" c:identifier="g_socket_leave_multicast_group" version="2.32" throws="1">
        <doc xml:space="preserve">Removes @socket from the multicast group defined by @group, @iface,
and @source_specific (which must all have the same values they had
when you joined the group).

@socket remains bound to its address and port, and can still receive
unicast messages after calling this.

To unbind to a given source-specific multicast address, use
g_socket_leave_multicast_group_ssm() instead.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddress specifying the group address to leave.</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </parameter>
          <parameter name="source_specific" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if source-specific multicast was used</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="iface" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Interface used</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="leave_multicast_group_ssm" c:identifier="g_socket_leave_multicast_group_ssm" version="2.56" throws="1">
        <doc xml:space="preserve">Removes @socket from the multicast group defined by @group, @iface,
and @source_specific (which must all have the same values they had
when you joined the group).

@socket remains bound to its address and port, and can still receive
unicast messages after calling this.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetAddress specifying the group address to leave.</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </parameter>
          <parameter name="source_specific" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GInetAddress specifying the
source-specific multicast address or %NULL to ignore.</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </parameter>
          <parameter name="iface" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Name of the interface to use, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="listen" c:identifier="g_socket_listen" version="2.22" throws="1">
        <doc xml:space="preserve">Marks the socket as a server socket, i.e. a socket that is used
to accept incoming requests using g_socket_accept().

Before calling this the socket must be bound to a local address using
g_socket_bind().

To set the maximum amount of outstanding clients, use
g_socket_set_listen_backlog().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="receive" c:identifier="g_socket_receive" version="2.22" throws="1">
        <doc xml:space="preserve">Receive data (up to @size bytes) from a socket. This is mainly used by
connection-oriented sockets; it is identical to g_socket_receive_from()
with @address set to %NULL.

For %G_SOCKET_TYPE_DATAGRAM and %G_SOCKET_TYPE_SEQPACKET sockets,
g_socket_receive() will always read either 0 or 1 complete messages from
the socket. If the received message is too large to fit in @buffer, then
the data beyond @size bytes will be discarded, without any explicit
indication that this has occurred.

For %G_SOCKET_TYPE_STREAM sockets, g_socket_receive() can return any
number of bytes, up to @size. If more than @size bytes have been
received, the additional data will be returned in future calls to
g_socket_receive().

If the socket is in blocking mode the call will block until there
is some data to receive, the connection is closed, or there is an
error. If there is no data available and the socket is in
non-blocking mode, a %G_IO_ERROR_WOULD_BLOCK error will be
returned. To be notified when data is available, wait for the
%G_IO_IN condition.

On error -1 is returned and @error is set accordingly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Number of bytes read, or 0 if the connection was closed by
the peer, or -1 on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a buffer to
    read data into (which should be at least @size bytes long).</doc>
            <array length="1" zero-terminated="0" c:type="gchar*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes you want to read from the socket</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="receive_from" c:identifier="g_socket_receive_from" version="2.22" throws="1">
        <doc xml:space="preserve">Receive data (up to @size bytes) from a socket.

If @address is non-%NULL then @address will be set equal to the
source address of the received packet.
@address is owned by the caller.

See g_socket_receive() for additional information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Number of bytes read, or 0 if the connection was closed by
the peer, or -1 on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="address" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a pointer to a #GSocketAddress
    pointer, or %NULL</doc>
            <type name="SocketAddress" c:type="GSocketAddress**"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a buffer to
    read data into (which should be at least @size bytes long).</doc>
            <array length="2" zero-terminated="0" c:type="gchar*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes you want to read from the socket</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="receive_message" c:identifier="g_socket_receive_message" version="2.22" throws="1">
        <doc xml:space="preserve">Receive data from a socket.  For receiving multiple messages, see
g_socket_receive_messages(); for easier use, see
g_socket_receive() and g_socket_receive_from().

If @address is non-%NULL then @address will be set equal to the
source address of the received packet.
@address is owned by the caller.

@vector must point to an array of #GInputVector structs and
@num_vectors must be the length of this array.  These structs
describe the buffers that received data will be scattered into.
If @num_vectors is -1, then @vectors is assumed to be terminated
by a #GInputVector with a %NULL buffer pointer.

As a special case, if @num_vectors is 0 (in which case, @vectors
may of course be %NULL), then a single byte is received and
discarded. This is to facilitate the common practice of sending a
single '\0' byte for the purposes of transferring ancillary data.

@messages, if non-%NULL, will be set to point to a newly-allocated
array of #GSocketControlMessage instances or %NULL if no such
messages was received. These correspond to the control messages
received from the kernel, one #GSocketControlMessage per message
from the kernel. This array is %NULL-terminated and must be freed
by the caller using g_free() after calling g_object_unref() on each
element. If @messages is %NULL, any control messages received will
be discarded.

@num_messages, if non-%NULL, will be set to the number of control
messages received.

If both @messages and @num_messages are non-%NULL, then
@num_messages gives the number of #GSocketControlMessage instances
in @messages (ie: not including the %NULL terminator).

@flags is an in/out parameter. The commonly available arguments
for this are available in the #GSocketMsgFlags enum, but the
values there are the same as the system values, and the flags
are passed in as-is, so you can pass in system-specific flags too
(and g_socket_receive_message() may pass system-specific flags out).
Flags passed in to the parameter affect the receive operation; flags returned
out of it are relevant to the specific returned message.

As with g_socket_receive(), data may be discarded if @socket is
%G_SOCKET_TYPE_DATAGRAM or %G_SOCKET_TYPE_SEQPACKET and you do not
provide enough buffer space to read a complete message. You can pass
%G_SOCKET_MSG_PEEK in @flags to peek at the current message without
removing it from the receive queue, but there is no portable way to find
out the length of the message other than by reading it into a
sufficiently-large buffer.

If the socket is in blocking mode the call will block until there
is some data to receive, the connection is closed, or there is an
error. If there is no data available and the socket is in
non-blocking mode, a %G_IO_ERROR_WOULD_BLOCK error will be
returned. To be notified when data is available, wait for the
%G_IO_IN condition.

On error -1 is returned and @error is set accordingly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Number of bytes read, or 0 if the connection was closed by
the peer, or -1 on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="address" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a pointer to a #GSocketAddress
    pointer, or %NULL</doc>
            <type name="SocketAddress" c:type="GSocketAddress**"/>
          </parameter>
          <parameter name="vectors" transfer-ownership="none">
            <doc xml:space="preserve">an array of #GInputVector structs</doc>
            <array length="2" zero-terminated="0" c:type="GInputVector*">
              <type name="InputVector" c:type="GInputVector"/>
            </array>
          </parameter>
          <parameter name="num_vectors" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements in @vectors, or -1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="messages" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">a pointer
   which may be filled with an array of #GSocketControlMessages, or %NULL</doc>
            <array length="4" zero-terminated="0" c:type="GSocketControlMessage***">
              <type name="SocketControlMessage" c:type="GSocketControlMessage**"/>
            </array>
          </parameter>
          <parameter name="num_messages" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">a pointer which will be filled with the number of
   elements in @messages, or %NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="flags" direction="inout" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">a pointer to an int containing #GSocketMsgFlags flags</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="receive_messages" c:identifier="g_socket_receive_messages" version="2.48" throws="1">
        <doc xml:space="preserve">Receive multiple data messages from @socket in one go.  This is the most
complicated and fully-featured version of this call. For easier use, see
g_socket_receive(), g_socket_receive_from(), and g_socket_receive_message().

@messages must point to an array of #GInputMessage structs and
@num_messages must be the length of this array. Each #GInputMessage
contains a pointer to an array of #GInputVector structs describing the
buffers that the data received in each message will be written to. Using
multiple #GInputVectors is more memory-efficient than manually copying data
out of a single buffer to multiple sources, and more system-call-efficient
than making multiple calls to g_socket_receive(), such as in scenarios where
a lot of data packets need to be received (e.g. high-bandwidth video
streaming over RTP/UDP).

@flags modify how all messages are received. The commonly available
arguments for this are available in the #GSocketMsgFlags enum, but the
values there are the same as the system values, and the flags
are passed in as-is, so you can pass in system-specific flags too. These
flags affect the overall receive operation. Flags affecting individual
messages are returned in #GInputMessage.flags.

The other members of #GInputMessage are treated as described in its
documentation.

If #GSocket:blocking is %TRUE the call will block until @num_messages have
been received, or the end of the stream is reached.

If #GSocket:blocking is %FALSE the call will return up to @num_messages
without blocking, or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the
operating system to be received.

In blocking mode, if #GSocket:timeout is positive and is reached before any
messages are received, %G_IO_ERROR_TIMED_OUT is returned, otherwise up to
@num_messages are returned. (Note: This is effectively the
behaviour of `MSG_WAITFORONE` with recvmmsg().)

To be notified when messages are available, wait for the
%G_IO_IN condition. Note though that you may still receive
%G_IO_ERROR_WOULD_BLOCK from g_socket_receive_messages() even if you were
previously notified of a %G_IO_IN condition.

If the remote peer closes the connection, any messages queued in the
operating system will be returned, and subsequent calls to
g_socket_receive_messages() will return 0 (with no error set).

On error -1 is returned and @error is set accordingly. An error will only
be returned if zero messages could be received; otherwise the number of
messages successfully received before the error will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">number of messages received, or -1 on error. Note that the number
    of messages received may be smaller than @num_messages if in non-blocking
    mode, if the peer closed the connection, or if @num_messages
    was larger than `UIO_MAXIOV` (1024), in which case the caller may re-try
    to receive the remaining messages.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="messages" transfer-ownership="none">
            <doc xml:space="preserve">an array of #GInputMessage structs</doc>
            <array length="1" zero-terminated="0" c:type="GInputMessage*">
              <type name="InputMessage" c:type="GInputMessage"/>
            </array>
          </parameter>
          <parameter name="num_messages" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements in @messages</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">an int containing #GSocketMsgFlags flags for the overall operation</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="receive_with_blocking" c:identifier="g_socket_receive_with_blocking" version="2.26" throws="1">
        <doc xml:space="preserve">This behaves exactly the same as g_socket_receive(), except that
the choice of blocking or non-blocking behavior is determined by
the @blocking argument rather than by @socket's properties.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Number of bytes read, or 0 if the connection was closed by
the peer, or -1 on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a buffer to
    read data into (which should be at least @size bytes long).</doc>
            <array length="1" zero-terminated="0" c:type="gchar*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes you want to read from the socket</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="blocking" transfer-ownership="none">
            <doc xml:space="preserve">whether to do blocking or non-blocking I/O</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send" c:identifier="g_socket_send" version="2.22" throws="1">
        <doc xml:space="preserve">Tries to send @size bytes from @buffer on the socket. This is
mainly used by connection-oriented sockets; it is identical to
g_socket_send_to() with @address set to %NULL.

If the socket is in blocking mode the call will block until there is
space for the data in the socket queue. If there is no space available
and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
will be returned. To be notified when space is available, wait for the
%G_IO_OUT condition. Note though that you may still receive
%G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
notified of a %G_IO_OUT condition. (On Windows in particular, this is
very common due to the way the underlying APIs work.)

On error -1 is returned and @error is set accordingly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Number of bytes written (which may be less than @size), or -1
on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">the buffer
    containing the data to send.</doc>
            <array length="1" zero-terminated="0" c:type="const gchar*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes to send</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_message" c:identifier="g_socket_send_message" version="2.22" throws="1">
        <doc xml:space="preserve">Send data to @address on @socket.  For sending multiple messages see
g_socket_send_messages(); for easier use, see
g_socket_send() and g_socket_send_to().

If @address is %NULL then the message is sent to the default receiver
(set by g_socket_connect()).

@vectors must point to an array of #GOutputVector structs and
@num_vectors must be the length of this array. (If @num_vectors is -1,
then @vectors is assumed to be terminated by a #GOutputVector with a
%NULL buffer pointer.) The #GOutputVector structs describe the buffers
that the sent data will be gathered from. Using multiple
#GOutputVectors is more memory-efficient than manually copying
data from multiple sources into a single buffer, and more
network-efficient than making multiple calls to g_socket_send().

@messages, if non-%NULL, is taken to point to an array of @num_messages
#GSocketControlMessage instances. These correspond to the control
messages to be sent on the socket.
If @num_messages is -1 then @messages is treated as a %NULL-terminated
array.

@flags modify how the message is sent. The commonly available arguments
for this are available in the #GSocketMsgFlags enum, but the
values there are the same as the system values, and the flags
are passed in as-is, so you can pass in system-specific flags too.

If the socket is in blocking mode the call will block until there is
space for the data in the socket queue. If there is no space available
and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
will be returned. To be notified when space is available, wait for the
%G_IO_OUT condition. Note though that you may still receive
%G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
notified of a %G_IO_OUT condition. (On Windows in particular, this is
very common due to the way the underlying APIs work.)

On error -1 is returned and @error is set accordingly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Number of bytes written (which may be less than @size), or -1
on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GSocketAddress, or %NULL</doc>
            <type name="SocketAddress" c:type="GSocketAddress*"/>
          </parameter>
          <parameter name="vectors" transfer-ownership="none">
            <doc xml:space="preserve">an array of #GOutputVector structs</doc>
            <array length="2" zero-terminated="0" c:type="GOutputVector*">
              <type name="OutputVector" c:type="GOutputVector"/>
            </array>
          </parameter>
          <parameter name="num_vectors" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements in @vectors, or -1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="messages" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a pointer to an
  array of #GSocketControlMessages, or %NULL.</doc>
            <array length="4" zero-terminated="0" c:type="GSocketControlMessage**">
              <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
            </array>
          </parameter>
          <parameter name="num_messages" transfer-ownership="none">
            <doc xml:space="preserve">number of elements in @messages, or -1.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">an int containing #GSocketMsgFlags flags</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_messages" c:identifier="g_socket_send_messages" version="2.44" throws="1">
        <doc xml:space="preserve">Send multiple data messages from @socket in one go.  This is the most
complicated and fully-featured version of this call. For easier use, see
g_socket_send(), g_socket_send_to(), and g_socket_send_message().

@messages must point to an array of #GOutputMessage structs and
@num_messages must be the length of this array. Each #GOutputMessage
contains an address to send the data to, and a pointer to an array of
#GOutputVector structs to describe the buffers that the data to be sent
for each message will be gathered from. Using multiple #GOutputVectors is
more memory-efficient than manually copying data from multiple sources
into a single buffer, and more network-efficient than making multiple
calls to g_socket_send(). Sending multiple messages in one go avoids the
overhead of making a lot of syscalls in scenarios where a lot of data
packets need to be sent (e.g. high-bandwidth video streaming over RTP/UDP),
or where the same data needs to be sent to multiple recipients.

@flags modify how the message is sent. The commonly available arguments
for this are available in the #GSocketMsgFlags enum, but the
values there are the same as the system values, and the flags
are passed in as-is, so you can pass in system-specific flags too.

If the socket is in blocking mode the call will block until there is
space for all the data in the socket queue. If there is no space available
and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
will be returned if no data was written at all, otherwise the number of
messages sent will be returned. To be notified when space is available,
wait for the %G_IO_OUT condition. Note though that you may still receive
%G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
notified of a %G_IO_OUT condition. (On Windows in particular, this is
very common due to the way the underlying APIs work.)

On error -1 is returned and @error is set accordingly. An error will only
be returned if zero messages could be sent; otherwise the number of messages
successfully sent before the error will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">number of messages sent, or -1 on error. Note that the number of
    messages sent may be smaller than @num_messages if the socket is
    non-blocking or if @num_messages was larger than UIO_MAXIOV (1024),
    in which case the caller may re-try to send the remaining messages.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="messages" transfer-ownership="none">
            <doc xml:space="preserve">an array of #GOutputMessage structs</doc>
            <array length="1" zero-terminated="0" c:type="GOutputMessage*">
              <type name="OutputMessage" c:type="GOutputMessage"/>
            </array>
          </parameter>
          <parameter name="num_messages" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements in @messages</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">an int containing #GSocketMsgFlags flags</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_to" c:identifier="g_socket_send_to" version="2.22" throws="1">
        <doc xml:space="preserve">Tries to send @size bytes from @buffer to @address. If @address is
%NULL then the message is sent to the default receiver (set by
g_socket_connect()).

See g_socket_send() for additional information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Number of bytes written (which may be less than @size), or -1
on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GSocketAddress, or %NULL</doc>
            <type name="SocketAddress" c:type="GSocketAddress*"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">the buffer
    containing the data to send.</doc>
            <array length="2" zero-terminated="0" c:type="const gchar*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes to send</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_with_blocking" c:identifier="g_socket_send_with_blocking" version="2.26" throws="1">
        <doc xml:space="preserve">This behaves exactly the same as g_socket_send(), except that
the choice of blocking or non-blocking behavior is determined by
the @blocking argument rather than by @socket's properties.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Number of bytes written (which may be less than @size), or -1
on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">the buffer
    containing the data to send.</doc>
            <array length="1" zero-terminated="0" c:type="const gchar*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes to send</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="blocking" transfer-ownership="none">
            <doc xml:space="preserve">whether to do blocking or non-blocking I/O</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blocking" c:identifier="g_socket_set_blocking" version="2.22">
        <doc xml:space="preserve">Sets the blocking mode of the socket. In blocking mode
all operations (which don&#x2019;t take an explicit blocking parameter) block until
they succeed or there is an error. In
non-blocking mode all functions return results immediately or
with a %G_IO_ERROR_WOULD_BLOCK error.

All sockets are created in blocking mode. However, note that the
platform level socket is always non-blocking, and blocking mode
is a GSocket level feature.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="blocking" transfer-ownership="none">
            <doc xml:space="preserve">Whether to use blocking I/O or not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_broadcast" c:identifier="g_socket_set_broadcast" version="2.32">
        <doc xml:space="preserve">Sets whether @socket should allow sending to broadcast addresses.
This is %FALSE by default.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="broadcast" transfer-ownership="none">
            <doc xml:space="preserve">whether @socket should allow sending to broadcast
    addresses</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_keepalive" c:identifier="g_socket_set_keepalive" version="2.22">
        <doc xml:space="preserve">Sets or unsets the %SO_KEEPALIVE flag on the underlying socket. When
this flag is set on a socket, the system will attempt to verify that the
remote socket endpoint is still present if a sufficiently long period of
time passes with no data being exchanged. If the system is unable to
verify the presence of the remote endpoint, it will automatically close
the connection.

This option is only functional on certain kinds of sockets. (Notably,
%G_SOCKET_PROTOCOL_TCP sockets.)

The exact time between pings is system- and protocol-dependent, but will
normally be at least two hours. Most commonly, you would set this flag
on a server socket if you want to allow clients to remain idle for long
periods of time, but also want to ensure that connections are eventually
garbage-collected if clients crash or become unreachable.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="keepalive" transfer-ownership="none">
            <doc xml:space="preserve">Value for the keepalive flag</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_listen_backlog" c:identifier="g_socket_set_listen_backlog" version="2.22">
        <doc xml:space="preserve">Sets the maximum number of outstanding connections allowed
when listening on this socket. If more clients than this are
connecting to the socket and the application is not handling them
on time then the new connections will be refused.

Note that this must be called before g_socket_listen() and has no
effect if called after that.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="backlog" transfer-ownership="none">
            <doc xml:space="preserve">the maximum number of pending connections.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_multicast_loopback" c:identifier="g_socket_set_multicast_loopback" version="2.32">
        <doc xml:space="preserve">Sets whether outgoing multicast packets will be received by sockets
listening on that multicast address on the same host. This is %TRUE
by default.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="loopback" transfer-ownership="none">
            <doc xml:space="preserve">whether @socket should receive messages sent to its
  multicast groups from the local host</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_multicast_ttl" c:identifier="g_socket_set_multicast_ttl" version="2.32">
        <doc xml:space="preserve">Sets the time-to-live for outgoing multicast datagrams on @socket.
By default, this is 1, meaning that multicast packets will not leave
the local network.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="ttl" transfer-ownership="none">
            <doc xml:space="preserve">the time-to-live value for all multicast datagrams on @socket</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_option" c:identifier="g_socket_set_option" version="2.36" throws="1">
        <doc xml:space="preserve">Sets the value of an integer-valued option on @socket, as with
setsockopt(). (If you need to set a non-integer-valued option,
you will need to call setsockopt() directly.)

The [&lt;gio/gnetworking.h&gt;][gio-gnetworking.h]
header pulls in system headers that will define most of the
standard/portable socket options. For unusual socket protocols or
platform-dependent options, you may need to include additional
headers.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">success or failure. On failure, @error will be set, and
  the system error value (`errno` or WSAGetLastError()) will still
  be set to the result of the setsockopt() call.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve">the "API level" of the option (eg, `SOL_SOCKET`)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="optname" transfer-ownership="none">
            <doc xml:space="preserve">the "name" of the option (eg, `SO_BROADCAST`)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value to set the option to</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_timeout" c:identifier="g_socket_set_timeout" version="2.26">
        <doc xml:space="preserve">Sets the time in seconds after which I/O operations on @socket will
time out if they have not yet completed.

On a blocking socket, this means that any blocking #GSocket
operation will time out after @timeout seconds of inactivity,
returning %G_IO_ERROR_TIMED_OUT.

On a non-blocking socket, calls to g_socket_condition_wait() will
also fail with %G_IO_ERROR_TIMED_OUT after the given time. Sources
created with g_socket_create_source() will trigger after
@timeout seconds of inactivity, with the requested condition
set, at which point calling g_socket_receive(), g_socket_send(),
g_socket_check_connect_result(), etc, will fail with
%G_IO_ERROR_TIMED_OUT.

If @timeout is 0 (the default), operations will never time out
on their own.

Note that if an I/O operation is interrupted by a signal, this may
cause the timeout to be reset.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:space="preserve">the timeout for @socket, in seconds, or 0 for none</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ttl" c:identifier="g_socket_set_ttl" version="2.32">
        <doc xml:space="preserve">Sets the time-to-live for outgoing unicast packets on @socket.
By default the platform-specific default value is used.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket.</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="ttl" transfer-ownership="none">
            <doc xml:space="preserve">the time-to-live value for all unicast packets on @socket</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="shutdown" c:identifier="g_socket_shutdown" version="2.22" throws="1">
        <doc xml:space="preserve">Shut down part or all of a full-duplex connection.

If @shutdown_read is %TRUE then the receiving side of the connection
is shut down, and further reading is disallowed.

If @shutdown_write is %TRUE then the sending side of the connection
is shut down, and further writing is disallowed.

It is allowed for both @shutdown_read and @shutdown_write to be %TRUE.

One example where it is useful to shut down only one side of a connection is
graceful disconnect for TCP connections where you close the sending side,
then wait for the other side to close the connection, thus ensuring that the
other side saw all sent data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
          <parameter name="shutdown_read" transfer-ownership="none">
            <doc xml:space="preserve">whether to shut down the read side</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="shutdown_write" transfer-ownership="none">
            <doc xml:space="preserve">whether to shut down the write side</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="speaks_ipv4" c:identifier="g_socket_speaks_ipv4" version="2.22">
        <doc xml:space="preserve">Checks if a socket is capable of speaking IPv4.

IPv4 sockets are capable of speaking IPv4.  On some operating systems
and under some combinations of circumstances IPv6 sockets are also
capable of speaking IPv4.  See RFC 3493 section 3.7 for more
information.

No other types of sockets are currently considered as being capable
of speaking IPv4.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if this socket can be used with IPv4.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocket</doc>
            <type name="Socket" c:type="GSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="blocking" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="broadcast" version="2.32" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether the socket should allow sending to broadcast addresses.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="family" writable="1" construct-only="1" transfer-ownership="none">
        <type name="SocketFamily"/>
      </property>
      <property name="fd" writable="1" construct-only="1" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="keepalive" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="listen-backlog" writable="1" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="local-address" transfer-ownership="none">
        <type name="SocketAddress"/>
      </property>
      <property name="multicast-loopback" version="2.32" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether outgoing multicast packets loop back to the local host.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="multicast-ttl" version="2.32" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Time-to-live out outgoing multicast packets</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="protocol" writable="1" construct-only="1" transfer-ownership="none">
        <type name="SocketProtocol"/>
      </property>
      <property name="remote-address" transfer-ownership="none">
        <type name="SocketAddress"/>
      </property>
      <property name="timeout" version="2.26" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The timeout in seconds on socket I/O</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="ttl" version="2.32" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Time-to-live for outgoing unicast packets</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="type" writable="1" construct-only="1" transfer-ownership="none">
        <type name="SocketType"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="SocketPrivate" c:type="GSocketPrivate*"/>
      </field>
    </class>
    <class name="SocketAddress" c:symbol-prefix="socket_address" c:type="GSocketAddress" parent="GObject.Object" abstract="1" glib:type-name="GSocketAddress" glib:get-type="g_socket_address_get_type" glib:type-struct="SocketAddressClass">
      <doc xml:space="preserve">#GSocketAddress is the equivalent of struct sockaddr in the BSD
sockets API. This is an abstract class; use #GInetSocketAddress
for internet sockets, or #GUnixSocketAddress for UNIX domain sockets.</doc>
      <implements name="SocketConnectable"/>
      <constructor name="new_from_native" c:identifier="g_socket_address_new_from_native" version="2.22">
        <doc xml:space="preserve">Creates a #GSocketAddress subclass corresponding to the native
struct sockaddr @native.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSocketAddress if @native could successfully
    be converted, otherwise %NULL</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <parameter name="native" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to a struct sockaddr</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">the size of the memory location pointed to by @native</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="get_family" invoker="get_family" version="2.22">
        <doc xml:space="preserve">Gets the socket family type of @address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the socket family type of @address</doc>
          <type name="SocketFamily" c:type="GSocketFamily"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketAddress</doc>
            <type name="SocketAddress" c:type="GSocketAddress*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_native_size" invoker="get_native_size" version="2.22">
        <doc xml:space="preserve">Gets the size of @address's native struct sockaddr.
You can use this to allocate memory to pass to
g_socket_address_to_native().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the size of the native struct sockaddr that
    @address represents</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketAddress</doc>
            <type name="SocketAddress" c:type="GSocketAddress*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="to_native" invoker="to_native" version="2.22" throws="1">
        <doc xml:space="preserve">Converts a #GSocketAddress to a native struct sockaddr, which can
be passed to low-level functions like connect() or bind().

If not enough space is available, a %G_IO_ERROR_NO_SPACE error
is returned. If the address type is not known on the system
then a %G_IO_ERROR_NOT_SUPPORTED error is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @dest was filled in, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketAddress</doc>
            <type name="SocketAddress" c:type="GSocketAddress*"/>
          </instance-parameter>
          <parameter name="dest" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a pointer to a memory location that will contain the native
struct sockaddr</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destlen" transfer-ownership="none">
            <doc xml:space="preserve">the size of @dest. Must be at least as large as
    g_socket_address_get_native_size()</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_family" c:identifier="g_socket_address_get_family" version="2.22">
        <doc xml:space="preserve">Gets the socket family type of @address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the socket family type of @address</doc>
          <type name="SocketFamily" c:type="GSocketFamily"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketAddress</doc>
            <type name="SocketAddress" c:type="GSocketAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_native_size" c:identifier="g_socket_address_get_native_size" version="2.22">
        <doc xml:space="preserve">Gets the size of @address's native struct sockaddr.
You can use this to allocate memory to pass to
g_socket_address_to_native().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the size of the native struct sockaddr that
    @address represents</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketAddress</doc>
            <type name="SocketAddress" c:type="GSocketAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_native" c:identifier="g_socket_address_to_native" version="2.22" throws="1">
        <doc xml:space="preserve">Converts a #GSocketAddress to a native struct sockaddr, which can
be passed to low-level functions like connect() or bind().

If not enough space is available, a %G_IO_ERROR_NO_SPACE error
is returned. If the address type is not known on the system
then a %G_IO_ERROR_NOT_SUPPORTED error is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @dest was filled in, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketAddress</doc>
            <type name="SocketAddress" c:type="GSocketAddress*"/>
          </instance-parameter>
          <parameter name="dest" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a pointer to a memory location that will contain the native
struct sockaddr</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destlen" transfer-ownership="none">
            <doc xml:space="preserve">the size of @dest. Must be at least as large as
    g_socket_address_get_native_size()</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <property name="family" transfer-ownership="none">
        <type name="SocketFamily"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="SocketAddressClass" c:type="GSocketAddressClass" glib:is-gtype-struct-for="SocketAddress">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="get_family">
        <callback name="get_family">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the socket family type of @address</doc>
            <type name="SocketFamily" c:type="GSocketFamily"/>
          </return-value>
          <parameters>
            <parameter name="address" transfer-ownership="none">
              <doc xml:space="preserve">a #GSocketAddress</doc>
              <type name="SocketAddress" c:type="GSocketAddress*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_native_size">
        <callback name="get_native_size">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the size of the native struct sockaddr that
    @address represents</doc>
            <type name="gssize" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="address" transfer-ownership="none">
              <doc xml:space="preserve">a #GSocketAddress</doc>
              <type name="SocketAddress" c:type="GSocketAddress*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="to_native">
        <callback name="to_native" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @dest was filled in, %FALSE on error</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="address" transfer-ownership="none">
              <doc xml:space="preserve">a #GSocketAddress</doc>
              <type name="SocketAddress" c:type="GSocketAddress*"/>
            </parameter>
            <parameter name="dest" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a pointer to a memory location that will contain the native
struct sockaddr</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="destlen" transfer-ownership="none">
              <doc xml:space="preserve">the size of @dest. Must be at least as large as
    g_socket_address_get_native_size()</doc>
              <type name="gsize" c:type="gsize"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="SocketAddressEnumerator" c:symbol-prefix="socket_address_enumerator" c:type="GSocketAddressEnumerator" parent="GObject.Object" abstract="1" glib:type-name="GSocketAddressEnumerator" glib:get-type="g_socket_address_enumerator_get_type" glib:type-struct="SocketAddressEnumeratorClass">
      <doc xml:space="preserve">Enumerator type for objects that contain or generate
#GSocketAddress instances.</doc>
      <virtual-method name="next" invoker="next" throws="1">
        <doc xml:space="preserve">Retrieves the next #GSocketAddress from @enumerator. Note that this
may block for some amount of time. (Eg, a #GNetworkAddress may need
to do a DNS lookup before it can return an address.) Use
g_socket_address_enumerator_next_async() if you need to avoid
blocking.

If @enumerator is expected to yield addresses, but for some reason
is unable to (eg, because of a DNS error), then the first call to
g_socket_address_enumerator_next() will return an appropriate error
in *@error. However, if the first call to
g_socket_address_enumerator_next() succeeds, then any further
internal errors (other than @cancellable being triggered) will be
ignored.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSocketAddress (owned by the caller), or %NULL on
    error (in which case *@error will be set) or if there are no
    more addresses.</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketAddressEnumerator</doc>
            <type name="SocketAddressEnumerator" c:type="GSocketAddressEnumerator*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="next_async" invoker="next_async">
        <doc xml:space="preserve">Asynchronously retrieves the next #GSocketAddress from @enumerator
and then calls @callback, which must call
g_socket_address_enumerator_next_finish() to get the result.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketAddressEnumerator</doc>
            <type name="SocketAddressEnumerator" c:type="GSocketAddressEnumerator*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request
    is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="next_finish" invoker="next_finish" throws="1">
        <doc xml:space="preserve">Retrieves the result of a completed call to
g_socket_address_enumerator_next_async(). See
g_socket_address_enumerator_next() for more information about
error handling.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSocketAddress (owned by the caller), or %NULL on
    error (in which case *@error will be set) or if there are no
    more addresses.</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketAddressEnumerator</doc>
            <type name="SocketAddressEnumerator" c:type="GSocketAddressEnumerator*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="next" c:identifier="g_socket_address_enumerator_next" throws="1">
        <doc xml:space="preserve">Retrieves the next #GSocketAddress from @enumerator. Note that this
may block for some amount of time. (Eg, a #GNetworkAddress may need
to do a DNS lookup before it can return an address.) Use
g_socket_address_enumerator_next_async() if you need to avoid
blocking.

If @enumerator is expected to yield addresses, but for some reason
is unable to (eg, because of a DNS error), then the first call to
g_socket_address_enumerator_next() will return an appropriate error
in *@error. However, if the first call to
g_socket_address_enumerator_next() succeeds, then any further
internal errors (other than @cancellable being triggered) will be
ignored.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSocketAddress (owned by the caller), or %NULL on
    error (in which case *@error will be set) or if there are no
    more addresses.</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketAddressEnumerator</doc>
            <type name="SocketAddressEnumerator" c:type="GSocketAddressEnumerator*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="next_async" c:identifier="g_socket_address_enumerator_next_async">
        <doc xml:space="preserve">Asynchronously retrieves the next #GSocketAddress from @enumerator
and then calls @callback, which must call
g_socket_address_enumerator_next_finish() to get the result.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketAddressEnumerator</doc>
            <type name="SocketAddressEnumerator" c:type="GSocketAddressEnumerator*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request
    is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="next_finish" c:identifier="g_socket_address_enumerator_next_finish" throws="1">
        <doc xml:space="preserve">Retrieves the result of a completed call to
g_socket_address_enumerator_next_async(). See
g_socket_address_enumerator_next() for more information about
error handling.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSocketAddress (owned by the caller), or %NULL on
    error (in which case *@error will be set) or if there are no
    more addresses.</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketAddressEnumerator</doc>
            <type name="SocketAddressEnumerator" c:type="GSocketAddressEnumerator*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="SocketAddressEnumeratorClass" c:type="GSocketAddressEnumeratorClass" glib:is-gtype-struct-for="SocketAddressEnumerator">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="next">
        <callback name="next" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GSocketAddress (owned by the caller), or %NULL on
    error (in which case *@error will be set) or if there are no
    more addresses.</doc>
            <type name="SocketAddress" c:type="GSocketAddress*"/>
          </return-value>
          <parameters>
            <parameter name="enumerator" transfer-ownership="none">
              <doc xml:space="preserve">a #GSocketAddressEnumerator</doc>
              <type name="SocketAddressEnumerator" c:type="GSocketAddressEnumerator*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="next_async">
        <callback name="next_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="enumerator" transfer-ownership="none">
              <doc xml:space="preserve">a #GSocketAddressEnumerator</doc>
              <type name="SocketAddressEnumerator" c:type="GSocketAddressEnumerator*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request
    is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="next_finish">
        <callback name="next_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GSocketAddress (owned by the caller), or %NULL on
    error (in which case *@error will be set) or if there are no
    more addresses.</doc>
            <type name="SocketAddress" c:type="GSocketAddress*"/>
          </return-value>
          <parameters>
            <parameter name="enumerator" transfer-ownership="none">
              <doc xml:space="preserve">a #GSocketAddressEnumerator</doc>
              <type name="SocketAddressEnumerator" c:type="GSocketAddressEnumerator*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="SocketClass" c:type="GSocketClass" glib:is-gtype-struct-for="Socket">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved6" introspectable="0">
        <callback name="_g_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved7" introspectable="0">
        <callback name="_g_reserved7">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved8" introspectable="0">
        <callback name="_g_reserved8">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved9" introspectable="0">
        <callback name="_g_reserved9">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved10" introspectable="0">
        <callback name="_g_reserved10">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <class name="SocketClient" c:symbol-prefix="socket_client" c:type="GSocketClient" version="2.22" parent="GObject.Object" glib:type-name="GSocketClient" glib:get-type="g_socket_client_get_type" glib:type-struct="SocketClientClass">
      <doc xml:space="preserve">#GSocketClient is a lightweight high-level utility class for connecting to
a network host using a connection oriented socket type.

You create a #GSocketClient object, set any options you want, and then
call a sync or async connect operation, which returns a #GSocketConnection
subclass on success.

The type of the #GSocketConnection object returned depends on the type of
the underlying socket that is in use. For instance, for a TCP/IP connection
it will be a #GTcpConnection.

As #GSocketClient is a lightweight object, you don't need to cache it. You
can just create a new one any time you need one.</doc>
      <constructor name="new" c:identifier="g_socket_client_new" version="2.22">
        <doc xml:space="preserve">Creates a new #GSocketClient with the default options.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSocketClient.
    Free the returned object with g_object_unref().</doc>
          <type name="SocketClient" c:type="GSocketClient*"/>
        </return-value>
      </constructor>
      <virtual-method name="event">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
          <parameter name="event" transfer-ownership="none">
            <type name="SocketClientEvent" c:type="GSocketClientEvent"/>
          </parameter>
          <parameter name="connectable" transfer-ownership="none">
            <type name="SocketConnectable" c:type="GSocketConnectable*"/>
          </parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="IOStream" c:type="GIOStream*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_application_proxy" c:identifier="g_socket_client_add_application_proxy">
        <doc xml:space="preserve">Enable proxy protocols to be handled by the application. When the
indicated proxy protocol is returned by the #GProxyResolver,
#GSocketClient will consider this protocol as supported but will
not try to find a #GProxy instance to handle handshaking. The
application must check for this case by calling
g_socket_connection_get_remote_address() on the returned
#GSocketConnection, and seeing if it's a #GProxyAddress of the
appropriate type, to determine whether or not it needs to handle
the proxy handshaking itself.

This should be used for proxy protocols that are dialects of
another protocol such as HTTP proxy. It also allows cohabitation of
proxy protocols that are reused between protocols. A good example
is HTTP. It can be used to proxy HTTP, FTP and Gopher and can also
be use as generic socket proxy through the HTTP CONNECT method.

When the proxy is detected as being an application proxy, TLS handshake
will be skipped. This is required to let the application do the proxy
specific handshake.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:space="preserve">The proxy protocol</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect" c:identifier="g_socket_client_connect" version="2.22" throws="1">
        <doc xml:space="preserve">Tries to resolve the @connectable and make a network connection to it.

Upon a successful connection, a new #GSocketConnection is constructed
and returned.  The caller owns this new object and must drop their
reference to it when finished with it.

The type of the #GSocketConnection object returned depends on the type of
the underlying socket that is used. For instance, for a TCP/IP connection
it will be a #GTcpConnection.

The socket created will be the same family as the address that the
@connectable resolves to, unless family is set with g_socket_client_set_family()
or indirectly via g_socket_client_set_local_address(). The socket type
defaults to %G_SOCKET_TYPE_STREAM but can be set with
g_socket_client_set_socket_type().

If a local address is specified with g_socket_client_set_local_address() the
socket will be bound to this address before connecting.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSocketConnection on success, %NULL on error.</doc>
          <type name="SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient.</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
          <parameter name="connectable" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketConnectable specifying the remote address.</doc>
            <type name="SocketConnectable" c:type="GSocketConnectable*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_async" c:identifier="g_socket_client_connect_async" version="2.22">
        <doc xml:space="preserve">This is the asynchronous version of g_socket_client_connect().

When the operation is finished @callback will be
called. You can then call g_socket_client_connect_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
          <parameter name="connectable" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketConnectable specifying the remote address.</doc>
            <type name="SocketConnectable" c:type="GSocketConnectable*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data for the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_finish" c:identifier="g_socket_client_connect_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes an async connect operation. See g_socket_client_connect_async()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSocketConnection on success, %NULL on error.</doc>
          <type name="SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient.</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_to_host" c:identifier="g_socket_client_connect_to_host" version="2.22" throws="1">
        <doc xml:space="preserve">This is a helper function for g_socket_client_connect().

Attempts to create a TCP connection to the named host.

@host_and_port may be in any of a number of recognized formats; an IPv6
address, an IPv4 address, or a domain name (in which case a DNS
lookup is performed).  Quoting with [] is supported for all address
types.  A port override may be specified in the usual way with a
colon.  Ports may be given as decimal numbers or symbolic names (in
which case an /etc/services lookup is performed).

If no port override is given in @host_and_port then @default_port will be
used as the port number to connect to.

In general, @host_and_port is expected to be provided by the user (allowing
them to give the hostname, and a port override if necessary) and
@default_port is expected to be provided by the application.

In the case that an IP address is given, a single connection
attempt is made.  In the case that a name is given, multiple
connection attempts may be made, in turn and according to the
number of address records in DNS, until a connection succeeds.

Upon a successful connection, a new #GSocketConnection is constructed
and returned.  The caller owns this new object and must drop their
reference to it when finished with it.

In the event of any failure (DNS error, service not found, no hosts
connectable) %NULL is returned and @error (if non-%NULL) is set
accordingly.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSocketConnection on success, %NULL on error.</doc>
          <type name="SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
          <parameter name="host_and_port" transfer-ownership="none">
            <doc xml:space="preserve">the name and optionally port of the host to connect to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="default_port" transfer-ownership="none">
            <doc xml:space="preserve">the default port to connect to</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_to_host_async" c:identifier="g_socket_client_connect_to_host_async" version="2.22">
        <doc xml:space="preserve">This is the asynchronous version of g_socket_client_connect_to_host().

When the operation is finished @callback will be
called. You can then call g_socket_client_connect_to_host_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
          <parameter name="host_and_port" transfer-ownership="none">
            <doc xml:space="preserve">the name and optionally the port of the host to connect to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="default_port" transfer-ownership="none">
            <doc xml:space="preserve">the default port to connect to</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data for the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_to_host_finish" c:identifier="g_socket_client_connect_to_host_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes an async connect operation. See g_socket_client_connect_to_host_async()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSocketConnection on success, %NULL on error.</doc>
          <type name="SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient.</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_to_service" c:identifier="g_socket_client_connect_to_service" throws="1">
        <doc xml:space="preserve">Attempts to create a TCP connection to a service.

This call looks up the SRV record for @service at @domain for the
"tcp" protocol.  It then attempts to connect, in turn, to each of
the hosts providing the service until either a connection succeeds
or there are no hosts remaining.

Upon a successful connection, a new #GSocketConnection is constructed
and returned.  The caller owns this new object and must drop their
reference to it when finished with it.

In the event of any failure (DNS error, service not found, no hosts
connectable) %NULL is returned and @error (if non-%NULL) is set
accordingly.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSocketConnection if successful, or %NULL on error</doc>
          <type name="SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketConnection</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a domain name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">the name of the service to connect to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_to_service_async" c:identifier="g_socket_client_connect_to_service_async" version="2.22">
        <doc xml:space="preserve">This is the asynchronous version of
g_socket_client_connect_to_service().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a domain name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">the name of the service to connect to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data for the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_to_service_finish" c:identifier="g_socket_client_connect_to_service_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes an async connect operation. See g_socket_client_connect_to_service_async()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSocketConnection on success, %NULL on error.</doc>
          <type name="SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient.</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_to_uri" c:identifier="g_socket_client_connect_to_uri" version="2.26" throws="1">
        <doc xml:space="preserve">This is a helper function for g_socket_client_connect().

Attempts to create a TCP connection with a network URI.

@uri may be any valid URI containing an "authority" (hostname/port)
component. If a port is not specified in the URI, @default_port
will be used. TLS will be negotiated if #GSocketClient:tls is %TRUE.
(#GSocketClient does not know to automatically assume TLS for
certain URI schemes.)

Using this rather than g_socket_client_connect() or
g_socket_client_connect_to_host() allows #GSocketClient to
determine when to use application-specific proxy protocols.

Upon a successful connection, a new #GSocketConnection is constructed
and returned.  The caller owns this new object and must drop their
reference to it when finished with it.

In the event of any failure (DNS error, service not found, no hosts
connectable) %NULL is returned and @error (if non-%NULL) is set
accordingly.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSocketConnection on success, %NULL on error.</doc>
          <type name="SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">A network URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="default_port" transfer-ownership="none">
            <doc xml:space="preserve">the default port to connect to</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_to_uri_async" c:identifier="g_socket_client_connect_to_uri_async" version="2.26">
        <doc xml:space="preserve">This is the asynchronous version of g_socket_client_connect_to_uri().

When the operation is finished @callback will be
called. You can then call g_socket_client_connect_to_uri_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a network uri</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="default_port" transfer-ownership="none">
            <doc xml:space="preserve">the default port to connect to</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data for the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_to_uri_finish" c:identifier="g_socket_client_connect_to_uri_finish" version="2.26" throws="1">
        <doc xml:space="preserve">Finishes an async connect operation. See g_socket_client_connect_to_uri_async()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSocketConnection on success, %NULL on error.</doc>
          <type name="SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient.</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_enable_proxy" c:identifier="g_socket_client_get_enable_proxy" version="2.26">
        <doc xml:space="preserve">Gets the proxy enable state; see g_socket_client_set_enable_proxy()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether proxying is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient.</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_family" c:identifier="g_socket_client_get_family" version="2.22">
        <doc xml:space="preserve">Gets the socket family of the socket client.

See g_socket_client_set_family() for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GSocketFamily</doc>
          <type name="SocketFamily" c:type="GSocketFamily"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient.</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_local_address" c:identifier="g_socket_client_get_local_address" version="2.22">
        <doc xml:space="preserve">Gets the local address of the socket client.

See g_socket_client_set_local_address() for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GSocketAddress or %NULL. Do not free.</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient.</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_protocol" c:identifier="g_socket_client_get_protocol" version="2.22">
        <doc xml:space="preserve">Gets the protocol name type of the socket client.

See g_socket_client_set_protocol() for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GSocketProtocol</doc>
          <type name="SocketProtocol" c:type="GSocketProtocol"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_proxy_resolver" c:identifier="g_socket_client_get_proxy_resolver" version="2.36">
        <doc xml:space="preserve">Gets the #GProxyResolver being used by @client. Normally, this will
be the resolver returned by g_proxy_resolver_get_default(), but you
can override it with g_socket_client_set_proxy_resolver().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #GProxyResolver being used by
  @client.</doc>
          <type name="ProxyResolver" c:type="GProxyResolver*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient.</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_socket_type" c:identifier="g_socket_client_get_socket_type" version="2.22">
        <doc xml:space="preserve">Gets the socket type of the socket client.

See g_socket_client_set_socket_type() for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GSocketFamily</doc>
          <type name="SocketType" c:type="GSocketType"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient.</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_timeout" c:identifier="g_socket_client_get_timeout" version="2.26">
        <doc xml:space="preserve">Gets the I/O timeout time for sockets created by @client.

See g_socket_client_set_timeout() for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the timeout in seconds</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tls" c:identifier="g_socket_client_get_tls" version="2.28">
        <doc xml:space="preserve">Gets whether @client creates TLS connections. See
g_socket_client_set_tls() for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @client uses TLS</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient.</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tls_validation_flags" c:identifier="g_socket_client_get_tls_validation_flags" version="2.28">
        <doc xml:space="preserve">Gets the TLS validation flags used creating TLS connections via
@client.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the TLS validation flags</doc>
          <type name="TlsCertificateFlags" c:type="GTlsCertificateFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient.</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_enable_proxy" c:identifier="g_socket_client_set_enable_proxy" version="2.26">
        <doc xml:space="preserve">Sets whether or not @client attempts to make connections via a
proxy server. When enabled (the default), #GSocketClient will use a
#GProxyResolver to determine if a proxy protocol such as SOCKS is
needed, and automatically do the necessary proxy negotiation.

See also g_socket_client_set_proxy_resolver().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient.</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
          <parameter name="enable" transfer-ownership="none">
            <doc xml:space="preserve">whether to enable proxies</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_family" c:identifier="g_socket_client_set_family" version="2.22">
        <doc xml:space="preserve">Sets the socket family of the socket client.
If this is set to something other than %G_SOCKET_FAMILY_INVALID
then the sockets created by this object will be of the specified
family.

This might be useful for instance if you want to force the local
connection to be an ipv4 socket, even though the address might
be an ipv6 mapped to ipv4 address.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient.</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
          <parameter name="family" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketFamily</doc>
            <type name="SocketFamily" c:type="GSocketFamily"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_local_address" c:identifier="g_socket_client_set_local_address" version="2.22">
        <doc xml:space="preserve">Sets the local address of the socket client.
The sockets created by this object will bound to the
specified address (if not %NULL) before connecting.

This is useful if you want to ensure that the local
side of the connection is on a specific port, or on
a specific interface.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient.</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GSocketAddress, or %NULL</doc>
            <type name="SocketAddress" c:type="GSocketAddress*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_protocol" c:identifier="g_socket_client_set_protocol" version="2.22">
        <doc xml:space="preserve">Sets the protocol of the socket client.
The sockets created by this object will use of the specified
protocol.

If @protocol is %0 that means to use the default
protocol for the socket family and type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient.</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketProtocol</doc>
            <type name="SocketProtocol" c:type="GSocketProtocol"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_proxy_resolver" c:identifier="g_socket_client_set_proxy_resolver" version="2.36">
        <doc xml:space="preserve">Overrides the #GProxyResolver used by @client. You can call this if
you want to use specific proxies, rather than using the system
default proxy settings.

Note that whether or not the proxy resolver is actually used
depends on the setting of #GSocketClient:enable-proxy, which is not
changed by this function (but which is %TRUE by default)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient.</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
          <parameter name="proxy_resolver" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GProxyResolver, or %NULL for the
  default.</doc>
            <type name="ProxyResolver" c:type="GProxyResolver*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_socket_type" c:identifier="g_socket_client_set_socket_type" version="2.22">
        <doc xml:space="preserve">Sets the socket type of the socket client.
The sockets created by this object will be of the specified
type.

It doesn't make sense to specify a type of %G_SOCKET_TYPE_DATAGRAM,
as GSocketClient is used for connection oriented services.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient.</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketType</doc>
            <type name="SocketType" c:type="GSocketType"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_timeout" c:identifier="g_socket_client_set_timeout" version="2.26">
        <doc xml:space="preserve">Sets the I/O timeout for sockets created by @client. @timeout is a
time in seconds, or 0 for no timeout (the default).

The timeout value affects the initial connection attempt as well,
so setting this may cause calls to g_socket_client_connect(), etc,
to fail with %G_IO_ERROR_TIMED_OUT.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient.</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:space="preserve">the timeout</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_tls" c:identifier="g_socket_client_set_tls" version="2.28">
        <doc xml:space="preserve">Sets whether @client creates TLS (aka SSL) connections. If @tls is
%TRUE, @client will wrap its connections in a #GTlsClientConnection
and perform a TLS handshake when connecting.

Note that since #GSocketClient must return a #GSocketConnection,
but #GTlsClientConnection is not a #GSocketConnection, this
actually wraps the resulting #GTlsClientConnection in a
#GTcpWrapperConnection when returning it. You can use
g_tcp_wrapper_connection_get_base_io_stream() on the return value
to extract the #GTlsClientConnection.

If you need to modify the behavior of the TLS handshake (eg, by
setting a client-side certificate to use, or connecting to the
#GTlsConnection::accept-certificate signal), you can connect to
@client's #GSocketClient::event signal and wait for it to be
emitted with %G_SOCKET_CLIENT_TLS_HANDSHAKING, which will give you
a chance to see the #GTlsClientConnection before the handshake
starts.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient.</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
          <parameter name="tls" transfer-ownership="none">
            <doc xml:space="preserve">whether to use TLS</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_tls_validation_flags" c:identifier="g_socket_client_set_tls_validation_flags" version="2.28">
        <doc xml:space="preserve">Sets the TLS validation flags used when creating TLS connections
via @client. The default value is %G_TLS_CERTIFICATE_VALIDATE_ALL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketClient.</doc>
            <type name="SocketClient" c:type="GSocketClient*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">the validation flags</doc>
            <type name="TlsCertificateFlags" c:type="GTlsCertificateFlags"/>
          </parameter>
        </parameters>
      </method>
      <property name="enable-proxy" writable="1" construct="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="family" writable="1" construct="1" transfer-ownership="none">
        <type name="SocketFamily"/>
      </property>
      <property name="local-address" writable="1" construct="1" transfer-ownership="none">
        <type name="SocketAddress"/>
      </property>
      <property name="protocol" writable="1" construct="1" transfer-ownership="none">
        <type name="SocketProtocol"/>
      </property>
      <property name="proxy-resolver" version="2.36" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">The proxy resolver to use</doc>
        <type name="ProxyResolver"/>
      </property>
      <property name="timeout" writable="1" construct="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="tls" writable="1" construct="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="tls-validation-flags" writable="1" construct="1" transfer-ownership="none">
        <type name="TlsCertificateFlags"/>
      </property>
      <property name="type" writable="1" construct="1" transfer-ownership="none">
        <type name="SocketType"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="SocketClientPrivate" c:type="GSocketClientPrivate*"/>
      </field>
      <glib:signal name="event" when="last" version="2.32">
        <doc xml:space="preserve">Emitted when @client's activity on @connectable changes state.
Among other things, this can be used to provide progress
information about a network connection in the UI. The meanings of
the different @event values are as follows:

- %G_SOCKET_CLIENT_RESOLVING: @client is about to look up @connectable
  in DNS. @connection will be %NULL.

- %G_SOCKET_CLIENT_RESOLVED:  @client has successfully resolved
  @connectable in DNS. @connection will be %NULL.

- %G_SOCKET_CLIENT_CONNECTING: @client is about to make a connection
  to a remote host; either a proxy server or the destination server
  itself. @connection is the #GSocketConnection, which is not yet
  connected.  Since GLib 2.40, you can access the remote
  address via g_socket_connection_get_remote_address().

- %G_SOCKET_CLIENT_CONNECTED: @client has successfully connected
  to a remote host. @connection is the connected #GSocketConnection.

- %G_SOCKET_CLIENT_PROXY_NEGOTIATING: @client is about to negotiate
  with a proxy to get it to connect to @connectable. @connection is
  the #GSocketConnection to the proxy server.

- %G_SOCKET_CLIENT_PROXY_NEGOTIATED: @client has negotiated a
  connection to @connectable through a proxy server. @connection is
  the stream returned from g_proxy_connect(), which may or may not
  be a #GSocketConnection.

- %G_SOCKET_CLIENT_TLS_HANDSHAKING: @client is about to begin a TLS
  handshake. @connection is a #GTlsClientConnection.

- %G_SOCKET_CLIENT_TLS_HANDSHAKED: @client has successfully completed
  the TLS handshake. @connection is a #GTlsClientConnection.

- %G_SOCKET_CLIENT_COMPLETE: @client has either successfully connected
  to @connectable (in which case @connection is the #GSocketConnection
  that it will be returning to the caller) or has failed (in which
  case @connection is %NULL and the client is about to return an error).

Each event except %G_SOCKET_CLIENT_COMPLETE may be emitted
multiple times (or not at all) for a given connectable (in
particular, if @client ends up attempting to connect to more than
one address). However, if @client emits the #GSocketClient::event
signal at all for a given connectable, that it will always emit
it with %G_SOCKET_CLIENT_COMPLETE when it is done.

Note that there may be additional #GSocketClientEvent values in
the future; unrecognized @event values should be ignored.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="none">
            <doc xml:space="preserve">the event that is occurring</doc>
            <type name="SocketClientEvent"/>
          </parameter>
          <parameter name="connectable" transfer-ownership="none">
            <doc xml:space="preserve">the #GSocketConnectable that @event is occurring on</doc>
            <type name="SocketConnectable"/>
          </parameter>
          <parameter name="connection" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the current representation of the connection</doc>
            <type name="IOStream"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="SocketClientClass" c:type="GSocketClientClass" glib:is-gtype-struct-for="SocketClient">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="event">
        <callback name="event">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="client" transfer-ownership="none">
              <type name="SocketClient" c:type="GSocketClient*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="SocketClientEvent" c:type="GSocketClientEvent"/>
            </parameter>
            <parameter name="connectable" transfer-ownership="none">
              <type name="SocketConnectable" c:type="GSocketConnectable*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="IOStream" c:type="GIOStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SocketClientEvent" version="2.32" glib:type-name="GSocketClientEvent" glib:get-type="g_socket_client_event_get_type" c:type="GSocketClientEvent">
      <doc xml:space="preserve">Describes an event occurring on a #GSocketClient. See the
#GSocketClient::event signal for more details.

Additional values may be added to this type in the future.</doc>
      <member name="resolving" value="0" c:identifier="G_SOCKET_CLIENT_RESOLVING" glib:nick="resolving">
        <doc xml:space="preserve">The client is doing a DNS lookup.</doc>
      </member>
      <member name="resolved" value="1" c:identifier="G_SOCKET_CLIENT_RESOLVED" glib:nick="resolved">
        <doc xml:space="preserve">The client has completed a DNS lookup.</doc>
      </member>
      <member name="connecting" value="2" c:identifier="G_SOCKET_CLIENT_CONNECTING" glib:nick="connecting">
        <doc xml:space="preserve">The client is connecting to a remote
  host (either a proxy or the destination server).</doc>
      </member>
      <member name="connected" value="3" c:identifier="G_SOCKET_CLIENT_CONNECTED" glib:nick="connected">
        <doc xml:space="preserve">The client has connected to a remote
  host.</doc>
      </member>
      <member name="proxy_negotiating" value="4" c:identifier="G_SOCKET_CLIENT_PROXY_NEGOTIATING" glib:nick="proxy-negotiating">
        <doc xml:space="preserve">The client is negotiating
  with a proxy to connect to the destination server.</doc>
      </member>
      <member name="proxy_negotiated" value="5" c:identifier="G_SOCKET_CLIENT_PROXY_NEGOTIATED" glib:nick="proxy-negotiated">
        <doc xml:space="preserve">The client has negotiated
  with the proxy server.</doc>
      </member>
      <member name="tls_handshaking" value="6" c:identifier="G_SOCKET_CLIENT_TLS_HANDSHAKING" glib:nick="tls-handshaking">
        <doc xml:space="preserve">The client is performing a
  TLS handshake.</doc>
      </member>
      <member name="tls_handshaked" value="7" c:identifier="G_SOCKET_CLIENT_TLS_HANDSHAKED" glib:nick="tls-handshaked">
        <doc xml:space="preserve">The client has performed a
  TLS handshake.</doc>
      </member>
      <member name="complete" value="8" c:identifier="G_SOCKET_CLIENT_COMPLETE" glib:nick="complete">
        <doc xml:space="preserve">The client is done with a particular
  #GSocketConnectable.</doc>
      </member>
    </enumeration>
    <record name="SocketClientPrivate" c:type="GSocketClientPrivate" disguised="1">
    </record>
    <interface name="SocketConnectable" c:symbol-prefix="socket_connectable" c:type="GSocketConnectable" glib:type-name="GSocketConnectable" glib:get-type="g_socket_connectable_get_type" glib:type-struct="SocketConnectableIface">
      <doc xml:space="preserve">Objects that describe one or more potential socket endpoints
implement #GSocketConnectable. Callers can then use
g_socket_connectable_enumerate() to get a #GSocketAddressEnumerator
to try out each socket address in turn until one succeeds, as shown
in the sample code below.

|[&lt;!-- language="C" --&gt;
MyConnectionType *
connect_to_host (const char    *hostname,
                 guint16        port,
                 GCancellable  *cancellable,
                 GError       **error)
{
  MyConnection *conn = NULL;
  GSocketConnectable *addr;
  GSocketAddressEnumerator *enumerator;
  GSocketAddress *sockaddr;
  GError *conn_error = NULL;

  addr = g_network_address_new (hostname, port);
  enumerator = g_socket_connectable_enumerate (addr);
  g_object_unref (addr);

  // Try each sockaddr until we succeed. Record the first connection error,
  // but not any further ones (since they'll probably be basically the same
  // as the first).
  while (!conn &amp;&amp; (sockaddr = g_socket_address_enumerator_next (enumerator, cancellable, error))
    {
      conn = connect_to_sockaddr (sockaddr, conn_error ? NULL : &amp;conn_error);
      g_object_unref (sockaddr);
    }
  g_object_unref (enumerator);

  if (conn)
    {
      if (conn_error)
        {
          // We couldn't connect to the first address, but we succeeded
          // in connecting to a later address.
          g_error_free (conn_error);
        }
      return conn;
    }
  else if (error)
    {
      /// Either initial lookup failed, or else the caller cancelled us.
      if (conn_error)
        g_error_free (conn_error);
      return NULL;
    }
  else
    {
      g_error_propagate (error, conn_error);
      return NULL;
    }
}
]|</doc>
      <virtual-method name="enumerate" invoker="enumerate" version="2.22">
        <doc xml:space="preserve">Creates a #GSocketAddressEnumerator for @connectable.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSocketAddressEnumerator.</doc>
          <type name="SocketAddressEnumerator" c:type="GSocketAddressEnumerator*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connectable" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketConnectable</doc>
            <type name="SocketConnectable" c:type="GSocketConnectable*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="proxy_enumerate" invoker="proxy_enumerate" version="2.26">
        <doc xml:space="preserve">Creates a #GSocketAddressEnumerator for @connectable that will
return #GProxyAddresses for addresses that you must connect
to via a proxy.

If @connectable does not implement
g_socket_connectable_proxy_enumerate(), this will fall back to
calling g_socket_connectable_enumerate().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSocketAddressEnumerator.</doc>
          <type name="SocketAddressEnumerator" c:type="GSocketAddressEnumerator*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connectable" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketConnectable</doc>
            <type name="SocketConnectable" c:type="GSocketConnectable*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="to_string" invoker="to_string" version="2.48">
        <doc xml:space="preserve">Format a #GSocketConnectable as a string. This is a human-readable format for
use in debugging output, and is not a stable serialization format. It is not
suitable for use in user interfaces as it exposes too much information for a
user.

If the #GSocketConnectable implementation does not support string formatting,
the implementation&#x2019;s type name will be returned as a fallback.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the formatted string</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connectable" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketConnectable</doc>
            <type name="SocketConnectable" c:type="GSocketConnectable*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="enumerate" c:identifier="g_socket_connectable_enumerate" version="2.22">
        <doc xml:space="preserve">Creates a #GSocketAddressEnumerator for @connectable.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSocketAddressEnumerator.</doc>
          <type name="SocketAddressEnumerator" c:type="GSocketAddressEnumerator*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connectable" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketConnectable</doc>
            <type name="SocketConnectable" c:type="GSocketConnectable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="proxy_enumerate" c:identifier="g_socket_connectable_proxy_enumerate" version="2.26">
        <doc xml:space="preserve">Creates a #GSocketAddressEnumerator for @connectable that will
return #GProxyAddresses for addresses that you must connect
to via a proxy.

If @connectable does not implement
g_socket_connectable_proxy_enumerate(), this will fall back to
calling g_socket_connectable_enumerate().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSocketAddressEnumerator.</doc>
          <type name="SocketAddressEnumerator" c:type="GSocketAddressEnumerator*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connectable" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketConnectable</doc>
            <type name="SocketConnectable" c:type="GSocketConnectable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="g_socket_connectable_to_string" version="2.48">
        <doc xml:space="preserve">Format a #GSocketConnectable as a string. This is a human-readable format for
use in debugging output, and is not a stable serialization format. It is not
suitable for use in user interfaces as it exposes too much information for a
user.

If the #GSocketConnectable implementation does not support string formatting,
the implementation&#x2019;s type name will be returned as a fallback.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the formatted string</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connectable" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketConnectable</doc>
            <type name="SocketConnectable" c:type="GSocketConnectable*"/>
          </instance-parameter>
        </parameters>
      </method>
    </interface>
    <record name="SocketConnectableIface" c:type="GSocketConnectableIface" glib:is-gtype-struct-for="SocketConnectable">
      <doc xml:space="preserve">Provides an interface for returning a #GSocketAddressEnumerator
and #GProxyAddressEnumerator</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="enumerate">
        <callback name="enumerate">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a new #GSocketAddressEnumerator.</doc>
            <type name="SocketAddressEnumerator" c:type="GSocketAddressEnumerator*"/>
          </return-value>
          <parameters>
            <parameter name="connectable" transfer-ownership="none">
              <doc xml:space="preserve">a #GSocketConnectable</doc>
              <type name="SocketConnectable" c:type="GSocketConnectable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="proxy_enumerate">
        <callback name="proxy_enumerate">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a new #GSocketAddressEnumerator.</doc>
            <type name="SocketAddressEnumerator" c:type="GSocketAddressEnumerator*"/>
          </return-value>
          <parameters>
            <parameter name="connectable" transfer-ownership="none">
              <doc xml:space="preserve">a #GSocketConnectable</doc>
              <type name="SocketConnectable" c:type="GSocketConnectable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="to_string">
        <callback name="to_string">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the formatted string</doc>
            <type name="utf8" c:type="gchar*"/>
          </return-value>
          <parameters>
            <parameter name="connectable" transfer-ownership="none">
              <doc xml:space="preserve">a #GSocketConnectable</doc>
              <type name="SocketConnectable" c:type="GSocketConnectable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="SocketConnection" c:symbol-prefix="socket_connection" c:type="GSocketConnection" version="2.22" parent="IOStream" glib:type-name="GSocketConnection" glib:get-type="g_socket_connection_get_type" glib:type-struct="SocketConnectionClass">
      <doc xml:space="preserve">#GSocketConnection is a #GIOStream for a connected socket. They
can be created either by #GSocketClient when connecting to a host,
or by #GSocketListener when accepting a new client.

The type of the #GSocketConnection object returned from these calls
depends on the type of the underlying socket that is in use. For
instance, for a TCP/IP connection it will be a #GTcpConnection.

Choosing what type of object to construct is done with the socket
connection factory, and it is possible for 3rd parties to register
custom socket connection types for specific combination of socket
family/type/protocol using g_socket_connection_factory_register_type().

To close a #GSocketConnection, use g_io_stream_close(). Closing both
substreams of the #GIOStream separately will not close the underlying
#GSocket.</doc>
      <function name="factory_lookup_type" c:identifier="g_socket_connection_factory_lookup_type" version="2.22">
        <doc xml:space="preserve">Looks up the #GType to be used when creating socket connections on
sockets with the specified @family, @type and @protocol_id.

If no type is registered, the #GSocketConnection base type is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GType</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <parameter name="family" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketFamily</doc>
            <type name="SocketFamily" c:type="GSocketFamily"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketType</doc>
            <type name="SocketType" c:type="GSocketType"/>
          </parameter>
          <parameter name="protocol_id" transfer-ownership="none">
            <doc xml:space="preserve">a protocol id</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </function>
      <function name="factory_register_type" c:identifier="g_socket_connection_factory_register_type" version="2.22">
        <doc xml:space="preserve">Looks up the #GType to be used when creating socket connections on
sockets with the specified @family, @type and @protocol.

If no type is registered, the #GSocketConnection base type is returned.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="g_type" transfer-ownership="none">
            <doc xml:space="preserve">a #GType, inheriting from %G_TYPE_SOCKET_CONNECTION</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="family" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketFamily</doc>
            <type name="SocketFamily" c:type="GSocketFamily"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketType</doc>
            <type name="SocketType" c:type="GSocketType"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:space="preserve">a protocol id</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </function>
      <method name="connect" c:identifier="g_socket_connection_connect" version="2.32" throws="1">
        <doc xml:space="preserve">Connect @connection to the specified remote address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection succeeded, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketConnection</doc>
            <type name="SocketConnection" c:type="GSocketConnection*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketAddress specifying the remote address.</doc>
            <type name="SocketAddress" c:type="GSocketAddress*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_async" c:identifier="g_socket_connection_connect_async" version="2.32">
        <doc xml:space="preserve">Asynchronously connect @connection to the specified remote address.

This clears the #GSocket:blocking flag on @connection's underlying
socket if it is currently set.

Use g_socket_connection_connect_finish() to retrieve the result.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketConnection</doc>
            <type name="SocketConnection" c:type="GSocketConnection*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketAddress specifying the remote address.</doc>
            <type name="SocketAddress" c:type="GSocketAddress*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data for the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_finish" c:identifier="g_socket_connection_connect_finish" version="2.32" throws="1">
        <doc xml:space="preserve">Gets the result of a g_socket_connection_connect_async() call.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection succeeded, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketConnection</doc>
            <type name="SocketConnection" c:type="GSocketConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_local_address" c:identifier="g_socket_connection_get_local_address" version="2.22" throws="1">
        <doc xml:space="preserve">Try to get the local address of a socket connection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSocketAddress or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketConnection</doc>
            <type name="SocketConnection" c:type="GSocketConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_remote_address" c:identifier="g_socket_connection_get_remote_address" version="2.22" throws="1">
        <doc xml:space="preserve">Try to get the remote address of a socket connection.

Since GLib 2.40, when used with g_socket_client_connect() or
g_socket_client_connect_async(), during emission of
%G_SOCKET_CLIENT_CONNECTING, this function will return the remote
address that will be used for the connection.  This allows
applications to print e.g. "Connecting to example.com
(10.42.77.3)...".</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSocketAddress or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketConnection</doc>
            <type name="SocketConnection" c:type="GSocketConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_socket" c:identifier="g_socket_connection_get_socket" version="2.22">
        <doc xml:space="preserve">Gets the underlying #GSocket object of the connection.
This can be useful if you want to do something unusual on it
not supported by the #GSocketConnection APIs.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GSocket or %NULL on error.</doc>
          <type name="Socket" c:type="GSocket*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketConnection</doc>
            <type name="SocketConnection" c:type="GSocketConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_connected" c:identifier="g_socket_connection_is_connected" version="2.32">
        <doc xml:space="preserve">Checks if @connection is connected. This is equivalent to calling
g_socket_is_connected() on @connection's underlying #GSocket.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @connection is connected</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketConnection</doc>
            <type name="SocketConnection" c:type="GSocketConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="socket" writable="1" construct-only="1" transfer-ownership="none">
        <type name="Socket"/>
      </property>
      <field name="parent_instance">
        <type name="IOStream" c:type="GIOStream"/>
      </field>
      <field name="priv">
        <type name="SocketConnectionPrivate" c:type="GSocketConnectionPrivate*"/>
      </field>
    </class>
    <record name="SocketConnectionClass" c:type="GSocketConnectionClass" glib:is-gtype-struct-for="SocketConnection">
      <field name="parent_class">
        <type name="IOStreamClass" c:type="GIOStreamClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved6" introspectable="0">
        <callback name="_g_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="SocketConnectionPrivate" c:type="GSocketConnectionPrivate" disguised="1">
    </record>
    <class name="SocketControlMessage" c:symbol-prefix="socket_control_message" c:type="GSocketControlMessage" parent="GObject.Object" abstract="1" glib:type-name="GSocketControlMessage" glib:get-type="g_socket_control_message_get_type" glib:type-struct="SocketControlMessageClass">
      <doc xml:space="preserve">A #GSocketControlMessage is a special-purpose utility message that
can be sent to or received from a #GSocket. These types of
messages are often called "ancillary data".

The message can represent some sort of special instruction to or
information from the socket or can represent a special kind of
transfer to the peer (for example, sending a file descriptor over
a UNIX socket).

These messages are sent with g_socket_send_message() and received
with g_socket_receive_message().

To extend the set of control message that can be sent, subclass this
class and override the get_size, get_level, get_type and serialize
methods.

To extend the set of control messages that can be received, subclass
this class and implement the deserialize method. Also, make sure your
class is registered with the GType typesystem before calling
g_socket_receive_message() to read such a message.</doc>
      <function name="deserialize" c:identifier="g_socket_control_message_deserialize" version="2.22">
        <doc xml:space="preserve">Tries to deserialize a socket control message of a given
@level and @type. This will ask all known (to GType) subclasses
of #GSocketControlMessage if they can understand this kind
of message and if so deserialize it into a #GSocketControlMessage.

If there is no implementation for this kind of control message, %NULL
will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the deserialized message or %NULL</doc>
          <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
        </return-value>
        <parameters>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve">a socket level</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a socket control message type for the given @level</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">the size of the data in bytes</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">pointer to the message data</doc>
            <array length="2" zero-terminated="0" c:type="gpointer">
              <type name="guint8"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="get_level" invoker="get_level" version="2.22">
        <doc xml:space="preserve">Returns the "level" (i.e. the originating protocol) of the control message.
This is often SOL_SOCKET.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an integer describing the level</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketControlMessage</doc>
            <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_size" invoker="get_size" version="2.22">
        <doc xml:space="preserve">Returns the space required for the control message, not including
headers or alignment.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of bytes required.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketControlMessage</doc>
            <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_type">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="serialize" invoker="serialize" version="2.22">
        <doc xml:space="preserve">Converts the data in the message to bytes placed in the
message.

@data is guaranteed to have enough space to fit the size
returned by g_socket_control_message_get_size() on this
object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketControlMessage</doc>
            <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">A buffer to write data to</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_level" c:identifier="g_socket_control_message_get_level" version="2.22">
        <doc xml:space="preserve">Returns the "level" (i.e. the originating protocol) of the control message.
This is often SOL_SOCKET.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an integer describing the level</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketControlMessage</doc>
            <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_msg_type" c:identifier="g_socket_control_message_get_msg_type" version="2.22">
        <doc xml:space="preserve">Returns the protocol specific type of the control message.
For instance, for UNIX fd passing this would be SCM_RIGHTS.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an integer describing the type of control message</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketControlMessage</doc>
            <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_size" c:identifier="g_socket_control_message_get_size" version="2.22">
        <doc xml:space="preserve">Returns the space required for the control message, not including
headers or alignment.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of bytes required.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketControlMessage</doc>
            <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="serialize" c:identifier="g_socket_control_message_serialize" version="2.22">
        <doc xml:space="preserve">Converts the data in the message to bytes placed in the
message.

@data is guaranteed to have enough space to fit the size
returned by g_socket_control_message_get_size() on this
object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketControlMessage</doc>
            <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">A buffer to write data to</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="SocketControlMessagePrivate" c:type="GSocketControlMessagePrivate*"/>
      </field>
    </class>
    <record name="SocketControlMessageClass" c:type="GSocketControlMessageClass" glib:is-gtype-struct-for="SocketControlMessage">
      <doc xml:space="preserve">Class structure for #GSocketControlMessage.</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="get_size">
        <callback name="get_size">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The number of bytes required.</doc>
            <type name="gsize" c:type="gsize"/>
          </return-value>
          <parameters>
            <parameter name="message" transfer-ownership="none">
              <doc xml:space="preserve">a #GSocketControlMessage</doc>
              <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_level">
        <callback name="get_level">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">an integer describing the level</doc>
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="message" transfer-ownership="none">
              <doc xml:space="preserve">a #GSocketControlMessage</doc>
              <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_type">
        <callback name="get_type">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="message" transfer-ownership="none">
              <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="serialize">
        <callback name="serialize">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="message" transfer-ownership="none">
              <doc xml:space="preserve">a #GSocketControlMessage</doc>
              <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <doc xml:space="preserve">A buffer to write data to</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="deserialize" introspectable="0">
        <callback name="deserialize" introspectable="0">
          <return-value>
            <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
          </return-value>
          <parameters>
            <parameter name="level" transfer-ownership="none">
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="SocketControlMessagePrivate" c:type="GSocketControlMessagePrivate" disguised="1">
    </record>
    <enumeration name="SocketFamily" version="2.22" glib:type-name="GSocketFamily" glib:get-type="g_socket_family_get_type" c:type="GSocketFamily">
      <doc xml:space="preserve">The protocol family of a #GSocketAddress. (These values are
identical to the system defines %AF_INET, %AF_INET6 and %AF_UNIX,
if available.)</doc>
      <member name="invalid" value="0" c:identifier="G_SOCKET_FAMILY_INVALID" glib:nick="invalid">
        <doc xml:space="preserve">no address family</doc>
      </member>
      <member name="unix" value="1" c:identifier="G_SOCKET_FAMILY_UNIX" glib:nick="unix">
        <doc xml:space="preserve">the UNIX domain family</doc>
      </member>
      <member name="ipv4" value="2" c:identifier="G_SOCKET_FAMILY_IPV4" glib:nick="ipv4">
        <doc xml:space="preserve">the IPv4 family</doc>
      </member>
      <member name="ipv6" value="10" c:identifier="G_SOCKET_FAMILY_IPV6" glib:nick="ipv6">
        <doc xml:space="preserve">the IPv6 family</doc>
      </member>
    </enumeration>
    <class name="SocketListener" c:symbol-prefix="socket_listener" c:type="GSocketListener" version="2.22" parent="GObject.Object" glib:type-name="GSocketListener" glib:get-type="g_socket_listener_get_type" glib:type-struct="SocketListenerClass">
      <doc xml:space="preserve">A #GSocketListener is an object that keeps track of a set
of server sockets and helps you accept sockets from any of the
socket, either sync or async.

Add addresses and ports to listen on using g_socket_listener_add_address()
and g_socket_listener_add_inet_port(). These will be listened on until
g_socket_listener_close() is called. Dropping your final reference to the
#GSocketListener will not cause g_socket_listener_close() to be called
implicitly, as some references to the #GSocketListener may be held
internally.

If you want to implement a network server, also look at #GSocketService
and #GThreadedSocketService which are subclasses of #GSocketListener
that make this even easier.</doc>
      <constructor name="new" c:identifier="g_socket_listener_new" version="2.22">
        <doc xml:space="preserve">Creates a new #GSocketListener with no sockets to listen for.
New listeners can be added with e.g. g_socket_listener_add_address()
or g_socket_listener_add_inet_port().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSocketListener.</doc>
          <type name="SocketListener" c:type="GSocketListener*"/>
        </return-value>
      </constructor>
      <virtual-method name="changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="listener" transfer-ownership="none">
            <type name="SocketListener" c:type="GSocketListener*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="event">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="listener" transfer-ownership="none">
            <type name="SocketListener" c:type="GSocketListener*"/>
          </instance-parameter>
          <parameter name="event" transfer-ownership="none">
            <type name="SocketListenerEvent" c:type="GSocketListenerEvent"/>
          </parameter>
          <parameter name="socket" transfer-ownership="none">
            <type name="Socket" c:type="GSocket*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="accept" c:identifier="g_socket_listener_accept" version="2.22" throws="1">
        <doc xml:space="preserve">Blocks waiting for a client to connect to any of the sockets added
to the listener. Returns a #GSocketConnection for the socket that was
accepted.

If @source_object is not %NULL it will be filled out with the source
object specified when the corresponding socket or address was added
to the listener.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSocketConnection on success, %NULL on error.</doc>
          <type name="SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="listener" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketListener</doc>
            <type name="SocketListener" c:type="GSocketListener*"/>
          </instance-parameter>
          <parameter name="source_object" direction="out" caller-allocates="0" transfer-ownership="none" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">location where #GObject pointer will be stored, or %NULL</doc>
            <type name="GObject.Object" c:type="GObject**"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="accept_async" c:identifier="g_socket_listener_accept_async" version="2.22">
        <doc xml:space="preserve">This is the asynchronous version of g_socket_listener_accept().

When the operation is finished @callback will be
called. You can then call g_socket_listener_accept_socket()
to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="listener" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketListener</doc>
            <type name="SocketListener" c:type="GSocketListener*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data for the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="accept_finish" c:identifier="g_socket_listener_accept_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes an async accept operation. See g_socket_listener_accept_async()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSocketConnection on success, %NULL on error.</doc>
          <type name="SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="listener" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketListener</doc>
            <type name="SocketListener" c:type="GSocketListener*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="source_object" direction="out" caller-allocates="0" transfer-ownership="none" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">Optional #GObject identifying this source</doc>
            <type name="GObject.Object" c:type="GObject**"/>
          </parameter>
        </parameters>
      </method>
      <method name="accept_socket" c:identifier="g_socket_listener_accept_socket" version="2.22" throws="1">
        <doc xml:space="preserve">Blocks waiting for a client to connect to any of the sockets added
to the listener. Returns the #GSocket that was accepted.

If you want to accept the high-level #GSocketConnection, not a #GSocket,
which is often the case, then you should use g_socket_listener_accept()
instead.

If @source_object is not %NULL it will be filled out with the source
object specified when the corresponding socket or address was added
to the listener.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSocket on success, %NULL on error.</doc>
          <type name="Socket" c:type="GSocket*"/>
        </return-value>
        <parameters>
          <instance-parameter name="listener" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketListener</doc>
            <type name="SocketListener" c:type="GSocketListener*"/>
          </instance-parameter>
          <parameter name="source_object" direction="out" caller-allocates="0" transfer-ownership="none" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">location where #GObject pointer will be stored, or %NULL.</doc>
            <type name="GObject.Object" c:type="GObject**"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="accept_socket_async" c:identifier="g_socket_listener_accept_socket_async" version="2.22">
        <doc xml:space="preserve">This is the asynchronous version of g_socket_listener_accept_socket().

When the operation is finished @callback will be
called. You can then call g_socket_listener_accept_socket_finish()
to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="listener" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketListener</doc>
            <type name="SocketListener" c:type="GSocketListener*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data for the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="accept_socket_finish" c:identifier="g_socket_listener_accept_socket_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes an async accept operation. See g_socket_listener_accept_socket_async()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSocket on success, %NULL on error.</doc>
          <type name="Socket" c:type="GSocket*"/>
        </return-value>
        <parameters>
          <instance-parameter name="listener" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketListener</doc>
            <type name="SocketListener" c:type="GSocketListener*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="source_object" direction="out" caller-allocates="0" transfer-ownership="none" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">Optional #GObject identifying this source</doc>
            <type name="GObject.Object" c:type="GObject**"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_address" c:identifier="g_socket_listener_add_address" version="2.22" throws="1">
        <doc xml:space="preserve">Creates a socket of type @type and protocol @protocol, binds
it to @address and adds it to the set of sockets we're accepting
sockets from.

Note that adding an IPv6 address, depending on the platform,
may or may not result in a listener that also accepts IPv4
connections.  For more deterministic behavior, see
g_socket_listener_add_inet_port().

@source_object will be passed out in the various calls
to accept to identify this particular source, which is
useful if you're listening on multiple addresses and do
different things depending on what address is connected to.

If successful and @effective_address is non-%NULL then it will
be set to the address that the binding actually occurred at.  This
is helpful for determining the port number that was used for when
requesting a binding to port 0 (ie: "any port").  This address, if
requested, belongs to the caller and must be freed.

Call g_socket_listener_close() to stop listening on @address; this will not
be done automatically when you drop your final reference to @listener, as
references may be held internally.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="listener" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketListener</doc>
            <type name="SocketListener" c:type="GSocketListener*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketAddress</doc>
            <type name="SocketAddress" c:type="GSocketAddress*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketType</doc>
            <type name="SocketType" c:type="GSocketType"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketProtocol</doc>
            <type name="SocketProtocol" c:type="GSocketProtocol"/>
          </parameter>
          <parameter name="source_object" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional #GObject identifying this source</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="effective_address" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">location to store the address that was bound to, or %NULL.</doc>
            <type name="SocketAddress" c:type="GSocketAddress**"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_any_inet_port" c:identifier="g_socket_listener_add_any_inet_port" version="2.24" throws="1">
        <doc xml:space="preserve">Listens for TCP connections on any available port number for both
IPv6 and IPv4 (if each is available).

This is useful if you need to have a socket for incoming connections
but don't care about the specific port number.

@source_object will be passed out in the various calls
to accept to identify this particular source, which is
useful if you're listening on multiple addresses and do
different things depending on what address is connected to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the port number, or 0 in case of failure.</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="listener" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketListener</doc>
            <type name="SocketListener" c:type="GSocketListener*"/>
          </instance-parameter>
          <parameter name="source_object" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional #GObject identifying this source</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_inet_port" c:identifier="g_socket_listener_add_inet_port" version="2.22" throws="1">
        <doc xml:space="preserve">Helper function for g_socket_listener_add_address() that
creates a TCP/IP socket listening on IPv4 and IPv6 (if
supported) on the specified port on all interfaces.

@source_object will be passed out in the various calls
to accept to identify this particular source, which is
useful if you're listening on multiple addresses and do
different things depending on what address is connected to.

Call g_socket_listener_close() to stop listening on @port; this will not
be done automatically when you drop your final reference to @listener, as
references may be held internally.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="listener" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketListener</doc>
            <type name="SocketListener" c:type="GSocketListener*"/>
          </instance-parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">an IP port number (non-zero)</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
          <parameter name="source_object" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional #GObject identifying this source</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_socket" c:identifier="g_socket_listener_add_socket" version="2.22" throws="1">
        <doc xml:space="preserve">Adds @socket to the set of sockets that we try to accept
new clients from. The socket must be bound to a local
address and listened to.

@source_object will be passed out in the various calls
to accept to identify this particular source, which is
useful if you're listening on multiple addresses and do
different things depending on what address is connected to.

The @socket will not be automatically closed when the @listener is finalized
unless the listener held the final reference to the socket. Before GLib 2.42,
the @socket was automatically closed on finalization of the @listener, even
if references to it were held elsewhere.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="listener" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketListener</doc>
            <type name="SocketListener" c:type="GSocketListener*"/>
          </instance-parameter>
          <parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a listening #GSocket</doc>
            <type name="Socket" c:type="GSocket*"/>
          </parameter>
          <parameter name="source_object" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Optional #GObject identifying this source</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="close" c:identifier="g_socket_listener_close" version="2.22">
        <doc xml:space="preserve">Closes all the sockets in the listener.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="listener" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketListener</doc>
            <type name="SocketListener" c:type="GSocketListener*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_backlog" c:identifier="g_socket_listener_set_backlog" version="2.22">
        <doc xml:space="preserve">Sets the listen backlog on the sockets in the listener.

See g_socket_set_listen_backlog() for details</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="listener" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketListener</doc>
            <type name="SocketListener" c:type="GSocketListener*"/>
          </instance-parameter>
          <parameter name="listen_backlog" transfer-ownership="none">
            <doc xml:space="preserve">an integer</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <property name="listen-backlog" writable="1" construct="1" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="SocketListenerPrivate" c:type="GSocketListenerPrivate*"/>
      </field>
      <glib:signal name="event" when="last" version="2.46">
        <doc xml:space="preserve">Emitted when @listener's activity on @socket changes state.
Note that when @listener is used to listen on both IPv4 and
IPv6, a separate set of signals will be emitted for each, and
the order they happen in is undefined.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="none">
            <doc xml:space="preserve">the event that is occurring</doc>
            <type name="SocketListenerEvent"/>
          </parameter>
          <parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">the #GSocket the event is occurring on</doc>
            <type name="Socket"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="SocketListenerClass" c:type="GSocketListenerClass" glib:is-gtype-struct-for="SocketListener">
      <doc xml:space="preserve">Class structure for #GSocketListener.</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="changed">
        <callback name="changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="listener" transfer-ownership="none">
              <type name="SocketListener" c:type="GSocketListener*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="event">
        <callback name="event">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="listener" transfer-ownership="none">
              <type name="SocketListener" c:type="GSocketListener*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="SocketListenerEvent" c:type="GSocketListenerEvent"/>
            </parameter>
            <parameter name="socket" transfer-ownership="none">
              <type name="Socket" c:type="GSocket*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved6" introspectable="0">
        <callback name="_g_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SocketListenerEvent" version="2.46" glib:type-name="GSocketListenerEvent" glib:get-type="g_socket_listener_event_get_type" c:type="GSocketListenerEvent">
      <doc xml:space="preserve">Describes an event occurring on a #GSocketListener. See the
#GSocketListener::event signal for more details.

Additional values may be added to this type in the future.</doc>
      <member name="binding" value="0" c:identifier="G_SOCKET_LISTENER_BINDING" glib:nick="binding">
        <doc xml:space="preserve">The listener is about to bind a socket.</doc>
      </member>
      <member name="bound" value="1" c:identifier="G_SOCKET_LISTENER_BOUND" glib:nick="bound">
        <doc xml:space="preserve">The listener has bound a socket.</doc>
      </member>
      <member name="listening" value="2" c:identifier="G_SOCKET_LISTENER_LISTENING" glib:nick="listening">
        <doc xml:space="preserve">The listener is about to start
   listening on this socket.</doc>
      </member>
      <member name="listened" value="3" c:identifier="G_SOCKET_LISTENER_LISTENED" glib:nick="listened">
        <doc xml:space="preserve">The listener is now listening on
  this socket.</doc>
      </member>
    </enumeration>
    <record name="SocketListenerPrivate" c:type="GSocketListenerPrivate" disguised="1">
    </record>
    <bitfield name="SocketMsgFlags" version="2.22" glib:type-name="GSocketMsgFlags" glib:get-type="g_socket_msg_flags_get_type" c:type="GSocketMsgFlags">
      <doc xml:space="preserve">Flags used in g_socket_receive_message() and g_socket_send_message().
The flags listed in the enum are some commonly available flags, but the
values used for them are the same as on the platform, and any other flags
are passed in/out as is. So to use a platform specific flag, just include
the right system header and pass in the flag.</doc>
      <member name="none" value="0" c:identifier="G_SOCKET_MSG_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags.</doc>
      </member>
      <member name="oob" value="1" c:identifier="G_SOCKET_MSG_OOB" glib:nick="oob">
        <doc xml:space="preserve">Request to send/receive out of band data.</doc>
      </member>
      <member name="peek" value="2" c:identifier="G_SOCKET_MSG_PEEK" glib:nick="peek">
        <doc xml:space="preserve">Read data from the socket without removing it from
    the queue.</doc>
      </member>
      <member name="dontroute" value="4" c:identifier="G_SOCKET_MSG_DONTROUTE" glib:nick="dontroute">
        <doc xml:space="preserve">Don't use a gateway to send out the packet,
    only send to hosts on directly connected networks.</doc>
      </member>
    </bitfield>
    <record name="SocketPrivate" c:type="GSocketPrivate" disguised="1">
    </record>
    <enumeration name="SocketProtocol" version="2.22" glib:type-name="GSocketProtocol" glib:get-type="g_socket_protocol_get_type" c:type="GSocketProtocol">
      <doc xml:space="preserve">A protocol identifier is specified when creating a #GSocket, which is a
family/type specific identifier, where 0 means the default protocol for
the particular family/type.

This enum contains a set of commonly available and used protocols. You
can also pass any other identifiers handled by the platform in order to
use protocols not listed here.</doc>
      <member name="unknown" value="-1" c:identifier="G_SOCKET_PROTOCOL_UNKNOWN" glib:nick="unknown">
        <doc xml:space="preserve">The protocol type is unknown</doc>
      </member>
      <member name="default" value="0" c:identifier="G_SOCKET_PROTOCOL_DEFAULT" glib:nick="default">
        <doc xml:space="preserve">The default protocol for the family/type</doc>
      </member>
      <member name="tcp" value="6" c:identifier="G_SOCKET_PROTOCOL_TCP" glib:nick="tcp">
        <doc xml:space="preserve">TCP over IP</doc>
      </member>
      <member name="udp" value="17" c:identifier="G_SOCKET_PROTOCOL_UDP" glib:nick="udp">
        <doc xml:space="preserve">UDP over IP</doc>
      </member>
      <member name="sctp" value="132" c:identifier="G_SOCKET_PROTOCOL_SCTP" glib:nick="sctp">
        <doc xml:space="preserve">SCTP over IP</doc>
      </member>
    </enumeration>
    <class name="SocketService" c:symbol-prefix="socket_service" c:type="GSocketService" version="2.22" parent="SocketListener" glib:type-name="GSocketService" glib:get-type="g_socket_service_get_type" glib:type-struct="SocketServiceClass">
      <doc xml:space="preserve">A #GSocketService is an object that represents a service that
is provided to the network or over local sockets.  When a new
connection is made to the service the #GSocketService::incoming
signal is emitted.

A #GSocketService is a subclass of #GSocketListener and you need
to add the addresses you want to accept connections on with the
#GSocketListener APIs.

There are two options for implementing a network service based on
#GSocketService. The first is to create the service using
g_socket_service_new() and to connect to the #GSocketService::incoming
signal. The second is to subclass #GSocketService and override the
default signal handler implementation.

In either case, the handler must immediately return, or else it
will block additional incoming connections from being serviced.
If you are interested in writing connection handlers that contain
blocking code then see #GThreadedSocketService.

The socket service runs on the main loop of the
[thread-default context][g-main-context-push-thread-default-context]
of the thread it is created in, and is not
threadsafe in general. However, the calls to start and stop the
service are thread-safe so these can be used from threads that
handle incoming clients.</doc>
      <constructor name="new" c:identifier="g_socket_service_new" version="2.22">
        <doc xml:space="preserve">Creates a new #GSocketService with no sockets to listen for.
New listeners can be added with e.g. g_socket_listener_add_address()
or g_socket_listener_add_inet_port().

New services are created active, there is no need to call
g_socket_service_start(), unless g_socket_service_stop() has been
called before.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSocketService.</doc>
          <type name="SocketService" c:type="GSocketService*"/>
        </return-value>
      </constructor>
      <virtual-method name="incoming">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <type name="SocketService" c:type="GSocketService*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="SocketConnection" c:type="GSocketConnection*"/>
          </parameter>
          <parameter name="source_object" transfer-ownership="none">
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="is_active" c:identifier="g_socket_service_is_active" version="2.22">
        <doc xml:space="preserve">Check whether the service is active or not. An active
service will accept new clients that connect, while
a non-active service will let connecting clients queue
up until the service is started.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the service is active, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketService</doc>
            <type name="SocketService" c:type="GSocketService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="start" c:identifier="g_socket_service_start" version="2.22">
        <doc xml:space="preserve">Restarts the service, i.e. start accepting connections
from the added sockets when the mainloop runs. This only needs
to be called after the service has been stopped from
g_socket_service_stop().

This call is thread-safe, so it may be called from a thread
handling an incoming client request.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketService</doc>
            <type name="SocketService" c:type="GSocketService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="stop" c:identifier="g_socket_service_stop" version="2.22">
        <doc xml:space="preserve">Stops the service, i.e. stops accepting connections
from the added sockets when the mainloop runs.

This call is thread-safe, so it may be called from a thread
handling an incoming client request.

Note that this only stops accepting new connections; it does not
close the listening sockets, and you can call
g_socket_service_start() again later to begin listening again. To
close the listening sockets, call g_socket_listener_close(). (This
will happen automatically when the #GSocketService is finalized.)

This must be called before calling g_socket_listener_close() as
the socket service will start accepting connections immediately
when a new socket is added.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketService</doc>
            <type name="SocketService" c:type="GSocketService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="active" version="2.46" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether the service is currently accepting connections.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent_instance">
        <type name="SocketListener" c:type="GSocketListener"/>
      </field>
      <field name="priv">
        <type name="SocketServicePrivate" c:type="GSocketServicePrivate*"/>
      </field>
      <glib:signal name="incoming" when="last" version="2.22">
        <doc xml:space="preserve">The ::incoming signal is emitted when a new incoming connection
to @service needs to be handled. The handler must initiate the
handling of @connection, but may not block; in essence,
asynchronous operations must be used.

@connection will be unreffed once the signal handler returns,
so you need to ref it yourself if you are planning to use it.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE to stop other handlers from being called</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a new #GSocketConnection object</doc>
            <type name="SocketConnection"/>
          </parameter>
          <parameter name="source_object" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the source_object passed to
    g_socket_listener_add_address()</doc>
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="SocketServiceClass" c:type="GSocketServiceClass" glib:is-gtype-struct-for="SocketService">
      <doc xml:space="preserve">Class structure for #GSocketService.</doc>
      <field name="parent_class">
        <type name="SocketListenerClass" c:type="GSocketListenerClass"/>
      </field>
      <field name="incoming">
        <callback name="incoming">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="service" transfer-ownership="none">
              <type name="SocketService" c:type="GSocketService*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="SocketConnection" c:type="GSocketConnection*"/>
            </parameter>
            <parameter name="source_object" transfer-ownership="none">
              <type name="GObject.Object" c:type="GObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved6" introspectable="0">
        <callback name="_g_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="SocketServicePrivate" c:type="GSocketServicePrivate" disguised="1">
    </record>
    <callback name="SocketSourceFunc" c:type="GSocketSourceFunc" version="2.22">
      <doc xml:space="preserve">This is the function type of the callback used for the #GSource
returned by g_socket_create_source().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">it should return %FALSE if the source should be removed.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="socket" transfer-ownership="none">
          <doc xml:space="preserve">the #GSocket</doc>
          <type name="Socket" c:type="GSocket*"/>
        </parameter>
        <parameter name="condition" transfer-ownership="none">
          <doc xml:space="preserve">the current condition at the source fired.</doc>
          <type name="GLib.IOCondition" c:type="GIOCondition"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">data passed in by the user.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="SocketType" version="2.22" glib:type-name="GSocketType" glib:get-type="g_socket_type_get_type" c:type="GSocketType">
      <doc xml:space="preserve">Flags used when creating a #GSocket. Some protocols may not implement
all the socket types.</doc>
      <member name="invalid" value="0" c:identifier="G_SOCKET_TYPE_INVALID" glib:nick="invalid">
        <doc xml:space="preserve">Type unknown or wrong</doc>
      </member>
      <member name="stream" value="1" c:identifier="G_SOCKET_TYPE_STREAM" glib:nick="stream">
        <doc xml:space="preserve">Reliable connection-based byte streams (e.g. TCP).</doc>
      </member>
      <member name="datagram" value="2" c:identifier="G_SOCKET_TYPE_DATAGRAM" glib:nick="datagram">
        <doc xml:space="preserve">Connectionless, unreliable datagram passing.
    (e.g. UDP)</doc>
      </member>
      <member name="seqpacket" value="3" c:identifier="G_SOCKET_TYPE_SEQPACKET" glib:nick="seqpacket">
        <doc xml:space="preserve">Reliable connection-based passing of datagrams
    of fixed maximum length (e.g. SCTP).</doc>
      </member>
    </enumeration>
    <record name="SrvTarget" c:type="GSrvTarget" glib:type-name="GSrvTarget" glib:get-type="g_srv_target_get_type" c:symbol-prefix="srv_target">
      <doc xml:space="preserve">SRV (service) records are used by some network protocols to provide
service-specific aliasing and load-balancing. For example, XMPP
(Jabber) uses SRV records to locate the XMPP server for a domain;
rather than connecting directly to "example.com" or assuming a
specific server hostname like "xmpp.example.com", an XMPP client
would look up the "xmpp-client" SRV record for "example.com", and
then connect to whatever host was pointed to by that record.

You can use g_resolver_lookup_service() or
g_resolver_lookup_service_async() to find the #GSrvTargets
for a given service. However, if you are simply planning to connect
to the remote service, you can use #GNetworkService's
#GSocketConnectable interface and not need to worry about
#GSrvTarget at all.</doc>
      <constructor name="new" c:identifier="g_srv_target_new" version="2.22">
        <doc xml:space="preserve">Creates a new #GSrvTarget with the given parameters.

You should not need to use this; normally #GSrvTargets are
created by #GResolver.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSrvTarget.</doc>
          <type name="SrvTarget" c:type="GSrvTarget*"/>
        </return-value>
        <parameters>
          <parameter name="hostname" transfer-ownership="none">
            <doc xml:space="preserve">the host that the service is running on</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">the port that the service is running on</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
          <parameter name="priority" transfer-ownership="none">
            <doc xml:space="preserve">the target's priority</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
          <parameter name="weight" transfer-ownership="none">
            <doc xml:space="preserve">the target's weight</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="g_srv_target_copy" version="2.22">
        <doc xml:space="preserve">Copies @target</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a copy of @target</doc>
          <type name="SrvTarget" c:type="GSrvTarget*"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">a #GSrvTarget</doc>
            <type name="SrvTarget" c:type="GSrvTarget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_srv_target_free" version="2.22">
        <doc xml:space="preserve">Frees @target</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">a #GSrvTarget</doc>
            <type name="SrvTarget" c:type="GSrvTarget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hostname" c:identifier="g_srv_target_get_hostname" version="2.22">
        <doc xml:space="preserve">Gets @target's hostname (in ASCII form; if you are going to present
this to the user, you should use g_hostname_is_ascii_encoded() to
check if it contains encoded Unicode segments, and use
g_hostname_to_unicode() to convert it if it does.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@target's hostname</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">a #GSrvTarget</doc>
            <type name="SrvTarget" c:type="GSrvTarget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_port" c:identifier="g_srv_target_get_port" version="2.22">
        <doc xml:space="preserve">Gets @target's port</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@target's port</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">a #GSrvTarget</doc>
            <type name="SrvTarget" c:type="GSrvTarget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_priority" c:identifier="g_srv_target_get_priority" version="2.22">
        <doc xml:space="preserve">Gets @target's priority. You should not need to look at this;
#GResolver already sorts the targets according to the algorithm in
RFC 2782.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@target's priority</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">a #GSrvTarget</doc>
            <type name="SrvTarget" c:type="GSrvTarget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_weight" c:identifier="g_srv_target_get_weight" version="2.22">
        <doc xml:space="preserve">Gets @target's weight. You should not need to look at this;
#GResolver already sorts the targets according to the algorithm in
RFC 2782.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@target's weight</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">a #GSrvTarget</doc>
            <type name="SrvTarget" c:type="GSrvTarget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="list_sort" c:identifier="g_srv_target_list_sort" version="2.22" introspectable="0">
        <doc xml:space="preserve">Sorts @targets in place according to the algorithm in RFC 2782.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the head of the sorted list.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="targets" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of #GSrvTarget</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="StaticResource" c:type="GStaticResource">
      <doc xml:space="preserve">#GStaticResource is an opaque data structure and can only be accessed
using the following functions.</doc>
      <field name="data" readable="0" private="1">
        <type name="guint8" c:type="const guint8*"/>
      </field>
      <field name="data_len" readable="0" private="1">
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="resource" readable="0" private="1">
        <type name="Resource" c:type="GResource*"/>
      </field>
      <field name="next" readable="0" private="1">
        <type name="StaticResource" c:type="GStaticResource*"/>
      </field>
      <field name="padding" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <method name="fini" c:identifier="g_static_resource_fini" version="2.32">
        <doc xml:space="preserve">Finalized a GResource initialized by g_static_resource_init().

This is normally used by code generated by
[glib-compile-resources][glib-compile-resources]
and is not typically used by other code.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="static_resource" transfer-ownership="none">
            <doc xml:space="preserve">pointer to a static #GStaticResource</doc>
            <type name="StaticResource" c:type="GStaticResource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_resource" c:identifier="g_static_resource_get_resource" version="2.32">
        <doc xml:space="preserve">Gets the GResource that was registered by a call to g_static_resource_init().

This is normally used by code generated by
[glib-compile-resources][glib-compile-resources]
and is not typically used by other code.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GResource</doc>
          <type name="Resource" c:type="GResource*"/>
        </return-value>
        <parameters>
          <instance-parameter name="static_resource" transfer-ownership="none">
            <doc xml:space="preserve">pointer to a static #GStaticResource</doc>
            <type name="StaticResource" c:type="GStaticResource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="g_static_resource_init" version="2.32">
        <doc xml:space="preserve">Initializes a GResource from static data using a
GStaticResource.

This is normally used by code generated by
[glib-compile-resources][glib-compile-resources]
and is not typically used by other code.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="static_resource" transfer-ownership="none">
            <doc xml:space="preserve">pointer to a static #GStaticResource</doc>
            <type name="StaticResource" c:type="GStaticResource*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <class name="Subprocess" c:symbol-prefix="subprocess" c:type="GSubprocess" version="2.40" parent="GObject.Object" glib:type-name="GSubprocess" glib:get-type="g_subprocess_get_type">
      <doc xml:space="preserve">#GSubprocess allows the creation of and interaction with child
processes.

Processes can be communicated with using standard GIO-style APIs (ie:
#GInputStream, #GOutputStream).  There are GIO-style APIs to wait for
process termination (ie: cancellable and with an asynchronous
variant).

There is an API to force a process to terminate, as well as a
race-free API for sending UNIX signals to a subprocess.

One major advantage that GIO brings over the core GLib library is
comprehensive API for asynchronous I/O, such
g_output_stream_splice_async().  This makes GSubprocess
significantly more powerful and flexible than equivalent APIs in
some other languages such as the `subprocess.py`
included with Python.  For example, using #GSubprocess one could
create two child processes, reading standard output from the first,
processing it, and writing to the input stream of the second, all
without blocking the main loop.

A powerful g_subprocess_communicate() API is provided similar to the
`communicate()` method of `subprocess.py`. This enables very easy
interaction with a subprocess that has been opened with pipes.

#GSubprocess defaults to tight control over the file descriptors open
in the child process, avoiding dangling-fd issues that are caused by
a simple fork()/exec().  The only open file descriptors in the
spawned process are ones that were explicitly specified by the
#GSubprocess API (unless %G_SUBPROCESS_FLAGS_INHERIT_FDS was
specified).

#GSubprocess will quickly reap all child processes as they exit,
avoiding "zombie processes" remaining around for long periods of
time.  g_subprocess_wait() can be used to wait for this to happen,
but it will happen even without the call being explicitly made.

As a matter of principle, #GSubprocess has no API that accepts
shell-style space-separated strings.  It will, however, match the
typical shell behaviour of searching the PATH for executables that do
not contain a directory separator in their name.

#GSubprocess attempts to have a very simple API for most uses (ie:
spawning a subprocess with arguments and support for most typical
kinds of input and output redirection).  See g_subprocess_new(). The
#GSubprocessLauncher API is provided for more complicated cases
(advanced types of redirection, environment variable manipulation,
change of working directory, child setup functions, etc).

A typical use of #GSubprocess will involve calling
g_subprocess_new(), followed by g_subprocess_wait_async() or
g_subprocess_wait().  After the process exits, the status can be
checked using functions such as g_subprocess_get_if_exited() (which
are similar to the familiar WIFEXITED-style POSIX macros).</doc>
      <implements name="Initable"/>
      <constructor name="new" c:identifier="g_subprocess_new" shadowed-by="newv" version="2.40" introspectable="0">
        <doc xml:space="preserve">Create a new process with the given flags and varargs argument
list.  By default, matching the g_spawn_async() defaults, the
child's stdin will be set to the system null device, and
stdout/stderr will be inherited from the parent.  You can use
@flags to control this behavior.

The argument list must be terminated with %NULL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly created #GSubprocess, or %NULL on error (and @error
  will be set)</doc>
          <type name="Subprocess" c:type="GSubprocess*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags that define the behaviour of the subprocess</doc>
            <type name="SubprocessFlags" c:type="GSubprocessFlags"/>
          </parameter>
          <parameter name="error" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">return location for an error, or %NULL</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="argv0" transfer-ownership="none">
            <doc xml:space="preserve">first commandline argument to pass to the subprocess</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">more commandline arguments, followed by %NULL</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="newv" c:identifier="g_subprocess_newv" shadows="new" version="2.40" throws="1">
        <doc xml:space="preserve">Create a new process with the given flags and argument list.

The argument list is expected to be %NULL-terminated.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly created #GSubprocess, or %NULL on error (and @error
  will be set)</doc>
          <type name="Subprocess" c:type="GSubprocess*"/>
        </return-value>
        <parameters>
          <parameter name="argv" transfer-ownership="none">
            <doc xml:space="preserve">commandline arguments for the subprocess</doc>
            <array c:type="const gchar* const*">
              <type name="filename"/>
            </array>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags that define the behaviour of the subprocess</doc>
            <type name="SubprocessFlags" c:type="GSubprocessFlags"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="communicate" c:identifier="g_subprocess_communicate" version="2.40" throws="1">
        <doc xml:space="preserve">Communicate with the subprocess until it terminates, and all input
and output has been completed.

If @stdin_buf is given, the subprocess must have been created with
%G_SUBPROCESS_FLAGS_STDIN_PIPE.  The given data is fed to the
stdin of the subprocess and the pipe is closed (ie: EOF).

At the same time (as not to cause blocking when dealing with large
amounts of data), if %G_SUBPROCESS_FLAGS_STDOUT_PIPE or
%G_SUBPROCESS_FLAGS_STDERR_PIPE were used, reads from those
streams.  The data that was read is returned in @stdout and/or
the @stderr.

If the subprocess was created with %G_SUBPROCESS_FLAGS_STDOUT_PIPE,
@stdout_buf will contain the data read from stdout.  Otherwise, for
subprocesses not created with %G_SUBPROCESS_FLAGS_STDOUT_PIPE,
@stdout_buf will be set to %NULL.  Similar provisions apply to
@stderr_buf and %G_SUBPROCESS_FLAGS_STDERR_PIPE.

As usual, any output variable may be given as %NULL to ignore it.

If you desire the stdout and stderr data to be interleaved, create
the subprocess with %G_SUBPROCESS_FLAGS_STDOUT_PIPE and
%G_SUBPROCESS_FLAGS_STDERR_MERGE.  The merged result will be returned
in @stdout_buf and @stderr_buf will be set to %NULL.

In case of any error (including cancellation), %FALSE will be
returned with @error set.  Some or all of the stdin data may have
been written.  Any stdout or stderr data that has been read will be
discarded. None of the out variables (aside from @error) will have
been set to anything in particular and should not be inspected.

In the case that %TRUE is returned, the subprocess has exited and the
exit status inspection APIs (eg: g_subprocess_get_if_exited(),
g_subprocess_get_exit_status()) may be used.

You should not attempt to use any of the subprocess pipes after
starting this function, since they may be left in strange states,
even if the operation was cancelled.  You should especially not
attempt to interact with the pipes while the operation is in progress
(either from another thread or if using the asynchronous version).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if successful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="subprocess" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocess</doc>
            <type name="Subprocess" c:type="GSubprocess*"/>
          </instance-parameter>
          <parameter name="stdin_buf" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to send to the stdin of the subprocess, or %NULL</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="stdout_buf" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">data read from the subprocess stdout</doc>
            <type name="GLib.Bytes" c:type="GBytes**"/>
          </parameter>
          <parameter name="stderr_buf" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">data read from the subprocess stderr</doc>
            <type name="GLib.Bytes" c:type="GBytes**"/>
          </parameter>
        </parameters>
      </method>
      <method name="communicate_async" c:identifier="g_subprocess_communicate_async">
        <doc xml:space="preserve">Asynchronous version of g_subprocess_communicate().  Complete
invocation with g_subprocess_communicate_finish().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="subprocess" transfer-ownership="none">
            <doc xml:space="preserve">Self</doc>
            <type name="Subprocess" c:type="GSubprocess*"/>
          </instance-parameter>
          <parameter name="stdin_buf" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Input data, or %NULL</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Cancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">Callback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">User data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="communicate_finish" c:identifier="g_subprocess_communicate_finish" throws="1">
        <doc xml:space="preserve">Complete an invocation of g_subprocess_communicate_async().</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="subprocess" transfer-ownership="none">
            <doc xml:space="preserve">Self</doc>
            <type name="Subprocess" c:type="GSubprocess*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">Result</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="stdout_buf" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">Return location for stdout data</doc>
            <type name="GLib.Bytes" c:type="GBytes**"/>
          </parameter>
          <parameter name="stderr_buf" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">Return location for stderr data</doc>
            <type name="GLib.Bytes" c:type="GBytes**"/>
          </parameter>
        </parameters>
      </method>
      <method name="communicate_utf8" c:identifier="g_subprocess_communicate_utf8" throws="1">
        <doc xml:space="preserve">Like g_subprocess_communicate(), but validates the output of the
process as UTF-8, and returns it as a regular NUL terminated string.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="subprocess" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocess</doc>
            <type name="Subprocess" c:type="GSubprocess*"/>
          </instance-parameter>
          <parameter name="stdin_buf" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to send to the stdin of the subprocess, or %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="stdout_buf" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">data read from the subprocess stdout</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
          <parameter name="stderr_buf" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">data read from the subprocess stderr</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="communicate_utf8_async" c:identifier="g_subprocess_communicate_utf8_async">
        <doc xml:space="preserve">Asynchronous version of g_subprocess_communicate_utf8().  Complete
invocation with g_subprocess_communicate_utf8_finish().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="subprocess" transfer-ownership="none">
            <doc xml:space="preserve">Self</doc>
            <type name="Subprocess" c:type="GSubprocess*"/>
          </instance-parameter>
          <parameter name="stdin_buf" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Input data, or %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Cancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">Callback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">User data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="communicate_utf8_finish" c:identifier="g_subprocess_communicate_utf8_finish" throws="1">
        <doc xml:space="preserve">Complete an invocation of g_subprocess_communicate_utf8_async().</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="subprocess" transfer-ownership="none">
            <doc xml:space="preserve">Self</doc>
            <type name="Subprocess" c:type="GSubprocess*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">Result</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="stdout_buf" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">Return location for stdout data</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
          <parameter name="stderr_buf" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">Return location for stderr data</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="force_exit" c:identifier="g_subprocess_force_exit" version="2.40">
        <doc xml:space="preserve">Use an operating-system specific method to attempt an immediate,
forceful termination of the process.  There is no mechanism to
determine whether or not the request itself was successful;
however, you can use g_subprocess_wait() to monitor the status of
the process after calling this function.

On Unix, this function sends %SIGKILL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="subprocess" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocess</doc>
            <type name="Subprocess" c:type="GSubprocess*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_exit_status" c:identifier="g_subprocess_get_exit_status" version="2.40">
        <doc xml:space="preserve">Check the exit status of the subprocess, given that it exited
normally.  This is the value passed to the exit() system call or the
return value from main.

This is equivalent to the system WEXITSTATUS macro.

It is an error to call this function before g_subprocess_wait() and
unless g_subprocess_get_if_exited() returned %TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the exit status</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="subprocess" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocess</doc>
            <type name="Subprocess" c:type="GSubprocess*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_identifier" c:identifier="g_subprocess_get_identifier">
        <doc xml:space="preserve">On UNIX, returns the process ID as a decimal string.
On Windows, returns the result of GetProcessId() also as a string.</doc>
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="subprocess" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocess</doc>
            <type name="Subprocess" c:type="GSubprocess*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_if_exited" c:identifier="g_subprocess_get_if_exited" version="2.40">
        <doc xml:space="preserve">Check if the given subprocess exited normally (ie: by way of exit()
or return from main()).

This is equivalent to the system WIFEXITED macro.

It is an error to call this function before g_subprocess_wait() has
returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the case of a normal exit</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="subprocess" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocess</doc>
            <type name="Subprocess" c:type="GSubprocess*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_if_signaled" c:identifier="g_subprocess_get_if_signaled" version="2.40">
        <doc xml:space="preserve">Check if the given subprocess terminated in response to a signal.

This is equivalent to the system WIFSIGNALED macro.

It is an error to call this function before g_subprocess_wait() has
returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the case of termination due to a signal</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="subprocess" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocess</doc>
            <type name="Subprocess" c:type="GSubprocess*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_status" c:identifier="g_subprocess_get_status" version="2.40">
        <doc xml:space="preserve">Gets the raw status code of the process, as from waitpid().

This value has no particular meaning, but it can be used with the
macros defined by the system headers such as WIFEXITED.  It can also
be used with g_spawn_check_exit_status().

It is more likely that you want to use g_subprocess_get_if_exited()
followed by g_subprocess_get_exit_status().

It is an error to call this function before g_subprocess_wait() has
returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the (meaningless) waitpid() exit status from the kernel</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="subprocess" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocess</doc>
            <type name="Subprocess" c:type="GSubprocess*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_stderr_pipe" c:identifier="g_subprocess_get_stderr_pipe" version="2.40">
        <doc xml:space="preserve">Gets the #GInputStream from which to read the stderr output of
@subprocess.

The process must have been created with
%G_SUBPROCESS_FLAGS_STDERR_PIPE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the stderr pipe</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="subprocess" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocess</doc>
            <type name="Subprocess" c:type="GSubprocess*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_stdin_pipe" c:identifier="g_subprocess_get_stdin_pipe" version="2.40">
        <doc xml:space="preserve">Gets the #GOutputStream that you can write to in order to give data
to the stdin of @subprocess.

The process must have been created with
%G_SUBPROCESS_FLAGS_STDIN_PIPE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the stdout pipe</doc>
          <type name="OutputStream" c:type="GOutputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="subprocess" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocess</doc>
            <type name="Subprocess" c:type="GSubprocess*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_stdout_pipe" c:identifier="g_subprocess_get_stdout_pipe" version="2.40">
        <doc xml:space="preserve">Gets the #GInputStream from which to read the stdout output of
@subprocess.

The process must have been created with
%G_SUBPROCESS_FLAGS_STDOUT_PIPE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the stdout pipe</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="subprocess" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocess</doc>
            <type name="Subprocess" c:type="GSubprocess*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_successful" c:identifier="g_subprocess_get_successful" version="2.40">
        <doc xml:space="preserve">Checks if the process was "successful".  A process is considered
successful if it exited cleanly with an exit status of 0, either by
way of the exit() system call or return from main().

It is an error to call this function before g_subprocess_wait() has
returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the process exited cleanly with a exit status of 0</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="subprocess" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocess</doc>
            <type name="Subprocess" c:type="GSubprocess*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_term_sig" c:identifier="g_subprocess_get_term_sig" version="2.40">
        <doc xml:space="preserve">Get the signal number that caused the subprocess to terminate, given
that it terminated due to a signal.

This is equivalent to the system WTERMSIG macro.

It is an error to call this function before g_subprocess_wait() and
unless g_subprocess_get_if_signaled() returned %TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the signal causing termination</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="subprocess" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocess</doc>
            <type name="Subprocess" c:type="GSubprocess*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="send_signal" c:identifier="g_subprocess_send_signal" version="2.40">
        <doc xml:space="preserve">Sends the UNIX signal @signal_num to the subprocess, if it is still
running.

This API is race-free.  If the subprocess has terminated, it will not
be signalled.

This API is not available on Windows.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="subprocess" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocess</doc>
            <type name="Subprocess" c:type="GSubprocess*"/>
          </instance-parameter>
          <parameter name="signal_num" transfer-ownership="none">
            <doc xml:space="preserve">the signal number to send</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="wait" c:identifier="g_subprocess_wait" version="2.40" throws="1">
        <doc xml:space="preserve">Synchronously wait for the subprocess to terminate.

After the process terminates you can query its exit status with
functions such as g_subprocess_get_if_exited() and
g_subprocess_get_exit_status().

This function does not fail in the case of the subprocess having
abnormal termination.  See g_subprocess_wait_check() for that.

Cancelling @cancellable doesn't kill the subprocess.  Call
g_subprocess_force_exit() if it is desirable.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if @cancellable was cancelled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="subprocess" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocess</doc>
            <type name="Subprocess" c:type="GSubprocess*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="wait_async" c:identifier="g_subprocess_wait_async" version="2.40">
        <doc xml:space="preserve">Wait for the subprocess to terminate.

This is the asynchronous version of g_subprocess_wait().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="subprocess" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocess</doc>
            <type name="Subprocess" c:type="GSubprocess*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the operation is complete</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user_data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="wait_check" c:identifier="g_subprocess_wait_check" version="2.40" throws="1">
        <doc xml:space="preserve">Combines g_subprocess_wait() with g_spawn_check_exit_status().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if process exited abnormally, or
@cancellable was cancelled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="subprocess" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocess</doc>
            <type name="Subprocess" c:type="GSubprocess*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="wait_check_async" c:identifier="g_subprocess_wait_check_async" version="2.40">
        <doc xml:space="preserve">Combines g_subprocess_wait_async() with g_spawn_check_exit_status().

This is the asynchronous version of g_subprocess_wait_check().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="subprocess" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocess</doc>
            <type name="Subprocess" c:type="GSubprocess*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the operation is complete</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user_data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="wait_check_finish" c:identifier="g_subprocess_wait_check_finish" version="2.40" throws="1">
        <doc xml:space="preserve">Collects the result of a previous call to
g_subprocess_wait_check_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if successful, or %FALSE with @error set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="subprocess" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocess</doc>
            <type name="Subprocess" c:type="GSubprocess*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="wait_finish" c:identifier="g_subprocess_wait_finish" version="2.40" throws="1">
        <doc xml:space="preserve">Collects the result of a previous call to
g_subprocess_wait_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if successful, or %FALSE with @error set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="subprocess" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocess</doc>
            <type name="Subprocess" c:type="GSubprocess*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="argv" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="flags" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <type name="SubprocessFlags"/>
      </property>
    </class>
    <bitfield name="SubprocessFlags" version="2.40" glib:type-name="GSubprocessFlags" glib:get-type="g_subprocess_flags_get_type" c:type="GSubprocessFlags">
      <doc xml:space="preserve">Flags to define the behaviour of a #GSubprocess.

Note that the default for stdin is to redirect from `/dev/null`.  For
stdout and stderr the default are for them to inherit the
corresponding descriptor from the calling process.

Note that it is a programmer error to mix 'incompatible' flags.  For
example, you may not request both %G_SUBPROCESS_FLAGS_STDOUT_PIPE and
%G_SUBPROCESS_FLAGS_STDOUT_SILENCE.</doc>
      <member name="none" value="0" c:identifier="G_SUBPROCESS_FLAGS_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags.</doc>
      </member>
      <member name="stdin_pipe" value="1" c:identifier="G_SUBPROCESS_FLAGS_STDIN_PIPE" glib:nick="stdin-pipe">
        <doc xml:space="preserve">create a pipe for the stdin of the
  spawned process that can be accessed with
  g_subprocess_get_stdin_pipe().</doc>
      </member>
      <member name="stdin_inherit" value="2" c:identifier="G_SUBPROCESS_FLAGS_STDIN_INHERIT" glib:nick="stdin-inherit">
        <doc xml:space="preserve">stdin is inherited from the
  calling process.</doc>
      </member>
      <member name="stdout_pipe" value="4" c:identifier="G_SUBPROCESS_FLAGS_STDOUT_PIPE" glib:nick="stdout-pipe">
        <doc xml:space="preserve">create a pipe for the stdout of the
  spawned process that can be accessed with
  g_subprocess_get_stdout_pipe().</doc>
      </member>
      <member name="stdout_silence" value="8" c:identifier="G_SUBPROCESS_FLAGS_STDOUT_SILENCE" glib:nick="stdout-silence">
        <doc xml:space="preserve">silence the stdout of the spawned
  process (ie: redirect to `/dev/null`).</doc>
      </member>
      <member name="stderr_pipe" value="16" c:identifier="G_SUBPROCESS_FLAGS_STDERR_PIPE" glib:nick="stderr-pipe">
        <doc xml:space="preserve">create a pipe for the stderr of the
  spawned process that can be accessed with
  g_subprocess_get_stderr_pipe().</doc>
      </member>
      <member name="stderr_silence" value="32" c:identifier="G_SUBPROCESS_FLAGS_STDERR_SILENCE" glib:nick="stderr-silence">
        <doc xml:space="preserve">silence the stderr of the spawned
  process (ie: redirect to `/dev/null`).</doc>
      </member>
      <member name="stderr_merge" value="64" c:identifier="G_SUBPROCESS_FLAGS_STDERR_MERGE" glib:nick="stderr-merge">
        <doc xml:space="preserve">merge the stderr of the spawned
  process with whatever the stdout happens to be.  This is a good way
  of directing both streams to a common log file, for example.</doc>
      </member>
      <member name="inherit_fds" value="128" c:identifier="G_SUBPROCESS_FLAGS_INHERIT_FDS" glib:nick="inherit-fds">
        <doc xml:space="preserve">spawned processes will inherit the
  file descriptors of their parent, unless those descriptors have
  been explicitly marked as close-on-exec.  This flag has no effect
  over the "standard" file descriptors (stdin, stdout, stderr).</doc>
      </member>
    </bitfield>
    <class name="SubprocessLauncher" c:symbol-prefix="subprocess_launcher" c:type="GSubprocessLauncher" version="2.40" parent="GObject.Object" glib:type-name="GSubprocessLauncher" glib:get-type="g_subprocess_launcher_get_type">
      <doc xml:space="preserve">This class contains a set of options for launching child processes,
such as where its standard input and output will be directed, the
argument list, the environment, and more.

While the #GSubprocess class has high level functions covering
popular cases, use of this class allows access to more advanced
options.  It can also be used to launch multiple subprocesses with
a similar configuration.</doc>
      <constructor name="new" c:identifier="g_subprocess_launcher_new" version="2.40">
        <doc xml:space="preserve">Creates a new #GSubprocessLauncher.

The launcher is created with the default options.  A copy of the
environment of the calling process is made at the time of this call
and will be used as the environment that the process is launched in.</doc>
        <return-value transfer-ownership="full">
          <type name="SubprocessLauncher" c:type="GSubprocessLauncher*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">#GSubprocessFlags</doc>
            <type name="SubprocessFlags" c:type="GSubprocessFlags"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="getenv" c:identifier="g_subprocess_launcher_getenv" version="2.40">
        <doc xml:space="preserve">Returns the value of the environment variable @variable in the
environment of processes launched from this launcher.

On UNIX, the returned string can be an arbitrary byte string.
On Windows, it will be UTF-8.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the environment variable,
    %NULL if unset</doc>
          <type name="filename" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocess</doc>
            <type name="SubprocessLauncher" c:type="GSubprocessLauncher*"/>
          </instance-parameter>
          <parameter name="variable" transfer-ownership="none">
            <doc xml:space="preserve">the environment variable to get</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_child_setup" c:identifier="g_subprocess_launcher_set_child_setup" version="2.40" introspectable="0">
        <doc xml:space="preserve">Sets up a child setup function.

The child setup function will be called after fork() but before
exec() on the child's side.

@destroy_notify will not be automatically called on the child's side
of the fork().  It will only be called when the last reference on the
#GSubprocessLauncher is dropped or when a new child setup function is
given.

%NULL can be given as @child_setup to disable the functionality.

Child setup functions are only available on UNIX.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocessLauncher</doc>
            <type name="SubprocessLauncher" c:type="GSubprocessLauncher*"/>
          </instance-parameter>
          <parameter name="child_setup" transfer-ownership="none" scope="notified" closure="1" destroy="2">
            <doc xml:space="preserve">a #GSpawnChildSetupFunc to use as the child setup function</doc>
            <type name="GLib.SpawnChildSetupFunc" c:type="GSpawnChildSetupFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data for @child_setup</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy_notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">a #GDestroyNotify for @user_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_cwd" c:identifier="g_subprocess_launcher_set_cwd" version="2.40">
        <doc xml:space="preserve">Sets the current working directory that processes will be launched
with.

By default processes are launched with the current working directory
of the launching process at the time of launch.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocess</doc>
            <type name="SubprocessLauncher" c:type="GSubprocessLauncher*"/>
          </instance-parameter>
          <parameter name="cwd" transfer-ownership="none">
            <doc xml:space="preserve">the cwd for launched processes</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_environ" c:identifier="g_subprocess_launcher_set_environ" version="2.40">
        <doc xml:space="preserve">Replace the entire environment of processes launched from this
launcher with the given 'environ' variable.

Typically you will build this variable by using g_listenv() to copy
the process 'environ' and using the functions g_environ_setenv(),
g_environ_unsetenv(), etc.

As an alternative, you can use g_subprocess_launcher_setenv(),
g_subprocess_launcher_unsetenv(), etc.

Pass an empty array to set an empty environment. Pass %NULL to inherit the
parent process&#x2019; environment. As of GLib 2.54, the parent process&#x2019; environment
will be copied when g_subprocess_launcher_set_environ() is called.
Previously, it was copied when the subprocess was executed. This means the
copied environment may now be modified (using g_subprocess_launcher_setenv(),
etc.) before launching the subprocess.

On UNIX, all strings in this array can be arbitrary byte strings.
On Windows, they should be in UTF-8.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocess</doc>
            <type name="SubprocessLauncher" c:type="GSubprocessLauncher*"/>
          </instance-parameter>
          <parameter name="env" transfer-ownership="none">
            <doc xml:space="preserve">
    the replacement environment</doc>
            <array c:type="gchar**">
              <type name="filename"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_flags" c:identifier="g_subprocess_launcher_set_flags" version="2.40">
        <doc xml:space="preserve">Sets the flags on the launcher.

The default flags are %G_SUBPROCESS_FLAGS_NONE.

You may not set flags that specify conflicting options for how to
handle a particular stdio stream (eg: specifying both
%G_SUBPROCESS_FLAGS_STDIN_PIPE and
%G_SUBPROCESS_FLAGS_STDIN_INHERIT).

You may also not set a flag that conflicts with a previous call to a
function like g_subprocess_launcher_set_stdin_file_path() or
g_subprocess_launcher_take_stdout_fd().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocessLauncher</doc>
            <type name="SubprocessLauncher" c:type="GSubprocessLauncher*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">#GSubprocessFlags</doc>
            <type name="SubprocessFlags" c:type="GSubprocessFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_stderr_file_path" c:identifier="g_subprocess_launcher_set_stderr_file_path" version="2.40">
        <doc xml:space="preserve">Sets the file path to use as the stderr for spawned processes.

If @path is %NULL then any previously given path is unset.

The file will be created or truncated when the process is spawned, as
would be the case if using '2&gt;' at the shell.

If you want to send both stdout and stderr to the same file then use
%G_SUBPROCESS_FLAGS_STDERR_MERGE.

You may not set a stderr file path if a stderr fd is already set or
if the launcher flags contain any flags directing stderr elsewhere.

This feature is only available on UNIX.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocessLauncher</doc>
            <type name="SubprocessLauncher" c:type="GSubprocessLauncher*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a filename or %NULL</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_stdin_file_path" c:identifier="g_subprocess_launcher_set_stdin_file_path" version="2.40">
        <doc xml:space="preserve">Sets the file path to use as the stdin for spawned processes.

If @path is %NULL then any previously given path is unset.

The file must exist or spawning the process will fail.

You may not set a stdin file path if a stdin fd is already set or if
the launcher flags contain any flags directing stdin elsewhere.

This feature is only available on UNIX.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocessLauncher</doc>
            <type name="SubprocessLauncher" c:type="GSubprocessLauncher*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_stdout_file_path" c:identifier="g_subprocess_launcher_set_stdout_file_path" version="2.40">
        <doc xml:space="preserve">Sets the file path to use as the stdout for spawned processes.

If @path is %NULL then any previously given path is unset.

The file will be created or truncated when the process is spawned, as
would be the case if using '&gt;' at the shell.

You may not set a stdout file path if a stdout fd is already set or
if the launcher flags contain any flags directing stdout elsewhere.

This feature is only available on UNIX.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocessLauncher</doc>
            <type name="SubprocessLauncher" c:type="GSubprocessLauncher*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a filename or %NULL</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="setenv" c:identifier="g_subprocess_launcher_setenv" version="2.40">
        <doc xml:space="preserve">Sets the environment variable @variable in the environment of
processes launched from this launcher.

On UNIX, both the variable's name and value can be arbitrary byte
strings, except that the variable's name cannot contain '='.
On Windows, they should be in UTF-8.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocess</doc>
            <type name="SubprocessLauncher" c:type="GSubprocessLauncher*"/>
          </instance-parameter>
          <parameter name="variable" transfer-ownership="none">
            <doc xml:space="preserve">the environment variable to set,
    must not contain '='</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the new value for the variable</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
          <parameter name="overwrite" transfer-ownership="none">
            <doc xml:space="preserve">whether to change the variable if it already exists</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="spawn" c:identifier="g_subprocess_launcher_spawn" version="2.40" introspectable="0">
        <doc xml:space="preserve">Creates a #GSubprocess given a provided varargs list of arguments.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GSubprocess, or %NULL on error (and @error will be set)</doc>
          <type name="Subprocess" c:type="GSubprocess*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocessLauncher</doc>
            <type name="SubprocessLauncher" c:type="GSubprocessLauncher*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">Error</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="argv0" transfer-ownership="none">
            <doc xml:space="preserve">Command line arguments</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">Continued arguments, %NULL terminated</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="spawnv" c:identifier="g_subprocess_launcher_spawnv" version="2.40" throws="1">
        <doc xml:space="preserve">Creates a #GSubprocess given a provided array of arguments.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GSubprocess, or %NULL on error (and @error will be set)</doc>
          <type name="Subprocess" c:type="GSubprocess*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocessLauncher</doc>
            <type name="SubprocessLauncher" c:type="GSubprocessLauncher*"/>
          </instance-parameter>
          <parameter name="argv" transfer-ownership="none">
            <doc xml:space="preserve">Command line arguments</doc>
            <array c:type="const gchar* const*">
              <type name="filename"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="take_fd" c:identifier="g_subprocess_launcher_take_fd">
        <doc xml:space="preserve">Transfer an arbitrary file descriptor from parent process to the
child.  This function takes "ownership" of the fd; it will be closed
in the parent when @self is freed.

By default, all file descriptors from the parent will be closed.
This function allows you to create (for example) a custom pipe() or
socketpair() before launching the process, and choose the target
descriptor in the child.

An example use case is GNUPG, which has a command line argument
--passphrase-fd providing a file descriptor number where it expects
the passphrase to be written.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocessLauncher</doc>
            <type name="SubprocessLauncher" c:type="GSubprocessLauncher*"/>
          </instance-parameter>
          <parameter name="source_fd" transfer-ownership="none">
            <doc xml:space="preserve">File descriptor in parent process</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="target_fd" transfer-ownership="none">
            <doc xml:space="preserve">Target descriptor for child process</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_stderr_fd" c:identifier="g_subprocess_launcher_take_stderr_fd" version="2.40">
        <doc xml:space="preserve">Sets the file descriptor to use as the stderr for spawned processes.

If @fd is -1 then any previously given fd is unset.

Note that the default behaviour is to pass stderr through to the
stderr of the parent process.

The passed @fd belongs to the #GSubprocessLauncher.  It will be
automatically closed when the launcher is finalized.  The file
descriptor will also be closed on the child side when executing the
spawned process.

You may not set a stderr fd if a stderr file path is already set or
if the launcher flags contain any flags directing stderr elsewhere.

This feature is only available on UNIX.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocessLauncher</doc>
            <type name="SubprocessLauncher" c:type="GSubprocessLauncher*"/>
          </instance-parameter>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:space="preserve">a file descriptor, or -1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_stdin_fd" c:identifier="g_subprocess_launcher_take_stdin_fd" version="2.40">
        <doc xml:space="preserve">Sets the file descriptor to use as the stdin for spawned processes.

If @fd is -1 then any previously given fd is unset.

Note that if your intention is to have the stdin of the calling
process inherited by the child then %G_SUBPROCESS_FLAGS_STDIN_INHERIT
is a better way to go about doing that.

The passed @fd is noted but will not be touched in the current
process.  It is therefore necessary that it be kept open by the
caller until the subprocess is spawned.  The file descriptor will
also not be explicitly closed on the child side, so it must be marked
O_CLOEXEC if that's what you want.

You may not set a stdin fd if a stdin file path is already set or if
the launcher flags contain any flags directing stdin elsewhere.

This feature is only available on UNIX.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocessLauncher</doc>
            <type name="SubprocessLauncher" c:type="GSubprocessLauncher*"/>
          </instance-parameter>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:space="preserve">a file descriptor, or -1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_stdout_fd" c:identifier="g_subprocess_launcher_take_stdout_fd" version="2.40">
        <doc xml:space="preserve">Sets the file descriptor to use as the stdout for spawned processes.

If @fd is -1 then any previously given fd is unset.

Note that the default behaviour is to pass stdout through to the
stdout of the parent process.

The passed @fd is noted but will not be touched in the current
process.  It is therefore necessary that it be kept open by the
caller until the subprocess is spawned.  The file descriptor will
also not be explicitly closed on the child side, so it must be marked
O_CLOEXEC if that's what you want.

You may not set a stdout fd if a stdout file path is already set or
if the launcher flags contain any flags directing stdout elsewhere.

This feature is only available on UNIX.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocessLauncher</doc>
            <type name="SubprocessLauncher" c:type="GSubprocessLauncher*"/>
          </instance-parameter>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:space="preserve">a file descriptor, or -1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="unsetenv" c:identifier="g_subprocess_launcher_unsetenv" version="2.40">
        <doc xml:space="preserve">Removes the environment variable @variable from the environment of
processes launched from this launcher.

On UNIX, the variable's name can be an arbitrary byte string not
containing '='. On Windows, it should be in UTF-8.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GSubprocess</doc>
            <type name="SubprocessLauncher" c:type="GSubprocessLauncher*"/>
          </instance-parameter>
          <parameter name="variable" transfer-ownership="none">
            <doc xml:space="preserve">the environment variable to unset,
    must not contain '='</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="flags" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <type name="SubprocessFlags"/>
      </property>
    </class>
    <constant name="TLS_BACKEND_EXTENSION_POINT_NAME" value="gio-tls-backend" c:type="G_TLS_BACKEND_EXTENSION_POINT_NAME">
      <doc xml:space="preserve">Extension point for TLS functionality via #GTlsBackend.
See [Extending GIO][extending-gio].</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT" value="1.3.6.1.5.5.7.3.2" c:type="G_TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT">
      <doc xml:space="preserve">The purpose used to verify the client certificate in a TLS connection.
Used by TLS servers.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER" value="1.3.6.1.5.5.7.3.1" c:type="G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER">
      <doc xml:space="preserve">The purpose used to verify the server certificate in a TLS connection. This
is the most common purpose in use. Used by TLS clients.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Task" c:symbol-prefix="task" c:type="GTask" parent="GObject.Object" glib:type-name="GTask" glib:get-type="g_task_get_type" glib:type-struct="TaskClass">
      <doc xml:space="preserve">A #GTask represents and manages a cancellable "task".

## Asynchronous operations

The most common usage of #GTask is as a #GAsyncResult, to
manage data during an asynchronous operation. You call
g_task_new() in the "start" method, followed by
g_task_set_task_data() and the like if you need to keep some
additional data associated with the task, and then pass the
task object around through your asynchronous operation.
Eventually, you will call a method such as
g_task_return_pointer() or g_task_return_error(), which will
save the value you give it and then invoke the task's callback
function in the
[thread-default main context][g-main-context-push-thread-default]
where it was created (waiting until the next iteration of the main
loop first, if necessary). The caller will pass the #GTask back to
the operation's finish function (as a #GAsyncResult), and you can
use g_task_propagate_pointer() or the like to extract the
return value.

Here is an example for using GTask as a GAsyncResult:
|[&lt;!-- language="C" --&gt;
    typedef struct {
      CakeFrostingType frosting;
      char *message;
    } DecorationData;

    static void
    decoration_data_free (DecorationData *decoration)
    {
      g_free (decoration-&gt;message);
      g_slice_free (DecorationData, decoration);
    }

    static void
    baked_cb (Cake     *cake,
              gpointer  user_data)
    {
      GTask *task = user_data;
      DecorationData *decoration = g_task_get_task_data (task);
      GError *error = NULL;

      if (cake == NULL)
        {
          g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
                                   "Go to the supermarket");
          g_object_unref (task);
          return;
        }

      if (!cake_decorate (cake, decoration-&gt;frosting, decoration-&gt;message, &amp;error))
        {
          g_object_unref (cake);
          // g_task_return_error() takes ownership of error
          g_task_return_error (task, error);
          g_object_unref (task);
          return;
        }

      g_task_return_pointer (task, cake, g_object_unref);
      g_object_unref (task);
    }

    void
    baker_bake_cake_async (Baker               *self,
                           guint                radius,
                           CakeFlavor           flavor,
                           CakeFrostingType     frosting,
                           const char          *message,
                           GCancellable        *cancellable,
                           GAsyncReadyCallback  callback,
                           gpointer             user_data)
    {
      GTask *task;
      DecorationData *decoration;
      Cake  *cake;

      task = g_task_new (self, cancellable, callback, user_data);
      if (radius &lt; 3)
        {
          g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_TOO_SMALL,
                                   "%ucm radius cakes are silly",
                                   radius);
          g_object_unref (task);
          return;
        }

      cake = _baker_get_cached_cake (self, radius, flavor, frosting, message);
      if (cake != NULL)
        {
          // _baker_get_cached_cake() returns a reffed cake
          g_task_return_pointer (task, cake, g_object_unref);
          g_object_unref (task);
          return;
        }

      decoration = g_slice_new (DecorationData);
      decoration-&gt;frosting = frosting;
      decoration-&gt;message = g_strdup (message);
      g_task_set_task_data (task, decoration, (GDestroyNotify) decoration_data_free);

      _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
    }

    Cake *
    baker_bake_cake_finish (Baker         *self,
                            GAsyncResult  *result,
                            GError       **error)
    {
      g_return_val_if_fail (g_task_is_valid (result, self), NULL);

      return g_task_propagate_pointer (G_TASK (result), error);
    }
]|

## Chained asynchronous operations

#GTask also tries to simplify asynchronous operations that
internally chain together several smaller asynchronous
operations. g_task_get_cancellable(), g_task_get_context(),
and g_task_get_priority() allow you to get back the task's
#GCancellable, #GMainContext, and [I/O priority][io-priority]
when starting a new subtask, so you don't have to keep track
of them yourself. g_task_attach_source() simplifies the case
of waiting for a source to fire (automatically using the correct
#GMainContext and priority).

Here is an example for chained asynchronous operations:
  |[&lt;!-- language="C" --&gt;
    typedef struct {
      Cake *cake;
      CakeFrostingType frosting;
      char *message;
    } BakingData;

    static void
    decoration_data_free (BakingData *bd)
    {
      if (bd-&gt;cake)
        g_object_unref (bd-&gt;cake);
      g_free (bd-&gt;message);
      g_slice_free (BakingData, bd);
    }

    static void
    decorated_cb (Cake         *cake,
                  GAsyncResult *result,
                  gpointer      user_data)
    {
      GTask *task = user_data;
      GError *error = NULL;

      if (!cake_decorate_finish (cake, result, &amp;error))
        {
          g_object_unref (cake);
          g_task_return_error (task, error);
          g_object_unref (task);
          return;
        }

      // baking_data_free() will drop its ref on the cake, so we have to
      // take another here to give to the caller.
      g_task_return_pointer (task, g_object_ref (cake), g_object_unref);
      g_object_unref (task);
    }

    static gboolean
    decorator_ready (gpointer user_data)
    {
      GTask *task = user_data;
      BakingData *bd = g_task_get_task_data (task);

      cake_decorate_async (bd-&gt;cake, bd-&gt;frosting, bd-&gt;message,
                           g_task_get_cancellable (task),
                           decorated_cb, task);

      return G_SOURCE_REMOVE;
    }

    static void
    baked_cb (Cake     *cake,
              gpointer  user_data)
    {
      GTask *task = user_data;
      BakingData *bd = g_task_get_task_data (task);
      GError *error = NULL;

      if (cake == NULL)
        {
          g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
                                   "Go to the supermarket");
          g_object_unref (task);
          return;
        }

      bd-&gt;cake = cake;

      // Bail out now if the user has already cancelled
      if (g_task_return_error_if_cancelled (task))
        {
          g_object_unref (task);
          return;
        }

      if (cake_decorator_available (cake))
        decorator_ready (task);
      else
        {
          GSource *source;

          source = cake_decorator_wait_source_new (cake);
          // Attach @source to @task's GMainContext and have it call
          // decorator_ready() when it is ready.
          g_task_attach_source (task, source, decorator_ready);
          g_source_unref (source);
        }
    }

    void
    baker_bake_cake_async (Baker               *self,
                           guint                radius,
                           CakeFlavor           flavor,
                           CakeFrostingType     frosting,
                           const char          *message,
                           gint                 priority,
                           GCancellable        *cancellable,
                           GAsyncReadyCallback  callback,
                           gpointer             user_data)
    {
      GTask *task;
      BakingData *bd;

      task = g_task_new (self, cancellable, callback, user_data);
      g_task_set_priority (task, priority);

      bd = g_slice_new0 (BakingData);
      bd-&gt;frosting = frosting;
      bd-&gt;message = g_strdup (message);
      g_task_set_task_data (task, bd, (GDestroyNotify) baking_data_free);

      _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
    }

    Cake *
    baker_bake_cake_finish (Baker         *self,
                            GAsyncResult  *result,
                            GError       **error)
    {
      g_return_val_if_fail (g_task_is_valid (result, self), NULL);

      return g_task_propagate_pointer (G_TASK (result), error);
    }
]|

## Asynchronous operations from synchronous ones

You can use g_task_run_in_thread() to turn a synchronous
operation into an asynchronous one, by running it in a thread.
When it completes, the result will be dispatched to the
[thread-default main context][g-main-context-push-thread-default]
where the #GTask was created.

Running a task in a thread:
  |[&lt;!-- language="C" --&gt;
    typedef struct {
      guint radius;
      CakeFlavor flavor;
      CakeFrostingType frosting;
      char *message;
    } CakeData;

    static void
    cake_data_free (CakeData *cake_data)
    {
      g_free (cake_data-&gt;message);
      g_slice_free (CakeData, cake_data);
    }

    static void
    bake_cake_thread (GTask         *task,
                      gpointer       source_object,
                      gpointer       task_data,
                      GCancellable  *cancellable)
    {
      Baker *self = source_object;
      CakeData *cake_data = task_data;
      Cake *cake;
      GError *error = NULL;

      cake = bake_cake (baker, cake_data-&gt;radius, cake_data-&gt;flavor,
                        cake_data-&gt;frosting, cake_data-&gt;message,
                        cancellable, &amp;error);
      if (cake)
        g_task_return_pointer (task, cake, g_object_unref);
      else
        g_task_return_error (task, error);
    }

    void
    baker_bake_cake_async (Baker               *self,
                           guint                radius,
                           CakeFlavor           flavor,
                           CakeFrostingType     frosting,
                           const char          *message,
                           GCancellable        *cancellable,
                           GAsyncReadyCallback  callback,
                           gpointer             user_data)
    {
      CakeData *cake_data;
      GTask *task;

      cake_data = g_slice_new (CakeData);
      cake_data-&gt;radius = radius;
      cake_data-&gt;flavor = flavor;
      cake_data-&gt;frosting = frosting;
      cake_data-&gt;message = g_strdup (message);
      task = g_task_new (self, cancellable, callback, user_data);
      g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
      g_task_run_in_thread (task, bake_cake_thread);
      g_object_unref (task);
    }

    Cake *
    baker_bake_cake_finish (Baker         *self,
                            GAsyncResult  *result,
                            GError       **error)
    {
      g_return_val_if_fail (g_task_is_valid (result, self), NULL);

      return g_task_propagate_pointer (G_TASK (result), error);
    }
]|

## Adding cancellability to uncancellable tasks

Finally, g_task_run_in_thread() and g_task_run_in_thread_sync()
can be used to turn an uncancellable operation into a
cancellable one. If you call g_task_set_return_on_cancel(),
passing %TRUE, then if the task's #GCancellable is cancelled,
it will return control back to the caller immediately, while
allowing the task thread to continue running in the background
(and simply discarding its result when it finally does finish).
Provided that the task thread is careful about how it uses
locks and other externally-visible resources, this allows you
to make "GLib-friendly" asynchronous and cancellable
synchronous variants of blocking APIs.

Cancelling a task:
  |[&lt;!-- language="C" --&gt;
    static void
    bake_cake_thread (GTask         *task,
                      gpointer       source_object,
                      gpointer       task_data,
                      GCancellable  *cancellable)
    {
      Baker *self = source_object;
      CakeData *cake_data = task_data;
      Cake *cake;
      GError *error = NULL;

      cake = bake_cake (baker, cake_data-&gt;radius, cake_data-&gt;flavor,
                        cake_data-&gt;frosting, cake_data-&gt;message,
                        &amp;error);
      if (error)
        {
          g_task_return_error (task, error);
          return;
        }

      // If the task has already been cancelled, then we don't want to add
      // the cake to the cake cache. Likewise, we don't  want to have the
      // task get cancelled in the middle of updating the cache.
      // g_task_set_return_on_cancel() will return %TRUE here if it managed
      // to disable return-on-cancel, or %FALSE if the task was cancelled
      // before it could.
      if (g_task_set_return_on_cancel (task, FALSE))
        {
          // If the caller cancels at this point, their
          // GAsyncReadyCallback won't be invoked until we return,
          // so we don't have to worry that this code will run at
          // the same time as that code does. But if there were
          // other functions that might look at the cake cache,
          // then we'd probably need a GMutex here as well.
          baker_add_cake_to_cache (baker, cake);
          g_task_return_pointer (task, cake, g_object_unref);
        }
    }

    void
    baker_bake_cake_async (Baker               *self,
                           guint                radius,
                           CakeFlavor           flavor,
                           CakeFrostingType     frosting,
                           const char          *message,
                           GCancellable        *cancellable,
                           GAsyncReadyCallback  callback,
                           gpointer             user_data)
    {
      CakeData *cake_data;
      GTask *task;

      cake_data = g_slice_new (CakeData);

      ...

      task = g_task_new (self, cancellable, callback, user_data);
      g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
      g_task_set_return_on_cancel (task, TRUE);
      g_task_run_in_thread (task, bake_cake_thread);
    }

    Cake *
    baker_bake_cake_sync (Baker               *self,
                          guint                radius,
                          CakeFlavor           flavor,
                          CakeFrostingType     frosting,
                          const char          *message,
                          GCancellable        *cancellable,
                          GError             **error)
    {
      CakeData *cake_data;
      GTask *task;
      Cake *cake;

      cake_data = g_slice_new (CakeData);

      ...

      task = g_task_new (self, cancellable, NULL, NULL);
      g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
      g_task_set_return_on_cancel (task, TRUE);
      g_task_run_in_thread_sync (task, bake_cake_thread);

      cake = g_task_propagate_pointer (task, error);
      g_object_unref (task);
      return cake;
    }
]|

## Porting from GSimpleAsyncResult

#GTask's API attempts to be simpler than #GSimpleAsyncResult's
in several ways:
- You can save task-specific data with g_task_set_task_data(), and
  retrieve it later with g_task_get_task_data(). This replaces the
  abuse of g_simple_async_result_set_op_res_gpointer() for the same
  purpose with #GSimpleAsyncResult.
- In addition to the task data, #GTask also keeps track of the
  [priority][io-priority], #GCancellable, and
  #GMainContext associated with the task, so tasks that consist of
  a chain of simpler asynchronous operations will have easy access
  to those values when starting each sub-task.
- g_task_return_error_if_cancelled() provides simplified
  handling for cancellation. In addition, cancellation
  overrides any other #GTask return value by default, like
  #GSimpleAsyncResult does when
  g_simple_async_result_set_check_cancellable() is called.
  (You can use g_task_set_check_cancellable() to turn off that
  behavior.) On the other hand, g_task_run_in_thread()
  guarantees that it will always run your
  `task_func`, even if the task's #GCancellable
  is already cancelled before the task gets a chance to run;
  you can start your `task_func` with a
  g_task_return_error_if_cancelled() check if you need the
  old behavior.
- The "return" methods (eg, g_task_return_pointer())
  automatically cause the task to be "completed" as well, and
  there is no need to worry about the "complete" vs "complete
  in idle" distinction. (#GTask automatically figures out
  whether the task's callback can be invoked directly, or
  if it needs to be sent to another #GMainContext, or delayed
  until the next iteration of the current #GMainContext.)
- The "finish" functions for #GTask based operations are generally
  much simpler than #GSimpleAsyncResult ones, normally consisting
  of only a single call to g_task_propagate_pointer() or the like.
  Since g_task_propagate_pointer() "steals" the return value from
  the #GTask, it is not necessary to juggle pointers around to
  prevent it from being freed twice.
- With #GSimpleAsyncResult, it was common to call
  g_simple_async_result_propagate_error() from the
  `_finish()` wrapper function, and have
  virtual method implementations only deal with successful
  returns. This behavior is deprecated, because it makes it
  difficult for a subclass to chain to a parent class's async
  methods. Instead, the wrapper function should just be a
  simple wrapper, and the virtual method should call an
  appropriate `g_task_propagate_` function.
  Note that wrapper methods can now use
  g_async_result_legacy_propagate_error() to do old-style
  #GSimpleAsyncResult error-returning behavior, and
  g_async_result_is_tagged() to check if a result is tagged as
  having come from the `_async()` wrapper
  function (for "short-circuit" results, such as when passing
  0 to g_input_stream_read_async()).</doc>
      <implements name="AsyncResult"/>
      <constructor name="new" c:identifier="g_task_new" version="2.36">
        <doc xml:space="preserve">Creates a #GTask acting on @source_object, which will eventually be
used to invoke @callback in the current
[thread-default main context][g-main-context-push-thread-default].

Call this in the "start" method of your asynchronous method, and
pass the #GTask around throughout the asynchronous operation. You
can use g_task_set_task_data() to attach task-specific data to the
object, which you can retrieve later via g_task_get_task_data().

By default, if @cancellable is cancelled, then the return value of
the task will always be %G_IO_ERROR_CANCELLED, even if the task had
already completed before the cancellation. This allows for
simplified handling in cases where cancellation may imply that
other objects that the task depends on have been destroyed. If you
do not want this behavior, you can use
g_task_set_check_cancellable() to change it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GTask.</doc>
          <type name="Task" c:type="GTask*"/>
        </return-value>
        <parameters>
          <parameter name="source_object" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the #GObject that owns
  this task, or %NULL.</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="callback_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="is_valid" c:identifier="g_task_is_valid" version="2.36">
        <doc xml:space="preserve">Checks that @result is a #GTask, and that @source_object is its
source object (or that @source_object is %NULL and @result has no
source object). This can be used in g_return_if_fail() checks.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @result and @source_object are valid, %FALSE
if not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">A #GAsyncResult</doc>
            <type name="AsyncResult" c:type="gpointer"/>
          </parameter>
          <parameter name="source_object" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the source object
  expected to be associated with the task</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="report_error" c:identifier="g_task_report_error" version="2.36">
        <doc xml:space="preserve">Creates a #GTask and then immediately calls g_task_return_error()
on it. Use this in the wrapper function of an asynchronous method
when you want to avoid even calling the virtual method. You can
then use g_async_result_is_tagged() in the finish method wrapper to
check if the result there is tagged as having been created by the
wrapper method, and deal with it appropriately if so.

See also g_task_report_new_error().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="source_object" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the #GObject that owns
  this task, or %NULL.</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="callback_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="source_tag" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an opaque pointer indicating the source of this task</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="error" transfer-ownership="full">
            <doc xml:space="preserve">error to report</doc>
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
        </parameters>
      </function>
      <function name="report_new_error" c:identifier="g_task_report_new_error" version="2.36" introspectable="0">
        <doc xml:space="preserve">Creates a #GTask and then immediately calls
g_task_return_new_error() on it. Use this in the wrapper function
of an asynchronous method when you want to avoid even calling the
virtual method. You can then use g_async_result_is_tagged() in the
finish method wrapper to check if the result there is tagged as
having been created by the wrapper method, and deal with it
appropriately if so.

See also g_task_report_error().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="source_object" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the #GObject that owns
  this task, or %NULL.</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="callback_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="source_tag" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an opaque pointer indicating the source of this task</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #GQuark.</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:space="preserve">an error code.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">a string with format characters.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">a list of values to insert into @format.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </function>
      <method name="attach_source" c:identifier="g_task_attach_source" version="2.36" introspectable="0">
        <doc xml:space="preserve">A utility function for dealing with async operations where you need
to wait for a #GSource to trigger. Attaches @source to @task's
#GMainContext with @task's [priority][io-priority], and sets @source's
callback to @callback, with @task as the callback's `user_data`.

This takes a reference on @task until @source is destroyed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">a #GTask</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">the source to attach</doc>
            <type name="GLib.Source" c:type="GSource*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none">
            <doc xml:space="preserve">the callback to invoke when @source triggers</doc>
            <type name="GLib.SourceFunc" c:type="GSourceFunc"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_cancellable" c:identifier="g_task_get_cancellable" version="2.36">
        <doc xml:space="preserve">Gets @task's #GCancellable</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@task's #GCancellable</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">a #GTask</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_check_cancellable" c:identifier="g_task_get_check_cancellable" version="2.36">
        <doc xml:space="preserve">Gets @task's check-cancellable flag. See
g_task_set_check_cancellable() for more details.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">the #GTask</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_completed" c:identifier="g_task_get_completed" version="2.44">
        <doc xml:space="preserve">Gets the value of #GTask:completed. This changes from %FALSE to %TRUE after
the task&#x2019;s callback is invoked, and will return %FALSE if called from inside
the callback.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the task has completed, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">a #GTask.</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_context" c:identifier="g_task_get_context" version="2.36">
        <doc xml:space="preserve">Gets the #GMainContext that @task will return its result in (that
is, the context that was the
[thread-default main context][g-main-context-push-thread-default]
at the point when @task was created).

This will always return a non-%NULL value, even if the task's
context is the default #GMainContext.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@task's #GMainContext</doc>
          <type name="GLib.MainContext" c:type="GMainContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">a #GTask</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_priority" c:identifier="g_task_get_priority" version="2.36">
        <doc xml:space="preserve">Gets @task's priority</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@task's priority</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">a #GTask</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_return_on_cancel" c:identifier="g_task_get_return_on_cancel" version="2.36">
        <doc xml:space="preserve">Gets @task's return-on-cancel flag. See
g_task_set_return_on_cancel() for more details.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">the #GTask</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_source_object" c:identifier="g_task_get_source_object" version="2.36">
        <doc xml:space="preserve">Gets the source object from @task. Like
g_async_result_get_source_object(), but does not ref the object.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">@task's source object, or %NULL</doc>
          <type name="GObject.Object" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">a #GTask</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_source_tag" c:identifier="g_task_get_source_tag" version="2.36">
        <doc xml:space="preserve">Gets @task's source tag. See g_task_set_source_tag().</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">@task's source tag</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">a #GTask</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_task_data" c:identifier="g_task_get_task_data" version="2.36">
        <doc xml:space="preserve">Gets @task's `task_data`.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">@task's `task_data`.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">a #GTask</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="had_error" c:identifier="g_task_had_error" version="2.36">
        <doc xml:space="preserve">Tests if @task resulted in an error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the task resulted in an error, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">a #GTask.</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="propagate_boolean" c:identifier="g_task_propagate_boolean" version="2.36" throws="1">
        <doc xml:space="preserve">Gets the result of @task as a #gboolean.

If the task resulted in an error, or was cancelled, then this will
instead return %FALSE and set @error.

Since this method transfers ownership of the return value (or
error) to the caller, you may only call it once.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the task result, or %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">a #GTask.</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="propagate_int" c:identifier="g_task_propagate_int" version="2.36" throws="1">
        <doc xml:space="preserve">Gets the result of @task as an integer (#gssize).

If the task resulted in an error, or was cancelled, then this will
instead return -1 and set @error.

Since this method transfers ownership of the return value (or
error) to the caller, you may only call it once.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the task result, or -1 on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">a #GTask.</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="propagate_pointer" c:identifier="g_task_propagate_pointer" version="2.36" throws="1">
        <doc xml:space="preserve">Gets the result of @task as a pointer, and transfers ownership
of that value to the caller.

If the task resulted in an error, or was cancelled, then this will
instead return %NULL and set @error.

Since this method transfers ownership of the return value (or
error) to the caller, you may only call it once.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the task result, or %NULL on error</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">a #GTask</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="return_boolean" c:identifier="g_task_return_boolean" version="2.36">
        <doc xml:space="preserve">Sets @task's result to @result and completes the task (see
g_task_return_pointer() for more discussion of exactly what this
means).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">a #GTask.</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #gboolean result of a task function.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="return_error" c:identifier="g_task_return_error" version="2.36">
        <doc xml:space="preserve">Sets @task's result to @error (which @task assumes ownership of)
and completes the task (see g_task_return_pointer() for more
discussion of exactly what this means).

Note that since the task takes ownership of @error, and since the
task may be completed before returning from g_task_return_error(),
you cannot assume that @error is still valid after calling this.
Call g_error_copy() on the error if you need to keep a local copy
as well.

See also g_task_return_new_error().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">a #GTask.</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="full">
            <doc xml:space="preserve">the #GError result of a task function.</doc>
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
        </parameters>
      </method>
      <method name="return_error_if_cancelled" c:identifier="g_task_return_error_if_cancelled" version="2.36">
        <doc xml:space="preserve">Checks if @task's #GCancellable has been cancelled, and if so, sets
@task's error accordingly and completes the task (see
g_task_return_pointer() for more discussion of exactly what this
means).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @task has been cancelled, %FALSE if not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">a #GTask</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="return_int" c:identifier="g_task_return_int" version="2.36">
        <doc xml:space="preserve">Sets @task's result to @result and completes the task (see
g_task_return_pointer() for more discussion of exactly what this
means).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">a #GTask.</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the integer (#gssize) result of a task function.</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="return_new_error" c:identifier="g_task_return_new_error" version="2.36" introspectable="0">
        <doc xml:space="preserve">Sets @task's result to a new #GError created from @domain, @code,
@format, and the remaining arguments, and completes the task (see
g_task_return_pointer() for more discussion of exactly what this
means).

See also g_task_return_error().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">a #GTask.</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #GQuark.</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:space="preserve">an error code.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">a string with format characters.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">a list of values to insert into @format.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="return_pointer" c:identifier="g_task_return_pointer" version="2.36">
        <doc xml:space="preserve">Sets @task's result to @result and completes the task. If @result
is not %NULL, then @result_destroy will be used to free @result if
the caller does not take ownership of it with
g_task_propagate_pointer().

"Completes the task" means that for an ordinary asynchronous task
it will either invoke the task's callback, or else queue that
callback to be invoked in the proper #GMainContext, or in the next
iteration of the current #GMainContext. For a task run via
g_task_run_in_thread() or g_task_run_in_thread_sync(), calling this
method will save @result to be returned to the caller later, but
the task will not actually be completed until the #GTaskThreadFunc
exits.

Note that since the task may be completed before returning from
g_task_return_pointer(), you cannot assume that @result is still
valid after calling this, unless you are still holding another
reference on it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">a #GTask</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the pointer result of a task
    function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="result_destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a #GDestroyNotify function.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="run_in_thread" c:identifier="g_task_run_in_thread" version="2.36" introspectable="0">
        <doc xml:space="preserve">Runs @task_func in another thread. When @task_func returns, @task's
#GAsyncReadyCallback will be invoked in @task's #GMainContext.

This takes a ref on @task until the task completes.

See #GTaskThreadFunc for more details about how @task_func is handled.

Although GLib currently rate-limits the tasks queued via
g_task_run_in_thread(), you should not assume that it will always
do this. If you have a very large number of tasks to run, but don't
want them to all run at once, you should only queue a limited
number of them at a time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">a #GTask</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
          <parameter name="task_func" transfer-ownership="none">
            <doc xml:space="preserve">a #GTaskThreadFunc</doc>
            <type name="TaskThreadFunc" c:type="GTaskThreadFunc"/>
          </parameter>
        </parameters>
      </method>
      <method name="run_in_thread_sync" c:identifier="g_task_run_in_thread_sync" version="2.36" introspectable="0">
        <doc xml:space="preserve">Runs @task_func in another thread, and waits for it to return or be
cancelled. You can use g_task_propagate_pointer(), etc, afterward
to get the result of @task_func.

See #GTaskThreadFunc for more details about how @task_func is handled.

Normally this is used with tasks created with a %NULL
`callback`, but note that even if the task does
have a callback, it will not be invoked when @task_func returns.
#GTask:completed will be set to %TRUE just before this function returns.

Although GLib currently rate-limits the tasks queued via
g_task_run_in_thread_sync(), you should not assume that it will
always do this. If you have a very large number of tasks to run,
but don't want them to all run at once, you should only queue a
limited number of them at a time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">a #GTask</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
          <parameter name="task_func" transfer-ownership="none">
            <doc xml:space="preserve">a #GTaskThreadFunc</doc>
            <type name="TaskThreadFunc" c:type="GTaskThreadFunc"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_check_cancellable" c:identifier="g_task_set_check_cancellable" version="2.36">
        <doc xml:space="preserve">Sets or clears @task's check-cancellable flag. If this is %TRUE
(the default), then g_task_propagate_pointer(), etc, and
g_task_had_error() will check the task's #GCancellable first, and
if it has been cancelled, then they will consider the task to have
returned an "Operation was cancelled" error
(%G_IO_ERROR_CANCELLED), regardless of any other error or return
value the task may have had.

If @check_cancellable is %FALSE, then the #GTask will not check the
cancellable itself, and it is up to @task's owner to do this (eg,
via g_task_return_error_if_cancelled()).

If you are using g_task_set_return_on_cancel() as well, then
you must leave check-cancellable set %TRUE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">the #GTask</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
          <parameter name="check_cancellable" transfer-ownership="none">
            <doc xml:space="preserve">whether #GTask will check the state of
  its #GCancellable for you.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_priority" c:identifier="g_task_set_priority" version="2.36">
        <doc xml:space="preserve">Sets @task's priority. If you do not call this, it will default to
%G_PRIORITY_DEFAULT.

This will affect the priority of #GSources created with
g_task_attach_source() and the scheduling of tasks run in threads,
and can also be explicitly retrieved later via
g_task_get_priority().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">the #GTask</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
          <parameter name="priority" transfer-ownership="none">
            <doc xml:space="preserve">the [priority][io-priority] of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_return_on_cancel" c:identifier="g_task_set_return_on_cancel" version="2.36">
        <doc xml:space="preserve">Sets or clears @task's return-on-cancel flag. This is only
meaningful for tasks run via g_task_run_in_thread() or
g_task_run_in_thread_sync().

If @return_on_cancel is %TRUE, then cancelling @task's
#GCancellable will immediately cause it to return, as though the
task's #GTaskThreadFunc had called
g_task_return_error_if_cancelled() and then returned.

This allows you to create a cancellable wrapper around an
uninterruptable function. The #GTaskThreadFunc just needs to be
careful that it does not modify any externally-visible state after
it has been cancelled. To do that, the thread should call
g_task_set_return_on_cancel() again to (atomically) set
return-on-cancel %FALSE before making externally-visible changes;
if the task gets cancelled before the return-on-cancel flag could
be changed, g_task_set_return_on_cancel() will indicate this by
returning %FALSE.

You can disable and re-enable this flag multiple times if you wish.
If the task's #GCancellable is cancelled while return-on-cancel is
%FALSE, then calling g_task_set_return_on_cancel() to set it %TRUE
again will cause the task to be cancelled at that point.

If the task's #GCancellable is already cancelled before you call
g_task_run_in_thread()/g_task_run_in_thread_sync(), then the
#GTaskThreadFunc will still be run (for consistency), but the task
will also be completed right away.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @task's return-on-cancel flag was changed to
  match @return_on_cancel. %FALSE if @task has already been
  cancelled.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">the #GTask</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
          <parameter name="return_on_cancel" transfer-ownership="none">
            <doc xml:space="preserve">whether the task returns automatically when
  it is cancelled.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_source_tag" c:identifier="g_task_set_source_tag" version="2.36">
        <doc xml:space="preserve">Sets @task's source tag. You can use this to tag a task return
value with a particular pointer (usually a pointer to the function
doing the tagging) and then later check it using
g_task_get_source_tag() (or g_async_result_is_tagged()) in the
task's "finish" function, to figure out if the response came from a
particular place.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">the #GTask</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
          <parameter name="source_tag" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an opaque pointer indicating the source of this task</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_task_data" c:identifier="g_task_set_task_data" version="2.36">
        <doc xml:space="preserve">Sets @task's task data (freeing the existing task data, if any).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">the #GTask</doc>
            <type name="Task" c:type="GTask*"/>
          </instance-parameter>
          <parameter name="task_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">task-specific data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="task_data_destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">#GDestroyNotify for @task_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <property name="completed" version="2.44" transfer-ownership="none">
        <doc xml:space="preserve">Whether the task has completed, meaning its callback (if set) has been
invoked. This can only happen after g_task_return_pointer(),
g_task_return_error() or one of the other return functions have been called
on the task.

This property is guaranteed to change from %FALSE to %TRUE exactly once.

The #GObject::notify signal for this change is emitted in the same main
context as the task&#x2019;s callback, immediately after that callback is invoked.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
    </class>
    <record name="TaskClass" c:type="GTaskClass" disguised="1" glib:is-gtype-struct-for="Task">
    </record>
    <callback name="TaskThreadFunc" c:type="GTaskThreadFunc" version="2.36">
      <doc xml:space="preserve">The prototype for a task function to be run in a thread via
g_task_run_in_thread() or g_task_run_in_thread_sync().

If the return-on-cancel flag is set on @task, and @cancellable gets
cancelled, then the #GTask will be completed immediately (as though
g_task_return_error_if_cancelled() had been called), without
waiting for the task function to complete. However, the task
function will continue running in its thread in the background. The
function therefore needs to be careful about how it uses
externally-visible state in this case. See
g_task_set_return_on_cancel() for more details.

Other than in that case, @task will be completed when the
#GTaskThreadFunc returns, not when it calls a
`g_task_return_` function.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="task" transfer-ownership="none">
          <doc xml:space="preserve">the #GTask</doc>
          <type name="Task" c:type="GTask*"/>
        </parameter>
        <parameter name="source_object" transfer-ownership="none">
          <doc xml:space="preserve">@task's source object</doc>
          <type name="GObject.Object" c:type="gpointer"/>
        </parameter>
        <parameter name="task_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">@task's task data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">@task's #GCancellable, or %NULL</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="TcpConnection" c:symbol-prefix="tcp_connection" c:type="GTcpConnection" version="2.22" parent="SocketConnection" glib:type-name="GTcpConnection" glib:get-type="g_tcp_connection_get_type" glib:type-struct="TcpConnectionClass">
      <doc xml:space="preserve">This is the subclass of #GSocketConnection that is created
for TCP/IP sockets.</doc>
      <method name="get_graceful_disconnect" c:identifier="g_tcp_connection_get_graceful_disconnect" version="2.22">
        <doc xml:space="preserve">Checks if graceful disconnects are used. See
g_tcp_connection_set_graceful_disconnect().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if graceful disconnect is used on close, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GTcpConnection</doc>
            <type name="TcpConnection" c:type="GTcpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_graceful_disconnect" c:identifier="g_tcp_connection_set_graceful_disconnect" version="2.22">
        <doc xml:space="preserve">This enables graceful disconnects on close. A graceful disconnect
means that we signal the receiving end that the connection is terminated
and wait for it to close the connection before closing the connection.

A graceful disconnect means that we can be sure that we successfully sent
all the outstanding data to the other end, or get an error reported.
However, it also means we have to wait for all the data to reach the
other side and for it to acknowledge this by closing the socket, which may
take a while. For this reason it is disabled by default.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GTcpConnection</doc>
            <type name="TcpConnection" c:type="GTcpConnection*"/>
          </instance-parameter>
          <parameter name="graceful_disconnect" transfer-ownership="none">
            <doc xml:space="preserve">Whether to do graceful disconnects or not</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="graceful-disconnect" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent_instance">
        <type name="SocketConnection" c:type="GSocketConnection"/>
      </field>
      <field name="priv">
        <type name="TcpConnectionPrivate" c:type="GTcpConnectionPrivate*"/>
      </field>
    </class>
    <record name="TcpConnectionClass" c:type="GTcpConnectionClass" glib:is-gtype-struct-for="TcpConnection">
      <field name="parent_class">
        <type name="SocketConnectionClass" c:type="GSocketConnectionClass"/>
      </field>
    </record>
    <record name="TcpConnectionPrivate" c:type="GTcpConnectionPrivate" disguised="1">
    </record>
    <class name="TcpWrapperConnection" c:symbol-prefix="tcp_wrapper_connection" c:type="GTcpWrapperConnection" parent="TcpConnection" glib:type-name="GTcpWrapperConnection" glib:get-type="g_tcp_wrapper_connection_get_type" glib:type-struct="TcpWrapperConnectionClass">
      <doc xml:space="preserve">A #GTcpWrapperConnection can be used to wrap a #GIOStream that is
based on a #GSocket, but which is not actually a
#GSocketConnection. This is used by #GSocketClient so that it can
always return a #GSocketConnection, even when the connection it has
actually created is not directly a #GSocketConnection.</doc>
      <constructor name="new" c:identifier="g_tcp_wrapper_connection_new" version="2.28">
        <doc xml:space="preserve">Wraps @base_io_stream and @socket together as a #GSocketConnection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #GSocketConnection.</doc>
          <type name="SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
        <parameters>
          <parameter name="base_io_stream" transfer-ownership="none">
            <doc xml:space="preserve">the #GIOStream to wrap</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </parameter>
          <parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">the #GSocket associated with @base_io_stream</doc>
            <type name="Socket" c:type="GSocket*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_base_io_stream" c:identifier="g_tcp_wrapper_connection_get_base_io_stream">
        <doc xml:space="preserve">Get's @conn's base #GIOStream</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@conn's base #GIOStream</doc>
          <type name="IOStream" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GTcpWrapperConnection</doc>
            <type name="TcpWrapperConnection" c:type="GTcpWrapperConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="base-io-stream" writable="1" construct-only="1" transfer-ownership="none">
        <type name="IOStream"/>
      </property>
      <field name="parent_instance">
        <type name="TcpConnection" c:type="GTcpConnection"/>
      </field>
      <field name="priv">
        <type name="TcpWrapperConnectionPrivate" c:type="GTcpWrapperConnectionPrivate*"/>
      </field>
    </class>
    <record name="TcpWrapperConnectionClass" c:type="GTcpWrapperConnectionClass" glib:is-gtype-struct-for="TcpWrapperConnection">
      <field name="parent_class">
        <type name="TcpConnectionClass" c:type="GTcpConnectionClass"/>
      </field>
    </record>
    <record name="TcpWrapperConnectionPrivate" c:type="GTcpWrapperConnectionPrivate" disguised="1">
    </record>
    <class name="TestDBus" c:symbol-prefix="test_dbus" c:type="GTestDBus" version="2.34" parent="GObject.Object" glib:type-name="GTestDBus" glib:get-type="g_test_dbus_get_type">
      <doc xml:space="preserve">A helper class for testing code which uses D-Bus without touching the user's
session bus.

Note that #GTestDBus modifies the user&#x2019;s environment, calling setenv().
This is not thread-safe, so all #GTestDBus calls should be completed before
threads are spawned, or should have appropriate locking to ensure no access
conflicts to environment variables shared between #GTestDBus and other
threads.

## Creating unit tests using GTestDBus

Testing of D-Bus services can be tricky because normally we only ever run
D-Bus services over an existing instance of the D-Bus daemon thus we
usually don't activate D-Bus services that are not yet installed into the
target system. The #GTestDBus object makes this easier for us by taking care
of the lower level tasks such as running a private D-Bus daemon and looking
up uninstalled services in customizable locations, typically in your source
code tree.

The first thing you will need is a separate service description file for the
D-Bus daemon. Typically a `services` subdirectory of your `tests` directory
is a good place to put this file.

The service file should list your service along with an absolute path to the
uninstalled service executable in your source tree. Using autotools we would
achieve this by adding a file such as `my-server.service.in` in the services
directory and have it processed by configure.
|[
    [D-BUS Service]
    Name=org.gtk.GDBus.Examples.ObjectManager
    Exec=@abs_top_builddir@/gio/tests/gdbus-example-objectmanager-server
]|
You will also need to indicate this service directory in your test
fixtures, so you will need to pass the path while compiling your
test cases. Typically this is done with autotools with an added
preprocessor flag specified to compile your tests such as:
|[
    -DTEST_SERVICES=\""$(abs_top_builddir)/tests/services"\"
]|
    Once you have a service definition file which is local to your source tree,
you can proceed to set up a GTest fixture using the #GTestDBus scaffolding.

An example of a test fixture for D-Bus services can be found
here:
[gdbus-test-fixture.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-test-fixture.c)

Note that these examples only deal with isolating the D-Bus aspect of your
service. To successfully run isolated unit tests on your service you may need
some additional modifications to your test case fixture. For example; if your
service uses GSettings and installs a schema then it is important that your test service
not load the schema in the ordinary installed location (chances are that your service
and schema files are not yet installed, or worse; there is an older version of the
schema file sitting in the install location).

Most of the time we can work around these obstacles using the
environment. Since the environment is inherited by the D-Bus daemon
created by #GTestDBus and then in turn inherited by any services the
D-Bus daemon activates, using the setup routine for your fixture is
a practical place to help sandbox your runtime environment. For the
rather typical GSettings case we can work around this by setting
`GSETTINGS_SCHEMA_DIR` to the in tree directory holding your schemas
in the above fixture_setup() routine.

The GSettings schemas need to be locally pre-compiled for this to work. This can be achieved
by compiling the schemas locally as a step before running test cases, an autotools setup might
do the following in the directory holding schemas:
|[
    all-am:
            $(GLIB_COMPILE_SCHEMAS) .

    CLEANFILES += gschemas.compiled
]|</doc>
      <constructor name="new" c:identifier="g_test_dbus_new">
        <doc xml:space="preserve">Create a new #GTestDBus object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GTestDBus.</doc>
          <type name="TestDBus" c:type="GTestDBus*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a #GTestDBusFlags</doc>
            <type name="TestDBusFlags" c:type="GTestDBusFlags"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="unset" c:identifier="g_test_dbus_unset">
        <doc xml:space="preserve">Unset DISPLAY and DBUS_SESSION_BUS_ADDRESS env variables to ensure the test
won't use user's session bus.

This is useful for unit tests that want to verify behaviour when no session
bus is running. It is not necessary to call this if unit test already calls
g_test_dbus_up() before acquiring the session bus.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="add_service_dir" c:identifier="g_test_dbus_add_service_dir">
        <doc xml:space="preserve">Add a path where dbus-daemon will look up .service files. This can't be
called after g_test_dbus_up().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTestDBus</doc>
            <type name="TestDBus" c:type="GTestDBus*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">path to a directory containing .service files</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="down" c:identifier="g_test_dbus_down">
        <doc xml:space="preserve">Stop the session bus started by g_test_dbus_up().

This will wait for the singleton returned by g_bus_get() or g_bus_get_sync()
is destroyed. This is done to ensure that the next unit test won't get a
leaked singleton from this test.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTestDBus</doc>
            <type name="TestDBus" c:type="GTestDBus*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bus_address" c:identifier="g_test_dbus_get_bus_address">
        <doc xml:space="preserve">Get the address on which dbus-daemon is running. If g_test_dbus_up() has not
been called yet, %NULL is returned. This can be used with
g_dbus_connection_new_for_address().</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the address of the bus, or %NULL.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTestDBus</doc>
            <type name="TestDBus" c:type="GTestDBus*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="g_test_dbus_get_flags">
        <doc xml:space="preserve">Get the flags of the #GTestDBus object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of #GTestDBus:flags property</doc>
          <type name="TestDBusFlags" c:type="GTestDBusFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTestDBus</doc>
            <type name="TestDBus" c:type="GTestDBus*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="stop" c:identifier="g_test_dbus_stop">
        <doc xml:space="preserve">Stop the session bus started by g_test_dbus_up().

Unlike g_test_dbus_down(), this won't verify the #GDBusConnection
singleton returned by g_bus_get() or g_bus_get_sync() is destroyed. Unit
tests wanting to verify behaviour after the session bus has been stopped
can use this function but should still call g_test_dbus_down() when done.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTestDBus</doc>
            <type name="TestDBus" c:type="GTestDBus*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="up" c:identifier="g_test_dbus_up">
        <doc xml:space="preserve">Start a dbus-daemon instance and set DBUS_SESSION_BUS_ADDRESS. After this
call, it is safe for unit tests to start sending messages on the session bus.

If this function is called from setup callback of g_test_add(),
g_test_dbus_down() must be called in its teardown callback.

If this function is called from unit test's main(), then g_test_dbus_down()
must be called after g_test_run().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTestDBus</doc>
            <type name="TestDBus" c:type="GTestDBus*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="flags" version="2.34" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">#GTestDBusFlags specifying the behaviour of the D-Bus session.</doc>
        <type name="TestDBusFlags"/>
      </property>
    </class>
    <bitfield name="TestDBusFlags" version="2.34" glib:type-name="GTestDBusFlags" glib:get-type="g_test_dbus_flags_get_type" c:type="GTestDBusFlags">
      <doc xml:space="preserve">Flags to define future #GTestDBus behaviour.</doc>
      <member name="none" value="0" c:identifier="G_TEST_DBUS_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags.</doc>
      </member>
    </bitfield>
    <class name="ThemedIcon" c:symbol-prefix="themed_icon" c:type="GThemedIcon" parent="GObject.Object" glib:type-name="GThemedIcon" glib:get-type="g_themed_icon_get_type" glib:type-struct="ThemedIconClass">
      <doc xml:space="preserve">#GThemedIcon is an implementation of #GIcon that supports icon themes.
#GThemedIcon contains a list of all of the icons present in an icon
theme, so that icons can be looked up quickly. #GThemedIcon does
not provide actual pixmaps for icons, just the icon names.
Ideally something like gtk_icon_theme_choose_icon() should be used to
resolve the list of names so that fallback icons work nicely with
themes that inherit other themes.</doc>
      <implements name="Icon"/>
      <constructor name="new" c:identifier="g_themed_icon_new">
        <doc xml:space="preserve">Creates a new themed icon for @iconname.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GThemedIcon.</doc>
          <type name="ThemedIcon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <parameter name="iconname" transfer-ownership="none">
            <doc xml:space="preserve">a string containing an icon name.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_names" c:identifier="g_themed_icon_new_from_names">
        <doc xml:space="preserve">Creates a new themed icon for @iconnames.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GThemedIcon</doc>
          <type name="ThemedIcon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <parameter name="iconnames" transfer-ownership="none">
            <doc xml:space="preserve">an array of strings containing icon names.</doc>
            <array length="1" zero-terminated="0" c:type="char**">
              <type name="utf8" c:type="char*"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @iconnames array, or -1 if @iconnames is
    %NULL-terminated</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_default_fallbacks" c:identifier="g_themed_icon_new_with_default_fallbacks">
        <doc xml:space="preserve">Creates a new themed icon for @iconname, and all the names
that can be created by shortening @iconname at '-' characters.

In the following example, @icon1 and @icon2 are equivalent:
|[&lt;!-- language="C" --&gt;
const char *names[] = {
  "gnome-dev-cdrom-audio",
  "gnome-dev-cdrom",
  "gnome-dev",
  "gnome"
};

icon1 = g_themed_icon_new_from_names (names, 4);
icon2 = g_themed_icon_new_with_default_fallbacks ("gnome-dev-cdrom-audio");
]|</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GThemedIcon.</doc>
          <type name="ThemedIcon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <parameter name="iconname" transfer-ownership="none">
            <doc xml:space="preserve">a string containing an icon name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="append_name" c:identifier="g_themed_icon_append_name">
        <doc xml:space="preserve">Append a name to the list of icons from within @icon.

Note that doing so invalidates the hash computed by prior calls
to g_icon_hash().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">a #GThemedIcon</doc>
            <type name="ThemedIcon" c:type="GThemedIcon*"/>
          </instance-parameter>
          <parameter name="iconname" transfer-ownership="none">
            <doc xml:space="preserve">name of icon to append to list of icons from within @icon.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_names" c:identifier="g_themed_icon_get_names">
        <doc xml:space="preserve">Gets the names of icons from within @icon.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a list of icon names.</doc>
          <array c:type="const gchar* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">a #GThemedIcon.</doc>
            <type name="ThemedIcon" c:type="GThemedIcon*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="prepend_name" c:identifier="g_themed_icon_prepend_name" version="2.18">
        <doc xml:space="preserve">Prepend a name to the list of icons from within @icon.

Note that doing so invalidates the hash computed by prior calls
to g_icon_hash().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none">
            <doc xml:space="preserve">a #GThemedIcon</doc>
            <type name="ThemedIcon" c:type="GThemedIcon*"/>
          </instance-parameter>
          <parameter name="iconname" transfer-ownership="none">
            <doc xml:space="preserve">name of icon to prepend to list of icons from within @icon.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="name" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The icon name.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="names" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">A %NULL-terminated array of icon names.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="use-default-fallbacks" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether to use the default fallbacks found by shortening the icon name
at '-' characters. If the "names" array has more than one element,
ignores any past the first.

For example, if the icon name was "gnome-dev-cdrom-audio", the array
would become
|[&lt;!-- language="C" --&gt;
{
  "gnome-dev-cdrom-audio",
  "gnome-dev-cdrom",
  "gnome-dev",
  "gnome",
  NULL
};
]|</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
    </class>
    <record name="ThemedIconClass" c:type="GThemedIconClass" disguised="1" glib:is-gtype-struct-for="ThemedIcon">
    </record>
    <class name="ThreadedSocketService" c:symbol-prefix="threaded_socket_service" c:type="GThreadedSocketService" version="2.22" parent="SocketService" glib:type-name="GThreadedSocketService" glib:get-type="g_threaded_socket_service_get_type" glib:type-struct="ThreadedSocketServiceClass">
      <doc xml:space="preserve">A #GThreadedSocketService is a simple subclass of #GSocketService
that handles incoming connections by creating a worker thread and
dispatching the connection to it by emitting the
#GThreadedSocketService::run signal in the new thread.

The signal handler may perform blocking IO and need not return
until the connection is closed.

The service is implemented using a thread pool, so there is a
limited amount of threads available to serve incoming requests.
The service automatically stops the #GSocketService from accepting
new connections when all threads are busy.

As with #GSocketService, you may connect to #GThreadedSocketService::run,
or subclass and override the default handler.</doc>
      <constructor name="new" c:identifier="g_threaded_socket_service_new" version="2.22">
        <doc xml:space="preserve">Creates a new #GThreadedSocketService with no listeners. Listeners
must be added with one of the #GSocketListener "add" methods.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSocketService.</doc>
          <type name="SocketService" c:type="GSocketService*"/>
        </return-value>
        <parameters>
          <parameter name="max_threads" transfer-ownership="none">
            <doc xml:space="preserve">the maximal number of threads to execute concurrently
  handling incoming clients, -1 means no limit</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="run">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <type name="ThreadedSocketService" c:type="GThreadedSocketService*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="SocketConnection" c:type="GSocketConnection*"/>
          </parameter>
          <parameter name="source_object" transfer-ownership="none">
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <property name="max-threads" writable="1" construct-only="1" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <field name="parent_instance">
        <type name="SocketService" c:type="GSocketService"/>
      </field>
      <field name="priv">
        <type name="ThreadedSocketServicePrivate" c:type="GThreadedSocketServicePrivate*"/>
      </field>
      <glib:signal name="run" when="last">
        <doc xml:space="preserve">The ::run signal is emitted in a worker thread in response to an
incoming connection. This thread is dedicated to handling
@connection and may perform blocking IO. The signal handler need
not return until the connection is closed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE to stop further signal handlers from being called</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a new #GSocketConnection object.</doc>
            <type name="SocketConnection"/>
          </parameter>
          <parameter name="source_object" transfer-ownership="none">
            <doc xml:space="preserve">the source_object passed to g_socket_listener_add_address().</doc>
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ThreadedSocketServiceClass" c:type="GThreadedSocketServiceClass" glib:is-gtype-struct-for="ThreadedSocketService">
      <field name="parent_class">
        <type name="SocketServiceClass" c:type="GSocketServiceClass"/>
      </field>
      <field name="run">
        <callback name="run">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="service" transfer-ownership="none">
              <type name="ThreadedSocketService" c:type="GThreadedSocketService*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="SocketConnection" c:type="GSocketConnection*"/>
            </parameter>
            <parameter name="source_object" transfer-ownership="none">
              <type name="GObject.Object" c:type="GObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="ThreadedSocketServicePrivate" c:type="GThreadedSocketServicePrivate" disguised="1">
    </record>
    <enumeration name="TlsAuthenticationMode" version="2.28" glib:type-name="GTlsAuthenticationMode" glib:get-type="g_tls_authentication_mode_get_type" c:type="GTlsAuthenticationMode">
      <doc xml:space="preserve">The client authentication mode for a #GTlsServerConnection.</doc>
      <member name="none" value="0" c:identifier="G_TLS_AUTHENTICATION_NONE" glib:nick="none">
        <doc xml:space="preserve">client authentication not required</doc>
      </member>
      <member name="requested" value="1" c:identifier="G_TLS_AUTHENTICATION_REQUESTED" glib:nick="requested">
        <doc xml:space="preserve">client authentication is requested</doc>
      </member>
      <member name="required" value="2" c:identifier="G_TLS_AUTHENTICATION_REQUIRED" glib:nick="required">
        <doc xml:space="preserve">client authentication is required</doc>
      </member>
    </enumeration>
    <interface name="TlsBackend" c:symbol-prefix="tls_backend" c:type="GTlsBackend" version="2.28" glib:type-name="GTlsBackend" glib:get-type="g_tls_backend_get_type" glib:type-struct="TlsBackendInterface">
      <doc xml:space="preserve">TLS (Transport Layer Security, aka SSL) and DTLS backend.</doc>
      <function name="get_default" c:identifier="g_tls_backend_get_default" version="2.28">
        <doc xml:space="preserve">Gets the default #GTlsBackend for the system.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GTlsBackend</doc>
          <type name="TlsBackend" c:type="GTlsBackend*"/>
        </return-value>
      </function>
      <virtual-method name="get_default_database" invoker="get_default_database" version="2.30">
        <doc xml:space="preserve">Gets the default #GTlsDatabase used to verify TLS connections.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the default database, which should be
              unreffed when done.</doc>
          <type name="TlsDatabase" c:type="GTlsDatabase*"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <doc xml:space="preserve">the #GTlsBackend</doc>
            <type name="TlsBackend" c:type="GTlsBackend*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="supports_dtls" invoker="supports_dtls" version="2.48">
        <doc xml:space="preserve">Checks if DTLS is supported. DTLS support may not be available even if TLS
support is available, and vice-versa.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether DTLS is supported</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <doc xml:space="preserve">the #GTlsBackend</doc>
            <type name="TlsBackend" c:type="GTlsBackend*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="supports_tls" invoker="supports_tls" version="2.28">
        <doc xml:space="preserve">Checks if TLS is supported; if this returns %FALSE for the default
#GTlsBackend, it means no "real" TLS backend is available.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether or not TLS is supported</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <doc xml:space="preserve">the #GTlsBackend</doc>
            <type name="TlsBackend" c:type="GTlsBackend*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="get_certificate_type" c:identifier="g_tls_backend_get_certificate_type" version="2.28">
        <doc xml:space="preserve">Gets the #GType of @backend's #GTlsCertificate implementation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GType of @backend's #GTlsCertificate
  implementation.</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <doc xml:space="preserve">the #GTlsBackend</doc>
            <type name="TlsBackend" c:type="GTlsBackend*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_client_connection_type" c:identifier="g_tls_backend_get_client_connection_type" version="2.28">
        <doc xml:space="preserve">Gets the #GType of @backend's #GTlsClientConnection implementation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GType of @backend's #GTlsClientConnection
  implementation.</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <doc xml:space="preserve">the #GTlsBackend</doc>
            <type name="TlsBackend" c:type="GTlsBackend*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_default_database" c:identifier="g_tls_backend_get_default_database" version="2.30">
        <doc xml:space="preserve">Gets the default #GTlsDatabase used to verify TLS connections.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the default database, which should be
              unreffed when done.</doc>
          <type name="TlsDatabase" c:type="GTlsDatabase*"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <doc xml:space="preserve">the #GTlsBackend</doc>
            <type name="TlsBackend" c:type="GTlsBackend*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dtls_client_connection_type" c:identifier="g_tls_backend_get_dtls_client_connection_type" version="2.48">
        <doc xml:space="preserve">Gets the #GType of @backend&#x2019;s #GDtlsClientConnection implementation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GType of @backend&#x2019;s #GDtlsClientConnection
  implementation, or %G_TYPE_INVALID if this backend doesn&#x2019;t support DTLS.</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <doc xml:space="preserve">the #GTlsBackend</doc>
            <type name="TlsBackend" c:type="GTlsBackend*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dtls_server_connection_type" c:identifier="g_tls_backend_get_dtls_server_connection_type" version="2.48">
        <doc xml:space="preserve">Gets the #GType of @backend&#x2019;s #GDtlsServerConnection implementation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GType of @backend&#x2019;s #GDtlsServerConnection
  implementation, or %G_TYPE_INVALID if this backend doesn&#x2019;t support DTLS.</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <doc xml:space="preserve">the #GTlsBackend</doc>
            <type name="TlsBackend" c:type="GTlsBackend*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_file_database_type" c:identifier="g_tls_backend_get_file_database_type" version="2.30">
        <doc xml:space="preserve">Gets the #GType of @backend's #GTlsFileDatabase implementation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GType of backend's #GTlsFileDatabase implementation.</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <doc xml:space="preserve">the #GTlsBackend</doc>
            <type name="TlsBackend" c:type="GTlsBackend*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_server_connection_type" c:identifier="g_tls_backend_get_server_connection_type" version="2.28">
        <doc xml:space="preserve">Gets the #GType of @backend's #GTlsServerConnection implementation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GType of @backend's #GTlsServerConnection
  implementation.</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <doc xml:space="preserve">the #GTlsBackend</doc>
            <type name="TlsBackend" c:type="GTlsBackend*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="supports_dtls" c:identifier="g_tls_backend_supports_dtls" version="2.48">
        <doc xml:space="preserve">Checks if DTLS is supported. DTLS support may not be available even if TLS
support is available, and vice-versa.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether DTLS is supported</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <doc xml:space="preserve">the #GTlsBackend</doc>
            <type name="TlsBackend" c:type="GTlsBackend*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="supports_tls" c:identifier="g_tls_backend_supports_tls" version="2.28">
        <doc xml:space="preserve">Checks if TLS is supported; if this returns %FALSE for the default
#GTlsBackend, it means no "real" TLS backend is available.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether or not TLS is supported</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <doc xml:space="preserve">the #GTlsBackend</doc>
            <type name="TlsBackend" c:type="GTlsBackend*"/>
          </instance-parameter>
        </parameters>
      </method>
    </interface>
    <record name="TlsBackendInterface" c:type="GTlsBackendInterface" glib:is-gtype-struct-for="TlsBackend" version="2.28">
      <doc xml:space="preserve">Provides an interface for describing TLS-related types.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="supports_tls">
        <callback name="supports_tls">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">whether or not TLS is supported</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="backend" transfer-ownership="none">
              <doc xml:space="preserve">the #GTlsBackend</doc>
              <type name="TlsBackend" c:type="GTlsBackend*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_certificate_type">
        <callback name="get_certificate_type">
          <return-value transfer-ownership="none">
            <type name="GType" c:type="GType"/>
          </return-value>
        </callback>
      </field>
      <field name="get_client_connection_type">
        <callback name="get_client_connection_type">
          <return-value transfer-ownership="none">
            <type name="GType" c:type="GType"/>
          </return-value>
        </callback>
      </field>
      <field name="get_server_connection_type">
        <callback name="get_server_connection_type">
          <return-value transfer-ownership="none">
            <type name="GType" c:type="GType"/>
          </return-value>
        </callback>
      </field>
      <field name="get_file_database_type">
        <callback name="get_file_database_type">
          <return-value transfer-ownership="none">
            <type name="GType" c:type="GType"/>
          </return-value>
        </callback>
      </field>
      <field name="get_default_database">
        <callback name="get_default_database">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the default database, which should be
              unreffed when done.</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </return-value>
          <parameters>
            <parameter name="backend" transfer-ownership="none">
              <doc xml:space="preserve">the #GTlsBackend</doc>
              <type name="TlsBackend" c:type="GTlsBackend*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="supports_dtls">
        <callback name="supports_dtls">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">whether DTLS is supported</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="backend" transfer-ownership="none">
              <doc xml:space="preserve">the #GTlsBackend</doc>
              <type name="TlsBackend" c:type="GTlsBackend*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_dtls_client_connection_type">
        <callback name="get_dtls_client_connection_type">
          <return-value transfer-ownership="none">
            <type name="GType" c:type="GType"/>
          </return-value>
        </callback>
      </field>
      <field name="get_dtls_server_connection_type">
        <callback name="get_dtls_server_connection_type">
          <return-value transfer-ownership="none">
            <type name="GType" c:type="GType"/>
          </return-value>
        </callback>
      </field>
    </record>
    <class name="TlsCertificate" c:symbol-prefix="tls_certificate" c:type="GTlsCertificate" version="2.28" parent="GObject.Object" abstract="1" glib:type-name="GTlsCertificate" glib:get-type="g_tls_certificate_get_type" glib:type-struct="TlsCertificateClass">
      <doc xml:space="preserve">A certificate used for TLS authentication and encryption.
This can represent either a certificate only (eg, the certificate
received by a client from a server), or the combination of
a certificate and a private key (which is needed when acting as a
#GTlsServerConnection).</doc>
      <constructor name="new_from_file" c:identifier="g_tls_certificate_new_from_file" version="2.28" throws="1">
        <doc xml:space="preserve">Creates a #GTlsCertificate from the PEM-encoded data in @file. The
returned certificate will be the first certificate found in @file. As
of GLib 2.44, if @file contains more certificates it will try to load
a certificate chain. All certificates will be verified in the order
found (top-level certificate should be the last one in the file) and
the #GTlsCertificate:issuer property of each certificate will be set
accordingly if the verification succeeds. If any certificate in the
chain cannot be verified, the first certificate in the file will
still be returned.

If @file cannot be read or parsed, the function will return %NULL and
set @error. Otherwise, this behaves like
g_tls_certificate_new_from_pem().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new certificate, or %NULL on error</doc>
          <type name="TlsCertificate" c:type="GTlsCertificate*"/>
        </return-value>
        <parameters>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">file containing a PEM-encoded certificate to import</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_files" c:identifier="g_tls_certificate_new_from_files" version="2.28" throws="1">
        <doc xml:space="preserve">Creates a #GTlsCertificate from the PEM-encoded data in @cert_file
and @key_file. The returned certificate will be the first certificate
found in @cert_file. As of GLib 2.44, if @cert_file contains more
certificates it will try to load a certificate chain. All
certificates will be verified in the order found (top-level
certificate should be the last one in the file) and the
#GTlsCertificate:issuer property of each certificate will be set
accordingly if the verification succeeds. If any certificate in the
chain cannot be verified, the first certificate in the file will
still be returned.

If either file cannot be read or parsed, the function will return
%NULL and set @error. Otherwise, this behaves like
g_tls_certificate_new_from_pem().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new certificate, or %NULL on error</doc>
          <type name="TlsCertificate" c:type="GTlsCertificate*"/>
        </return-value>
        <parameters>
          <parameter name="cert_file" transfer-ownership="none">
            <doc xml:space="preserve">file containing one or more PEM-encoded
    certificates to import</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
          <parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">file containing a PEM-encoded private key
    to import</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_pem" c:identifier="g_tls_certificate_new_from_pem" version="2.28" throws="1">
        <doc xml:space="preserve">Creates a #GTlsCertificate from the PEM-encoded data in @data. If
@data includes both a certificate and a private key, then the
returned certificate will include the private key data as well. (See
the #GTlsCertificate:private-key-pem property for information about
supported formats.)

The returned certificate will be the first certificate found in
@data. As of GLib 2.44, if @data contains more certificates it will
try to load a certificate chain. All certificates will be verified in
the order found (top-level certificate should be the last one in the
file) and the #GTlsCertificate:issuer property of each certificate
will be set accordingly if the verification succeeds. If any
certificate in the chain cannot be verified, the first certificate in
the file will still be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new certificate, or %NULL if @data is invalid</doc>
          <type name="TlsCertificate" c:type="GTlsCertificate*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">PEM-encoded certificate data</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of @data, or -1 if it's 0-terminated.</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="list_new_from_file" c:identifier="g_tls_certificate_list_new_from_file" version="2.28" throws="1">
        <doc xml:space="preserve">Creates one or more #GTlsCertificates from the PEM-encoded
data in @file. If @file cannot be read or parsed, the function will
return %NULL and set @error. If @file does not contain any
PEM-encoded certificates, this will return an empty list and not
set @error.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a
#GList containing #GTlsCertificate objects. You must free the list
and its contents when you are done with it.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="TlsCertificate"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">file containing PEM-encoded certificates to import</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="verify" invoker="verify" version="2.28">
        <doc xml:space="preserve">This verifies @cert and returns a set of #GTlsCertificateFlags
indicating any problems found with it. This can be used to verify a
certificate outside the context of making a connection, or to
check a certificate against a CA that is not part of the system
CA database.

If @identity is not %NULL, @cert's name(s) will be compared against
it, and %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return
value if it does not match. If @identity is %NULL, that bit will
never be set in the return value.

If @trusted_ca is not %NULL, then @cert (or one of the certificates
in its chain) must be signed by it, or else
%G_TLS_CERTIFICATE_UNKNOWN_CA will be set in the return value. If
@trusted_ca is %NULL, that bit will never be set in the return
value.

(All other #GTlsCertificateFlags values will always be set or unset
as appropriate.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the appropriate #GTlsCertificateFlags</doc>
          <type name="TlsCertificateFlags" c:type="GTlsCertificateFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="cert" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsCertificate</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </instance-parameter>
          <parameter name="identity" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the expected peer identity</doc>
            <type name="SocketConnectable" c:type="GSocketConnectable*"/>
          </parameter>
          <parameter name="trusted_ca" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the certificate of a trusted authority</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_issuer" c:identifier="g_tls_certificate_get_issuer" version="2.28">
        <doc xml:space="preserve">Gets the #GTlsCertificate representing @cert's issuer, if known</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The certificate of @cert's issuer,
or %NULL if @cert is self-signed or signed with an unknown
certificate.</doc>
          <type name="TlsCertificate" c:type="GTlsCertificate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cert" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsCertificate</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_same" c:identifier="g_tls_certificate_is_same" version="2.34">
        <doc xml:space="preserve">Check if two #GTlsCertificate objects represent the same certificate.
The raw DER byte data of the two certificates are checked for equality.
This has the effect that two certificates may compare equal even if
their #GTlsCertificate:issuer, #GTlsCertificate:private-key, or
#GTlsCertificate:private-key-pem properties differ.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the same or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cert_one" transfer-ownership="none">
            <doc xml:space="preserve">first certificate to compare</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </instance-parameter>
          <parameter name="cert_two" transfer-ownership="none">
            <doc xml:space="preserve">second certificate to compare</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="verify" c:identifier="g_tls_certificate_verify" version="2.28">
        <doc xml:space="preserve">This verifies @cert and returns a set of #GTlsCertificateFlags
indicating any problems found with it. This can be used to verify a
certificate outside the context of making a connection, or to
check a certificate against a CA that is not part of the system
CA database.

If @identity is not %NULL, @cert's name(s) will be compared against
it, and %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return
value if it does not match. If @identity is %NULL, that bit will
never be set in the return value.

If @trusted_ca is not %NULL, then @cert (or one of the certificates
in its chain) must be signed by it, or else
%G_TLS_CERTIFICATE_UNKNOWN_CA will be set in the return value. If
@trusted_ca is %NULL, that bit will never be set in the return
value.

(All other #GTlsCertificateFlags values will always be set or unset
as appropriate.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the appropriate #GTlsCertificateFlags</doc>
          <type name="TlsCertificateFlags" c:type="GTlsCertificateFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="cert" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsCertificate</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </instance-parameter>
          <parameter name="identity" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the expected peer identity</doc>
            <type name="SocketConnectable" c:type="GSocketConnectable*"/>
          </parameter>
          <parameter name="trusted_ca" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the certificate of a trusted authority</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
        </parameters>
      </method>
      <property name="certificate" version="2.28" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The DER (binary) encoded representation of the certificate.
This property and the #GTlsCertificate:certificate-pem property
represent the same data, just in different forms.</doc>
        <array name="GLib.ByteArray">
          <type name="guint8" c:type="guint8"/>
        </array>
      </property>
      <property name="certificate-pem" version="2.28" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The PEM (ASCII) encoded representation of the certificate.
This property and the #GTlsCertificate:certificate
property represent the same data, just in different forms.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="issuer" version="2.28" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">A #GTlsCertificate representing the entity that issued this
certificate. If %NULL, this means that the certificate is either
self-signed, or else the certificate of the issuer is not
available.</doc>
        <type name="TlsCertificate"/>
      </property>
      <property name="private-key" version="2.28" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The DER (binary) encoded representation of the certificate's
private key, in either PKCS#1 format or unencrypted PKCS#8
format. This property (or the #GTlsCertificate:private-key-pem
property) can be set when constructing a key (eg, from a file),
but cannot be read.

PKCS#8 format is supported since 2.32; earlier releases only
support PKCS#1. You can use the `openssl rsa`
tool to convert PKCS#8 keys to PKCS#1.</doc>
        <array name="GLib.ByteArray">
          <type name="guint8" c:type="guint8"/>
        </array>
      </property>
      <property name="private-key-pem" version="2.28" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The PEM (ASCII) encoded representation of the certificate's
private key in either PKCS#1 format ("`BEGIN RSA PRIVATE
KEY`") or unencrypted PKCS#8 format ("`BEGIN
PRIVATE KEY`"). This property (or the
#GTlsCertificate:private-key property) can be set when
constructing a key (eg, from a file), but cannot be read.

PKCS#8 format is supported since 2.32; earlier releases only
support PKCS#1. You can use the `openssl rsa`
tool to convert PKCS#8 keys to PKCS#1.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="TlsCertificatePrivate" c:type="GTlsCertificatePrivate*"/>
      </field>
    </class>
    <record name="TlsCertificateClass" c:type="GTlsCertificateClass" glib:is-gtype-struct-for="TlsCertificate">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="verify">
        <callback name="verify">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the appropriate #GTlsCertificateFlags</doc>
            <type name="TlsCertificateFlags" c:type="GTlsCertificateFlags"/>
          </return-value>
          <parameters>
            <parameter name="cert" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsCertificate</doc>
              <type name="TlsCertificate" c:type="GTlsCertificate*"/>
            </parameter>
            <parameter name="identity" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">the expected peer identity</doc>
              <type name="SocketConnectable" c:type="GSocketConnectable*"/>
            </parameter>
            <parameter name="trusted_ca" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">the certificate of a trusted authority</doc>
              <type name="TlsCertificate" c:type="GTlsCertificate*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="TlsCertificateFlags" version="2.28" glib:type-name="GTlsCertificateFlags" glib:get-type="g_tls_certificate_flags_get_type" c:type="GTlsCertificateFlags">
      <doc xml:space="preserve">A set of flags describing TLS certification validation. This can be
used to set which validation steps to perform (eg, with
g_tls_client_connection_set_validation_flags()), or to describe why
a particular certificate was rejected (eg, in
#GTlsConnection::accept-certificate).</doc>
      <member name="unknown_ca" value="1" c:identifier="G_TLS_CERTIFICATE_UNKNOWN_CA" glib:nick="unknown-ca">
        <doc xml:space="preserve">The signing certificate authority is
  not known.</doc>
      </member>
      <member name="bad_identity" value="2" c:identifier="G_TLS_CERTIFICATE_BAD_IDENTITY" glib:nick="bad-identity">
        <doc xml:space="preserve">The certificate does not match the
  expected identity of the site that it was retrieved from.</doc>
      </member>
      <member name="not_activated" value="4" c:identifier="G_TLS_CERTIFICATE_NOT_ACTIVATED" glib:nick="not-activated">
        <doc xml:space="preserve">The certificate's activation time
  is still in the future</doc>
      </member>
      <member name="expired" value="8" c:identifier="G_TLS_CERTIFICATE_EXPIRED" glib:nick="expired">
        <doc xml:space="preserve">The certificate has expired</doc>
      </member>
      <member name="revoked" value="16" c:identifier="G_TLS_CERTIFICATE_REVOKED" glib:nick="revoked">
        <doc xml:space="preserve">The certificate has been revoked
  according to the #GTlsConnection's certificate revocation list.</doc>
      </member>
      <member name="insecure" value="32" c:identifier="G_TLS_CERTIFICATE_INSECURE" glib:nick="insecure">
        <doc xml:space="preserve">The certificate's algorithm is
  considered insecure.</doc>
      </member>
      <member name="generic_error" value="64" c:identifier="G_TLS_CERTIFICATE_GENERIC_ERROR" glib:nick="generic-error">
        <doc xml:space="preserve">Some other error occurred validating
  the certificate</doc>
      </member>
      <member name="validate_all" value="127" c:identifier="G_TLS_CERTIFICATE_VALIDATE_ALL" glib:nick="validate-all">
        <doc xml:space="preserve">the combination of all of the above
  flags</doc>
      </member>
    </bitfield>
    <record name="TlsCertificatePrivate" c:type="GTlsCertificatePrivate" disguised="1">
    </record>
    <enumeration name="TlsCertificateRequestFlags" version="2.40" glib:type-name="GTlsCertificateRequestFlags" glib:get-type="g_tls_certificate_request_flags_get_type" c:type="GTlsCertificateRequestFlags">
      <doc xml:space="preserve">Flags for g_tls_interaction_request_certificate(),
g_tls_interaction_request_certificate_async(), and
g_tls_interaction_invoke_request_certificate().</doc>
      <member name="none" value="0" c:identifier="G_TLS_CERTIFICATE_REQUEST_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags</doc>
      </member>
    </enumeration>
    <interface name="TlsClientConnection" c:symbol-prefix="tls_client_connection" c:type="GTlsClientConnection" version="2.28" glib:type-name="GTlsClientConnection" glib:get-type="g_tls_client_connection_get_type" glib:type-struct="TlsClientConnectionInterface">
      <doc xml:space="preserve">#GTlsClientConnection is the client-side subclass of
#GTlsConnection, representing a client-side TLS connection.</doc>
      <prerequisite name="TlsConnection"/>
      <function name="new" c:identifier="g_tls_client_connection_new" version="2.28" throws="1">
        <doc xml:space="preserve">Creates a new #GTlsClientConnection wrapping @base_io_stream (which
must have pollable input and output streams) which is assumed to
communicate with the server identified by @server_identity.

See the documentation for #GTlsConnection:base-io-stream for restrictions
on when application code can run operations on the @base_io_stream after
this function has returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new
#GTlsClientConnection, or %NULL on error</doc>
          <type name="TlsClientConnection" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <parameter name="base_io_stream" transfer-ownership="none">
            <doc xml:space="preserve">the #GIOStream to wrap</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </parameter>
          <parameter name="server_identity" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the expected identity of the server</doc>
            <type name="SocketConnectable" c:type="GSocketConnectable*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="copy_session_state" invoker="copy_session_state" version="2.46">
        <doc xml:space="preserve">Copies session state from one connection to another. This is
not normally needed, but may be used when the same session
needs to be used between different endpoints as is required
by some protocols such as FTP over TLS. @source should have
already completed a handshake, and @conn should not have
completed a handshake.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsClientConnection</doc>
            <type name="TlsClientConnection" c:type="GTlsClientConnection*"/>
          </instance-parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsClientConnection</doc>
            <type name="TlsClientConnection" c:type="GTlsClientConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="copy_session_state" c:identifier="g_tls_client_connection_copy_session_state" version="2.46">
        <doc xml:space="preserve">Copies session state from one connection to another. This is
not normally needed, but may be used when the same session
needs to be used between different endpoints as is required
by some protocols such as FTP over TLS. @source should have
already completed a handshake, and @conn should not have
completed a handshake.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsClientConnection</doc>
            <type name="TlsClientConnection" c:type="GTlsClientConnection*"/>
          </instance-parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsClientConnection</doc>
            <type name="TlsClientConnection" c:type="GTlsClientConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_accepted_cas" c:identifier="g_tls_client_connection_get_accepted_cas" version="2.28">
        <doc xml:space="preserve">Gets the list of distinguished names of the Certificate Authorities
that the server will accept certificates from. This will be set
during the TLS handshake if the server requests a certificate.
Otherwise, it will be %NULL.

Each item in the list is a #GByteArray which contains the complete
subject DN of the certificate authority.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the list of
CA DNs. You should unref each element with g_byte_array_unref() and then
the free the list with g_list_free().</doc>
          <type name="GLib.List" c:type="GList*">
            <array name="GLib.ByteArray">
              <type name="guint8" c:type="guint8"/>
            </array>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">the #GTlsClientConnection</doc>
            <type name="TlsClientConnection" c:type="GTlsClientConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_server_identity" c:identifier="g_tls_client_connection_get_server_identity" version="2.28">
        <doc xml:space="preserve">Gets @conn's expected server identity</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GSocketConnectable describing the
expected server identity, or %NULL if the expected identity is not
known.</doc>
          <type name="SocketConnectable" c:type="GSocketConnectable*"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">the #GTlsClientConnection</doc>
            <type name="TlsClientConnection" c:type="GTlsClientConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_use_ssl3" c:identifier="g_tls_client_connection_get_use_ssl3" version="2.28" deprecated="1" deprecated-version="2.56">
        <doc xml:space="preserve">Gets whether @conn will force the lowest-supported TLS protocol
version rather than attempt to negotiate the highest mutually-
supported version of TLS; see g_tls_client_connection_set_use_ssl3().</doc>
        <doc-deprecated xml:space="preserve">SSL 3.0 is insecure, and this function does not
actually indicate whether it is enabled.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @conn will use the lowest-supported TLS protocol version</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">the #GTlsClientConnection</doc>
            <type name="TlsClientConnection" c:type="GTlsClientConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_validation_flags" c:identifier="g_tls_client_connection_get_validation_flags" version="2.28">
        <doc xml:space="preserve">Gets @conn's validation flags</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the validation flags</doc>
          <type name="TlsCertificateFlags" c:type="GTlsCertificateFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">the #GTlsClientConnection</doc>
            <type name="TlsClientConnection" c:type="GTlsClientConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_server_identity" c:identifier="g_tls_client_connection_set_server_identity" version="2.28">
        <doc xml:space="preserve">Sets @conn's expected server identity, which is used both to tell
servers on virtual hosts which certificate to present, and also
to let @conn know what name to look for in the certificate when
performing %G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">the #GTlsClientConnection</doc>
            <type name="TlsClientConnection" c:type="GTlsClientConnection*"/>
          </instance-parameter>
          <parameter name="identity" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketConnectable describing the expected server identity</doc>
            <type name="SocketConnectable" c:type="GSocketConnectable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_use_ssl3" c:identifier="g_tls_client_connection_set_use_ssl3" version="2.28" deprecated="1" deprecated-version="2.56">
        <doc xml:space="preserve">Since 2.42.1, if @use_ssl3 is %TRUE, this forces @conn to use the
lowest-supported TLS protocol version rather than trying to properly
negotiate the highest mutually-supported protocol version with the
peer. Be aware that SSL 3.0 is generally disabled by the
#GTlsBackend, so the lowest-supported protocol version is probably
not SSL 3.0.

Since 2.58, this may additionally cause an RFC 7507 fallback SCSV to
be sent to the server, causing modern TLS servers to immediately
terminate the connection. You should generally only use this function
if you need to connect to broken servers that exhibit TLS protocol
version intolerance, and when an initial attempt to connect to a
server normally has already failed.</doc>
        <doc-deprecated xml:space="preserve">SSL 3.0 is insecure, and this function does not
generally enable or disable it, despite its name.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">the #GTlsClientConnection</doc>
            <type name="TlsClientConnection" c:type="GTlsClientConnection*"/>
          </instance-parameter>
          <parameter name="use_ssl3" transfer-ownership="none">
            <doc xml:space="preserve">whether to use the lowest-supported protocol version</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_validation_flags" c:identifier="g_tls_client_connection_set_validation_flags" version="2.28">
        <doc xml:space="preserve">Sets @conn's validation flags, to override the default set of
checks performed when validating a server certificate. By default,
%G_TLS_CERTIFICATE_VALIDATE_ALL is used.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">the #GTlsClientConnection</doc>
            <type name="TlsClientConnection" c:type="GTlsClientConnection*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">the #GTlsCertificateFlags to use</doc>
            <type name="TlsCertificateFlags" c:type="GTlsCertificateFlags"/>
          </parameter>
        </parameters>
      </method>
      <property name="accepted-cas" version="2.28" transfer-ownership="none">
        <doc xml:space="preserve">A list of the distinguished names of the Certificate Authorities
that the server will accept client certificates signed by. If the
server requests a client certificate during the handshake, then
this property will be set after the handshake completes.

Each item in the list is a #GByteArray which contains the complete
subject DN of the certificate authority.</doc>
        <type name="GLib.List" c:type="gpointer">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </property>
      <property name="server-identity" version="2.28" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">A #GSocketConnectable describing the identity of the server that
is expected on the other end of the connection.

If the %G_TLS_CERTIFICATE_BAD_IDENTITY flag is set in
#GTlsClientConnection:validation-flags, this object will be used
to determine the expected identify of the remote end of the
connection; if #GTlsClientConnection:server-identity is not set,
or does not match the identity presented by the server, then the
%G_TLS_CERTIFICATE_BAD_IDENTITY validation will fail.

In addition to its use in verifying the server certificate,
this is also used to give a hint to the server about what
certificate we expect, which is useful for servers that serve
virtual hosts.</doc>
        <type name="SocketConnectable"/>
      </property>
      <property name="use-ssl3" version="2.28" deprecated="1" deprecated-version="2.56" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, forces the connection to use a fallback version of TLS
or SSL, rather than trying to negotiate the best version of TLS
to use. See g_tls_client_connection_set_use_ssl3().</doc>
        <doc-deprecated xml:space="preserve">SSL 3.0 is insecure, and this property does not
generally enable or disable it, despite its name.</doc-deprecated>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="validation-flags" version="2.28" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">What steps to perform when validating a certificate received from
a server. Server certificates that fail to validate in all of the
ways indicated here will be rejected unless the application
overrides the default via #GTlsConnection::accept-certificate.</doc>
        <type name="TlsCertificateFlags"/>
      </property>
    </interface>
    <record name="TlsClientConnectionInterface" c:type="GTlsClientConnectionInterface" glib:is-gtype-struct-for="TlsClientConnection" version="2.26">
      <doc xml:space="preserve">vtable for a #GTlsClientConnection implementation.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="copy_session_state">
        <callback name="copy_session_state">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="conn" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsClientConnection</doc>
              <type name="TlsClientConnection" c:type="GTlsClientConnection*"/>
            </parameter>
            <parameter name="source" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsClientConnection</doc>
              <type name="TlsClientConnection" c:type="GTlsClientConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="TlsConnection" c:symbol-prefix="tls_connection" c:type="GTlsConnection" version="2.28" parent="IOStream" abstract="1" glib:type-name="GTlsConnection" glib:get-type="g_tls_connection_get_type" glib:type-struct="TlsConnectionClass">
      <doc xml:space="preserve">#GTlsConnection is the base TLS connection class type, which wraps
a #GIOStream and provides TLS encryption on top of it. Its
subclasses, #GTlsClientConnection and #GTlsServerConnection,
implement client-side and server-side TLS, respectively.

For DTLS (Datagram TLS) support, see #GDtlsConnection.</doc>
      <virtual-method name="accept_certificate">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </instance-parameter>
          <parameter name="peer_cert" transfer-ownership="none">
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
          <parameter name="errors" transfer-ownership="none">
            <type name="TlsCertificateFlags" c:type="GTlsCertificateFlags"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="handshake" invoker="handshake" version="2.28" throws="1">
        <doc xml:space="preserve">Attempts a TLS handshake on @conn.

On the client side, it is never necessary to call this method;
although the connection needs to perform a handshake after
connecting (or after sending a "STARTTLS"-type command) and may
need to rehandshake later if the server requests it,
#GTlsConnection will handle this for you automatically when you try
to send or receive data on the connection. However, you can call
g_tls_connection_handshake() manually if you want to know for sure
whether the initial handshake succeeded or failed (as opposed to
just immediately trying to write to @conn's output stream, in which
case if it fails, it may not be possible to tell if it failed
before or after completing the handshake).

Likewise, on the server side, although a handshake is necessary at
the beginning of the communication, you do not need to call this
function explicitly unless you want clearer error reporting.
However, you may call g_tls_connection_handshake() later on to
rehandshake, if TLS 1.2 or older is in use. With TLS 1.3, the
behavior is undefined but guaranteed to be reasonable and
nondestructive, so most older code should be expected to continue to
work without changes.

#GTlsConnection::accept_certificate may be emitted during the
handshake.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">success or failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsConnection</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="handshake_async" invoker="handshake_async" version="2.28">
        <doc xml:space="preserve">Asynchronously performs a TLS handshake on @conn. See
g_tls_connection_handshake() for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsConnection</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">callback to call when the handshake is complete</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">the data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="handshake_finish" invoker="handshake_finish" version="2.28" throws="1">
        <doc xml:space="preserve">Finish an asynchronous TLS handshake operation. See
g_tls_connection_handshake() for more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure, in which
case @error will be set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsConnection</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="emit_accept_certificate" c:identifier="g_tls_connection_emit_accept_certificate" version="2.28">
        <doc xml:space="preserve">Used by #GTlsConnection implementations to emit the
#GTlsConnection::accept-certificate signal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if one of the signal handlers has returned
    %TRUE to accept @peer_cert</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsConnection</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </instance-parameter>
          <parameter name="peer_cert" transfer-ownership="none">
            <doc xml:space="preserve">the peer's #GTlsCertificate</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
          <parameter name="errors" transfer-ownership="none">
            <doc xml:space="preserve">the problems with @peer_cert</doc>
            <type name="TlsCertificateFlags" c:type="GTlsCertificateFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_certificate" c:identifier="g_tls_connection_get_certificate" version="2.28">
        <doc xml:space="preserve">Gets @conn's certificate, as set by
g_tls_connection_set_certificate().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@conn's certificate, or %NULL</doc>
          <type name="TlsCertificate" c:type="GTlsCertificate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsConnection</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_database" c:identifier="g_tls_connection_get_database" version="2.30">
        <doc xml:space="preserve">Gets the certificate database that @conn uses to verify
peer certificates. See g_tls_connection_set_database().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the certificate database that @conn uses or %NULL</doc>
          <type name="TlsDatabase" c:type="GTlsDatabase*"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsConnection</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_interaction" c:identifier="g_tls_connection_get_interaction" version="2.30">
        <doc xml:space="preserve">Get the object that will be used to interact with the user. It will be used
for things like prompting the user for passwords. If %NULL is returned, then
no user interaction will occur for this connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The interaction object.</doc>
          <type name="TlsInteraction" c:type="GTlsInteraction*"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_peer_certificate" c:identifier="g_tls_connection_get_peer_certificate" version="2.28">
        <doc xml:space="preserve">Gets @conn's peer's certificate after the handshake has completed.
(It is not set during the emission of
#GTlsConnection::accept-certificate.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@conn's peer's certificate, or %NULL</doc>
          <type name="TlsCertificate" c:type="GTlsCertificate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsConnection</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_peer_certificate_errors" c:identifier="g_tls_connection_get_peer_certificate_errors" version="2.28">
        <doc xml:space="preserve">Gets the errors associated with validating @conn's peer's
certificate, after the handshake has completed. (It is not set
during the emission of #GTlsConnection::accept-certificate.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@conn's peer's certificate errors</doc>
          <type name="TlsCertificateFlags" c:type="GTlsCertificateFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsConnection</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_rehandshake_mode" c:identifier="g_tls_connection_get_rehandshake_mode" version="2.28">
        <doc xml:space="preserve">Gets @conn rehandshaking mode. See
g_tls_connection_set_rehandshake_mode() for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@conn's rehandshaking mode</doc>
          <type name="TlsRehandshakeMode" c:type="GTlsRehandshakeMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsConnection</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_require_close_notify" c:identifier="g_tls_connection_get_require_close_notify" version="2.28">
        <doc xml:space="preserve">Tests whether or not @conn expects a proper TLS close notification
when the connection is closed. See
g_tls_connection_set_require_close_notify() for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @conn requires a proper TLS close
notification.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsConnection</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_use_system_certdb" c:identifier="g_tls_connection_get_use_system_certdb" deprecated="1" deprecated-version="2.30">
        <doc xml:space="preserve">Gets whether @conn uses the system certificate database to verify
peer certificates. See g_tls_connection_set_use_system_certdb().</doc>
        <doc-deprecated xml:space="preserve">Use g_tls_connection_get_database() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @conn uses the system certificate database</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsConnection</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="handshake" c:identifier="g_tls_connection_handshake" version="2.28" throws="1">
        <doc xml:space="preserve">Attempts a TLS handshake on @conn.

On the client side, it is never necessary to call this method;
although the connection needs to perform a handshake after
connecting (or after sending a "STARTTLS"-type command) and may
need to rehandshake later if the server requests it,
#GTlsConnection will handle this for you automatically when you try
to send or receive data on the connection. However, you can call
g_tls_connection_handshake() manually if you want to know for sure
whether the initial handshake succeeded or failed (as opposed to
just immediately trying to write to @conn's output stream, in which
case if it fails, it may not be possible to tell if it failed
before or after completing the handshake).

Likewise, on the server side, although a handshake is necessary at
the beginning of the communication, you do not need to call this
function explicitly unless you want clearer error reporting.
However, you may call g_tls_connection_handshake() later on to
rehandshake, if TLS 1.2 or older is in use. With TLS 1.3, the
behavior is undefined but guaranteed to be reasonable and
nondestructive, so most older code should be expected to continue to
work without changes.

#GTlsConnection::accept_certificate may be emitted during the
handshake.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">success or failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsConnection</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="handshake_async" c:identifier="g_tls_connection_handshake_async" version="2.28">
        <doc xml:space="preserve">Asynchronously performs a TLS handshake on @conn. See
g_tls_connection_handshake() for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsConnection</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">callback to call when the handshake is complete</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="handshake_finish" c:identifier="g_tls_connection_handshake_finish" version="2.28" throws="1">
        <doc xml:space="preserve">Finish an asynchronous TLS handshake operation. See
g_tls_connection_handshake() for more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure, in which
case @error will be set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsConnection</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_certificate" c:identifier="g_tls_connection_set_certificate" version="2.28">
        <doc xml:space="preserve">This sets the certificate that @conn will present to its peer
during the TLS handshake. For a #GTlsServerConnection, it is
mandatory to set this, and that will normally be done at construct
time.

For a #GTlsClientConnection, this is optional. If a handshake fails
with %G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server
requires a certificate, and if you try connecting again, you should
call this method first. You can call
g_tls_client_connection_get_accepted_cas() on the failed connection
to get a list of Certificate Authorities that the server will
accept certificates from.

(It is also possible that a server will allow the connection with
or without a certificate; in that case, if you don't provide a
certificate, you can tell that the server requested one by the fact
that g_tls_client_connection_get_accepted_cas() will return
non-%NULL.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsConnection</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </instance-parameter>
          <parameter name="certificate" transfer-ownership="none">
            <doc xml:space="preserve">the certificate to use for @conn</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_database" c:identifier="g_tls_connection_set_database" version="2.30">
        <doc xml:space="preserve">Sets the certificate database that is used to verify peer certificates.
This is set to the default database by default. See
g_tls_backend_get_default_database(). If set to %NULL, then
peer certificate validation will always set the
%G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
#GTlsConnection::accept-certificate will always be emitted on
client-side connections, unless that bit is not set in
#GTlsClientConnection:validation-flags).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsConnection</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </instance-parameter>
          <parameter name="database" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_interaction" c:identifier="g_tls_connection_set_interaction" version="2.30">
        <doc xml:space="preserve">Set the object that will be used to interact with the user. It will be used
for things like prompting the user for passwords.

The @interaction argument will normally be a derived subclass of
#GTlsInteraction. %NULL can also be provided if no user interaction
should occur for this connection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a connection</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </instance-parameter>
          <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an interaction object, or %NULL</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_rehandshake_mode" c:identifier="g_tls_connection_set_rehandshake_mode" version="2.28">
        <doc xml:space="preserve">Sets how @conn behaves with respect to rehandshaking requests, when
TLS 1.2 or older is in use.

%G_TLS_REHANDSHAKE_NEVER means that it will never agree to
rehandshake after the initial handshake is complete. (For a client,
this means it will refuse rehandshake requests from the server, and
for a server, this means it will close the connection with an error
if the client attempts to rehandshake.)

%G_TLS_REHANDSHAKE_SAFELY means that the connection will allow a
rehandshake only if the other end of the connection supports the
TLS `renegotiation_info` extension. This is the default behavior,
but means that rehandshaking will not work against older
implementations that do not support that extension.

%G_TLS_REHANDSHAKE_UNSAFELY means that the connection will allow
rehandshaking even without the `renegotiation_info` extension. On
the server side in particular, this is not recommended, since it
leaves the server open to certain attacks. However, this mode is
necessary if you need to allow renegotiation with older client
software.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsConnection</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </instance-parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">the rehandshaking mode</doc>
            <type name="TlsRehandshakeMode" c:type="GTlsRehandshakeMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_require_close_notify" c:identifier="g_tls_connection_set_require_close_notify" version="2.28">
        <doc xml:space="preserve">Sets whether or not @conn expects a proper TLS close notification
before the connection is closed. If this is %TRUE (the default),
then @conn will expect to receive a TLS close notification from its
peer before the connection is closed, and will return a
%G_TLS_ERROR_EOF error if the connection is closed without proper
notification (since this may indicate a network error, or
man-in-the-middle attack).

In some protocols, the application will know whether or not the
connection was closed cleanly based on application-level data
(because the application-level data includes a length field, or is
somehow self-delimiting); in this case, the close notify is
redundant and sometimes omitted. (TLS 1.1 explicitly allows this;
in TLS 1.0 it is technically an error, but often done anyway.) You
can use g_tls_connection_set_require_close_notify() to tell @conn
to allow an "unannounced" connection close, in which case the close
will show up as a 0-length read, as in a non-TLS
#GSocketConnection, and it is up to the application to check that
the data has been fully received.

Note that this only affects the behavior when the peer closes the
connection; when the application calls g_io_stream_close() itself
on @conn, this will send a close notification regardless of the
setting of this property. If you explicitly want to do an unclean
close, you can close @conn's #GTlsConnection:base-io-stream rather
than closing @conn itself, but note that this may only be done when no other
operations are pending on @conn or the base I/O stream.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsConnection</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </instance-parameter>
          <parameter name="require_close_notify" transfer-ownership="none">
            <doc xml:space="preserve">whether or not to require close notification</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_use_system_certdb" c:identifier="g_tls_connection_set_use_system_certdb" deprecated="1" deprecated-version="2.30">
        <doc xml:space="preserve">Sets whether @conn uses the system certificate database to verify
peer certificates. This is %TRUE by default. If set to %FALSE, then
peer certificate validation will always set the
%G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
#GTlsConnection::accept-certificate will always be emitted on
client-side connections, unless that bit is not set in
#GTlsClientConnection:validation-flags).</doc>
        <doc-deprecated xml:space="preserve">Use g_tls_connection_set_database() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsConnection</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </instance-parameter>
          <parameter name="use_system_certdb" transfer-ownership="none">
            <doc xml:space="preserve">whether to use the system certificate database</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="base-io-stream" version="2.28" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The #GIOStream that the connection wraps. The connection holds a reference
to this stream, and may run operations on the stream from other threads
throughout its lifetime. Consequently, after the #GIOStream has been
constructed, application code may only run its own operations on this
stream when no #GIOStream operations are running.</doc>
        <type name="IOStream"/>
      </property>
      <property name="certificate" version="2.28" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The connection's certificate; see
g_tls_connection_set_certificate().</doc>
        <type name="TlsCertificate"/>
      </property>
      <property name="database" version="2.30" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The certificate database to use when verifying this TLS connection.
If no certificate database is set, then the default database will be
used. See g_tls_backend_get_default_database().</doc>
        <type name="TlsDatabase"/>
      </property>
      <property name="interaction" version="2.30" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">A #GTlsInteraction object to be used when the connection or certificate
database need to interact with the user. This will be used to prompt the
user for passwords where necessary.</doc>
        <type name="TlsInteraction"/>
      </property>
      <property name="peer-certificate" version="2.28" transfer-ownership="none">
        <doc xml:space="preserve">The connection's peer's certificate, after the TLS handshake has
completed and the certificate has been accepted. Note in
particular that this is not yet set during the emission of
#GTlsConnection::accept-certificate.

(You can watch for a #GObject::notify signal on this property to
detect when a handshake has occurred.)</doc>
        <type name="TlsCertificate"/>
      </property>
      <property name="peer-certificate-errors" version="2.28" transfer-ownership="none">
        <doc xml:space="preserve">The errors noticed-and-ignored while verifying
#GTlsConnection:peer-certificate. Normally this should be 0, but
it may not be if #GTlsClientConnection:validation-flags is not
%G_TLS_CERTIFICATE_VALIDATE_ALL, or if
#GTlsConnection::accept-certificate overrode the default
behavior.</doc>
        <type name="TlsCertificateFlags"/>
      </property>
      <property name="rehandshake-mode" version="2.28" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">The rehandshaking mode. See
g_tls_connection_set_rehandshake_mode().</doc>
        <type name="TlsRehandshakeMode"/>
      </property>
      <property name="require-close-notify" version="2.28" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether or not proper TLS close notification is required.
See g_tls_connection_set_require_close_notify().</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="use-system-certdb" deprecated="1" deprecated-version="2.30" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether or not the system certificate database will be used to
verify peer certificates. See
g_tls_connection_set_use_system_certdb().</doc>
        <doc-deprecated xml:space="preserve">Use GTlsConnection:database instead</doc-deprecated>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent_instance">
        <type name="IOStream" c:type="GIOStream"/>
      </field>
      <field name="priv">
        <type name="TlsConnectionPrivate" c:type="GTlsConnectionPrivate*"/>
      </field>
      <glib:signal name="accept-certificate" when="last" version="2.28">
        <doc xml:space="preserve">Emitted during the TLS handshake after the peer certificate has
been received. You can examine @peer_cert's certification path by
calling g_tls_certificate_get_issuer() on it.

For a client-side connection, @peer_cert is the server's
certificate, and the signal will only be emitted if the
certificate was not acceptable according to @conn's
#GTlsClientConnection:validation_flags. If you would like the
certificate to be accepted despite @errors, return %TRUE from the
signal handler. Otherwise, if no handler accepts the certificate,
the handshake will fail with %G_TLS_ERROR_BAD_CERTIFICATE.

For a server-side connection, @peer_cert is the certificate
presented by the client, if this was requested via the server's
#GTlsServerConnection:authentication_mode. On the server side,
the signal is always emitted when the client presents a
certificate, and the certificate will only be accepted if a
handler returns %TRUE.

Note that if this signal is emitted as part of asynchronous I/O
in the main thread, then you should not attempt to interact with
the user before returning from the signal handler. If you want to
let the user decide whether or not to accept the certificate, you
would have to return %FALSE from the signal handler on the first
attempt, and then after the connection attempt returns a
%G_TLS_ERROR_HANDSHAKE, you can interact with the user, and if
the user decides to accept the certificate, remember that fact,
create a new connection, and return %TRUE from the signal handler
the next time.

If you are doing I/O in another thread, you do not
need to worry about this, and can simply block in the signal
handler until the UI thread returns an answer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE to accept @peer_cert (which will also
immediately end the signal emission). %FALSE to allow the signal
emission to continue, which will cause the handshake to fail if
no one else overrides it.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="peer_cert" transfer-ownership="none">
            <doc xml:space="preserve">the peer's #GTlsCertificate</doc>
            <type name="TlsCertificate"/>
          </parameter>
          <parameter name="errors" transfer-ownership="none">
            <doc xml:space="preserve">the problems with @peer_cert.</doc>
            <type name="TlsCertificateFlags"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="TlsConnectionClass" c:type="GTlsConnectionClass" glib:is-gtype-struct-for="TlsConnection">
      <field name="parent_class">
        <type name="IOStreamClass" c:type="GIOStreamClass"/>
      </field>
      <field name="accept_certificate">
        <callback name="accept_certificate">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="connection" transfer-ownership="none">
              <type name="TlsConnection" c:type="GTlsConnection*"/>
            </parameter>
            <parameter name="peer_cert" transfer-ownership="none">
              <type name="TlsCertificate" c:type="GTlsCertificate*"/>
            </parameter>
            <parameter name="errors" transfer-ownership="none">
              <type name="TlsCertificateFlags" c:type="GTlsCertificateFlags"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="handshake">
        <callback name="handshake" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">success or failure</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="conn" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsConnection</doc>
              <type name="TlsConnection" c:type="GTlsConnection*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="handshake_async">
        <callback name="handshake_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="conn" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsConnection</doc>
              <type name="TlsConnection" c:type="GTlsConnection*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">callback to call when the handshake is complete</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">the data to pass to the callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="handshake_finish">
        <callback name="handshake_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on failure, in which
case @error will be set.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="conn" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsConnection</doc>
              <type name="TlsConnection" c:type="GTlsConnection*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="TlsConnectionPrivate" c:type="GTlsConnectionPrivate" disguised="1">
    </record>
    <class name="TlsDatabase" c:symbol-prefix="tls_database" c:type="GTlsDatabase" version="2.30" parent="GObject.Object" abstract="1" glib:type-name="GTlsDatabase" glib:get-type="g_tls_database_get_type" glib:type-struct="TlsDatabaseClass">
      <doc xml:space="preserve">#GTlsDatabase is used to lookup certificates and other information
from a certificate or key store. It is an abstract base class which
TLS library specific subtypes override.

Most common client applications will not directly interact with
#GTlsDatabase. It is used internally by #GTlsConnection.</doc>
      <virtual-method name="create_certificate_handle" invoker="create_certificate_handle" version="2.30">
        <doc xml:space="preserve">Create a handle string for the certificate. The database will only be able
to create a handle for certificates that originate from the database. In
cases where the database cannot create a handle for a certificate, %NULL
will be returned.

This handle should be stable across various instances of the application,
and between applications. If a certificate is modified in the database,
then it is not guaranteed that this handle will continue to point to it.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a newly allocated string containing the
handle.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="certificate" transfer-ownership="none">
            <doc xml:space="preserve">certificate for which to create a handle.</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_certificate_for_handle" invoker="lookup_certificate_for_handle" version="2.30" throws="1">
        <doc xml:space="preserve">Lookup a certificate by its handle.

The handle should have been created by calling
g_tls_database_create_certificate_handle() on a #GTlsDatabase object of
the same TLS backend. The handle is designed to remain valid across
instantiations of the database.

If the handle is no longer valid, or does not point to a certificate in
this database, then %NULL will be returned.

This function can block, use g_tls_database_lookup_certificate_for_handle_async() to perform
the lookup operation asynchronously.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a newly allocated
#GTlsCertificate, or %NULL. Use g_object_unref() to release the certificate.</doc>
          <type name="TlsCertificate" c:type="GTlsCertificate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:space="preserve">a certificate handle</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">used to interact with the user if necessary</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags which affect the lookup.</doc>
            <type name="TlsDatabaseLookupFlags" c:type="GTlsDatabaseLookupFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_certificate_for_handle_async" invoker="lookup_certificate_for_handle_async" version="2.30">
        <doc xml:space="preserve">Asynchronously lookup a certificate by its handle in the database. See
g_tls_database_lookup_certificate_for_handle() for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:space="preserve">a certificate handle</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">used to interact with the user if necessary</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags which affect the lookup.</doc>
            <type name="TlsDatabaseLookupFlags" c:type="GTlsDatabaseLookupFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">callback to call when the operation completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
            <doc xml:space="preserve">the data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_certificate_for_handle_finish" invoker="lookup_certificate_for_handle_finish" version="2.30" throws="1">
        <doc xml:space="preserve">Finish an asynchronous lookup of a certificate by its handle. See
g_tls_database_lookup_certificate_by_handle() for more information.

If the handle is no longer valid, or does not point to a certificate in
this database, then %NULL will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #GTlsCertificate object.
Use g_object_unref() to release the certificate.</doc>
          <type name="TlsCertificate" c:type="GTlsCertificate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_certificate_issuer" invoker="lookup_certificate_issuer" version="2.30" throws="1">
        <doc xml:space="preserve">Lookup the issuer of @certificate in the database.

The %issuer property
of @certificate is not modified, and the two certificates are not hooked
into a chain.

This function can block, use g_tls_database_lookup_certificate_issuer_async() to perform
the lookup operation asynchronously.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated issuer #GTlsCertificate,
or %NULL. Use g_object_unref() to release the certificate.</doc>
          <type name="TlsCertificate" c:type="GTlsCertificate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="certificate" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsCertificate</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
          <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">used to interact with the user if necessary</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags which affect the lookup operation</doc>
            <type name="TlsDatabaseLookupFlags" c:type="GTlsDatabaseLookupFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_certificate_issuer_async" invoker="lookup_certificate_issuer_async" version="2.30">
        <doc xml:space="preserve">Asynchronously lookup the issuer of @certificate in the database. See
g_tls_database_lookup_certificate_issuer() for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="certificate" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsCertificate</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
          <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">used to interact with the user if necessary</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags which affect the lookup operation</doc>
            <type name="TlsDatabaseLookupFlags" c:type="GTlsDatabaseLookupFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">callback to call when the operation completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
            <doc xml:space="preserve">the data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_certificate_issuer_finish" invoker="lookup_certificate_issuer_finish" version="2.30" throws="1">
        <doc xml:space="preserve">Finish an asynchronous lookup issuer operation. See
g_tls_database_lookup_certificate_issuer() for more information.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated issuer #GTlsCertificate,
or %NULL. Use g_object_unref() to release the certificate.</doc>
          <type name="TlsCertificate" c:type="GTlsCertificate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_certificates_issued_by" invoker="lookup_certificates_issued_by" version="2.30" throws="1">
        <doc xml:space="preserve">Lookup certificates issued by this issuer in the database.

This function can block, use g_tls_database_lookup_certificates_issued_by_async() to perform
the lookup operation asynchronously.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated list of #GTlsCertificate
objects. Use g_object_unref() on each certificate, and g_list_free() on the release the list.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="TlsCertificate"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="issuer_raw_dn" transfer-ownership="none">
            <doc xml:space="preserve">a #GByteArray which holds the DER encoded issuer DN.</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">used to interact with the user if necessary</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags which affect the lookup operation.</doc>
            <type name="TlsDatabaseLookupFlags" c:type="GTlsDatabaseLookupFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_certificates_issued_by_async" invoker="lookup_certificates_issued_by_async" version="2.30">
        <doc xml:space="preserve">Asynchronously lookup certificates issued by this issuer in the database. See
g_tls_database_lookup_certificates_issued_by() for more information.

The database may choose to hold a reference to the issuer byte array for the duration
of of this asynchronous operation. The byte array should not be modified during
this time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="issuer_raw_dn" transfer-ownership="none">
            <doc xml:space="preserve">a #GByteArray which holds the DER encoded issuer DN.</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">used to interact with the user if necessary</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags which affect the lookup operation.</doc>
            <type name="TlsDatabaseLookupFlags" c:type="GTlsDatabaseLookupFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">callback to call when the operation completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
            <doc xml:space="preserve">the data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_certificates_issued_by_finish" invoker="lookup_certificates_issued_by_finish" version="2.30" throws="1">
        <doc xml:space="preserve">Finish an asynchronous lookup of certificates. See
g_tls_database_lookup_certificates_issued_by() for more information.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated list of #GTlsCertificate
objects. Use g_object_unref() on each certificate, and g_list_free() on the release the list.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="TlsCertificate"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="verify_chain" invoker="verify_chain" version="2.30" throws="1">
        <doc xml:space="preserve">Determines the validity of a certificate chain after looking up and
adding any missing certificates to the chain.

@chain is a chain of #GTlsCertificate objects each pointing to the next
certificate in the chain by its #GTlsCertificate:issuer property. The chain may initially
consist of one or more certificates. After the verification process is
complete, @chain may be modified by adding missing certificates, or removing
extra certificates. If a certificate anchor was found, then it is added to
the @chain.

@purpose describes the purpose (or usage) for which the certificate
is being used. Typically @purpose will be set to #G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER
which means that the certificate is being used to authenticate a server
(and we are acting as the client).

The @identity is used to check for pinned certificates (trust exceptions)
in the database. These will override the normal verification process on a
host by host basis.

Currently there are no @flags, and %G_TLS_DATABASE_VERIFY_NONE should be
used.

If @chain is found to be valid, then the return value will be 0. If
@chain is found to be invalid, then the return value will indicate
the problems found. If the function is unable to determine whether
@chain is valid or not (eg, because @cancellable is triggered
before it completes) then the return value will be
%G_TLS_CERTIFICATE_GENERIC_ERROR and @error will be set
accordingly. @error is not set when @chain is successfully analyzed
but found to be invalid.

This function can block, use g_tls_database_verify_chain_async() to perform
the verification operation asynchronously.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the appropriate #GTlsCertificateFlags which represents the
result of verification.</doc>
          <type name="TlsCertificateFlags" c:type="GTlsCertificateFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="chain" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsCertificate chain</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
          <parameter name="purpose" transfer-ownership="none">
            <doc xml:space="preserve">the purpose that this certificate chain will be used for.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="identity" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the expected peer identity</doc>
            <type name="SocketConnectable" c:type="GSocketConnectable*"/>
          </parameter>
          <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">used to interact with the user if necessary</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">additional verify flags</doc>
            <type name="TlsDatabaseVerifyFlags" c:type="GTlsDatabaseVerifyFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="verify_chain_async" invoker="verify_chain_async" version="2.30">
        <doc xml:space="preserve">Asynchronously determines the validity of a certificate chain after
looking up and adding any missing certificates to the chain. See
g_tls_database_verify_chain() for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="chain" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsCertificate chain</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
          <parameter name="purpose" transfer-ownership="none">
            <doc xml:space="preserve">the purpose that this certificate chain will be used for.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="identity" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the expected peer identity</doc>
            <type name="SocketConnectable" c:type="GSocketConnectable*"/>
          </parameter>
          <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">used to interact with the user if necessary</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">additional verify flags</doc>
            <type name="TlsDatabaseVerifyFlags" c:type="GTlsDatabaseVerifyFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="7">
            <doc xml:space="preserve">callback to call when the operation completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="7">
            <doc xml:space="preserve">the data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="verify_chain_finish" invoker="verify_chain_finish" version="2.30" throws="1">
        <doc xml:space="preserve">Finish an asynchronous verify chain operation. See
g_tls_database_verify_chain() for more information.

If @chain is found to be valid, then the return value will be 0. If
@chain is found to be invalid, then the return value will indicate
the problems found. If the function is unable to determine whether
@chain is valid or not (eg, because @cancellable is triggered
before it completes) then the return value will be
%G_TLS_CERTIFICATE_GENERIC_ERROR and @error will be set
accordingly. @error is not set when @chain is successfully analyzed
but found to be invalid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the appropriate #GTlsCertificateFlags which represents the
result of verification.</doc>
          <type name="TlsCertificateFlags" c:type="GTlsCertificateFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="create_certificate_handle" c:identifier="g_tls_database_create_certificate_handle" version="2.30">
        <doc xml:space="preserve">Create a handle string for the certificate. The database will only be able
to create a handle for certificates that originate from the database. In
cases where the database cannot create a handle for a certificate, %NULL
will be returned.

This handle should be stable across various instances of the application,
and between applications. If a certificate is modified in the database,
then it is not guaranteed that this handle will continue to point to it.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a newly allocated string containing the
handle.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="certificate" transfer-ownership="none">
            <doc xml:space="preserve">certificate for which to create a handle.</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_certificate_for_handle" c:identifier="g_tls_database_lookup_certificate_for_handle" version="2.30" throws="1">
        <doc xml:space="preserve">Lookup a certificate by its handle.

The handle should have been created by calling
g_tls_database_create_certificate_handle() on a #GTlsDatabase object of
the same TLS backend. The handle is designed to remain valid across
instantiations of the database.

If the handle is no longer valid, or does not point to a certificate in
this database, then %NULL will be returned.

This function can block, use g_tls_database_lookup_certificate_for_handle_async() to perform
the lookup operation asynchronously.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a newly allocated
#GTlsCertificate, or %NULL. Use g_object_unref() to release the certificate.</doc>
          <type name="TlsCertificate" c:type="GTlsCertificate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:space="preserve">a certificate handle</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">used to interact with the user if necessary</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags which affect the lookup.</doc>
            <type name="TlsDatabaseLookupFlags" c:type="GTlsDatabaseLookupFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_certificate_for_handle_async" c:identifier="g_tls_database_lookup_certificate_for_handle_async" version="2.30">
        <doc xml:space="preserve">Asynchronously lookup a certificate by its handle in the database. See
g_tls_database_lookup_certificate_for_handle() for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:space="preserve">a certificate handle</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">used to interact with the user if necessary</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags which affect the lookup.</doc>
            <type name="TlsDatabaseLookupFlags" c:type="GTlsDatabaseLookupFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">callback to call when the operation completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_certificate_for_handle_finish" c:identifier="g_tls_database_lookup_certificate_for_handle_finish" version="2.30" throws="1">
        <doc xml:space="preserve">Finish an asynchronous lookup of a certificate by its handle. See
g_tls_database_lookup_certificate_by_handle() for more information.

If the handle is no longer valid, or does not point to a certificate in
this database, then %NULL will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #GTlsCertificate object.
Use g_object_unref() to release the certificate.</doc>
          <type name="TlsCertificate" c:type="GTlsCertificate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_certificate_issuer" c:identifier="g_tls_database_lookup_certificate_issuer" version="2.30" throws="1">
        <doc xml:space="preserve">Lookup the issuer of @certificate in the database.

The %issuer property
of @certificate is not modified, and the two certificates are not hooked
into a chain.

This function can block, use g_tls_database_lookup_certificate_issuer_async() to perform
the lookup operation asynchronously.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated issuer #GTlsCertificate,
or %NULL. Use g_object_unref() to release the certificate.</doc>
          <type name="TlsCertificate" c:type="GTlsCertificate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="certificate" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsCertificate</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
          <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">used to interact with the user if necessary</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags which affect the lookup operation</doc>
            <type name="TlsDatabaseLookupFlags" c:type="GTlsDatabaseLookupFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_certificate_issuer_async" c:identifier="g_tls_database_lookup_certificate_issuer_async" version="2.30">
        <doc xml:space="preserve">Asynchronously lookup the issuer of @certificate in the database. See
g_tls_database_lookup_certificate_issuer() for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="certificate" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsCertificate</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
          <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">used to interact with the user if necessary</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags which affect the lookup operation</doc>
            <type name="TlsDatabaseLookupFlags" c:type="GTlsDatabaseLookupFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">callback to call when the operation completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_certificate_issuer_finish" c:identifier="g_tls_database_lookup_certificate_issuer_finish" version="2.30" throws="1">
        <doc xml:space="preserve">Finish an asynchronous lookup issuer operation. See
g_tls_database_lookup_certificate_issuer() for more information.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated issuer #GTlsCertificate,
or %NULL. Use g_object_unref() to release the certificate.</doc>
          <type name="TlsCertificate" c:type="GTlsCertificate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_certificates_issued_by" c:identifier="g_tls_database_lookup_certificates_issued_by" version="2.30" throws="1">
        <doc xml:space="preserve">Lookup certificates issued by this issuer in the database.

This function can block, use g_tls_database_lookup_certificates_issued_by_async() to perform
the lookup operation asynchronously.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated list of #GTlsCertificate
objects. Use g_object_unref() on each certificate, and g_list_free() on the release the list.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="TlsCertificate"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="issuer_raw_dn" transfer-ownership="none">
            <doc xml:space="preserve">a #GByteArray which holds the DER encoded issuer DN.</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">used to interact with the user if necessary</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags which affect the lookup operation.</doc>
            <type name="TlsDatabaseLookupFlags" c:type="GTlsDatabaseLookupFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_certificates_issued_by_async" c:identifier="g_tls_database_lookup_certificates_issued_by_async" version="2.30">
        <doc xml:space="preserve">Asynchronously lookup certificates issued by this issuer in the database. See
g_tls_database_lookup_certificates_issued_by() for more information.

The database may choose to hold a reference to the issuer byte array for the duration
of of this asynchronous operation. The byte array should not be modified during
this time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="issuer_raw_dn" transfer-ownership="none">
            <doc xml:space="preserve">a #GByteArray which holds the DER encoded issuer DN.</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">used to interact with the user if necessary</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags which affect the lookup operation.</doc>
            <type name="TlsDatabaseLookupFlags" c:type="GTlsDatabaseLookupFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">callback to call when the operation completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_certificates_issued_by_finish" c:identifier="g_tls_database_lookup_certificates_issued_by_finish" version="2.30" throws="1">
        <doc xml:space="preserve">Finish an asynchronous lookup of certificates. See
g_tls_database_lookup_certificates_issued_by() for more information.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated list of #GTlsCertificate
objects. Use g_object_unref() on each certificate, and g_list_free() on the release the list.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="TlsCertificate"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="verify_chain" c:identifier="g_tls_database_verify_chain" version="2.30" throws="1">
        <doc xml:space="preserve">Determines the validity of a certificate chain after looking up and
adding any missing certificates to the chain.

@chain is a chain of #GTlsCertificate objects each pointing to the next
certificate in the chain by its #GTlsCertificate:issuer property. The chain may initially
consist of one or more certificates. After the verification process is
complete, @chain may be modified by adding missing certificates, or removing
extra certificates. If a certificate anchor was found, then it is added to
the @chain.

@purpose describes the purpose (or usage) for which the certificate
is being used. Typically @purpose will be set to #G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER
which means that the certificate is being used to authenticate a server
(and we are acting as the client).

The @identity is used to check for pinned certificates (trust exceptions)
in the database. These will override the normal verification process on a
host by host basis.

Currently there are no @flags, and %G_TLS_DATABASE_VERIFY_NONE should be
used.

If @chain is found to be valid, then the return value will be 0. If
@chain is found to be invalid, then the return value will indicate
the problems found. If the function is unable to determine whether
@chain is valid or not (eg, because @cancellable is triggered
before it completes) then the return value will be
%G_TLS_CERTIFICATE_GENERIC_ERROR and @error will be set
accordingly. @error is not set when @chain is successfully analyzed
but found to be invalid.

This function can block, use g_tls_database_verify_chain_async() to perform
the verification operation asynchronously.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the appropriate #GTlsCertificateFlags which represents the
result of verification.</doc>
          <type name="TlsCertificateFlags" c:type="GTlsCertificateFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="chain" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsCertificate chain</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
          <parameter name="purpose" transfer-ownership="none">
            <doc xml:space="preserve">the purpose that this certificate chain will be used for.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="identity" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the expected peer identity</doc>
            <type name="SocketConnectable" c:type="GSocketConnectable*"/>
          </parameter>
          <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">used to interact with the user if necessary</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">additional verify flags</doc>
            <type name="TlsDatabaseVerifyFlags" c:type="GTlsDatabaseVerifyFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="verify_chain_async" c:identifier="g_tls_database_verify_chain_async" version="2.30">
        <doc xml:space="preserve">Asynchronously determines the validity of a certificate chain after
looking up and adding any missing certificates to the chain. See
g_tls_database_verify_chain() for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="chain" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsCertificate chain</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
          <parameter name="purpose" transfer-ownership="none">
            <doc xml:space="preserve">the purpose that this certificate chain will be used for.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="identity" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the expected peer identity</doc>
            <type name="SocketConnectable" c:type="GSocketConnectable*"/>
          </parameter>
          <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">used to interact with the user if necessary</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">additional verify flags</doc>
            <type name="TlsDatabaseVerifyFlags" c:type="GTlsDatabaseVerifyFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="7">
            <doc xml:space="preserve">callback to call when the operation completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="verify_chain_finish" c:identifier="g_tls_database_verify_chain_finish" version="2.30" throws="1">
        <doc xml:space="preserve">Finish an asynchronous verify chain operation. See
g_tls_database_verify_chain() for more information.

If @chain is found to be valid, then the return value will be 0. If
@chain is found to be invalid, then the return value will indicate
the problems found. If the function is unable to determine whether
@chain is valid or not (eg, because @cancellable is triggered
before it completes) then the return value will be
%G_TLS_CERTIFICATE_GENERIC_ERROR and @error will be set
accordingly. @error is not set when @chain is successfully analyzed
but found to be invalid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the appropriate #GTlsCertificateFlags which represents the
result of verification.</doc>
          <type name="TlsCertificateFlags" c:type="GTlsCertificateFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="TlsDatabase" c:type="GTlsDatabase*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="TlsDatabasePrivate" c:type="GTlsDatabasePrivate*"/>
      </field>
    </class>
    <record name="TlsDatabaseClass" c:type="GTlsDatabaseClass" glib:is-gtype-struct-for="TlsDatabase" version="2.30">
      <doc xml:space="preserve">The class for #GTlsDatabase. Derived classes should implement the various
virtual methods. _async and _finish methods have a default
implementation that runs the corresponding sync method in a thread.</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="verify_chain">
        <callback name="verify_chain" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the appropriate #GTlsCertificateFlags which represents the
result of verification.</doc>
            <type name="TlsCertificateFlags" c:type="GTlsCertificateFlags"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsDatabase</doc>
              <type name="TlsDatabase" c:type="GTlsDatabase*"/>
            </parameter>
            <parameter name="chain" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsCertificate chain</doc>
              <type name="TlsCertificate" c:type="GTlsCertificate*"/>
            </parameter>
            <parameter name="purpose" transfer-ownership="none">
              <doc xml:space="preserve">the purpose that this certificate chain will be used for.</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="identity" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">the expected peer identity</doc>
              <type name="SocketConnectable" c:type="GSocketConnectable*"/>
            </parameter>
            <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">used to interact with the user if necessary</doc>
              <type name="TlsInteraction" c:type="GTlsInteraction*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">additional verify flags</doc>
              <type name="TlsDatabaseVerifyFlags" c:type="GTlsDatabaseVerifyFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="verify_chain_async">
        <callback name="verify_chain_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsDatabase</doc>
              <type name="TlsDatabase" c:type="GTlsDatabase*"/>
            </parameter>
            <parameter name="chain" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsCertificate chain</doc>
              <type name="TlsCertificate" c:type="GTlsCertificate*"/>
            </parameter>
            <parameter name="purpose" transfer-ownership="none">
              <doc xml:space="preserve">the purpose that this certificate chain will be used for.</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="identity" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">the expected peer identity</doc>
              <type name="SocketConnectable" c:type="GSocketConnectable*"/>
            </parameter>
            <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">used to interact with the user if necessary</doc>
              <type name="TlsInteraction" c:type="GTlsInteraction*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">additional verify flags</doc>
              <type name="TlsDatabaseVerifyFlags" c:type="GTlsDatabaseVerifyFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="8">
              <doc xml:space="preserve">callback to call when the operation completes</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="8">
              <doc xml:space="preserve">the data to pass to the callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="verify_chain_finish">
        <callback name="verify_chain_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the appropriate #GTlsCertificateFlags which represents the
result of verification.</doc>
            <type name="TlsCertificateFlags" c:type="GTlsCertificateFlags"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsDatabase</doc>
              <type name="TlsDatabase" c:type="GTlsDatabase*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_certificate_handle">
        <callback name="create_certificate_handle">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">a newly allocated string containing the
handle.</doc>
            <type name="utf8" c:type="gchar*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsDatabase</doc>
              <type name="TlsDatabase" c:type="GTlsDatabase*"/>
            </parameter>
            <parameter name="certificate" transfer-ownership="none">
              <doc xml:space="preserve">certificate for which to create a handle.</doc>
              <type name="TlsCertificate" c:type="GTlsCertificate*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_certificate_for_handle">
        <callback name="lookup_certificate_for_handle" throws="1">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">a newly allocated
#GTlsCertificate, or %NULL. Use g_object_unref() to release the certificate.</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsDatabase</doc>
              <type name="TlsDatabase" c:type="GTlsDatabase*"/>
            </parameter>
            <parameter name="handle" transfer-ownership="none">
              <doc xml:space="preserve">a certificate handle</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">used to interact with the user if necessary</doc>
              <type name="TlsInteraction" c:type="GTlsInteraction*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">Flags which affect the lookup.</doc>
              <type name="TlsDatabaseLookupFlags" c:type="GTlsDatabaseLookupFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_certificate_for_handle_async">
        <callback name="lookup_certificate_for_handle_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsDatabase</doc>
              <type name="TlsDatabase" c:type="GTlsDatabase*"/>
            </parameter>
            <parameter name="handle" transfer-ownership="none">
              <doc xml:space="preserve">a certificate handle</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">used to interact with the user if necessary</doc>
              <type name="TlsInteraction" c:type="GTlsInteraction*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">Flags which affect the lookup.</doc>
              <type name="TlsDatabaseLookupFlags" c:type="GTlsDatabaseLookupFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
              <doc xml:space="preserve">callback to call when the operation completes</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6">
              <doc xml:space="preserve">the data to pass to the callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_certificate_for_handle_finish">
        <callback name="lookup_certificate_for_handle_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a newly allocated #GTlsCertificate object.
Use g_object_unref() to release the certificate.</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsDatabase</doc>
              <type name="TlsDatabase" c:type="GTlsDatabase*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_certificate_issuer">
        <callback name="lookup_certificate_issuer" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a newly allocated issuer #GTlsCertificate,
or %NULL. Use g_object_unref() to release the certificate.</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsDatabase</doc>
              <type name="TlsDatabase" c:type="GTlsDatabase*"/>
            </parameter>
            <parameter name="certificate" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsCertificate</doc>
              <type name="TlsCertificate" c:type="GTlsCertificate*"/>
            </parameter>
            <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">used to interact with the user if necessary</doc>
              <type name="TlsInteraction" c:type="GTlsInteraction*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags which affect the lookup operation</doc>
              <type name="TlsDatabaseLookupFlags" c:type="GTlsDatabaseLookupFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_certificate_issuer_async">
        <callback name="lookup_certificate_issuer_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsDatabase</doc>
              <type name="TlsDatabase" c:type="GTlsDatabase*"/>
            </parameter>
            <parameter name="certificate" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsCertificate</doc>
              <type name="TlsCertificate" c:type="GTlsCertificate*"/>
            </parameter>
            <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">used to interact with the user if necessary</doc>
              <type name="TlsInteraction" c:type="GTlsInteraction*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags which affect the lookup operation</doc>
              <type name="TlsDatabaseLookupFlags" c:type="GTlsDatabaseLookupFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
              <doc xml:space="preserve">callback to call when the operation completes</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6">
              <doc xml:space="preserve">the data to pass to the callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_certificate_issuer_finish">
        <callback name="lookup_certificate_issuer_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a newly allocated issuer #GTlsCertificate,
or %NULL. Use g_object_unref() to release the certificate.</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsDatabase</doc>
              <type name="TlsDatabase" c:type="GTlsDatabase*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_certificates_issued_by">
        <callback name="lookup_certificates_issued_by" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a newly allocated list of #GTlsCertificate
objects. Use g_object_unref() on each certificate, and g_list_free() on the release the list.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="TlsCertificate"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsDatabase</doc>
              <type name="TlsDatabase" c:type="GTlsDatabase*"/>
            </parameter>
            <parameter name="issuer_raw_dn" transfer-ownership="none">
              <doc xml:space="preserve">a #GByteArray which holds the DER encoded issuer DN.</doc>
              <array name="GLib.ByteArray" c:type="GByteArray*">
                <type name="guint8" c:type="guint8"/>
              </array>
            </parameter>
            <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">used to interact with the user if necessary</doc>
              <type name="TlsInteraction" c:type="GTlsInteraction*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">Flags which affect the lookup operation.</doc>
              <type name="TlsDatabaseLookupFlags" c:type="GTlsDatabaseLookupFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_certificates_issued_by_async">
        <callback name="lookup_certificates_issued_by_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsDatabase</doc>
              <type name="TlsDatabase" c:type="GTlsDatabase*"/>
            </parameter>
            <parameter name="issuer_raw_dn" transfer-ownership="none">
              <doc xml:space="preserve">a #GByteArray which holds the DER encoded issuer DN.</doc>
              <array name="GLib.ByteArray" c:type="GByteArray*">
                <type name="guint8" c:type="guint8"/>
              </array>
            </parameter>
            <parameter name="interaction" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">used to interact with the user if necessary</doc>
              <type name="TlsInteraction" c:type="GTlsInteraction*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">Flags which affect the lookup operation.</doc>
              <type name="TlsDatabaseLookupFlags" c:type="GTlsDatabaseLookupFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
              <doc xml:space="preserve">callback to call when the operation completes</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6">
              <doc xml:space="preserve">the data to pass to the callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_certificates_issued_by_finish">
        <callback name="lookup_certificates_issued_by_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a newly allocated list of #GTlsCertificate
objects. Use g_object_unref() on each certificate, and g_list_free() on the release the list.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="TlsCertificate"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsDatabase</doc>
              <type name="TlsDatabase" c:type="GTlsDatabase*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="16">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="TlsDatabaseLookupFlags" version="2.30" glib:type-name="GTlsDatabaseLookupFlags" glib:get-type="g_tls_database_lookup_flags_get_type" c:type="GTlsDatabaseLookupFlags">
      <doc xml:space="preserve">Flags for g_tls_database_lookup_certificate_for_handle(),
g_tls_database_lookup_certificate_issuer(),
and g_tls_database_lookup_certificates_issued_by().</doc>
      <member name="none" value="0" c:identifier="G_TLS_DATABASE_LOOKUP_NONE" glib:nick="none">
        <doc xml:space="preserve">No lookup flags</doc>
      </member>
      <member name="keypair" value="1" c:identifier="G_TLS_DATABASE_LOOKUP_KEYPAIR" glib:nick="keypair">
        <doc xml:space="preserve">Restrict lookup to certificates that have
    a private key.</doc>
      </member>
    </enumeration>
    <record name="TlsDatabasePrivate" c:type="GTlsDatabasePrivate" disguised="1">
    </record>
    <bitfield name="TlsDatabaseVerifyFlags" version="2.30" glib:type-name="GTlsDatabaseVerifyFlags" glib:get-type="g_tls_database_verify_flags_get_type" c:type="GTlsDatabaseVerifyFlags">
      <doc xml:space="preserve">Flags for g_tls_database_verify_chain().</doc>
      <member name="none" value="0" c:identifier="G_TLS_DATABASE_VERIFY_NONE" glib:nick="none">
        <doc xml:space="preserve">No verification flags</doc>
      </member>
    </bitfield>
    <enumeration name="TlsError" version="2.28" glib:type-name="GTlsError" glib:get-type="g_tls_error_get_type" c:type="GTlsError" glib:error-domain="g-tls-error-quark">
      <doc xml:space="preserve">An error code used with %G_TLS_ERROR in a #GError returned from a
TLS-related routine.</doc>
      <member name="unavailable" value="0" c:identifier="G_TLS_ERROR_UNAVAILABLE" glib:nick="unavailable">
        <doc xml:space="preserve">No TLS provider is available</doc>
      </member>
      <member name="misc" value="1" c:identifier="G_TLS_ERROR_MISC" glib:nick="misc">
        <doc xml:space="preserve">Miscellaneous TLS error</doc>
      </member>
      <member name="bad_certificate" value="2" c:identifier="G_TLS_ERROR_BAD_CERTIFICATE" glib:nick="bad-certificate">
        <doc xml:space="preserve">A certificate could not be parsed</doc>
      </member>
      <member name="not_tls" value="3" c:identifier="G_TLS_ERROR_NOT_TLS" glib:nick="not-tls">
        <doc xml:space="preserve">The TLS handshake failed because the
  peer does not seem to be a TLS server.</doc>
      </member>
      <member name="handshake" value="4" c:identifier="G_TLS_ERROR_HANDSHAKE" glib:nick="handshake">
        <doc xml:space="preserve">The TLS handshake failed because the
  peer's certificate was not acceptable.</doc>
      </member>
      <member name="certificate_required" value="5" c:identifier="G_TLS_ERROR_CERTIFICATE_REQUIRED" glib:nick="certificate-required">
        <doc xml:space="preserve">The TLS handshake failed because
  the server requested a client-side certificate, but none was
  provided. See g_tls_connection_set_certificate().</doc>
      </member>
      <member name="eof" value="6" c:identifier="G_TLS_ERROR_EOF" glib:nick="eof">
        <doc xml:space="preserve">The TLS connection was closed without proper
  notice, which may indicate an attack. See
  g_tls_connection_set_require_close_notify().</doc>
      </member>
      <function name="quark" c:identifier="g_tls_error_quark" version="2.28">
        <doc xml:space="preserve">Gets the TLS error quark.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GQuark.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <interface name="TlsFileDatabase" c:symbol-prefix="tls_file_database" c:type="GTlsFileDatabase" version="2.30" glib:type-name="GTlsFileDatabase" glib:get-type="g_tls_file_database_get_type" glib:type-struct="TlsFileDatabaseInterface">
      <doc xml:space="preserve">#GTlsFileDatabase is implemented by #GTlsDatabase objects which load
their certificate information from a file. It is an interface which
TLS library specific subtypes implement.</doc>
      <prerequisite name="TlsDatabase"/>
      <function name="new" c:identifier="g_tls_file_database_new" version="2.30" throws="1">
        <doc xml:space="preserve">Creates a new #GTlsFileDatabase which uses anchor certificate authorities
in @anchors to verify certificate chains.

The certificates in @anchors must be PEM encoded.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new
#GTlsFileDatabase, or %NULL on error</doc>
          <type name="TlsFileDatabase" c:type="GTlsDatabase*"/>
        </return-value>
        <parameters>
          <parameter name="anchors" transfer-ownership="none">
            <doc xml:space="preserve">filename of anchor certificate authorities.</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <property name="anchors" version="2.30" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">The path to a file containing PEM encoded certificate authority
root anchors. The certificates in this file will be treated as
root authorities for the purpose of verifying other certificates
via the g_tls_database_verify_chain() operation.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
    </interface>
    <record name="TlsFileDatabaseInterface" c:type="GTlsFileDatabaseInterface" glib:is-gtype-struct-for="TlsFileDatabase">
      <doc xml:space="preserve">Provides an interface for #GTlsFileDatabase implementations.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="TlsInteraction" c:symbol-prefix="tls_interaction" c:type="GTlsInteraction" version="2.30" parent="GObject.Object" glib:type-name="GTlsInteraction" glib:get-type="g_tls_interaction_get_type" glib:type-struct="TlsInteractionClass">
      <doc xml:space="preserve">#GTlsInteraction provides a mechanism for the TLS connection and database
code to interact with the user. It can be used to ask the user for passwords.

To use a #GTlsInteraction with a TLS connection use
g_tls_connection_set_interaction().

Callers should instantiate a derived class that implements the various
interaction methods to show the required dialogs.

Callers should use the 'invoke' functions like
g_tls_interaction_invoke_ask_password() to run interaction methods. These
functions make sure that the interaction is invoked in the main loop
and not in the current thread, if the current thread is not running the
main loop.

Derived classes can choose to implement whichever interactions methods they'd
like to support by overriding those virtual methods in their class
initialization function. Any interactions not implemented will return
%G_TLS_INTERACTION_UNHANDLED. If a derived class implements an async method,
it must also implement the corresponding finish method.</doc>
      <virtual-method name="ask_password" invoker="ask_password" version="2.30" throws="1">
        <doc xml:space="preserve">Run synchronous interaction to ask the user for a password. In general,
g_tls_interaction_invoke_ask_password() should be used instead of this
function.

Derived subclasses usually implement a password prompt, although they may
also choose to provide a password from elsewhere. The @password value will
be filled in and then @callback will be called. Alternatively the user may
abort this password request, which will usually abort the TLS connection.

If the interaction is cancelled by the cancellation object, or by the
user then %G_TLS_INTERACTION_FAILED will be returned with an error that
contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
not support immediate cancellation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The status of the ask password interaction.</doc>
          <type name="TlsInteractionResult" c:type="GTlsInteractionResult"/>
        </return-value>
        <parameters>
          <instance-parameter name="interaction" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsInteraction object</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </instance-parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsPassword object</doc>
            <type name="TlsPassword" c:type="GTlsPassword*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an optional #GCancellable cancellation object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="ask_password_async" invoker="ask_password_async" version="2.30">
        <doc xml:space="preserve">Run asynchronous interaction to ask the user for a password. In general,
g_tls_interaction_invoke_ask_password() should be used instead of this
function.

Derived subclasses usually implement a password prompt, although they may
also choose to provide a password from elsewhere. The @password value will
be filled in and then @callback will be called. Alternatively the user may
abort this password request, which will usually abort the TLS connection.

If the interaction is cancelled by the cancellation object, or by the
user then %G_TLS_INTERACTION_FAILED will be returned with an error that
contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
not support immediate cancellation.

Certain implementations may not support immediate cancellation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interaction" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsInteraction object</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </instance-parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsPassword object</doc>
            <type name="TlsPassword" c:type="GTlsPassword*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an optional #GCancellable cancellation object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">will be called when the interaction completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">data to pass to the @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="ask_password_finish" invoker="ask_password_finish" version="2.30" throws="1">
        <doc xml:space="preserve">Complete an ask password user interaction request. This should be once
the g_tls_interaction_ask_password_async() completion callback is called.

If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsPassword passed
to g_tls_interaction_ask_password() will have its password filled in.

If the interaction is cancelled by the cancellation object, or by the
user then %G_TLS_INTERACTION_FAILED will be returned with an error that
contains a %G_IO_ERROR_CANCELLED error code.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The status of the ask password interaction.</doc>
          <type name="TlsInteractionResult" c:type="GTlsInteractionResult"/>
        </return-value>
        <parameters>
          <instance-parameter name="interaction" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsInteraction object</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the callback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="request_certificate" invoker="request_certificate" version="2.40" throws="1">
        <doc xml:space="preserve">Run synchronous interaction to ask the user to choose a certificate to use
with the connection. In general, g_tls_interaction_invoke_request_certificate()
should be used instead of this function.

Derived subclasses usually implement a certificate selector, although they may
also choose to provide a certificate from elsewhere. Alternatively the user may
abort this certificate request, which will usually abort the TLS connection.

If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
passed to g_tls_interaction_request_certificate() will have had its
#GTlsConnection:certificate filled in.

If the interaction is cancelled by the cancellation object, or by the
user then %G_TLS_INTERACTION_FAILED will be returned with an error that
contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
not support immediate cancellation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The status of the request certificate interaction.</doc>
          <type name="TlsInteractionResult" c:type="GTlsInteractionResult"/>
        </return-value>
        <parameters>
          <instance-parameter name="interaction" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsInteraction object</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsConnection object</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags providing more information about the request</doc>
            <type name="TlsCertificateRequestFlags" c:type="GTlsCertificateRequestFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an optional #GCancellable cancellation object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="request_certificate_async" invoker="request_certificate_async" version="2.40">
        <doc xml:space="preserve">Run asynchronous interaction to ask the user for a certificate to use with
the connection. In general, g_tls_interaction_invoke_request_certificate() should
be used instead of this function.

Derived subclasses usually implement a certificate selector, although they may
also choose to provide a certificate from elsewhere. @callback will be called
when the operation completes. Alternatively the user may abort this certificate
request, which will usually abort the TLS connection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interaction" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsInteraction object</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsConnection object</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags providing more information about the request</doc>
            <type name="TlsCertificateRequestFlags" c:type="GTlsCertificateRequestFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an optional #GCancellable cancellation object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">will be called when the interaction completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">data to pass to the @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="request_certificate_finish" invoker="request_certificate_finish" version="2.40" throws="1">
        <doc xml:space="preserve">Complete an request certificate user interaction request. This should be once
the g_tls_interaction_request_certificate_async() completion callback is called.

If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
passed to g_tls_interaction_request_certificate_async() will have had its
#GTlsConnection:certificate filled in.

If the interaction is cancelled by the cancellation object, or by the
user then %G_TLS_INTERACTION_FAILED will be returned with an error that
contains a %G_IO_ERROR_CANCELLED error code.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The status of the request certificate interaction.</doc>
          <type name="TlsInteractionResult" c:type="GTlsInteractionResult"/>
        </return-value>
        <parameters>
          <instance-parameter name="interaction" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsInteraction object</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the callback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="ask_password" c:identifier="g_tls_interaction_ask_password" version="2.30" throws="1">
        <doc xml:space="preserve">Run synchronous interaction to ask the user for a password. In general,
g_tls_interaction_invoke_ask_password() should be used instead of this
function.

Derived subclasses usually implement a password prompt, although they may
also choose to provide a password from elsewhere. The @password value will
be filled in and then @callback will be called. Alternatively the user may
abort this password request, which will usually abort the TLS connection.

If the interaction is cancelled by the cancellation object, or by the
user then %G_TLS_INTERACTION_FAILED will be returned with an error that
contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
not support immediate cancellation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The status of the ask password interaction.</doc>
          <type name="TlsInteractionResult" c:type="GTlsInteractionResult"/>
        </return-value>
        <parameters>
          <instance-parameter name="interaction" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsInteraction object</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </instance-parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsPassword object</doc>
            <type name="TlsPassword" c:type="GTlsPassword*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an optional #GCancellable cancellation object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ask_password_async" c:identifier="g_tls_interaction_ask_password_async" version="2.30">
        <doc xml:space="preserve">Run asynchronous interaction to ask the user for a password. In general,
g_tls_interaction_invoke_ask_password() should be used instead of this
function.

Derived subclasses usually implement a password prompt, although they may
also choose to provide a password from elsewhere. The @password value will
be filled in and then @callback will be called. Alternatively the user may
abort this password request, which will usually abort the TLS connection.

If the interaction is cancelled by the cancellation object, or by the
user then %G_TLS_INTERACTION_FAILED will be returned with an error that
contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
not support immediate cancellation.

Certain implementations may not support immediate cancellation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interaction" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsInteraction object</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </instance-parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsPassword object</doc>
            <type name="TlsPassword" c:type="GTlsPassword*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an optional #GCancellable cancellation object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">will be called when the interaction completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to the @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ask_password_finish" c:identifier="g_tls_interaction_ask_password_finish" version="2.30" throws="1">
        <doc xml:space="preserve">Complete an ask password user interaction request. This should be once
the g_tls_interaction_ask_password_async() completion callback is called.

If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsPassword passed
to g_tls_interaction_ask_password() will have its password filled in.

If the interaction is cancelled by the cancellation object, or by the
user then %G_TLS_INTERACTION_FAILED will be returned with an error that
contains a %G_IO_ERROR_CANCELLED error code.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The status of the ask password interaction.</doc>
          <type name="TlsInteractionResult" c:type="GTlsInteractionResult"/>
        </return-value>
        <parameters>
          <instance-parameter name="interaction" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsInteraction object</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the callback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="invoke_ask_password" c:identifier="g_tls_interaction_invoke_ask_password" version="2.30" throws="1">
        <doc xml:space="preserve">Invoke the interaction to ask the user for a password. It invokes this
interaction in the main loop, specifically the #GMainContext returned by
g_main_context_get_thread_default() when the interaction is created. This
is called by called by #GTlsConnection or #GTlsDatabase to ask the user
for a password.

Derived subclasses usually implement a password prompt, although they may
also choose to provide a password from elsewhere. The @password value will
be filled in and then @callback will be called. Alternatively the user may
abort this password request, which will usually abort the TLS connection.

The implementation can either be a synchronous (eg: modal dialog) or an
asynchronous one (eg: modeless dialog). This function will take care of
calling which ever one correctly.

If the interaction is cancelled by the cancellation object, or by the
user then %G_TLS_INTERACTION_FAILED will be returned with an error that
contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
not support immediate cancellation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The status of the ask password interaction.</doc>
          <type name="TlsInteractionResult" c:type="GTlsInteractionResult"/>
        </return-value>
        <parameters>
          <instance-parameter name="interaction" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsInteraction object</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </instance-parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsPassword object</doc>
            <type name="TlsPassword" c:type="GTlsPassword*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an optional #GCancellable cancellation object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="invoke_request_certificate" c:identifier="g_tls_interaction_invoke_request_certificate" version="2.40" throws="1">
        <doc xml:space="preserve">Invoke the interaction to ask the user to choose a certificate to
use with the connection. It invokes this interaction in the main
loop, specifically the #GMainContext returned by
g_main_context_get_thread_default() when the interaction is
created. This is called by called by #GTlsConnection when the peer
requests a certificate during the handshake.

Derived subclasses usually implement a certificate selector,
although they may also choose to provide a certificate from
elsewhere. Alternatively the user may abort this certificate
request, which may or may not abort the TLS connection.

The implementation can either be a synchronous (eg: modal dialog) or an
asynchronous one (eg: modeless dialog). This function will take care of
calling which ever one correctly.

If the interaction is cancelled by the cancellation object, or by the
user then %G_TLS_INTERACTION_FAILED will be returned with an error that
contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
not support immediate cancellation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The status of the certificate request interaction.</doc>
          <type name="TlsInteractionResult" c:type="GTlsInteractionResult"/>
        </return-value>
        <parameters>
          <instance-parameter name="interaction" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsInteraction object</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsConnection object</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags providing more information about the request</doc>
            <type name="TlsCertificateRequestFlags" c:type="GTlsCertificateRequestFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an optional #GCancellable cancellation object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_certificate" c:identifier="g_tls_interaction_request_certificate" version="2.40" throws="1">
        <doc xml:space="preserve">Run synchronous interaction to ask the user to choose a certificate to use
with the connection. In general, g_tls_interaction_invoke_request_certificate()
should be used instead of this function.

Derived subclasses usually implement a certificate selector, although they may
also choose to provide a certificate from elsewhere. Alternatively the user may
abort this certificate request, which will usually abort the TLS connection.

If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
passed to g_tls_interaction_request_certificate() will have had its
#GTlsConnection:certificate filled in.

If the interaction is cancelled by the cancellation object, or by the
user then %G_TLS_INTERACTION_FAILED will be returned with an error that
contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
not support immediate cancellation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The status of the request certificate interaction.</doc>
          <type name="TlsInteractionResult" c:type="GTlsInteractionResult"/>
        </return-value>
        <parameters>
          <instance-parameter name="interaction" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsInteraction object</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsConnection object</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags providing more information about the request</doc>
            <type name="TlsCertificateRequestFlags" c:type="GTlsCertificateRequestFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an optional #GCancellable cancellation object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_certificate_async" c:identifier="g_tls_interaction_request_certificate_async" version="2.40">
        <doc xml:space="preserve">Run asynchronous interaction to ask the user for a certificate to use with
the connection. In general, g_tls_interaction_invoke_request_certificate() should
be used instead of this function.

Derived subclasses usually implement a certificate selector, although they may
also choose to provide a certificate from elsewhere. @callback will be called
when the operation completes. Alternatively the user may abort this certificate
request, which will usually abort the TLS connection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interaction" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsInteraction object</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsConnection object</doc>
            <type name="TlsConnection" c:type="GTlsConnection*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags providing more information about the request</doc>
            <type name="TlsCertificateRequestFlags" c:type="GTlsCertificateRequestFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an optional #GCancellable cancellation object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">will be called when the interaction completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to the @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_certificate_finish" c:identifier="g_tls_interaction_request_certificate_finish" version="2.40" throws="1">
        <doc xml:space="preserve">Complete an request certificate user interaction request. This should be once
the g_tls_interaction_request_certificate_async() completion callback is called.

If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
passed to g_tls_interaction_request_certificate_async() will have had its
#GTlsConnection:certificate filled in.

If the interaction is cancelled by the cancellation object, or by the
user then %G_TLS_INTERACTION_FAILED will be returned with an error that
contains a %G_IO_ERROR_CANCELLED error code.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The status of the request certificate interaction.</doc>
          <type name="TlsInteractionResult" c:type="GTlsInteractionResult"/>
        </return-value>
        <parameters>
          <instance-parameter name="interaction" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsInteraction object</doc>
            <type name="TlsInteraction" c:type="GTlsInteraction*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the result passed to the callback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="TlsInteractionPrivate" c:type="GTlsInteractionPrivate*"/>
      </field>
    </class>
    <record name="TlsInteractionClass" c:type="GTlsInteractionClass" glib:is-gtype-struct-for="TlsInteraction" version="2.30">
      <doc xml:space="preserve">The class for #GTlsInteraction. Derived classes implement the various
virtual interaction methods to handle TLS interactions.

Derived classes can choose to implement whichever interactions methods they'd
like to support by overriding those virtual methods in their class
initialization function. If a derived class implements an async method,
it must also implement the corresponding finish method.

The synchronous interaction methods should implement to display modal dialogs,
and the asynchronous methods to display modeless dialogs.

If the user cancels an interaction, then the result should be
%G_TLS_INTERACTION_FAILED and the error should be set with a domain of
%G_IO_ERROR and code of %G_IO_ERROR_CANCELLED.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="ask_password">
        <callback name="ask_password" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The status of the ask password interaction.</doc>
            <type name="TlsInteractionResult" c:type="GTlsInteractionResult"/>
          </return-value>
          <parameters>
            <parameter name="interaction" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsInteraction object</doc>
              <type name="TlsInteraction" c:type="GTlsInteraction*"/>
            </parameter>
            <parameter name="password" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsPassword object</doc>
              <type name="TlsPassword" c:type="GTlsPassword*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">an optional #GCancellable cancellation object</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="ask_password_async">
        <callback name="ask_password_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="interaction" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsInteraction object</doc>
              <type name="TlsInteraction" c:type="GTlsInteraction*"/>
            </parameter>
            <parameter name="password" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsPassword object</doc>
              <type name="TlsPassword" c:type="GTlsPassword*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">an optional #GCancellable cancellation object</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">will be called when the interaction completes</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">data to pass to the @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="ask_password_finish">
        <callback name="ask_password_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The status of the ask password interaction.</doc>
            <type name="TlsInteractionResult" c:type="GTlsInteractionResult"/>
          </return-value>
          <parameters>
            <parameter name="interaction" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsInteraction object</doc>
              <type name="TlsInteraction" c:type="GTlsInteraction*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">the result passed to the callback</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="request_certificate">
        <callback name="request_certificate" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The status of the request certificate interaction.</doc>
            <type name="TlsInteractionResult" c:type="GTlsInteractionResult"/>
          </return-value>
          <parameters>
            <parameter name="interaction" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsInteraction object</doc>
              <type name="TlsInteraction" c:type="GTlsInteraction*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsConnection object</doc>
              <type name="TlsConnection" c:type="GTlsConnection*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags providing more information about the request</doc>
              <type name="TlsCertificateRequestFlags" c:type="GTlsCertificateRequestFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">an optional #GCancellable cancellation object</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="request_certificate_async">
        <callback name="request_certificate_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="interaction" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsInteraction object</doc>
              <type name="TlsInteraction" c:type="GTlsInteraction*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsConnection object</doc>
              <type name="TlsConnection" c:type="GTlsConnection*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags providing more information about the request</doc>
              <type name="TlsCertificateRequestFlags" c:type="GTlsCertificateRequestFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">an optional #GCancellable cancellation object</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">will be called when the interaction completes</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">data to pass to the @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="request_certificate_finish">
        <callback name="request_certificate_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The status of the request certificate interaction.</doc>
            <type name="TlsInteractionResult" c:type="GTlsInteractionResult"/>
          </return-value>
          <parameters>
            <parameter name="interaction" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsInteraction object</doc>
              <type name="TlsInteraction" c:type="GTlsInteraction*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">the result passed to the callback</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="21">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="TlsInteractionPrivate" c:type="GTlsInteractionPrivate" disguised="1">
    </record>
    <enumeration name="TlsInteractionResult" version="2.30" glib:type-name="GTlsInteractionResult" glib:get-type="g_tls_interaction_result_get_type" c:type="GTlsInteractionResult">
      <doc xml:space="preserve">#GTlsInteractionResult is returned by various functions in #GTlsInteraction
when finishing an interaction request.</doc>
      <member name="unhandled" value="0" c:identifier="G_TLS_INTERACTION_UNHANDLED" glib:nick="unhandled">
        <doc xml:space="preserve">The interaction was unhandled (i.e. not
    implemented).</doc>
      </member>
      <member name="handled" value="1" c:identifier="G_TLS_INTERACTION_HANDLED" glib:nick="handled">
        <doc xml:space="preserve">The interaction completed, and resulting data
    is available.</doc>
      </member>
      <member name="failed" value="2" c:identifier="G_TLS_INTERACTION_FAILED" glib:nick="failed">
        <doc xml:space="preserve">The interaction has failed, or was cancelled.
    and the operation should be aborted.</doc>
      </member>
    </enumeration>
    <class name="TlsPassword" c:symbol-prefix="tls_password" c:type="GTlsPassword" version="2.30" parent="GObject.Object" glib:type-name="GTlsPassword" glib:get-type="g_tls_password_get_type" glib:type-struct="TlsPasswordClass">
      <doc xml:space="preserve">Holds a password used in TLS.</doc>
      <constructor name="new" c:identifier="g_tls_password_new">
        <doc xml:space="preserve">Create a new #GTlsPassword object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The newly allocated password object</doc>
          <type name="TlsPassword" c:type="GTlsPassword*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">the password flags</doc>
            <type name="TlsPasswordFlags" c:type="GTlsPasswordFlags"/>
          </parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:space="preserve">description of what the password is for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="get_default_warning">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="password" transfer-ownership="none">
            <type name="TlsPassword" c:type="GTlsPassword*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_value" invoker="get_value" version="2.30">
        <doc xml:space="preserve">Get the password value. If @length is not %NULL then it will be
filled in with the length of the password value. (Note that the
password value is not nul-terminated, so you can only pass %NULL
for @length in contexts where you know the password will have a
certain fixed length.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The password value (owned by the password object).</doc>
          <type name="guint8" c:type="const guchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsPassword object</doc>
            <type name="TlsPassword" c:type="GTlsPassword*"/>
          </instance-parameter>
          <parameter name="length" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">location to place the length of the password.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_value" invoker="set_value_full" version="2.30">
        <doc xml:space="preserve">Provide the value for this password.

The @value will be owned by the password object, and later freed using
the @destroy function callback.

Specify the @length, for a non-nul-terminated password. Pass -1 as
@length if using a nul-terminated password, and @length will be
calculated automatically. (Note that the terminating nul is not
considered part of the password in this case.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsPassword object</doc>
            <type name="TlsPassword" c:type="GTlsPassword*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value for the password</doc>
            <array length="1" zero-terminated="0" c:type="guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of the password, or -1</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a function to use to free the password.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_description" c:identifier="g_tls_password_get_description" version="2.30">
        <doc xml:space="preserve">Get a description string about what the password will be used for.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The description of the password.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsPassword object</doc>
            <type name="TlsPassword" c:type="GTlsPassword*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="g_tls_password_get_flags" version="2.30">
        <doc xml:space="preserve">Get flags about the password.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The flags about the password.</doc>
          <type name="TlsPasswordFlags" c:type="GTlsPasswordFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsPassword object</doc>
            <type name="TlsPassword" c:type="GTlsPassword*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_value" c:identifier="g_tls_password_get_value" version="2.30">
        <doc xml:space="preserve">Get the password value. If @length is not %NULL then it will be
filled in with the length of the password value. (Note that the
password value is not nul-terminated, so you can only pass %NULL
for @length in contexts where you know the password will have a
certain fixed length.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The password value (owned by the password object).</doc>
          <type name="guint8" c:type="const guchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsPassword object</doc>
            <type name="TlsPassword" c:type="GTlsPassword*"/>
          </instance-parameter>
          <parameter name="length" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">location to place the length of the password.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_warning" c:identifier="g_tls_password_get_warning" version="2.30">
        <doc xml:space="preserve">Get a user readable translated warning. Usually this warning is a
representation of the password flags returned from
g_tls_password_get_flags().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The warning.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsPassword object</doc>
            <type name="TlsPassword" c:type="GTlsPassword*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_description" c:identifier="g_tls_password_set_description" version="2.30">
        <doc xml:space="preserve">Set a description string about what the password will be used for.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsPassword object</doc>
            <type name="TlsPassword" c:type="GTlsPassword*"/>
          </instance-parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:space="preserve">The description of the password</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flags" c:identifier="g_tls_password_set_flags" version="2.30">
        <doc xml:space="preserve">Set flags about the password.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsPassword object</doc>
            <type name="TlsPassword" c:type="GTlsPassword*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">The flags about the password</doc>
            <type name="TlsPasswordFlags" c:type="GTlsPasswordFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_value" c:identifier="g_tls_password_set_value" version="2.30">
        <doc xml:space="preserve">Set the value for this password. The @value will be copied by the password
object.

Specify the @length, for a non-nul-terminated password. Pass -1 as
@length if using a nul-terminated password, and @length will be
calculated automatically. (Note that the terminating nul is not
considered part of the password in this case.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsPassword object</doc>
            <type name="TlsPassword" c:type="GTlsPassword*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the new password value</doc>
            <array length="1" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of the password, or -1</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_value_full" c:identifier="g_tls_password_set_value_full" version="2.30">
        <doc xml:space="preserve">Provide the value for this password.

The @value will be owned by the password object, and later freed using
the @destroy function callback.

Specify the @length, for a non-nul-terminated password. Pass -1 as
@length if using a nul-terminated password, and @length will be
calculated automatically. (Note that the terminating nul is not
considered part of the password in this case.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsPassword object</doc>
            <type name="TlsPassword" c:type="GTlsPassword*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value for the password</doc>
            <array length="1" zero-terminated="0" c:type="guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of the password, or -1</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a function to use to free the password.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_warning" c:identifier="g_tls_password_set_warning" version="2.30">
        <doc xml:space="preserve">Set a user readable translated warning. Usually this warning is a
representation of the password flags returned from
g_tls_password_get_flags().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsPassword object</doc>
            <type name="TlsPassword" c:type="GTlsPassword*"/>
          </instance-parameter>
          <parameter name="warning" transfer-ownership="none">
            <doc xml:space="preserve">The user readable warning</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="description" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="flags" writable="1" transfer-ownership="none">
        <type name="TlsPasswordFlags"/>
      </property>
      <property name="warning" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="TlsPasswordPrivate" c:type="GTlsPasswordPrivate*"/>
      </field>
    </class>
    <record name="TlsPasswordClass" c:type="GTlsPasswordClass" glib:is-gtype-struct-for="TlsPassword">
      <doc xml:space="preserve">Class structure for #GTlsPassword.</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="get_value">
        <callback name="get_value">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The password value (owned by the password object).</doc>
            <type name="guint8" c:type="const guchar*"/>
          </return-value>
          <parameters>
            <parameter name="password" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsPassword object</doc>
              <type name="TlsPassword" c:type="GTlsPassword*"/>
            </parameter>
            <parameter name="length" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">location to place the length of the password.</doc>
              <type name="gsize" c:type="gsize*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_value">
        <callback name="set_value">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="password" transfer-ownership="none">
              <doc xml:space="preserve">a #GTlsPassword object</doc>
              <type name="TlsPassword" c:type="GTlsPassword*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <doc xml:space="preserve">the value for the password</doc>
              <array length="2" zero-terminated="0" c:type="guchar*">
                <type name="guint8" c:type="guchar"/>
              </array>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <doc xml:space="preserve">the length of the password, or -1</doc>
              <type name="gssize" c:type="gssize"/>
            </parameter>
            <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
              <doc xml:space="preserve">a function to use to free the password.</doc>
              <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_default_warning">
        <callback name="get_default_warning">
          <return-value transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="password" transfer-ownership="none">
              <type name="TlsPassword" c:type="GTlsPassword*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="TlsPasswordFlags" version="2.30" glib:type-name="GTlsPasswordFlags" glib:get-type="g_tls_password_flags_get_type" c:type="GTlsPasswordFlags">
      <doc xml:space="preserve">Various flags for the password.</doc>
      <member name="none" value="0" c:identifier="G_TLS_PASSWORD_NONE" glib:nick="none">
        <doc xml:space="preserve">No flags</doc>
      </member>
      <member name="retry" value="2" c:identifier="G_TLS_PASSWORD_RETRY" glib:nick="retry">
        <doc xml:space="preserve">The password was wrong, and the user should retry.</doc>
      </member>
      <member name="many_tries" value="4" c:identifier="G_TLS_PASSWORD_MANY_TRIES" glib:nick="many-tries">
        <doc xml:space="preserve">Hint to the user that the password has been
   wrong many times, and the user may not have many chances left.</doc>
      </member>
      <member name="final_try" value="8" c:identifier="G_TLS_PASSWORD_FINAL_TRY" glib:nick="final-try">
        <doc xml:space="preserve">Hint to the user that this is the last try to get
   this password right.</doc>
      </member>
    </bitfield>
    <record name="TlsPasswordPrivate" c:type="GTlsPasswordPrivate" disguised="1">
    </record>
    <enumeration name="TlsRehandshakeMode" version="2.28" glib:type-name="GTlsRehandshakeMode" glib:get-type="g_tls_rehandshake_mode_get_type" c:type="GTlsRehandshakeMode">
      <doc xml:space="preserve">When to allow rehandshaking. See
g_tls_connection_set_rehandshake_mode().</doc>
      <member name="never" value="0" c:identifier="G_TLS_REHANDSHAKE_NEVER" glib:nick="never">
        <doc xml:space="preserve">Never allow rehandshaking</doc>
      </member>
      <member name="safely" value="1" c:identifier="G_TLS_REHANDSHAKE_SAFELY" glib:nick="safely">
        <doc xml:space="preserve">Allow safe rehandshaking only</doc>
      </member>
      <member name="unsafely" value="2" c:identifier="G_TLS_REHANDSHAKE_UNSAFELY" glib:nick="unsafely">
        <doc xml:space="preserve">Allow unsafe rehandshaking</doc>
      </member>
    </enumeration>
    <interface name="TlsServerConnection" c:symbol-prefix="tls_server_connection" c:type="GTlsServerConnection" version="2.28" glib:type-name="GTlsServerConnection" glib:get-type="g_tls_server_connection_get_type" glib:type-struct="TlsServerConnectionInterface">
      <doc xml:space="preserve">#GTlsServerConnection is the server-side subclass of #GTlsConnection,
representing a server-side TLS connection.</doc>
      <prerequisite name="TlsConnection"/>
      <function name="new" c:identifier="g_tls_server_connection_new" version="2.28" throws="1">
        <doc xml:space="preserve">Creates a new #GTlsServerConnection wrapping @base_io_stream (which
must have pollable input and output streams).

See the documentation for #GTlsConnection:base-io-stream for restrictions
on when application code can run operations on the @base_io_stream after
this function has returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new
#GTlsServerConnection, or %NULL on error</doc>
          <type name="TlsServerConnection" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <parameter name="base_io_stream" transfer-ownership="none">
            <doc xml:space="preserve">the #GIOStream to wrap</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </parameter>
          <parameter name="certificate" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the default server certificate, or %NULL</doc>
            <type name="TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
        </parameters>
      </function>
      <property name="authentication-mode" version="2.28" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The #GTlsAuthenticationMode for the server. This can be changed
before calling g_tls_connection_handshake() if you want to
rehandshake with a different mode from the initial handshake.</doc>
        <type name="TlsAuthenticationMode"/>
      </property>
    </interface>
    <record name="TlsServerConnectionInterface" c:type="GTlsServerConnectionInterface" glib:is-gtype-struct-for="TlsServerConnection" version="2.26">
      <doc xml:space="preserve">vtable for a #GTlsServerConnection implementation.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
    </record>
    <class name="UnixConnection" c:symbol-prefix="unix_connection" c:type="GUnixConnection" parent="SocketConnection" glib:type-name="GUnixConnection" glib:get-type="g_unix_connection_get_type" glib:type-struct="UnixConnectionClass">
      <doc xml:space="preserve">This is the subclass of #GSocketConnection that is created
for UNIX domain sockets.

It contains functions to do some of the UNIX socket specific
functionality like passing file descriptors.

Note that `&lt;gio/gunixconnection.h&gt;` belongs to the UNIX-specific
GIO interfaces, thus you have to use the `gio-unix-2.0.pc`
pkg-config file when using it.</doc>
      <method name="receive_credentials" c:identifier="g_unix_connection_receive_credentials" version="2.26" throws="1">
        <doc xml:space="preserve">Receives credentials from the sending end of the connection.  The
sending end has to call g_unix_connection_send_credentials() (or
similar) for this to work.

As well as reading the credentials this also reads (and discards) a
single byte from the stream, as this is required for credentials
passing to work on some implementations.

Other ways to exchange credentials with a foreign peer includes the
#GUnixCredentialsMessage type and g_socket_get_credentials() function.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">Received credentials on success (free with
g_object_unref()), %NULL if @error is set.</doc>
          <type name="Credentials" c:type="GCredentials*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #GUnixConnection.</doc>
            <type name="UnixConnection" c:type="GUnixConnection*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="receive_credentials_async" c:identifier="g_unix_connection_receive_credentials_async" version="2.32">
        <doc xml:space="preserve">Asynchronously receive credentials.

For more details, see g_unix_connection_receive_credentials() which is
the synchronous version of this call.

When the operation is finished, @callback will be called. You can then call
g_unix_connection_receive_credentials_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #GUnixConnection.</doc>
            <type name="UnixConnection" c:type="GUnixConnection*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="receive_credentials_finish" c:identifier="g_unix_connection_receive_credentials_finish" version="2.32" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous receive credentials operation started with
g_unix_connection_receive_credentials_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GCredentials, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="Credentials" c:type="GCredentials*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #GUnixConnection.</doc>
            <type name="UnixConnection" c:type="GUnixConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="receive_fd" c:identifier="g_unix_connection_receive_fd" version="2.22" throws="1">
        <doc xml:space="preserve">Receives a file descriptor from the sending end of the connection.
The sending end has to call g_unix_connection_send_fd() for this
to work.

As well as reading the fd this also reads a single byte from the
stream, as this is required for fd passing to work on some
implementations.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a file descriptor on success, -1 on error.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixConnection</doc>
            <type name="UnixConnection" c:type="GUnixConnection*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_credentials" c:identifier="g_unix_connection_send_credentials" version="2.26" throws="1">
        <doc xml:space="preserve">Passes the credentials of the current user the receiving side
of the connection. The receiving end has to call
g_unix_connection_receive_credentials() (or similar) to accept the
credentials.

As well as sending the credentials this also writes a single NUL
byte to the stream, as this is required for credentials passing to
work on some implementations.

Other ways to exchange credentials with a foreign peer includes the
#GUnixCredentialsMessage type and g_socket_get_credentials() function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if @error is set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #GUnixConnection.</doc>
            <type name="UnixConnection" c:type="GUnixConnection*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_credentials_async" c:identifier="g_unix_connection_send_credentials_async" version="2.32">
        <doc xml:space="preserve">Asynchronously send credentials.

For more details, see g_unix_connection_send_credentials() which is
the synchronous version of this call.

When the operation is finished, @callback will be called. You can then call
g_unix_connection_send_credentials_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #GUnixConnection.</doc>
            <type name="UnixConnection" c:type="GUnixConnection*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_credentials_finish" c:identifier="g_unix_connection_send_credentials_finish" version="2.32" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous send credentials operation started with
g_unix_connection_send_credentials_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #GUnixConnection.</doc>
            <type name="UnixConnection" c:type="GUnixConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_fd" c:identifier="g_unix_connection_send_fd" version="2.22" throws="1">
        <doc xml:space="preserve">Passes a file descriptor to the receiving side of the
connection. The receiving end has to call g_unix_connection_receive_fd()
to accept the file descriptor.

As well as sending the fd this also writes a single byte to the
stream, as this is required for fd passing to work on some
implementations.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a %TRUE on success, %NULL on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixConnection</doc>
            <type name="UnixConnection" c:type="GUnixConnection*"/>
          </instance-parameter>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:space="preserve">a file descriptor</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="SocketConnection" c:type="GSocketConnection"/>
      </field>
      <field name="priv">
        <type name="UnixConnectionPrivate" c:type="GUnixConnectionPrivate*"/>
      </field>
    </class>
    <record name="UnixConnectionClass" c:type="GUnixConnectionClass" glib:is-gtype-struct-for="UnixConnection">
      <field name="parent_class">
        <type name="SocketConnectionClass" c:type="GSocketConnectionClass"/>
      </field>
    </record>
    <record name="UnixConnectionPrivate" c:type="GUnixConnectionPrivate" disguised="1">
    </record>
    <class name="UnixCredentialsMessage" c:symbol-prefix="unix_credentials_message" c:type="GUnixCredentialsMessage" version="2.26" parent="SocketControlMessage" glib:type-name="GUnixCredentialsMessage" glib:get-type="g_unix_credentials_message_get_type" glib:type-struct="UnixCredentialsMessageClass">
      <doc xml:space="preserve">This #GSocketControlMessage contains a #GCredentials instance.  It
may be sent using g_socket_send_message() and received using
g_socket_receive_message() over UNIX sockets (ie: sockets in the
%G_SOCKET_FAMILY_UNIX family).

For an easier way to send and receive credentials over
stream-oriented UNIX sockets, see
g_unix_connection_send_credentials() and
g_unix_connection_receive_credentials(). To receive credentials of
a foreign process connected to a socket, use
g_socket_get_credentials().</doc>
      <constructor name="new" c:identifier="g_unix_credentials_message_new" version="2.26">
        <doc xml:space="preserve">Creates a new #GUnixCredentialsMessage with credentials matching the current processes.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GUnixCredentialsMessage</doc>
          <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
        </return-value>
      </constructor>
      <constructor name="new_with_credentials" c:identifier="g_unix_credentials_message_new_with_credentials" version="2.26">
        <doc xml:space="preserve">Creates a new #GUnixCredentialsMessage holding @credentials.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GUnixCredentialsMessage</doc>
          <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
        </return-value>
        <parameters>
          <parameter name="credentials" transfer-ownership="none">
            <doc xml:space="preserve">A #GCredentials object.</doc>
            <type name="Credentials" c:type="GCredentials*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="is_supported" c:identifier="g_unix_credentials_message_is_supported" version="2.26">
        <doc xml:space="preserve">Checks if passing #GCredentials on a #GSocket is supported on this platform.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if supported, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </function>
      <method name="get_credentials" c:identifier="g_unix_credentials_message_get_credentials" version="2.26">
        <doc xml:space="preserve">Gets the credentials stored in @message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GCredentials instance. Do not free, it is owned by @message.</doc>
          <type name="Credentials" c:type="GCredentials*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #GUnixCredentialsMessage.</doc>
            <type name="UnixCredentialsMessage" c:type="GUnixCredentialsMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="credentials" version="2.26" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The credentials stored in the message.</doc>
        <type name="Credentials"/>
      </property>
      <field name="parent_instance">
        <type name="SocketControlMessage" c:type="GSocketControlMessage"/>
      </field>
      <field name="priv">
        <type name="UnixCredentialsMessagePrivate" c:type="GUnixCredentialsMessagePrivate*"/>
      </field>
    </class>
    <record name="UnixCredentialsMessageClass" c:type="GUnixCredentialsMessageClass" glib:is-gtype-struct-for="UnixCredentialsMessage" version="2.26">
      <doc xml:space="preserve">Class structure for #GUnixCredentialsMessage.</doc>
      <field name="parent_class">
        <type name="SocketControlMessageClass" c:type="GSocketControlMessageClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="UnixCredentialsMessagePrivate" c:type="GUnixCredentialsMessagePrivate" disguised="1">
    </record>
    <class name="UnixFDList" c:symbol-prefix="unix_fd_list" c:type="GUnixFDList" parent="GObject.Object" glib:type-name="GUnixFDList" glib:get-type="g_unix_fd_list_get_type" glib:type-struct="UnixFDListClass">
      <doc xml:space="preserve">A #GUnixFDList contains a list of file descriptors.  It owns the file
descriptors that it contains, closing them when finalized.

It may be wrapped in a #GUnixFDMessage and sent over a #GSocket in
the %G_SOCKET_ADDRESS_UNIX family by using g_socket_send_message()
and received using g_socket_receive_message().

Note that `&lt;gio/gunixfdlist.h&gt;` belongs to the UNIX-specific GIO
interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
file when using it.</doc>
      <constructor name="new" c:identifier="g_unix_fd_list_new" version="2.24">
        <doc xml:space="preserve">Creates a new #GUnixFDList containing no file descriptors.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GUnixFDList</doc>
          <type name="UnixFDList" c:type="GUnixFDList*"/>
        </return-value>
      </constructor>
      <constructor name="new_from_array" c:identifier="g_unix_fd_list_new_from_array" version="2.24">
        <doc xml:space="preserve">Creates a new #GUnixFDList containing the file descriptors given in
@fds.  The file descriptors become the property of the new list and
may no longer be used by the caller.  The array itself is owned by
the caller.

Each file descriptor in the array should be set to close-on-exec.

If @n_fds is -1 then @fds must be terminated with -1.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GUnixFDList</doc>
          <type name="UnixFDList" c:type="GUnixFDList*"/>
        </return-value>
        <parameters>
          <parameter name="fds" transfer-ownership="none">
            <doc xml:space="preserve">the initial list of file descriptors</doc>
            <array length="1" zero-terminated="0" c:type="const gint*">
              <type name="gint" c:type="gint"/>
            </array>
          </parameter>
          <parameter name="n_fds" transfer-ownership="none">
            <doc xml:space="preserve">the length of #fds, or -1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="append" c:identifier="g_unix_fd_list_append" version="2.24" throws="1">
        <doc xml:space="preserve">Adds a file descriptor to @list.

The file descriptor is duplicated using dup(). You keep your copy
of the descriptor and the copy contained in @list will be closed
when @list is finalized.

A possible cause of failure is exceeding the per-process or
system-wide file descriptor limit.

The index of the file descriptor in the list is returned.  If you use
this index with g_unix_fd_list_get() then you will receive back a
duplicated copy of the same file descriptor.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the index of the appended fd in case of success, else -1
         (and @error is set)</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixFDList</doc>
            <type name="UnixFDList" c:type="GUnixFDList*"/>
          </instance-parameter>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:space="preserve">a valid open file descriptor</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="g_unix_fd_list_get" version="2.24" throws="1">
        <doc xml:space="preserve">Gets a file descriptor out of @list.

@index_ specifies the index of the file descriptor to get.  It is a
programmer error for @index_ to be out of range; see
g_unix_fd_list_get_length().

The file descriptor is duplicated using dup() and set as
close-on-exec before being returned.  You must call close() on it
when you are done.

A possible cause of failure is exceeding the per-process or
system-wide file descriptor limit.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the file descriptor, or -1 in case of error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixFDList</doc>
            <type name="UnixFDList" c:type="GUnixFDList*"/>
          </instance-parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index into the list</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_length" c:identifier="g_unix_fd_list_get_length" version="2.24">
        <doc xml:space="preserve">Gets the length of @list (ie: the number of file descriptors
contained within).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the length of @list</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixFDList</doc>
            <type name="UnixFDList" c:type="GUnixFDList*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_fds" c:identifier="g_unix_fd_list_peek_fds" version="2.24">
        <doc xml:space="preserve">Returns the array of file descriptors that is contained in this
object.

After this call, the descriptors remain the property of @list.  The
caller must not close them and must not free the array.  The array is
valid only until @list is changed in any way.

If @length is non-%NULL then it is set to the number of file
descriptors in the returned array. The returned array is also
terminated with -1.

This function never returns %NULL. In case there are no file
descriptors contained in @list, an empty array is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an array of file
    descriptors</doc>
          <array length="0" zero-terminated="0" c:type="const gint*">
            <type name="gint" c:type="gint"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixFDList</doc>
            <type name="UnixFDList" c:type="GUnixFDList*"/>
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">pointer to the length of the returned
    array, or %NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="steal_fds" c:identifier="g_unix_fd_list_steal_fds" version="2.24">
        <doc xml:space="preserve">Returns the array of file descriptors that is contained in this
object.

After this call, the descriptors are no longer contained in
@list. Further calls will return an empty list (unless more
descriptors have been added).

The return result of this function must be freed with g_free().
The caller is also responsible for closing all of the file
descriptors.  The file descriptors in the array are set to
close-on-exec.

If @length is non-%NULL then it is set to the number of file
descriptors in the returned array. The returned array is also
terminated with -1.

This function never returns %NULL. In case there are no file
descriptors contained in @list, an empty array is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an array of file
    descriptors</doc>
          <array length="0" zero-terminated="0" c:type="gint*">
            <type name="gint" c:type="gint"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixFDList</doc>
            <type name="UnixFDList" c:type="GUnixFDList*"/>
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">pointer to the length of the returned
    array, or %NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="UnixFDListPrivate" c:type="GUnixFDListPrivate*"/>
      </field>
    </class>
    <record name="UnixFDListClass" c:type="GUnixFDListClass" glib:is-gtype-struct-for="UnixFDList">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="UnixFDListPrivate" c:type="GUnixFDListPrivate" disguised="1">
    </record>
    <class name="UnixFDMessage" c:symbol-prefix="unix_fd_message" c:type="GUnixFDMessage" parent="SocketControlMessage" glib:type-name="GUnixFDMessage" glib:get-type="g_unix_fd_message_get_type" glib:type-struct="UnixFDMessageClass">
      <doc xml:space="preserve">This #GSocketControlMessage contains a #GUnixFDList.
It may be sent using g_socket_send_message() and received using
g_socket_receive_message() over UNIX sockets (ie: sockets in the
%G_SOCKET_ADDRESS_UNIX family). The file descriptors are copied
between processes by the kernel.

For an easier way to send and receive file descriptors over
stream-oriented UNIX sockets, see g_unix_connection_send_fd() and
g_unix_connection_receive_fd().

Note that `&lt;gio/gunixfdmessage.h&gt;` belongs to the UNIX-specific GIO
interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
file when using it.</doc>
      <constructor name="new" c:identifier="g_unix_fd_message_new" version="2.22">
        <doc xml:space="preserve">Creates a new #GUnixFDMessage containing an empty file descriptor
list.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GUnixFDMessage</doc>
          <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
        </return-value>
      </constructor>
      <constructor name="new_with_fd_list" c:identifier="g_unix_fd_message_new_with_fd_list" version="2.24">
        <doc xml:space="preserve">Creates a new #GUnixFDMessage containing @list.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GUnixFDMessage</doc>
          <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
        </return-value>
        <parameters>
          <parameter name="fd_list" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixFDList</doc>
            <type name="UnixFDList" c:type="GUnixFDList*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="append_fd" c:identifier="g_unix_fd_message_append_fd" version="2.22" throws="1">
        <doc xml:space="preserve">Adds a file descriptor to @message.

The file descriptor is duplicated using dup(). You keep your copy
of the descriptor and the copy contained in @message will be closed
when @message is finalized.

A possible cause of failure is exceeding the per-process or
system-wide file descriptor limit.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE in case of success, else %FALSE (and @error is set)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixFDMessage</doc>
            <type name="UnixFDMessage" c:type="GUnixFDMessage*"/>
          </instance-parameter>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:space="preserve">a valid open file descriptor</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_fd_list" c:identifier="g_unix_fd_message_get_fd_list" version="2.24">
        <doc xml:space="preserve">Gets the #GUnixFDList contained in @message.  This function does not
return a reference to the caller, but the returned list is valid for
the lifetime of @message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GUnixFDList from @message</doc>
          <type name="UnixFDList" c:type="GUnixFDList*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixFDMessage</doc>
            <type name="UnixFDMessage" c:type="GUnixFDMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="steal_fds" c:identifier="g_unix_fd_message_steal_fds" version="2.22">
        <doc xml:space="preserve">Returns the array of file descriptors that is contained in this
object.

After this call, the descriptors are no longer contained in
@message. Further calls will return an empty list (unless more
descriptors have been added).

The return result of this function must be freed with g_free().
The caller is also responsible for closing all of the file
descriptors.

If @length is non-%NULL then it is set to the number of file
descriptors in the returned array. The returned array is also
terminated with -1.

This function never returns %NULL. In case there are no file
descriptors contained in @message, an empty array is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an array of file
    descriptors</doc>
          <array length="0" zero-terminated="0" c:type="gint*">
            <type name="gint" c:type="gint"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixFDMessage</doc>
            <type name="UnixFDMessage" c:type="GUnixFDMessage*"/>
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">pointer to the length of the returned
    array, or %NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <property name="fd-list" writable="1" construct-only="1" transfer-ownership="none">
        <type name="UnixFDList"/>
      </property>
      <field name="parent_instance">
        <type name="SocketControlMessage" c:type="GSocketControlMessage"/>
      </field>
      <field name="priv">
        <type name="UnixFDMessagePrivate" c:type="GUnixFDMessagePrivate*"/>
      </field>
    </class>
    <record name="UnixFDMessageClass" c:type="GUnixFDMessageClass" glib:is-gtype-struct-for="UnixFDMessage">
      <field name="parent_class">
        <type name="SocketControlMessageClass" c:type="GSocketControlMessageClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="UnixFDMessagePrivate" c:type="GUnixFDMessagePrivate" disguised="1">
    </record>
    <class name="UnixInputStream" c:symbol-prefix="unix_input_stream" c:type="GUnixInputStream" parent="InputStream" glib:type-name="GUnixInputStream" glib:get-type="g_unix_input_stream_get_type" glib:type-struct="UnixInputStreamClass">
      <doc xml:space="preserve">#GUnixInputStream implements #GInputStream for reading from a UNIX
file descriptor, including asynchronous operations. (If the file
descriptor refers to a socket or pipe, this will use poll() to do
asynchronous I/O. If it refers to a regular file, it will fall back
to doing asynchronous I/O in another thread.)

Note that `&lt;gio/gunixinputstream.h&gt;` belongs to the UNIX-specific GIO
interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
file when using it.</doc>
      <implements name="FileDescriptorBased"/>
      <implements name="PollableInputStream"/>
      <constructor name="new" c:identifier="g_unix_input_stream_new">
        <doc xml:space="preserve">Creates a new #GUnixInputStream for the given @fd.

If @close_fd is %TRUE, the file descriptor will be closed
when the stream is closed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GUnixInputStream</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:space="preserve">a UNIX file descriptor</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="close_fd" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to close the file descriptor when done</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_close_fd" c:identifier="g_unix_input_stream_get_close_fd" version="2.20">
        <doc xml:space="preserve">Returns whether the file descriptor of @stream will be
closed when the stream is closed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the file descriptor is closed when done</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixInputStream</doc>
            <type name="UnixInputStream" c:type="GUnixInputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_fd" c:identifier="g_unix_input_stream_get_fd" version="2.20">
        <doc xml:space="preserve">Return the UNIX file descriptor that the stream reads from.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The file descriptor of @stream</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixInputStream</doc>
            <type name="UnixInputStream" c:type="GUnixInputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_close_fd" c:identifier="g_unix_input_stream_set_close_fd" version="2.20">
        <doc xml:space="preserve">Sets whether the file descriptor of @stream shall be closed
when the stream is closed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixInputStream</doc>
            <type name="UnixInputStream" c:type="GUnixInputStream*"/>
          </instance-parameter>
          <parameter name="close_fd" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to close the file descriptor when done</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="close-fd" version="2.20" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether to close the file descriptor when the stream is closed.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="fd" version="2.20" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The file descriptor that the stream reads from.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <field name="parent_instance">
        <type name="InputStream" c:type="GInputStream"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="UnixInputStreamPrivate" c:type="GUnixInputStreamPrivate*"/>
      </field>
    </class>
    <record name="UnixInputStreamClass" c:type="GUnixInputStreamClass" glib:is-gtype-struct-for="UnixInputStream">
      <field name="parent_class">
        <type name="InputStreamClass" c:type="GInputStreamClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="UnixInputStreamPrivate" c:type="GUnixInputStreamPrivate" disguised="1">
    </record>
    <record name="UnixMountEntry" c:type="GUnixMountEntry" glib:type-name="GUnixMountEntry" glib:get-type="g_unix_mount_entry_get_type" c:symbol-prefix="unix_mount_entry">
      <doc xml:space="preserve">Defines a Unix mount entry (e.g. &lt;filename&gt;/media/cdrom&lt;/filename&gt;).
This corresponds roughly to a mtab entry.</doc>
    </record>
    <class name="UnixMountMonitor" c:symbol-prefix="unix_mount_monitor" c:type="GUnixMountMonitor" parent="GObject.Object" glib:type-name="GUnixMountMonitor" glib:get-type="g_unix_mount_monitor_get_type" glib:type-struct="UnixMountMonitorClass">
      <doc xml:space="preserve">Watches #GUnixMounts for changes.</doc>
      <constructor name="new" c:identifier="g_unix_mount_monitor_new" deprecated="1" deprecated-version="2.44">
        <doc xml:space="preserve">Deprecated alias for g_unix_mount_monitor_get().

This function was never a true constructor, which is why it was
renamed.</doc>
        <doc-deprecated xml:space="preserve">Use g_unix_mount_monitor_get() instead.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GUnixMountMonitor.</doc>
          <type name="UnixMountMonitor" c:type="GUnixMountMonitor*"/>
        </return-value>
      </constructor>
      <function name="get" c:identifier="g_unix_mount_monitor_get" version="2.44">
        <doc xml:space="preserve">Gets the #GUnixMountMonitor for the current thread-default main
context.

The mount monitor can be used to monitor for changes to the list of
mounted filesystems as well as the list of mount points (ie: fstab
entries).

You must only call g_object_unref() on the return value from under
the same main context as you called this function.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the #GUnixMountMonitor.</doc>
          <type name="UnixMountMonitor" c:type="GUnixMountMonitor*"/>
        </return-value>
      </function>
      <method name="set_rate_limit" c:identifier="g_unix_mount_monitor_set_rate_limit" version="2.18" deprecated="1" deprecated-version="2.44">
        <doc xml:space="preserve">This function does nothing.

Before 2.44, this was a partially-effective way of controlling the
rate at which events would be reported under some uncommon
circumstances.  Since @mount_monitor is a singleton, it also meant
that calling this function would have side effects for other users of
the monitor.</doc>
        <doc-deprecated xml:space="preserve">This function does nothing.  Don't call it.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount_monitor" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixMountMonitor</doc>
            <type name="UnixMountMonitor" c:type="GUnixMountMonitor*"/>
          </instance-parameter>
          <parameter name="limit_msec" transfer-ownership="none">
            <doc xml:space="preserve">a integer with the limit in milliseconds to
    poll for changes.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <glib:signal name="mountpoints-changed" when="last">
        <doc xml:space="preserve">Emitted when the unix mount points have changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="mounts-changed" when="last">
        <doc xml:space="preserve">Emitted when the unix mounts have changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="UnixMountMonitorClass" c:type="GUnixMountMonitorClass" disguised="1" glib:is-gtype-struct-for="UnixMountMonitor">
    </record>
    <record name="UnixMountPoint" c:type="GUnixMountPoint" glib:type-name="GUnixMountPoint" glib:get-type="g_unix_mount_point_get_type" c:symbol-prefix="unix_mount_point">
      <doc xml:space="preserve">Defines a Unix mount point (e.g. &lt;filename&gt;/dev&lt;/filename&gt;).
This corresponds roughly to a fstab entry.</doc>
      <method name="compare" c:identifier="g_unix_mount_point_compare">
        <doc xml:space="preserve">Compares two unix mount points.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">1, 0 or -1 if @mount1 is greater than, equal to,
or less than @mount2, respectively.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount1" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixMount.</doc>
            <type name="UnixMountPoint" c:type="GUnixMountPoint*"/>
          </instance-parameter>
          <parameter name="mount2" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixMount.</doc>
            <type name="UnixMountPoint" c:type="GUnixMountPoint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="g_unix_mount_point_copy" version="2.54">
        <doc xml:space="preserve">Makes a copy of @mount_point.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GUnixMountPoint</doc>
          <type name="UnixMountPoint" c:type="GUnixMountPoint*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount_point" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixMountPoint.</doc>
            <type name="UnixMountPoint" c:type="GUnixMountPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_unix_mount_point_free">
        <doc xml:space="preserve">Frees a unix mount point.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount_point" transfer-ownership="none">
            <doc xml:space="preserve">unix mount point to free.</doc>
            <type name="UnixMountPoint" c:type="GUnixMountPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_device_path" c:identifier="g_unix_mount_point_get_device_path">
        <doc xml:space="preserve">Gets the device path for a unix mount point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string containing the device path.</doc>
          <type name="filename" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount_point" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixMountPoint.</doc>
            <type name="UnixMountPoint" c:type="GUnixMountPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_fs_type" c:identifier="g_unix_mount_point_get_fs_type">
        <doc xml:space="preserve">Gets the file system type for the mount point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string containing the file system type.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount_point" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixMountPoint.</doc>
            <type name="UnixMountPoint" c:type="GUnixMountPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mount_path" c:identifier="g_unix_mount_point_get_mount_path">
        <doc xml:space="preserve">Gets the mount path for a unix mount point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string containing the mount path.</doc>
          <type name="filename" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount_point" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixMountPoint.</doc>
            <type name="UnixMountPoint" c:type="GUnixMountPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_options" c:identifier="g_unix_mount_point_get_options" version="2.32">
        <doc xml:space="preserve">Gets the options for the mount point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string containing the options.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount_point" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixMountPoint.</doc>
            <type name="UnixMountPoint" c:type="GUnixMountPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="guess_can_eject" c:identifier="g_unix_mount_point_guess_can_eject">
        <doc xml:space="preserve">Guesses whether a Unix mount point can be ejected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @mount_point is deemed to be ejectable.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount_point" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixMountPoint</doc>
            <type name="UnixMountPoint" c:type="GUnixMountPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="guess_icon" c:identifier="g_unix_mount_point_guess_icon">
        <doc xml:space="preserve">Guesses the icon of a Unix mount point.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GIcon</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount_point" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixMountPoint</doc>
            <type name="UnixMountPoint" c:type="GUnixMountPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="guess_name" c:identifier="g_unix_mount_point_guess_name">
        <doc xml:space="preserve">Guesses the name of a Unix mount point.
The result is a translated string.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated string that must
    be freed with g_free()</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount_point" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixMountPoint</doc>
            <type name="UnixMountPoint" c:type="GUnixMountPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="guess_symbolic_icon" c:identifier="g_unix_mount_point_guess_symbolic_icon" version="2.34">
        <doc xml:space="preserve">Guesses the symbolic icon of a Unix mount point.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GIcon</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount_point" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixMountPoint</doc>
            <type name="UnixMountPoint" c:type="GUnixMountPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_loopback" c:identifier="g_unix_mount_point_is_loopback">
        <doc xml:space="preserve">Checks if a unix mount point is a loopback device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the mount point is a loopback. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount_point" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixMountPoint.</doc>
            <type name="UnixMountPoint" c:type="GUnixMountPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_readonly" c:identifier="g_unix_mount_point_is_readonly">
        <doc xml:space="preserve">Checks if a unix mount point is read only.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a mount point is read only.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount_point" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixMountPoint.</doc>
            <type name="UnixMountPoint" c:type="GUnixMountPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_user_mountable" c:identifier="g_unix_mount_point_is_user_mountable">
        <doc xml:space="preserve">Checks if a unix mount point is mountable by the user.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the mount point is user mountable.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mount_point" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixMountPoint.</doc>
            <type name="UnixMountPoint" c:type="GUnixMountPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <class name="UnixOutputStream" c:symbol-prefix="unix_output_stream" c:type="GUnixOutputStream" parent="OutputStream" glib:type-name="GUnixOutputStream" glib:get-type="g_unix_output_stream_get_type" glib:type-struct="UnixOutputStreamClass">
      <doc xml:space="preserve">#GUnixOutputStream implements #GOutputStream for writing to a UNIX
file descriptor, including asynchronous operations. (If the file
descriptor refers to a socket or pipe, this will use poll() to do
asynchronous I/O. If it refers to a regular file, it will fall back
to doing asynchronous I/O in another thread.)

Note that `&lt;gio/gunixoutputstream.h&gt;` belongs to the UNIX-specific GIO
interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file
when using it.</doc>
      <implements name="FileDescriptorBased"/>
      <implements name="PollableOutputStream"/>
      <constructor name="new" c:identifier="g_unix_output_stream_new">
        <doc xml:space="preserve">Creates a new #GUnixOutputStream for the given @fd.

If @close_fd, is %TRUE, the file descriptor will be closed when
the output stream is destroyed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GOutputStream</doc>
          <type name="OutputStream" c:type="GOutputStream*"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:space="preserve">a UNIX file descriptor</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="close_fd" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to close the file descriptor when done</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_close_fd" c:identifier="g_unix_output_stream_get_close_fd" version="2.20">
        <doc xml:space="preserve">Returns whether the file descriptor of @stream will be
closed when the stream is closed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the file descriptor is closed when done</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixOutputStream</doc>
            <type name="UnixOutputStream" c:type="GUnixOutputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_fd" c:identifier="g_unix_output_stream_get_fd" version="2.20">
        <doc xml:space="preserve">Return the UNIX file descriptor that the stream writes to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The file descriptor of @stream</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixOutputStream</doc>
            <type name="UnixOutputStream" c:type="GUnixOutputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_close_fd" c:identifier="g_unix_output_stream_set_close_fd" version="2.20">
        <doc xml:space="preserve">Sets whether the file descriptor of @stream shall be closed
when the stream is closed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixOutputStream</doc>
            <type name="UnixOutputStream" c:type="GUnixOutputStream*"/>
          </instance-parameter>
          <parameter name="close_fd" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to close the file descriptor when done</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="close-fd" version="2.20" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether to close the file descriptor when the stream is closed.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="fd" version="2.20" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The file descriptor that the stream writes to.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <field name="parent_instance">
        <type name="OutputStream" c:type="GOutputStream"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="UnixOutputStreamPrivate" c:type="GUnixOutputStreamPrivate*"/>
      </field>
    </class>
    <record name="UnixOutputStreamClass" c:type="GUnixOutputStreamClass" glib:is-gtype-struct-for="UnixOutputStream">
      <field name="parent_class">
        <type name="OutputStreamClass" c:type="GOutputStreamClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="UnixOutputStreamPrivate" c:type="GUnixOutputStreamPrivate" disguised="1">
    </record>
    <class name="UnixSocketAddress" c:symbol-prefix="unix_socket_address" c:type="GUnixSocketAddress" parent="SocketAddress" glib:type-name="GUnixSocketAddress" glib:get-type="g_unix_socket_address_get_type" glib:type-struct="UnixSocketAddressClass">
      <doc xml:space="preserve">Support for UNIX-domain (also known as local) sockets.

UNIX domain sockets are generally visible in the filesystem.
However, some systems support abstract socket names which are not
visible in the filesystem and not affected by the filesystem
permissions, visibility, etc. Currently this is only supported
under Linux. If you attempt to use abstract sockets on other
systems, function calls may return %G_IO_ERROR_NOT_SUPPORTED
errors. You can use g_unix_socket_address_abstract_names_supported()
to see if abstract names are supported.

Note that `&lt;gio/gunixsocketaddress.h&gt;` belongs to the UNIX-specific GIO
interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file
when using it.</doc>
      <implements name="SocketConnectable"/>
      <constructor name="new" c:identifier="g_unix_socket_address_new" version="2.22">
        <doc xml:space="preserve">Creates a new #GUnixSocketAddress for @path.

To create abstract socket addresses, on systems that support that,
use g_unix_socket_address_new_abstract().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GUnixSocketAddress</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the socket path</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_abstract" c:identifier="g_unix_socket_address_new_abstract" deprecated="1">
        <doc xml:space="preserve">Creates a new %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED
#GUnixSocketAddress for @path.</doc>
        <doc-deprecated xml:space="preserve">Use g_unix_socket_address_new_with_type().</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GUnixSocketAddress</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the abstract name</doc>
            <array length="1" zero-terminated="0" c:type="const gchar*">
              <type name="gchar"/>
            </array>
          </parameter>
          <parameter name="path_len" transfer-ownership="none">
            <doc xml:space="preserve">the length of @path, or -1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_type" c:identifier="g_unix_socket_address_new_with_type" version="2.26">
        <doc xml:space="preserve">Creates a new #GUnixSocketAddress of type @type with name @path.

If @type is %G_UNIX_SOCKET_ADDRESS_PATH, this is equivalent to
calling g_unix_socket_address_new().

If @type is %G_UNIX_SOCKET_ADDRESS_ANONYMOUS, @path and @path_len will be
ignored.

If @path_type is %G_UNIX_SOCKET_ADDRESS_ABSTRACT, then @path_len
bytes of @path will be copied to the socket's path, and only those
bytes will be considered part of the name. (If @path_len is -1,
then @path is assumed to be NUL-terminated.) For example, if @path
was "test", then calling g_socket_address_get_native_size() on the
returned socket would return 7 (2 bytes of overhead, 1 byte for the
abstract-socket indicator byte, and 4 bytes for the name "test").

If @path_type is %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED, then
@path_len bytes of @path will be copied to the socket's path, the
rest of the path will be padded with 0 bytes, and the entire
zero-padded buffer will be considered the name. (As above, if
@path_len is -1, then @path is assumed to be NUL-terminated.) In
this case, g_socket_address_get_native_size() will always return
the full size of a `struct sockaddr_un`, although
g_unix_socket_address_get_path_len() will still return just the
length of @path.

%G_UNIX_SOCKET_ADDRESS_ABSTRACT is preferred over
%G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED for new programs. Of course,
when connecting to a server created by another process, you must
use the appropriate type corresponding to how that process created
its listening socket.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GUnixSocketAddress</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the name</doc>
            <array length="1" zero-terminated="0" c:type="const gchar*">
              <type name="gchar"/>
            </array>
          </parameter>
          <parameter name="path_len" transfer-ownership="none">
            <doc xml:space="preserve">the length of @path, or -1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixSocketAddressType</doc>
            <type name="UnixSocketAddressType" c:type="GUnixSocketAddressType"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="abstract_names_supported" c:identifier="g_unix_socket_address_abstract_names_supported" version="2.22">
        <doc xml:space="preserve">Checks if abstract UNIX domain socket names are supported.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if supported, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </function>
      <method name="get_address_type" c:identifier="g_unix_socket_address_get_address_type" version="2.26">
        <doc xml:space="preserve">Gets @address's type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GUnixSocketAddressType</doc>
          <type name="UnixSocketAddressType" c:type="GUnixSocketAddressType"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetSocketAddress</doc>
            <type name="UnixSocketAddress" c:type="GUnixSocketAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_abstract" c:identifier="g_unix_socket_address_get_is_abstract" version="2.22" deprecated="1">
        <doc xml:space="preserve">Tests if @address is abstract.</doc>
        <doc-deprecated xml:space="preserve">Use g_unix_socket_address_get_address_type()</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the address is abstract, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetSocketAddress</doc>
            <type name="UnixSocketAddress" c:type="GUnixSocketAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_path" c:identifier="g_unix_socket_address_get_path" version="2.22">
        <doc xml:space="preserve">Gets @address's path, or for abstract sockets the "name".

Guaranteed to be zero-terminated, but an abstract socket
may contain embedded zeros, and thus you should use
g_unix_socket_address_get_path_len() to get the true length
of this string.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the path for @address</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetSocketAddress</doc>
            <type name="UnixSocketAddress" c:type="GUnixSocketAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_path_len" c:identifier="g_unix_socket_address_get_path_len" version="2.22">
        <doc xml:space="preserve">Gets the length of @address's path.

For details, see g_unix_socket_address_get_path().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the length of the path</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">a #GInetSocketAddress</doc>
            <type name="UnixSocketAddress" c:type="GUnixSocketAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="abstract" deprecated="1" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether or not this is an abstract address</doc>
        <doc-deprecated xml:space="preserve">Use #GUnixSocketAddress:address-type, which
distinguishes between zero-padded and non-zero-padded
abstract addresses.</doc-deprecated>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="address-type" writable="1" construct-only="1" transfer-ownership="none">
        <type name="UnixSocketAddressType"/>
      </property>
      <property name="path" writable="1" construct-only="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="path-as-array" writable="1" construct-only="1" transfer-ownership="none">
        <array name="GLib.ByteArray">
          <type name="guint8" c:type="guint8"/>
        </array>
      </property>
      <field name="parent_instance">
        <type name="SocketAddress" c:type="GSocketAddress"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="UnixSocketAddressPrivate" c:type="GUnixSocketAddressPrivate*"/>
      </field>
    </class>
    <record name="UnixSocketAddressClass" c:type="GUnixSocketAddressClass" glib:is-gtype-struct-for="UnixSocketAddress">
      <field name="parent_class">
        <type name="SocketAddressClass" c:type="GSocketAddressClass"/>
      </field>
    </record>
    <record name="UnixSocketAddressPrivate" c:type="GUnixSocketAddressPrivate" disguised="1">
    </record>
    <enumeration name="UnixSocketAddressType" version="2.26" glib:type-name="GUnixSocketAddressType" glib:get-type="g_unix_socket_address_type_get_type" c:type="GUnixSocketAddressType">
      <doc xml:space="preserve">The type of name used by a #GUnixSocketAddress.
%G_UNIX_SOCKET_ADDRESS_PATH indicates a traditional unix domain
socket bound to a filesystem path. %G_UNIX_SOCKET_ADDRESS_ANONYMOUS
indicates a socket not bound to any name (eg, a client-side socket,
or a socket created with socketpair()).

For abstract sockets, there are two incompatible ways of naming
them; the man pages suggest using the entire `struct sockaddr_un`
as the name, padding the unused parts of the %sun_path field with
zeroes; this corresponds to %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED.
However, many programs instead just use a portion of %sun_path, and
pass an appropriate smaller length to bind() or connect(). This is
%G_UNIX_SOCKET_ADDRESS_ABSTRACT.</doc>
      <member name="invalid" value="0" c:identifier="G_UNIX_SOCKET_ADDRESS_INVALID" glib:nick="invalid">
        <doc xml:space="preserve">invalid</doc>
      </member>
      <member name="anonymous" value="1" c:identifier="G_UNIX_SOCKET_ADDRESS_ANONYMOUS" glib:nick="anonymous">
        <doc xml:space="preserve">anonymous</doc>
      </member>
      <member name="path" value="2" c:identifier="G_UNIX_SOCKET_ADDRESS_PATH" glib:nick="path">
        <doc xml:space="preserve">a filesystem path</doc>
      </member>
      <member name="abstract" value="3" c:identifier="G_UNIX_SOCKET_ADDRESS_ABSTRACT" glib:nick="abstract">
        <doc xml:space="preserve">an abstract name</doc>
      </member>
      <member name="abstract_padded" value="4" c:identifier="G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED" glib:nick="abstract-padded">
        <doc xml:space="preserve">an abstract name, 0-padded
  to the full length of a unix socket name</doc>
      </member>
    </enumeration>
    <constant name="VFS_EXTENSION_POINT_NAME" value="gio-vfs" c:type="G_VFS_EXTENSION_POINT_NAME">
      <doc xml:space="preserve">Extension point for #GVfs functionality.
See [Extending GIO][extending-gio].</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VOLUME_IDENTIFIER_KIND_CLASS" value="class" c:type="G_VOLUME_IDENTIFIER_KIND_CLASS">
      <doc xml:space="preserve">The string used to obtain the volume class with g_volume_get_identifier().

Known volume classes include `device` and `network`. Other classes may
be added in the future.

This is intended to be used by applications to classify #GVolume
instances into different sections - for example a file manager or
file chooser can use this information to show `network` volumes under
a "Network" heading and `device` volumes under a "Devices" heading.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VOLUME_IDENTIFIER_KIND_HAL_UDI" value="hal-udi" c:type="G_VOLUME_IDENTIFIER_KIND_HAL_UDI" deprecated="1" deprecated-version="2.58">
      <doc xml:space="preserve">The string used to obtain a Hal UDI with g_volume_get_identifier().</doc>
      <doc-deprecated xml:space="preserve">Do not use, HAL is deprecated.</doc-deprecated>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VOLUME_IDENTIFIER_KIND_LABEL" value="label" c:type="G_VOLUME_IDENTIFIER_KIND_LABEL">
      <doc xml:space="preserve">The string used to obtain a filesystem label with g_volume_get_identifier().</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VOLUME_IDENTIFIER_KIND_NFS_MOUNT" value="nfs-mount" c:type="G_VOLUME_IDENTIFIER_KIND_NFS_MOUNT">
      <doc xml:space="preserve">The string used to obtain a NFS mount with g_volume_get_identifier().</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VOLUME_IDENTIFIER_KIND_UNIX_DEVICE" value="unix-device" c:type="G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE">
      <doc xml:space="preserve">The string used to obtain a Unix device path with g_volume_get_identifier().</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VOLUME_IDENTIFIER_KIND_UUID" value="uuid" c:type="G_VOLUME_IDENTIFIER_KIND_UUID">
      <doc xml:space="preserve">The string used to obtain a UUID with g_volume_get_identifier().</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VOLUME_MONITOR_EXTENSION_POINT_NAME" value="gio-volume-monitor" c:type="G_VOLUME_MONITOR_EXTENSION_POINT_NAME">
      <doc xml:space="preserve">Extension point for volume monitor functionality.
See [Extending GIO][extending-gio].</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Vfs" c:symbol-prefix="vfs" c:type="GVfs" parent="GObject.Object" glib:type-name="GVfs" glib:get-type="g_vfs_get_type" glib:type-struct="VfsClass">
      <doc xml:space="preserve">Entry point for using GIO functionality.</doc>
      <function name="get_default" c:identifier="g_vfs_get_default">
        <doc xml:space="preserve">Gets the default #GVfs for the system.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GVfs.</doc>
          <type name="Vfs" c:type="GVfs*"/>
        </return-value>
      </function>
      <function name="get_local" c:identifier="g_vfs_get_local">
        <doc xml:space="preserve">Gets the local #GVfs for the system.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GVfs.</doc>
          <type name="Vfs" c:type="GVfs*"/>
        </return-value>
      </function>
      <virtual-method name="add_writable_namespaces">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfs" transfer-ownership="none">
            <type name="Vfs" c:type="GVfs*"/>
          </instance-parameter>
          <parameter name="list" transfer-ownership="none">
            <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="deserialize_icon" introspectable="0">
        <return-value>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfs" transfer-ownership="none">
            <type name="Vfs" c:type="GVfs*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_file_for_path" invoker="get_file_for_path">
        <doc xml:space="preserve">Gets a #GFile for @path.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFile.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfs" transfer-ownership="none">
            <doc xml:space="preserve">a #GVfs.</doc>
            <type name="Vfs" c:type="GVfs*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a string containing a VFS path.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_file_for_uri" invoker="get_file_for_uri">
        <doc xml:space="preserve">Gets a #GFile for @uri.

This operation never fails, but the returned object
might not support any I/O operation if the URI
is malformed or if the URI scheme is not supported.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFile.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfs" transfer-ownership="none">
            <doc xml:space="preserve">a#GVfs.</doc>
            <type name="Vfs" c:type="GVfs*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a string containing a URI</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_supported_uri_schemes" invoker="get_supported_uri_schemes">
        <doc xml:space="preserve">Gets a list of URI schemes supported by @vfs.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a %NULL-terminated array of strings.
    The returned array belongs to GIO and must
    not be freed or modified.</doc>
          <array c:type="const gchar* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="vfs" transfer-ownership="none">
            <doc xml:space="preserve">a #GVfs.</doc>
            <type name="Vfs" c:type="GVfs*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_active" invoker="is_active">
        <doc xml:space="preserve">Checks if the VFS is active.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if construction of the @vfs was successful
    and it is now active.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfs" transfer-ownership="none">
            <doc xml:space="preserve">a #GVfs.</doc>
            <type name="Vfs" c:type="GVfs*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="local_file_add_info">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfs" transfer-ownership="none">
            <type name="Vfs" c:type="GVfs*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="device" transfer-ownership="none">
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="attribute_matcher" transfer-ownership="none">
            <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="FileInfo" c:type="GFileInfo*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="extra_data" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
          <parameter name="free_extra_data" transfer-ownership="none" scope="async">
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="local_file_moved">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfs" transfer-ownership="none">
            <type name="Vfs" c:type="GVfs*"/>
          </instance-parameter>
          <parameter name="source" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="dest" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="local_file_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfs" transfer-ownership="none">
            <type name="Vfs" c:type="GVfs*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="local_file_set_attributes" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfs" transfer-ownership="none">
            <type name="Vfs" c:type="GVfs*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="FileInfo" c:type="GFileInfo*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="parse_name" invoker="parse_name">
        <doc xml:space="preserve">This operation never fails, but the returned object might
not support any I/O operations if the @parse_name cannot
be parsed by the #GVfs module.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFile for the given @parse_name.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfs" transfer-ownership="none">
            <doc xml:space="preserve">a #GVfs.</doc>
            <type name="Vfs" c:type="GVfs*"/>
          </instance-parameter>
          <parameter name="parse_name" transfer-ownership="none">
            <doc xml:space="preserve">a string to be parsed by the VFS module.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_file_for_path" c:identifier="g_vfs_get_file_for_path">
        <doc xml:space="preserve">Gets a #GFile for @path.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFile.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfs" transfer-ownership="none">
            <doc xml:space="preserve">a #GVfs.</doc>
            <type name="Vfs" c:type="GVfs*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a string containing a VFS path.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_file_for_uri" c:identifier="g_vfs_get_file_for_uri">
        <doc xml:space="preserve">Gets a #GFile for @uri.

This operation never fails, but the returned object
might not support any I/O operation if the URI
is malformed or if the URI scheme is not supported.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFile.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfs" transfer-ownership="none">
            <doc xml:space="preserve">a#GVfs.</doc>
            <type name="Vfs" c:type="GVfs*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a string containing a URI</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_supported_uri_schemes" c:identifier="g_vfs_get_supported_uri_schemes">
        <doc xml:space="preserve">Gets a list of URI schemes supported by @vfs.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a %NULL-terminated array of strings.
    The returned array belongs to GIO and must
    not be freed or modified.</doc>
          <array c:type="const gchar* const*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="vfs" transfer-ownership="none">
            <doc xml:space="preserve">a #GVfs.</doc>
            <type name="Vfs" c:type="GVfs*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_active" c:identifier="g_vfs_is_active">
        <doc xml:space="preserve">Checks if the VFS is active.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if construction of the @vfs was successful
    and it is now active.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfs" transfer-ownership="none">
            <doc xml:space="preserve">a #GVfs.</doc>
            <type name="Vfs" c:type="GVfs*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="parse_name" c:identifier="g_vfs_parse_name">
        <doc xml:space="preserve">This operation never fails, but the returned object might
not support any I/O operations if the @parse_name cannot
be parsed by the #GVfs module.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFile for the given @parse_name.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfs" transfer-ownership="none">
            <doc xml:space="preserve">a #GVfs.</doc>
            <type name="Vfs" c:type="GVfs*"/>
          </instance-parameter>
          <parameter name="parse_name" transfer-ownership="none">
            <doc xml:space="preserve">a string to be parsed by the VFS module.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="register_uri_scheme" c:identifier="g_vfs_register_uri_scheme" version="2.50">
        <doc xml:space="preserve">Registers @uri_func and @parse_name_func as the #GFile URI and parse name
lookup functions for URIs with a scheme matching @scheme.
Note that @scheme is registered only within the running application, as
opposed to desktop-wide as it happens with GVfs backends.

When a #GFile is requested with an URI containing @scheme (e.g. through
g_file_new_for_uri()), @uri_func will be called to allow a custom
constructor. The implementation of @uri_func should not be blocking, and
must not call g_vfs_register_uri_scheme() or g_vfs_unregister_uri_scheme().

When g_file_parse_name() is called with a parse name obtained from such file,
@parse_name_func will be called to allow the #GFile to be created again. In
that case, it's responsibility of @parse_name_func to make sure the parse
name matches what the custom #GFile implementation returned when
g_file_get_parse_name() was previously called. The implementation of
@parse_name_func should not be blocking, and must not call
g_vfs_register_uri_scheme() or g_vfs_unregister_uri_scheme().

It's an error to call this function twice with the same scheme. To unregister
a custom URI scheme, use g_vfs_unregister_uri_scheme().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @scheme was successfully registered, or %FALSE if a handler
    for @scheme already exists.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfs" transfer-ownership="none">
            <doc xml:space="preserve">a #GVfs</doc>
            <type name="Vfs" c:type="GVfs*"/>
          </instance-parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:space="preserve">an URI scheme, e.g. "http"</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="uri_func" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="2" destroy="3">
            <doc xml:space="preserve">a #GVfsFileLookupFunc</doc>
            <type name="VfsFileLookupFunc" c:type="GVfsFileLookupFunc"/>
          </parameter>
          <parameter name="uri_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">custom data passed to be passed to @uri_func, or %NULL</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="uri_destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">function to be called when unregistering the
    URI scheme, or when @vfs is disposed, to free the resources used
    by the URI lookup function</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="parse_name_func" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="5" destroy="6">
            <doc xml:space="preserve">a #GVfsFileLookupFunc</doc>
            <type name="VfsFileLookupFunc" c:type="GVfsFileLookupFunc"/>
          </parameter>
          <parameter name="parse_name_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">custom data passed to be passed to
    @parse_name_func, or %NULL</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="parse_name_destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">function to be called when unregistering the
    URI scheme, or when @vfs is disposed, to free the resources used
    by the parse name lookup function</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="unregister_uri_scheme" c:identifier="g_vfs_unregister_uri_scheme" version="2.50">
        <doc xml:space="preserve">Unregisters the URI handler for @scheme previously registered with
g_vfs_register_uri_scheme().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @scheme was successfully unregistered, or %FALSE if a
    handler for @scheme does not exist.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfs" transfer-ownership="none">
            <doc xml:space="preserve">a #GVfs</doc>
            <type name="Vfs" c:type="GVfs*"/>
          </instance-parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:space="preserve">an URI scheme, e.g. "http"</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="VfsClass" c:type="GVfsClass" glib:is-gtype-struct-for="Vfs">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="is_active">
        <callback name="is_active">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if construction of the @vfs was successful
    and it is now active.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="vfs" transfer-ownership="none">
              <doc xml:space="preserve">a #GVfs.</doc>
              <type name="Vfs" c:type="GVfs*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_file_for_path">
        <callback name="get_file_for_path">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFile.
    Free the returned object with g_object_unref().</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="vfs" transfer-ownership="none">
              <doc xml:space="preserve">a #GVfs.</doc>
              <type name="Vfs" c:type="GVfs*"/>
            </parameter>
            <parameter name="path" transfer-ownership="none">
              <doc xml:space="preserve">a string containing a VFS path.</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_file_for_uri">
        <callback name="get_file_for_uri">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFile.
    Free the returned object with g_object_unref().</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="vfs" transfer-ownership="none">
              <doc xml:space="preserve">a#GVfs.</doc>
              <type name="Vfs" c:type="GVfs*"/>
            </parameter>
            <parameter name="uri" transfer-ownership="none">
              <doc xml:space="preserve">a string containing a URI</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_supported_uri_schemes">
        <callback name="get_supported_uri_schemes">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">a %NULL-terminated array of strings.
    The returned array belongs to GIO and must
    not be freed or modified.</doc>
            <array c:type="const gchar* const*">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="vfs" transfer-ownership="none">
              <doc xml:space="preserve">a #GVfs.</doc>
              <type name="Vfs" c:type="GVfs*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="parse_name">
        <callback name="parse_name">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GFile for the given @parse_name.
    Free the returned object with g_object_unref().</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="vfs" transfer-ownership="none">
              <doc xml:space="preserve">a #GVfs.</doc>
              <type name="Vfs" c:type="GVfs*"/>
            </parameter>
            <parameter name="parse_name" transfer-ownership="none">
              <doc xml:space="preserve">a string to be parsed by the VFS module.</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="local_file_add_info">
        <callback name="local_file_add_info">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="vfs" transfer-ownership="none">
              <type name="Vfs" c:type="GVfs*"/>
            </parameter>
            <parameter name="filename" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="device" transfer-ownership="none">
              <type name="guint64" c:type="guint64"/>
            </parameter>
            <parameter name="attribute_matcher" transfer-ownership="none">
              <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <type name="FileInfo" c:type="GFileInfo*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="extra_data" transfer-ownership="none" nullable="1" allow-none="1">
              <type name="gpointer" c:type="gpointer*"/>
            </parameter>
            <parameter name="free_extra_data" transfer-ownership="none" scope="async">
              <type name="GLib.DestroyNotify" c:type="GDestroyNotify*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_writable_namespaces">
        <callback name="add_writable_namespaces">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="vfs" transfer-ownership="none">
              <type name="Vfs" c:type="GVfs*"/>
            </parameter>
            <parameter name="list" transfer-ownership="none">
              <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="local_file_set_attributes">
        <callback name="local_file_set_attributes" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="vfs" transfer-ownership="none">
              <type name="Vfs" c:type="GVfs*"/>
            </parameter>
            <parameter name="filename" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <type name="FileInfo" c:type="GFileInfo*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="local_file_removed">
        <callback name="local_file_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="vfs" transfer-ownership="none">
              <type name="Vfs" c:type="GVfs*"/>
            </parameter>
            <parameter name="filename" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="local_file_moved">
        <callback name="local_file_moved">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="vfs" transfer-ownership="none">
              <type name="Vfs" c:type="GVfs*"/>
            </parameter>
            <parameter name="source" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="dest" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="deserialize_icon" introspectable="0">
        <callback name="deserialize_icon" introspectable="0">
          <return-value>
            <type name="Icon" c:type="GIcon*"/>
          </return-value>
          <parameters>
            <parameter name="vfs" transfer-ownership="none">
              <type name="Vfs" c:type="GVfs*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved6" introspectable="0">
        <callback name="_g_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <callback name="VfsFileLookupFunc" c:type="GVfsFileLookupFunc" version="2.50">
      <doc xml:space="preserve">This function type is used by g_vfs_register_uri_scheme() to make it
possible for a client to associate an URI scheme to a different #GFile
implementation.

The client should return a reference to the new file that has been
created for @uri, or %NULL to continue with the default implementation.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #GFile for @identifier.</doc>
        <type name="File" c:type="GFile*"/>
      </return-value>
      <parameters>
        <parameter name="vfs" transfer-ownership="none">
          <doc xml:space="preserve">a #GVfs</doc>
          <type name="Vfs" c:type="GVfs*"/>
        </parameter>
        <parameter name="identifier" transfer-ownership="none">
          <doc xml:space="preserve">the identifier to lookup a #GFile for. This can either
    be an URI or a parse name as returned by g_file_get_parse_name()</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">user data passed to the function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <interface name="Volume" c:symbol-prefix="volume" c:type="GVolume" glib:type-name="GVolume" glib:get-type="g_volume_get_type" glib:type-struct="VolumeIface">
      <doc xml:space="preserve">The #GVolume interface represents user-visible objects that can be
mounted. Note, when porting from GnomeVFS, #GVolume is the moral
equivalent of #GnomeVFSDrive.

Mounting a #GVolume instance is an asynchronous operation. For more
information about asynchronous operations, see #GAsyncResult and
#GTask. To mount a #GVolume, first call g_volume_mount() with (at
least) the #GVolume instance, optionally a #GMountOperation object
and a #GAsyncReadyCallback.

Typically, one will only want to pass %NULL for the
#GMountOperation if automounting all volumes when a desktop session
starts since it's not desirable to put up a lot of dialogs asking
for credentials.

The callback will be fired when the operation has resolved (either
with success or failure), and a #GAsyncReady structure will be
passed to the callback.  That callback should then call
g_volume_mount_finish() with the #GVolume instance and the
#GAsyncReady data to see if the operation was completed
successfully.  If an @error is present when g_volume_mount_finish()
is called, then it will be filled with any error information.

## Volume Identifiers # {#volume-identifier}

It is sometimes necessary to directly access the underlying
operating system object behind a volume (e.g. for passing a volume
to an application via the commandline). For this purpose, GIO
allows to obtain an 'identifier' for the volume. There can be
different kinds of identifiers, such as Hal UDIs, filesystem labels,
traditional Unix devices (e.g. `/dev/sda2`), UUIDs. GIO uses predefined
strings as names for the different kinds of identifiers:
#G_VOLUME_IDENTIFIER_KIND_UUID, #G_VOLUME_IDENTIFIER_KIND_LABEL, etc.
Use g_volume_get_identifier() to obtain an identifier for a volume.


Note that #G_VOLUME_IDENTIFIER_KIND_HAL_UDI will only be available
when the gvfs hal volume monitor is in use. Other volume monitors
will generally be able to provide the #G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE
identifier, which can be used to obtain a hal device by means of
libhal_manager_find_device_string_match().</doc>
      <virtual-method name="can_eject" invoker="can_eject">
        <doc xml:space="preserve">Checks if a volume can be ejected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @volume can be ejected. %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="can_mount" invoker="can_mount">
        <doc xml:space="preserve">Checks if a volume can be mounted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @volume can be mounted. %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject" invoker="eject" deprecated="1" deprecated-version="2.22">
        <doc xml:space="preserve">Ejects a volume. This is an asynchronous operation, and is
finished by calling g_volume_eject_finish() with the @volume
and #GAsyncResult returned in the @callback.</doc>
        <doc-deprecated xml:space="preserve">Use g_volume_eject_with_operation() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the unmount if required for eject</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
            <doc xml:space="preserve">user data that gets passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_finish" invoker="eject_finish" deprecated="1" deprecated-version="2.22" throws="1">
        <doc xml:space="preserve">Finishes ejecting a volume. If any errors occurred during the operation,
@error will be set to contain the errors and %FALSE will be returned.</doc>
        <doc-deprecated xml:space="preserve">Use g_volume_eject_with_operation_finish() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE, %FALSE if operation failed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">pointer to a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_with_operation" invoker="eject_with_operation" version="2.22">
        <doc xml:space="preserve">Ejects a volume. This is an asynchronous operation, and is
finished by calling g_volume_eject_with_operation_finish() with the @volume
and #GAsyncResult data returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the unmount if required for eject</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation or %NULL to
    avoid user interaction</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">user data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_with_operation_finish" invoker="eject_with_operation_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes ejecting a volume. If any errors occurred during the operation,
@error will be set to contain the errors and %FALSE will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the volume was successfully ejected. %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="enumerate_identifiers" invoker="enumerate_identifiers">
        <doc xml:space="preserve">Gets the kinds of [identifiers][volume-identifier] that @volume has.
Use g_volume_get_identifier() to obtain the identifiers themselves.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a %NULL-terminated array
  of strings containing kinds of identifiers. Use g_strfreev() to free.</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_activation_root" invoker="get_activation_root" version="2.18">
        <doc xml:space="preserve">Gets the activation root for a #GVolume if it is known ahead of
mount time. Returns %NULL otherwise. If not %NULL and if @volume
is mounted, then the result of g_mount_get_root() on the
#GMount object obtained from g_volume_get_mount() will always
either be equal or a prefix of what this function returns. In
other words, in code

|[&lt;!-- language="C" --&gt;
  GMount *mount;
  GFile *mount_root
  GFile *volume_activation_root;

  mount = g_volume_get_mount (volume); // mounted, so never NULL
  mount_root = g_mount_get_root (mount);
  volume_activation_root = g_volume_get_activation_root (volume); // assume not NULL
]|
then the expression
|[&lt;!-- language="C" --&gt;
  (g_file_has_prefix (volume_activation_root, mount_root) ||
   g_file_equal (volume_activation_root, mount_root))
]|
will always be %TRUE.

Activation roots are typically used in #GVolumeMonitor
implementations to find the underlying mount to shadow, see
g_mount_is_shadowed() for more details.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the activation root of @volume
    or %NULL. Use g_object_unref() to free.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_drive" invoker="get_drive">
        <doc xml:space="preserve">Gets the drive for the @volume.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #GDrive or %NULL if @volume is not
    associated with a drive. The returned object should be unreffed
    with g_object_unref() when no longer needed.</doc>
          <type name="Drive" c:type="GDrive*"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_icon" invoker="get_icon">
        <doc xml:space="preserve">Gets the icon for @volume.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GIcon.
    The returned object should be unreffed with g_object_unref()
    when no longer needed.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_identifier" invoker="get_identifier">
        <doc xml:space="preserve">Gets the identifier of the given kind for @volume.
See the [introduction][volume-identifier] for more
information about volume identifiers.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a newly allocated string containing the
    requested identifier, or %NULL if the #GVolume
    doesn't have this kind of identifier</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
          <parameter name="kind" transfer-ownership="none">
            <doc xml:space="preserve">the kind of identifier to return</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_mount" invoker="get_mount">
        <doc xml:space="preserve">Gets the mount for the @volume.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #GMount or %NULL if @volume isn't mounted.
    The returned object should be unreffed with g_object_unref()
    when no longer needed.</doc>
          <type name="Mount" c:type="GMount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_name" invoker="get_name">
        <doc xml:space="preserve">Gets the name of @volume.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the name for the given @volume. The returned string should
    be freed with g_free() when no longer needed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_sort_key" invoker="get_sort_key" version="2.32">
        <doc xml:space="preserve">Gets the sort key for @volume, if any.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">Sorting key for @volume or %NULL if no such key is available</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_symbolic_icon" invoker="get_symbolic_icon" version="2.34">
        <doc xml:space="preserve">Gets the symbolic icon for @volume.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GIcon.
    The returned object should be unreffed with g_object_unref()
    when no longer needed.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_uuid" invoker="get_uuid">
        <doc xml:space="preserve">Gets the UUID for the @volume. The reference is typically based on
the file system UUID for the volume in question and should be
considered an opaque string. Returns %NULL if there is no UUID
available.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the UUID for @volume or %NULL if no UUID
    can be computed.
    The returned string should be freed with g_free()
    when no longer needed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="mount_finish" invoker="mount_finish" throws="1">
        <doc xml:space="preserve">Finishes mounting a volume. If any errors occurred during the operation,
@error will be set to contain the errors and %FALSE will be returned.

If the mount operation succeeded, g_volume_get_mount() on @volume
is guaranteed to return the mount right after calling this
function; there's no need to listen for the 'mount-added' signal on
#GVolumeMonitor.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE, %FALSE if operation failed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="mount_fn" invoker="mount">
        <doc xml:space="preserve">Mounts a volume. This is an asynchronous operation, and is
finished by calling g_volume_mount_finish() with the @volume
and #GAsyncResult returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the operation</doc>
            <type name="MountMountFlags" c:type="GMountMountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation or %NULL to avoid user interaction</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
            <doc xml:space="preserve">user data that gets passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="should_automount" invoker="should_automount">
        <doc xml:space="preserve">Returns whether the volume should be automatically mounted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the volume should be automatically mounted</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="can_eject" c:identifier="g_volume_can_eject">
        <doc xml:space="preserve">Checks if a volume can be ejected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @volume can be ejected. %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="can_mount" c:identifier="g_volume_can_mount">
        <doc xml:space="preserve">Checks if a volume can be mounted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @volume can be mounted. %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="eject" c:identifier="g_volume_eject" deprecated="1" deprecated-version="2.22">
        <doc xml:space="preserve">Ejects a volume. This is an asynchronous operation, and is
finished by calling g_volume_eject_finish() with the @volume
and #GAsyncResult returned in the @callback.</doc>
        <doc-deprecated xml:space="preserve">Use g_volume_eject_with_operation() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the unmount if required for eject</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data that gets passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="eject_finish" c:identifier="g_volume_eject_finish" deprecated="1" deprecated-version="2.22" throws="1">
        <doc xml:space="preserve">Finishes ejecting a volume. If any errors occurred during the operation,
@error will be set to contain the errors and %FALSE will be returned.</doc>
        <doc-deprecated xml:space="preserve">Use g_volume_eject_with_operation_finish() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE, %FALSE if operation failed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">pointer to a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="eject_with_operation" c:identifier="g_volume_eject_with_operation" version="2.22">
        <doc xml:space="preserve">Ejects a volume. This is an asynchronous operation, and is
finished by calling g_volume_eject_with_operation_finish() with the @volume
and #GAsyncResult data returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the unmount if required for eject</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation or %NULL to
    avoid user interaction</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="eject_with_operation_finish" c:identifier="g_volume_eject_with_operation_finish" version="2.22" throws="1">
        <doc xml:space="preserve">Finishes ejecting a volume. If any errors occurred during the operation,
@error will be set to contain the errors and %FALSE will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the volume was successfully ejected. %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="enumerate_identifiers" c:identifier="g_volume_enumerate_identifiers">
        <doc xml:space="preserve">Gets the kinds of [identifiers][volume-identifier] that @volume has.
Use g_volume_get_identifier() to obtain the identifiers themselves.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a %NULL-terminated array
  of strings containing kinds of identifiers. Use g_strfreev() to free.</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_activation_root" c:identifier="g_volume_get_activation_root" version="2.18">
        <doc xml:space="preserve">Gets the activation root for a #GVolume if it is known ahead of
mount time. Returns %NULL otherwise. If not %NULL and if @volume
is mounted, then the result of g_mount_get_root() on the
#GMount object obtained from g_volume_get_mount() will always
either be equal or a prefix of what this function returns. In
other words, in code

|[&lt;!-- language="C" --&gt;
  GMount *mount;
  GFile *mount_root
  GFile *volume_activation_root;

  mount = g_volume_get_mount (volume); // mounted, so never NULL
  mount_root = g_mount_get_root (mount);
  volume_activation_root = g_volume_get_activation_root (volume); // assume not NULL
]|
then the expression
|[&lt;!-- language="C" --&gt;
  (g_file_has_prefix (volume_activation_root, mount_root) ||
   g_file_equal (volume_activation_root, mount_root))
]|
will always be %TRUE.

Activation roots are typically used in #GVolumeMonitor
implementations to find the underlying mount to shadow, see
g_mount_is_shadowed() for more details.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the activation root of @volume
    or %NULL. Use g_object_unref() to free.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_drive" c:identifier="g_volume_get_drive">
        <doc xml:space="preserve">Gets the drive for the @volume.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #GDrive or %NULL if @volume is not
    associated with a drive. The returned object should be unreffed
    with g_object_unref() when no longer needed.</doc>
          <type name="Drive" c:type="GDrive*"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_icon" c:identifier="g_volume_get_icon">
        <doc xml:space="preserve">Gets the icon for @volume.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GIcon.
    The returned object should be unreffed with g_object_unref()
    when no longer needed.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_identifier" c:identifier="g_volume_get_identifier">
        <doc xml:space="preserve">Gets the identifier of the given kind for @volume.
See the [introduction][volume-identifier] for more
information about volume identifiers.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a newly allocated string containing the
    requested identifier, or %NULL if the #GVolume
    doesn't have this kind of identifier</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
          <parameter name="kind" transfer-ownership="none">
            <doc xml:space="preserve">the kind of identifier to return</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_mount" c:identifier="g_volume_get_mount">
        <doc xml:space="preserve">Gets the mount for the @volume.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #GMount or %NULL if @volume isn't mounted.
    The returned object should be unreffed with g_object_unref()
    when no longer needed.</doc>
          <type name="Mount" c:type="GMount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="g_volume_get_name">
        <doc xml:space="preserve">Gets the name of @volume.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the name for the given @volume. The returned string should
    be freed with g_free() when no longer needed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sort_key" c:identifier="g_volume_get_sort_key" version="2.32">
        <doc xml:space="preserve">Gets the sort key for @volume, if any.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">Sorting key for @volume or %NULL if no such key is available</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_symbolic_icon" c:identifier="g_volume_get_symbolic_icon" version="2.34">
        <doc xml:space="preserve">Gets the symbolic icon for @volume.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GIcon.
    The returned object should be unreffed with g_object_unref()
    when no longer needed.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uuid" c:identifier="g_volume_get_uuid">
        <doc xml:space="preserve">Gets the UUID for the @volume. The reference is typically based on
the file system UUID for the volume in question and should be
considered an opaque string. Returns %NULL if there is no UUID
available.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the UUID for @volume or %NULL if no UUID
    can be computed.
    The returned string should be freed with g_free()
    when no longer needed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="mount" c:identifier="g_volume_mount">
        <doc xml:space="preserve">Mounts a volume. This is an asynchronous operation, and is
finished by calling g_volume_mount_finish() with the @volume
and #GAsyncResult returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags affecting the operation</doc>
            <type name="MountMountFlags" c:type="GMountMountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMountOperation or %NULL to avoid user interaction</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data that gets passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="mount_finish" c:identifier="g_volume_mount_finish" throws="1">
        <doc xml:space="preserve">Finishes mounting a volume. If any errors occurred during the operation,
@error will be set to contain the errors and %FALSE will be returned.

If the mount operation succeeded, g_volume_get_mount() on @volume
is guaranteed to return the mount right after calling this
function; there's no need to listen for the 'mount-added' signal on
#GVolumeMonitor.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE, %FALSE if operation failed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="should_automount" c:identifier="g_volume_should_automount">
        <doc xml:space="preserve">Returns whether the volume should be automatically mounted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the volume should be automatically mounted</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume</doc>
            <type name="Volume" c:type="GVolume*"/>
          </instance-parameter>
        </parameters>
      </method>
      <glib:signal name="changed" when="last">
        <doc xml:space="preserve">Emitted when the volume has been changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="removed" when="last">
        <doc xml:space="preserve">This signal is emitted when the #GVolume have been removed. If
the recipient is holding references to the object they should
release them so the object can be finalized.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </interface>
    <record name="VolumeIface" c:type="GVolumeIface" glib:is-gtype-struct-for="Volume">
      <doc xml:space="preserve">Interface for implementing operations for mountable volumes.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="changed">
        <callback name="changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="removed">
        <callback name="removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_name">
        <callback name="get_name">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the name for the given @volume. The returned string should
    be freed with g_free() when no longer needed.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <doc xml:space="preserve">a #GVolume</doc>
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_icon">
        <callback name="get_icon">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GIcon.
    The returned object should be unreffed with g_object_unref()
    when no longer needed.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <doc xml:space="preserve">a #GVolume</doc>
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_uuid">
        <callback name="get_uuid">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">the UUID for @volume or %NULL if no UUID
    can be computed.
    The returned string should be freed with g_free()
    when no longer needed.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <doc xml:space="preserve">a #GVolume</doc>
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_drive">
        <callback name="get_drive">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">a #GDrive or %NULL if @volume is not
    associated with a drive. The returned object should be unreffed
    with g_object_unref() when no longer needed.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <doc xml:space="preserve">a #GVolume</doc>
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_mount">
        <callback name="get_mount">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">a #GMount or %NULL if @volume isn't mounted.
    The returned object should be unreffed with g_object_unref()
    when no longer needed.</doc>
            <type name="Mount" c:type="GMount*"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <doc xml:space="preserve">a #GVolume</doc>
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_mount">
        <callback name="can_mount">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the @volume can be mounted. %FALSE otherwise</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <doc xml:space="preserve">a #GVolume</doc>
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_eject">
        <callback name="can_eject">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the @volume can be ejected. %FALSE otherwise</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <doc xml:space="preserve">a #GVolume</doc>
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="mount_fn">
        <callback name="mount_fn">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <doc xml:space="preserve">a #GVolume</doc>
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags affecting the operation</doc>
              <type name="MountMountFlags" c:type="GMountMountFlags"/>
            </parameter>
            <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GMountOperation or %NULL to avoid user interaction</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">user data that gets passed to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="mount_finish">
        <callback name="mount_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE, %FALSE if operation failed</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <doc xml:space="preserve">a #GVolume</doc>
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject">
        <callback name="eject">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <doc xml:space="preserve">a #GVolume</doc>
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags affecting the unmount if required for eject</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <doc xml:space="preserve">user data that gets passed to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_finish">
        <callback name="eject_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE, %FALSE if operation failed</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <doc xml:space="preserve">pointer to a #GVolume</doc>
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_identifier">
        <callback name="get_identifier">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">a newly allocated string containing the
    requested identifier, or %NULL if the #GVolume
    doesn't have this kind of identifier</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <doc xml:space="preserve">a #GVolume</doc>
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
            <parameter name="kind" transfer-ownership="none">
              <doc xml:space="preserve">the kind of identifier to return</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="enumerate_identifiers">
        <callback name="enumerate_identifiers">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a %NULL-terminated array
  of strings containing kinds of identifiers. Use g_strfreev() to free.</doc>
            <array c:type="char**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <doc xml:space="preserve">a #GVolume</doc>
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="should_automount">
        <callback name="should_automount">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the volume should be automatically mounted</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <doc xml:space="preserve">a #GVolume</doc>
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_activation_root">
        <callback name="get_activation_root">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">the activation root of @volume
    or %NULL. Use g_object_unref() to free.</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <doc xml:space="preserve">a #GVolume</doc>
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_with_operation">
        <callback name="eject_with_operation">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <doc xml:space="preserve">a #GVolume</doc>
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags affecting the unmount if required for eject</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="mount_operation" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GMountOperation or %NULL to
    avoid user interaction</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
              <doc xml:space="preserve">a #GAsyncReadyCallback, or %NULL</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5">
              <doc xml:space="preserve">user data passed to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_with_operation_finish">
        <callback name="eject_with_operation_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the volume was successfully ejected. %FALSE otherwise</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <doc xml:space="preserve">a #GVolume</doc>
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_sort_key">
        <callback name="get_sort_key">
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve">Sorting key for @volume or %NULL if no such key is available</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <doc xml:space="preserve">a #GVolume</doc>
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_symbolic_icon">
        <callback name="get_symbolic_icon">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GIcon.
    The returned object should be unreffed with g_object_unref()
    when no longer needed.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <doc xml:space="preserve">a #GVolume</doc>
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="VolumeMonitor" c:symbol-prefix="volume_monitor" c:type="GVolumeMonitor" parent="GObject.Object" glib:type-name="GVolumeMonitor" glib:get-type="g_volume_monitor_get_type" glib:type-struct="VolumeMonitorClass">
      <doc xml:space="preserve">#GVolumeMonitor is for listing the user interesting devices and volumes
on the computer. In other words, what a file selector or file manager
would show in a sidebar.

#GVolumeMonitor is not
[thread-default-context aware][g-main-context-push-thread-default],
and so should not be used other than from the main thread, with no
thread-default-context active.</doc>
      <function name="adopt_orphan_mount" c:identifier="g_volume_monitor_adopt_orphan_mount" deprecated="1" deprecated-version="2.20">
        <doc xml:space="preserve">This function should be called by any #GVolumeMonitor
implementation when a new #GMount object is created that is not
associated with a #GVolume object. It must be called just before
emitting the @mount_added signal.

If the return value is not %NULL, the caller must associate the
returned #GVolume object with the #GMount. This involves returning
it in its g_mount_get_volume() implementation. The caller must
also listen for the "removed" signal on the returned object
and give up its reference when handling that signal

Similarly, if implementing g_volume_monitor_adopt_orphan_mount(),
the implementor must take a reference to @mount and return it in
its g_volume_get_mount() implemented. Also, the implementor must
listen for the "unmounted" signal on @mount and give up its
reference upon handling that signal.

There are two main use cases for this function.

One is when implementing a user space file system driver that reads
blocks of a block device that is already represented by the native
volume monitor (for example a CD Audio file system driver). Such
a driver will generate its own #GMount object that needs to be
associated with the #GVolume object that represents the volume.

The other is for implementing a #GVolumeMonitor whose sole purpose
is to return #GVolume objects representing entries in the users
"favorite servers" list or similar.</doc>
        <doc-deprecated xml:space="preserve">Instead of using this function, #GVolumeMonitor
implementations should instead create shadow mounts with the URI of
the mount they intend to adopt. See the proxy volume monitor in
gvfs for an example of this. Also see g_mount_is_shadowed(),
g_mount_shadow() and g_mount_unshadow() functions.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the #GVolume object that is the parent for @mount or %NULL
if no wants to adopt the #GMount.</doc>
          <type name="Volume" c:type="GVolume*"/>
        </return-value>
        <parameters>
          <parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount object to find a parent for</doc>
            <type name="Mount" c:type="GMount*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get" c:identifier="g_volume_monitor_get">
        <doc xml:space="preserve">Gets the volume monitor used by gio.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a reference to the #GVolumeMonitor used by gio. Call
   g_object_unref() when done with it.</doc>
          <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
        </return-value>
      </function>
      <virtual-method name="drive_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume_monitor" transfer-ownership="none">
            <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
          </instance-parameter>
          <parameter name="drive" transfer-ownership="none">
            <type name="Drive" c:type="GDrive*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="drive_connected">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume_monitor" transfer-ownership="none">
            <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
          </instance-parameter>
          <parameter name="drive" transfer-ownership="none">
            <type name="Drive" c:type="GDrive*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="drive_disconnected">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume_monitor" transfer-ownership="none">
            <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
          </instance-parameter>
          <parameter name="drive" transfer-ownership="none">
            <type name="Drive" c:type="GDrive*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="drive_eject_button">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume_monitor" transfer-ownership="none">
            <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
          </instance-parameter>
          <parameter name="drive" transfer-ownership="none">
            <type name="Drive" c:type="GDrive*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="drive_stop_button">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume_monitor" transfer-ownership="none">
            <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
          </instance-parameter>
          <parameter name="drive" transfer-ownership="none">
            <type name="Drive" c:type="GDrive*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_connected_drives" invoker="get_connected_drives">
        <doc xml:space="preserve">Gets a list of drives connected to the system.

The returned list should be freed with g_list_free(), after
its elements have been unreffed with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GList of connected #GDrive objects.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Drive"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="volume_monitor" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolumeMonitor.</doc>
            <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_mount_for_uuid" invoker="get_mount_for_uuid">
        <doc xml:space="preserve">Finds a #GMount object by its UUID (see g_mount_get_uuid())</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GMount or %NULL if no such mount is available.
    Free the returned object with g_object_unref().</doc>
          <type name="Mount" c:type="GMount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume_monitor" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolumeMonitor.</doc>
            <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
          </instance-parameter>
          <parameter name="uuid" transfer-ownership="none">
            <doc xml:space="preserve">the UUID to look for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_mounts" invoker="get_mounts">
        <doc xml:space="preserve">Gets a list of the mounts on the system.

The returned list should be freed with g_list_free(), after
its elements have been unreffed with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GList of #GMount objects.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Mount"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="volume_monitor" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolumeMonitor.</doc>
            <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_volume_for_uuid" invoker="get_volume_for_uuid">
        <doc xml:space="preserve">Finds a #GVolume object by its UUID (see g_volume_get_uuid())</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GVolume or %NULL if no such volume is available.
    Free the returned object with g_object_unref().</doc>
          <type name="Volume" c:type="GVolume*"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume_monitor" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolumeMonitor.</doc>
            <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
          </instance-parameter>
          <parameter name="uuid" transfer-ownership="none">
            <doc xml:space="preserve">the UUID to look for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_volumes" invoker="get_volumes">
        <doc xml:space="preserve">Gets a list of the volumes on the system.

The returned list should be freed with g_list_free(), after
its elements have been unreffed with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GList of #GVolume objects.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Volume"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="volume_monitor" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolumeMonitor.</doc>
            <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="mount_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume_monitor" transfer-ownership="none">
            <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
          </instance-parameter>
          <parameter name="mount" transfer-ownership="none">
            <type name="Mount" c:type="GMount*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="mount_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume_monitor" transfer-ownership="none">
            <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
          </instance-parameter>
          <parameter name="mount" transfer-ownership="none">
            <type name="Mount" c:type="GMount*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="mount_pre_unmount">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume_monitor" transfer-ownership="none">
            <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
          </instance-parameter>
          <parameter name="mount" transfer-ownership="none">
            <type name="Mount" c:type="GMount*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="mount_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume_monitor" transfer-ownership="none">
            <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
          </instance-parameter>
          <parameter name="mount" transfer-ownership="none">
            <type name="Mount" c:type="GMount*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="volume_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume_monitor" transfer-ownership="none">
            <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
          </instance-parameter>
          <parameter name="volume" transfer-ownership="none">
            <type name="Volume" c:type="GVolume*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="volume_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume_monitor" transfer-ownership="none">
            <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
          </instance-parameter>
          <parameter name="volume" transfer-ownership="none">
            <type name="Volume" c:type="GVolume*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="volume_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume_monitor" transfer-ownership="none">
            <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
          </instance-parameter>
          <parameter name="volume" transfer-ownership="none">
            <type name="Volume" c:type="GVolume*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_connected_drives" c:identifier="g_volume_monitor_get_connected_drives">
        <doc xml:space="preserve">Gets a list of drives connected to the system.

The returned list should be freed with g_list_free(), after
its elements have been unreffed with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GList of connected #GDrive objects.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Drive"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="volume_monitor" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolumeMonitor.</doc>
            <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mount_for_uuid" c:identifier="g_volume_monitor_get_mount_for_uuid">
        <doc xml:space="preserve">Finds a #GMount object by its UUID (see g_mount_get_uuid())</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GMount or %NULL if no such mount is available.
    Free the returned object with g_object_unref().</doc>
          <type name="Mount" c:type="GMount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume_monitor" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolumeMonitor.</doc>
            <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
          </instance-parameter>
          <parameter name="uuid" transfer-ownership="none">
            <doc xml:space="preserve">the UUID to look for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_mounts" c:identifier="g_volume_monitor_get_mounts">
        <doc xml:space="preserve">Gets a list of the mounts on the system.

The returned list should be freed with g_list_free(), after
its elements have been unreffed with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GList of #GMount objects.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Mount"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="volume_monitor" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolumeMonitor.</doc>
            <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_volume_for_uuid" c:identifier="g_volume_monitor_get_volume_for_uuid">
        <doc xml:space="preserve">Finds a #GVolume object by its UUID (see g_volume_get_uuid())</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GVolume or %NULL if no such volume is available.
    Free the returned object with g_object_unref().</doc>
          <type name="Volume" c:type="GVolume*"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume_monitor" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolumeMonitor.</doc>
            <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
          </instance-parameter>
          <parameter name="uuid" transfer-ownership="none">
            <doc xml:space="preserve">the UUID to look for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_volumes" c:identifier="g_volume_monitor_get_volumes">
        <doc xml:space="preserve">Gets a list of the volumes on the system.

The returned list should be freed with g_list_free(), after
its elements have been unreffed with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GList of #GVolume objects.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Volume"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="volume_monitor" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolumeMonitor.</doc>
            <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <glib:signal name="drive-changed" when="last">
        <doc xml:space="preserve">Emitted when a drive changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">the drive that changed</doc>
            <type name="Drive"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="drive-connected" when="last">
        <doc xml:space="preserve">Emitted when a drive is connected to the system.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive that was connected.</doc>
            <type name="Drive"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="drive-disconnected" when="last">
        <doc xml:space="preserve">Emitted when a drive is disconnected from the system.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">a #GDrive that was disconnected.</doc>
            <type name="Drive"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="drive-eject-button" when="last" version="2.18">
        <doc xml:space="preserve">Emitted when the eject button is pressed on @drive.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">the drive where the eject button was pressed</doc>
            <type name="Drive"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="drive-stop-button" when="last" version="2.22">
        <doc xml:space="preserve">Emitted when the stop button is pressed on @drive.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="drive" transfer-ownership="none">
            <doc xml:space="preserve">the drive where the stop button was pressed</doc>
            <type name="Drive"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="mount-added" when="last">
        <doc xml:space="preserve">Emitted when a mount is added.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount that was added.</doc>
            <type name="Mount"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="mount-changed" when="last">
        <doc xml:space="preserve">Emitted when a mount changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount that changed.</doc>
            <type name="Mount"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="mount-pre-unmount" when="last">
        <doc xml:space="preserve">May be emitted when a mount is about to be removed.

This signal depends on the backend and is only emitted if
GIO was used to unmount.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount that is being unmounted.</doc>
            <type name="Mount"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="mount-removed" when="last">
        <doc xml:space="preserve">Emitted when a mount is removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mount" transfer-ownership="none">
            <doc xml:space="preserve">a #GMount that was removed.</doc>
            <type name="Mount"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="volume-added" when="last">
        <doc xml:space="preserve">Emitted when a mountable volume is added to the system.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume that was added.</doc>
            <type name="Volume"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="volume-changed" when="last">
        <doc xml:space="preserve">Emitted when mountable volume is changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume that changed.</doc>
            <type name="Volume"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="volume-removed" when="last">
        <doc xml:space="preserve">Emitted when a mountable volume is removed from the system.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">a #GVolume that was removed.</doc>
            <type name="Volume"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="VolumeMonitorClass" c:type="GVolumeMonitorClass" glib:is-gtype-struct-for="VolumeMonitor">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="volume_added">
        <callback name="volume_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="volume_removed">
        <callback name="volume_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="volume_changed">
        <callback name="volume_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="mount_added">
        <callback name="mount_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="mount_removed">
        <callback name="mount_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="mount_pre_unmount">
        <callback name="mount_pre_unmount">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="mount_changed">
        <callback name="mount_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="drive_connected">
        <callback name="drive_connected">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="drive_disconnected">
        <callback name="drive_disconnected">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="drive_changed">
        <callback name="drive_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_supported">
        <callback name="is_supported">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
        </callback>
      </field>
      <field name="get_connected_drives">
        <callback name="get_connected_drives">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GList of connected #GDrive objects.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Drive"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <doc xml:space="preserve">a #GVolumeMonitor.</doc>
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_volumes">
        <callback name="get_volumes">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GList of #GVolume objects.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Volume"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <doc xml:space="preserve">a #GVolumeMonitor.</doc>
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_mounts">
        <callback name="get_mounts">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GList of #GMount objects.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Mount"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <doc xml:space="preserve">a #GVolumeMonitor.</doc>
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_volume_for_uuid">
        <callback name="get_volume_for_uuid">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GVolume or %NULL if no such volume is available.
    Free the returned object with g_object_unref().</doc>
            <type name="Volume" c:type="GVolume*"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <doc xml:space="preserve">a #GVolumeMonitor.</doc>
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="uuid" transfer-ownership="none">
              <doc xml:space="preserve">the UUID to look for</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_mount_for_uuid">
        <callback name="get_mount_for_uuid">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GMount or %NULL if no such mount is available.
    Free the returned object with g_object_unref().</doc>
            <type name="Mount" c:type="GMount*"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <doc xml:space="preserve">a #GVolumeMonitor.</doc>
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="uuid" transfer-ownership="none">
              <doc xml:space="preserve">the UUID to look for</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="adopt_orphan_mount" introspectable="0">
        <callback name="adopt_orphan_mount" introspectable="0">
          <return-value>
            <type name="Volume" c:type="GVolume*"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="drive_eject_button">
        <callback name="drive_eject_button">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="drive_stop_button">
        <callback name="drive_stop_button">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved6" introspectable="0">
        <callback name="_g_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <class name="ZlibCompressor" c:symbol-prefix="zlib_compressor" c:type="GZlibCompressor" parent="GObject.Object" glib:type-name="GZlibCompressor" glib:get-type="g_zlib_compressor_get_type" glib:type-struct="ZlibCompressorClass">
      <doc xml:space="preserve">Zlib decompression</doc>
      <implements name="Converter"/>
      <constructor name="new" c:identifier="g_zlib_compressor_new" version="2.24">
        <doc xml:space="preserve">Creates a new #GZlibCompressor.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GZlibCompressor</doc>
          <type name="ZlibCompressor" c:type="GZlibCompressor*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">The format to use for the compressed data</doc>
            <type name="ZlibCompressorFormat" c:type="GZlibCompressorFormat"/>
          </parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve">compression level (0-9), -1 for default</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_file_info" c:identifier="g_zlib_compressor_get_file_info" version="2.26">
        <doc xml:space="preserve">Returns the #GZlibCompressor:file-info property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GFileInfo, or %NULL</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="compressor" transfer-ownership="none">
            <doc xml:space="preserve">a #GZlibCompressor</doc>
            <type name="ZlibCompressor" c:type="GZlibCompressor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_file_info" c:identifier="g_zlib_compressor_set_file_info" version="2.26">
        <doc xml:space="preserve">Sets @file_info in @compressor. If non-%NULL, and @compressor's
#GZlibCompressor:format property is %G_ZLIB_COMPRESSOR_FORMAT_GZIP,
it will be used to set the file name and modification time in
the GZIP header of the compressed data.

Note: it is an error to call this function while a compression is in
progress; it may only be called immediately after creation of @compressor,
or after resetting it with g_converter_reset().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="compressor" transfer-ownership="none">
            <doc xml:space="preserve">a #GZlibCompressor</doc>
            <type name="ZlibCompressor" c:type="GZlibCompressor*"/>
          </instance-parameter>
          <parameter name="file_info" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </parameter>
        </parameters>
      </method>
      <property name="file-info" version="2.26" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">If set to a non-%NULL #GFileInfo object, and #GZlibCompressor:format is
%G_ZLIB_COMPRESSOR_FORMAT_GZIP, the compressor will write the file name
and modification time from the file info to the GZIP header.</doc>
        <type name="FileInfo"/>
      </property>
      <property name="format" writable="1" construct-only="1" transfer-ownership="none">
        <type name="ZlibCompressorFormat"/>
      </property>
      <property name="level" writable="1" construct-only="1" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
    </class>
    <record name="ZlibCompressorClass" c:type="GZlibCompressorClass" glib:is-gtype-struct-for="ZlibCompressor">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <enumeration name="ZlibCompressorFormat" version="2.24" glib:type-name="GZlibCompressorFormat" glib:get-type="g_zlib_compressor_format_get_type" c:type="GZlibCompressorFormat">
      <doc xml:space="preserve">Used to select the type of data format to use for #GZlibDecompressor
and #GZlibCompressor.</doc>
      <member name="zlib" value="0" c:identifier="G_ZLIB_COMPRESSOR_FORMAT_ZLIB" glib:nick="zlib">
        <doc xml:space="preserve">deflate compression with zlib header</doc>
      </member>
      <member name="gzip" value="1" c:identifier="G_ZLIB_COMPRESSOR_FORMAT_GZIP" glib:nick="gzip">
        <doc xml:space="preserve">gzip file format</doc>
      </member>
      <member name="raw" value="2" c:identifier="G_ZLIB_COMPRESSOR_FORMAT_RAW" glib:nick="raw">
        <doc xml:space="preserve">deflate compression with no header</doc>
      </member>
    </enumeration>
    <class name="ZlibDecompressor" c:symbol-prefix="zlib_decompressor" c:type="GZlibDecompressor" parent="GObject.Object" glib:type-name="GZlibDecompressor" glib:get-type="g_zlib_decompressor_get_type" glib:type-struct="ZlibDecompressorClass">
      <doc xml:space="preserve">Zlib decompression</doc>
      <implements name="Converter"/>
      <constructor name="new" c:identifier="g_zlib_decompressor_new" version="2.24">
        <doc xml:space="preserve">Creates a new #GZlibDecompressor.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GZlibDecompressor</doc>
          <type name="ZlibDecompressor" c:type="GZlibDecompressor*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">The format to use for the compressed data</doc>
            <type name="ZlibCompressorFormat" c:type="GZlibCompressorFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_file_info" c:identifier="g_zlib_decompressor_get_file_info" version="2.26">
        <doc xml:space="preserve">Retrieves the #GFileInfo constructed from the GZIP header data
of compressed data processed by @compressor, or %NULL if @decompressor's
#GZlibDecompressor:format property is not %G_ZLIB_COMPRESSOR_FORMAT_GZIP,
or the header data was not fully processed yet, or it not present in the
data stream at all.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GFileInfo, or %NULL</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="decompressor" transfer-ownership="none">
            <doc xml:space="preserve">a #GZlibDecompressor</doc>
            <type name="ZlibDecompressor" c:type="GZlibDecompressor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="file-info" version="2.26" transfer-ownership="none">
        <doc xml:space="preserve">A #GFileInfo containing the information found in the GZIP header
of the data stream processed, or %NULL if the header was not yet
fully processed, is not present at all, or the compressor's
#GZlibDecompressor:format property is not %G_ZLIB_COMPRESSOR_FORMAT_GZIP.</doc>
        <type name="FileInfo"/>
      </property>
      <property name="format" writable="1" construct-only="1" transfer-ownership="none">
        <type name="ZlibCompressorFormat"/>
      </property>
    </class>
    <record name="ZlibDecompressorClass" c:type="GZlibDecompressorClass" glib:is-gtype-struct-for="ZlibDecompressor">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <function name="action_name_is_valid" c:identifier="g_action_name_is_valid" moved-to="Action.name_is_valid" version="2.38">
      <doc xml:space="preserve">Checks if @action_name is valid.

@action_name is valid if it consists only of alphanumeric characters,
plus '-' and '.'.  The empty string is not a valid action name.

It is an error to call this function with a non-utf8 @action_name.
@action_name must not be %NULL.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @action_name is valid</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="action_name" transfer-ownership="none">
          <doc xml:space="preserve">an potential action name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="action_parse_detailed_name" c:identifier="g_action_parse_detailed_name" moved-to="Action.parse_detailed_name" version="2.38" throws="1">
      <doc xml:space="preserve">Parses a detailed action name into its separate name and target
components.

Detailed action names can have three formats.

The first format is used to represent an action name with no target
value and consists of just an action name containing no whitespace
nor the characters ':', '(' or ')'.  For example: "app.action".

The second format is used to represent an action with a target value
that is a non-empty string consisting only of alphanumerics, plus '-'
and '.'.  In that case, the action name and target value are
separated by a double colon ("::").  For example:
"app.action::target".

The third format is used to represent an action with any type of
target value, including strings.  The target value follows the action
name, surrounded in parens.  For example: "app.action(42)".  The
target value is parsed using g_variant_parse().  If a tuple-typed
value is desired, it must be specified in the same way, resulting in
two sets of parens, for example: "app.action((1,2,3))".  A string
target can be specified this way as well: "app.action('target')".
For strings, this third format must be used if * target value is
empty or contains characters other than alphanumerics, '-' and '.'.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if successful, else %FALSE with @error set</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="detailed_name" transfer-ownership="none">
          <doc xml:space="preserve">a detailed action name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="action_name" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">the action name</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="target_value" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">the target value, or %NULL for no target</doc>
          <type name="GLib.Variant" c:type="GVariant**"/>
        </parameter>
      </parameters>
    </function>
    <function name="action_print_detailed_name" c:identifier="g_action_print_detailed_name" moved-to="Action.print_detailed_name" version="2.38">
      <doc xml:space="preserve">Formats a detailed action name from @action_name and @target_value.

It is an error to call this function with an invalid action name.

This function is the opposite of g_action_parse_detailed_name().
It will produce a string that can be parsed back to the @action_name
and @target_value by that function.

See that function for the types of strings that will be printed by
this function.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a detailed format string</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="action_name" transfer-ownership="none">
          <doc xml:space="preserve">a valid action name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="target_value" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a #GVariant target value, or %NULL</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
      </parameters>
    </function>
    <function name="app_info_create_from_commandline" c:identifier="g_app_info_create_from_commandline" moved-to="AppInfo.create_from_commandline" throws="1">
      <doc xml:space="preserve">Creates a new #GAppInfo from the given information.

Note that for @commandline, the quoting rules of the Exec key of the
[freedesktop.org Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec)
are applied. For example, if the @commandline contains
percent-encoded URIs, the percent-character must be doubled in order to prevent it from
being swallowed by Exec key unquoting. See the specification for exact quoting rules.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">new #GAppInfo for given command.</doc>
        <type name="AppInfo" c:type="GAppInfo*"/>
      </return-value>
      <parameters>
        <parameter name="commandline" transfer-ownership="none">
          <doc xml:space="preserve">the commandline to use</doc>
          <type name="filename" c:type="const char*"/>
        </parameter>
        <parameter name="application_name" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the application name, or %NULL to use @commandline</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags that can specify details of the created #GAppInfo</doc>
          <type name="AppInfoCreateFlags" c:type="GAppInfoCreateFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="app_info_get_all" c:identifier="g_app_info_get_all" moved-to="AppInfo.get_all">
      <doc xml:space="preserve">Gets a list of all of the applications currently registered
on this system.

For desktop files, this includes applications that have
`NoDisplay=true` set or are excluded from display by means
of `OnlyShowIn` or `NotShowIn`. See g_app_info_should_show().
The returned list does not include applications which have
the `Hidden` key set.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated #GList of references to #GAppInfos.</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="AppInfo"/>
        </type>
      </return-value>
    </function>
    <function name="app_info_get_all_for_type" c:identifier="g_app_info_get_all_for_type" moved-to="AppInfo.get_all_for_type">
      <doc xml:space="preserve">Gets a list of all #GAppInfos for a given content type,
including the recommended and fallback #GAppInfos. See
g_app_info_get_recommended_for_type() and
g_app_info_get_fallback_for_type().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">#GList of #GAppInfos
    for given @content_type or %NULL on error.</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="AppInfo"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="content_type" transfer-ownership="none">
          <doc xml:space="preserve">the content type to find a #GAppInfo for</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="app_info_get_default_for_type" c:identifier="g_app_info_get_default_for_type" moved-to="AppInfo.get_default_for_type">
      <doc xml:space="preserve">Gets the default #GAppInfo for a given content type.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">#GAppInfo for given @content_type or
    %NULL on error.</doc>
        <type name="AppInfo" c:type="GAppInfo*"/>
      </return-value>
      <parameters>
        <parameter name="content_type" transfer-ownership="none">
          <doc xml:space="preserve">the content type to find a #GAppInfo for</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="must_support_uris" transfer-ownership="none">
          <doc xml:space="preserve">if %TRUE, the #GAppInfo is expected to
    support URIs</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="app_info_get_default_for_uri_scheme" c:identifier="g_app_info_get_default_for_uri_scheme" moved-to="AppInfo.get_default_for_uri_scheme">
      <doc xml:space="preserve">Gets the default application for handling URIs with
the given URI scheme. A URI scheme is the initial part
of the URI, up to but not including the ':', e.g. "http",
"ftp" or "sip".</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">#GAppInfo for given @uri_scheme or %NULL on error.</doc>
        <type name="AppInfo" c:type="GAppInfo*"/>
      </return-value>
      <parameters>
        <parameter name="uri_scheme" transfer-ownership="none">
          <doc xml:space="preserve">a string containing a URI scheme.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="app_info_get_fallback_for_type" c:identifier="g_app_info_get_fallback_for_type" moved-to="AppInfo.get_fallback_for_type" version="2.28">
      <doc xml:space="preserve">Gets a list of fallback #GAppInfos for a given content type, i.e.
those applications which claim to support the given content type
by MIME type subclassing and not directly.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">#GList of #GAppInfos
    for given @content_type or %NULL on error.</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="AppInfo"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="content_type" transfer-ownership="none">
          <doc xml:space="preserve">the content type to find a #GAppInfo for</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="app_info_get_recommended_for_type" c:identifier="g_app_info_get_recommended_for_type" moved-to="AppInfo.get_recommended_for_type" version="2.28">
      <doc xml:space="preserve">Gets a list of recommended #GAppInfos for a given content type, i.e.
those applications which claim to support the given content type exactly,
and not by MIME type subclassing.
Note that the first application of the list is the last used one, i.e.
the last one for which g_app_info_set_as_last_used_for_type() has been
called.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">#GList of #GAppInfos
    for given @content_type or %NULL on error.</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="AppInfo"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="content_type" transfer-ownership="none">
          <doc xml:space="preserve">the content type to find a #GAppInfo for</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="app_info_launch_default_for_uri" c:identifier="g_app_info_launch_default_for_uri" moved-to="AppInfo.launch_default_for_uri" throws="1">
      <doc xml:space="preserve">Utility function that launches the default application
registered to handle the specified uri. Synchronous I/O
is done on the uri to detect the type of the file if
required.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:space="preserve">the uri to show</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">an optional #GAppLaunchContext</doc>
          <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
        </parameter>
      </parameters>
    </function>
    <function name="app_info_launch_default_for_uri_async" c:identifier="g_app_info_launch_default_for_uri_async" moved-to="AppInfo.launch_default_for_uri_async" version="2.50">
      <doc xml:space="preserve">Async version of g_app_info_launch_default_for_uri().

This version is useful if you are interested in receiving
error information in the case where the application is
sandboxed and the portal may present an application chooser
dialog to the user.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:space="preserve">the uri to show</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">an optional #GAppLaunchContext</doc>
          <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a #GCancellable</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
          <doc xml:space="preserve">a #GASyncReadyCallback to call when the request is done</doc>
          <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data to pass to @callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="app_info_launch_default_for_uri_finish" c:identifier="g_app_info_launch_default_for_uri_finish" moved-to="AppInfo.launch_default_for_uri_finish" version="2.50" throws="1">
      <doc xml:space="preserve">Finishes an asynchronous launch-default-for-uri operation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the launch was successful, %FALSE if @error is set</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="result" transfer-ownership="none">
          <doc xml:space="preserve">a #GAsyncResult</doc>
          <type name="AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
      </parameters>
    </function>
    <function name="app_info_reset_type_associations" c:identifier="g_app_info_reset_type_associations" moved-to="AppInfo.reset_type_associations" version="2.20">
      <doc xml:space="preserve">Removes all changes to the type associations done by
g_app_info_set_as_default_for_type(),
g_app_info_set_as_default_for_extension(),
g_app_info_add_supports_type() or
g_app_info_remove_supports_type().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="content_type" transfer-ownership="none">
          <doc xml:space="preserve">a content type</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="async_initable_newv_async" c:identifier="g_async_initable_newv_async" moved-to="AsyncInitable.newv_async" version="2.22" deprecated="1" deprecated-version="2.54">
      <doc xml:space="preserve">Helper function for constructing #GAsyncInitable object. This is
similar to g_object_newv() but also initializes the object asynchronously.

When the initialization is finished, @callback will be called. You can
then call g_async_initable_new_finish() to get the new object and check
for any errors.</doc>
      <doc-deprecated xml:space="preserve">Use g_object_new_with_properties() and
g_async_initable_init_async() instead. See #GParameter for more information.</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object_type" transfer-ownership="none">
          <doc xml:space="preserve">a #GType supporting #GAsyncInitable.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="n_parameters" transfer-ownership="none">
          <doc xml:space="preserve">the number of parameters in @parameters</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="parameters" transfer-ownership="none">
          <doc xml:space="preserve">the parameters to use to construct the object</doc>
          <type name="GObject.Parameter" c:type="GParameter*"/>
        </parameter>
        <parameter name="io_priority" transfer-ownership="none">
          <doc xml:space="preserve">the [I/O priority][io-priority] of the operation</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
          <doc xml:space="preserve">a #GAsyncReadyCallback to call when the initialization is
    finished</doc>
          <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the data to pass to callback function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_get" c:identifier="g_bus_get" version="2.26">
      <doc xml:space="preserve">Asynchronously connects to the message bus specified by @bus_type.

When the operation is finished, @callback will be invoked. You can
then call g_bus_get_finish() to get the result of the operation.

This is a asynchronous failable function. See g_bus_get_sync() for
the synchronous version.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bus_type" transfer-ownership="none">
          <doc xml:space="preserve">a #GBusType</doc>
          <type name="BusType" c:type="GBusType"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a #GCancellable or %NULL</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
          <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
          <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the data to pass to @callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_get_finish" c:identifier="g_bus_get_finish" version="2.26" throws="1">
      <doc xml:space="preserve">Finishes an operation started with g_bus_get().

The returned object is a singleton, that is, shared with other
callers of g_bus_get() and g_bus_get_sync() for @bus_type. In the
event that you need a private message bus connection, use
g_dbus_address_get_for_bus_sync() and
g_dbus_connection_new_for_address().

Note that the returned #GDBusConnection object will (usually) have
the #GDBusConnection:exit-on-close property set to %TRUE.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #GDBusConnection or %NULL if @error is set.
    Free with g_object_unref().</doc>
        <type name="DBusConnection" c:type="GDBusConnection*"/>
      </return-value>
      <parameters>
        <parameter name="res" transfer-ownership="none">
          <doc xml:space="preserve">a #GAsyncResult obtained from the #GAsyncReadyCallback passed
    to g_bus_get()</doc>
          <type name="AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_get_sync" c:identifier="g_bus_get_sync" version="2.26" throws="1">
      <doc xml:space="preserve">Synchronously connects to the message bus specified by @bus_type.
Note that the returned object may shared with other callers,
e.g. if two separate parts of a process calls this function with
the same @bus_type, they will share the same object.

This is a synchronous failable function. See g_bus_get() and
g_bus_get_finish() for the asynchronous version.

The returned object is a singleton, that is, shared with other
callers of g_bus_get() and g_bus_get_sync() for @bus_type. In the
event that you need a private message bus connection, use
g_dbus_address_get_for_bus_sync() and
g_dbus_connection_new_for_address().

Note that the returned #GDBusConnection object will (usually) have
the #GDBusConnection:exit-on-close property set to %TRUE.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #GDBusConnection or %NULL if @error is set.
    Free with g_object_unref().</doc>
        <type name="DBusConnection" c:type="GDBusConnection*"/>
      </return-value>
      <parameters>
        <parameter name="bus_type" transfer-ownership="none">
          <doc xml:space="preserve">a #GBusType</doc>
          <type name="BusType" c:type="GBusType"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a #GCancellable or %NULL</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_own_name" c:identifier="g_bus_own_name" shadowed-by="bus_own_name_with_closures" version="2.26" introspectable="0">
      <doc xml:space="preserve">Starts acquiring @name on the bus specified by @bus_type and calls
@name_acquired_handler and @name_lost_handler when the name is
acquired respectively lost. Callbacks will be invoked in the
[thread-default main context][g-main-context-push-thread-default]
of the thread you are calling this function from.

You are guaranteed that one of the @name_acquired_handler and @name_lost_handler
callbacks will be invoked after calling this function - there are three
possible cases:

- @name_lost_handler with a %NULL connection (if a connection to the bus
  can't be made).

- @bus_acquired_handler then @name_lost_handler (if the name can't be
  obtained)

- @bus_acquired_handler then @name_acquired_handler (if the name was
  obtained).

When you are done owning the name, just call g_bus_unown_name()
with the owner id this function returns.

If the name is acquired or lost (for example another application
could acquire the name if you allow replacement or the application
currently owning the name exits), the handlers are also invoked.
If the #GDBusConnection that is used for attempting to own the name
closes, then @name_lost_handler is invoked since it is no longer
possible for other processes to access the process.

You cannot use g_bus_own_name() several times for the same name (unless
interleaved with calls to g_bus_unown_name()) - only the first call
will work.

Another guarantee is that invocations of @name_acquired_handler
and @name_lost_handler are guaranteed to alternate; that
is, if @name_acquired_handler is invoked then you are
guaranteed that the next time one of the handlers is invoked, it
will be @name_lost_handler. The reverse is also true.

If you plan on exporting objects (using e.g.
g_dbus_connection_register_object()), note that it is generally too late
to export the objects in @name_acquired_handler. Instead, you can do this
in @bus_acquired_handler since you are guaranteed that this will run
before @name is requested from the bus.

This behavior makes it very simple to write applications that wants
to [own names][gdbus-owning-names] and export objects.
Simply register objects to be exported in @bus_acquired_handler and
unregister the objects (if any) in @name_lost_handler.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">an identifier (never 0) that an be used with
    g_bus_unown_name() to stop owning the name.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="bus_type" transfer-ownership="none">
          <doc xml:space="preserve">the type of bus to own a name on</doc>
          <type name="BusType" c:type="GBusType"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">the well-known name to own</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">a set of flags from the #GBusNameOwnerFlags enumeration</doc>
          <type name="BusNameOwnerFlags" c:type="GBusNameOwnerFlags"/>
        </parameter>
        <parameter name="bus_acquired_handler" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">handler to invoke when connected to the bus of type @bus_type or %NULL</doc>
          <type name="BusAcquiredCallback" c:type="GBusAcquiredCallback"/>
        </parameter>
        <parameter name="name_acquired_handler" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">handler to invoke when @name is acquired or %NULL</doc>
          <type name="BusNameAcquiredCallback" c:type="GBusNameAcquiredCallback"/>
        </parameter>
        <parameter name="name_lost_handler" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="6" destroy="7">
          <doc xml:space="preserve">handler to invoke when @name is lost or %NULL</doc>
          <type name="BusNameLostCallback" c:type="GBusNameLostCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data to pass to handlers</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="user_data_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
          <doc xml:space="preserve">function for freeing @user_data or %NULL</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_own_name_on_connection" c:identifier="g_bus_own_name_on_connection" shadowed-by="bus_own_name_on_connection_with_closures" version="2.26" introspectable="0">
      <doc xml:space="preserve">Like g_bus_own_name() but takes a #GDBusConnection instead of a
#GBusType.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">an identifier (never 0) that an be used with
    g_bus_unown_name() to stop owning the name</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">a #GDBusConnection</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">the well-known name to own</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">a set of flags from the #GBusNameOwnerFlags enumeration</doc>
          <type name="BusNameOwnerFlags" c:type="GBusNameOwnerFlags"/>
        </parameter>
        <parameter name="name_acquired_handler" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">handler to invoke when @name is acquired or %NULL</doc>
          <type name="BusNameAcquiredCallback" c:type="GBusNameAcquiredCallback"/>
        </parameter>
        <parameter name="name_lost_handler" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="5" destroy="6">
          <doc xml:space="preserve">handler to invoke when @name is lost or %NULL</doc>
          <type name="BusNameLostCallback" c:type="GBusNameLostCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data to pass to handlers</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="user_data_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
          <doc xml:space="preserve">function for freeing @user_data or %NULL</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_own_name_on_connection_with_closures" c:identifier="g_bus_own_name_on_connection_with_closures" shadows="bus_own_name_on_connection" version="2.26">
      <doc xml:space="preserve">Version of g_bus_own_name_on_connection() using closures instead of
callbacks for easier binding in other languages.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">an identifier (never 0) that an be used with
    g_bus_unown_name() to stop owning the name.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">a #GDBusConnection</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">the well-known name to own</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">a set of flags from the #GBusNameOwnerFlags enumeration</doc>
          <type name="BusNameOwnerFlags" c:type="GBusNameOwnerFlags"/>
        </parameter>
        <parameter name="name_acquired_closure" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">#GClosure to invoke when @name is
    acquired or %NULL</doc>
          <type name="GObject.Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="name_lost_closure" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">#GClosure to invoke when @name is lost
    or %NULL</doc>
          <type name="GObject.Closure" c:type="GClosure*"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_own_name_with_closures" c:identifier="g_bus_own_name_with_closures" shadows="bus_own_name" version="2.26">
      <doc xml:space="preserve">Version of g_bus_own_name() using closures instead of callbacks for
easier binding in other languages.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">an identifier (never 0) that an be used with
    g_bus_unown_name() to stop owning the name.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="bus_type" transfer-ownership="none">
          <doc xml:space="preserve">the type of bus to own a name on</doc>
          <type name="BusType" c:type="GBusType"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">the well-known name to own</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">a set of flags from the #GBusNameOwnerFlags enumeration</doc>
          <type name="BusNameOwnerFlags" c:type="GBusNameOwnerFlags"/>
        </parameter>
        <parameter name="bus_acquired_closure" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">#GClosure to invoke when connected to
    the bus of type @bus_type or %NULL</doc>
          <type name="GObject.Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="name_acquired_closure" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">#GClosure to invoke when @name is
    acquired or %NULL</doc>
          <type name="GObject.Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="name_lost_closure" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">#GClosure to invoke when @name is lost or
    %NULL</doc>
          <type name="GObject.Closure" c:type="GClosure*"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_unown_name" c:identifier="g_bus_unown_name" version="2.26">
      <doc xml:space="preserve">Stops owning a name.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="owner_id" transfer-ownership="none">
          <doc xml:space="preserve">an identifier obtained from g_bus_own_name()</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_unwatch_name" c:identifier="g_bus_unwatch_name" version="2.26">
      <doc xml:space="preserve">Stops watching a name.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="watcher_id" transfer-ownership="none">
          <doc xml:space="preserve">An identifier obtained from g_bus_watch_name()</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_watch_name" c:identifier="g_bus_watch_name" shadowed-by="bus_watch_name_with_closures" version="2.26" introspectable="0">
      <doc xml:space="preserve">Starts watching @name on the bus specified by @bus_type and calls
@name_appeared_handler and @name_vanished_handler when the name is
known to have a owner respectively known to lose its
owner. Callbacks will be invoked in the
[thread-default main context][g-main-context-push-thread-default]
of the thread you are calling this function from.

You are guaranteed that one of the handlers will be invoked after
calling this function. When you are done watching the name, just
call g_bus_unwatch_name() with the watcher id this function
returns.

If the name vanishes or appears (for example the application owning
the name could restart), the handlers are also invoked. If the
#GDBusConnection that is used for watching the name disconnects, then
@name_vanished_handler is invoked since it is no longer
possible to access the name.

Another guarantee is that invocations of @name_appeared_handler
and @name_vanished_handler are guaranteed to alternate; that
is, if @name_appeared_handler is invoked then you are
guaranteed that the next time one of the handlers is invoked, it
will be @name_vanished_handler. The reverse is also true.

This behavior makes it very simple to write applications that want
to take action when a certain [name exists][gdbus-watching-names].
Basically, the application should create object proxies in
@name_appeared_handler and destroy them again (if any) in
@name_vanished_handler.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">An identifier (never 0) that an be used with
g_bus_unwatch_name() to stop watching the name.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="bus_type" transfer-ownership="none">
          <doc xml:space="preserve">The type of bus to watch a name on.</doc>
          <type name="BusType" c:type="GBusType"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">The name (well-known or unique) to watch.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">Flags from the #GBusNameWatcherFlags enumeration.</doc>
          <type name="BusNameWatcherFlags" c:type="GBusNameWatcherFlags"/>
        </parameter>
        <parameter name="name_appeared_handler" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Handler to invoke when @name is known to exist or %NULL.</doc>
          <type name="BusNameAppearedCallback" c:type="GBusNameAppearedCallback"/>
        </parameter>
        <parameter name="name_vanished_handler" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="5" destroy="6">
          <doc xml:space="preserve">Handler to invoke when @name is known to not exist or %NULL.</doc>
          <type name="BusNameVanishedCallback" c:type="GBusNameVanishedCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">User data to pass to handlers.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="user_data_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
          <doc xml:space="preserve">Function for freeing @user_data or %NULL.</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_watch_name_on_connection" c:identifier="g_bus_watch_name_on_connection" shadowed-by="bus_watch_name_on_connection_with_closures" version="2.26" introspectable="0">
      <doc xml:space="preserve">Like g_bus_watch_name() but takes a #GDBusConnection instead of a
#GBusType.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">An identifier (never 0) that an be used with
g_bus_unwatch_name() to stop watching the name.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusConnection.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">The name (well-known or unique) to watch.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">Flags from the #GBusNameWatcherFlags enumeration.</doc>
          <type name="BusNameWatcherFlags" c:type="GBusNameWatcherFlags"/>
        </parameter>
        <parameter name="name_appeared_handler" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Handler to invoke when @name is known to exist or %NULL.</doc>
          <type name="BusNameAppearedCallback" c:type="GBusNameAppearedCallback"/>
        </parameter>
        <parameter name="name_vanished_handler" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="5" destroy="6">
          <doc xml:space="preserve">Handler to invoke when @name is known to not exist or %NULL.</doc>
          <type name="BusNameVanishedCallback" c:type="GBusNameVanishedCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">User data to pass to handlers.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="user_data_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
          <doc xml:space="preserve">Function for freeing @user_data or %NULL.</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_watch_name_on_connection_with_closures" c:identifier="g_bus_watch_name_on_connection_with_closures" shadows="bus_watch_name_on_connection" version="2.26">
      <doc xml:space="preserve">Version of g_bus_watch_name_on_connection() using closures instead of callbacks for
easier binding in other languages.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">An identifier (never 0) that an be used with
g_bus_unwatch_name() to stop watching the name.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">A #GDBusConnection.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">The name (well-known or unique) to watch.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">Flags from the #GBusNameWatcherFlags enumeration.</doc>
          <type name="BusNameWatcherFlags" c:type="GBusNameWatcherFlags"/>
        </parameter>
        <parameter name="name_appeared_closure" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">#GClosure to invoke when @name is known
to exist or %NULL.</doc>
          <type name="GObject.Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="name_vanished_closure" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">#GClosure to invoke when @name is known
to not exist or %NULL.</doc>
          <type name="GObject.Closure" c:type="GClosure*"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_watch_name_with_closures" c:identifier="g_bus_watch_name_with_closures" shadows="bus_watch_name" version="2.26">
      <doc xml:space="preserve">Version of g_bus_watch_name() using closures instead of callbacks for
easier binding in other languages.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">An identifier (never 0) that an be used with
g_bus_unwatch_name() to stop watching the name.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="bus_type" transfer-ownership="none">
          <doc xml:space="preserve">The type of bus to watch a name on.</doc>
          <type name="BusType" c:type="GBusType"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">The name (well-known or unique) to watch.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">Flags from the #GBusNameWatcherFlags enumeration.</doc>
          <type name="BusNameWatcherFlags" c:type="GBusNameWatcherFlags"/>
        </parameter>
        <parameter name="name_appeared_closure" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">#GClosure to invoke when @name is known
to exist or %NULL.</doc>
          <type name="GObject.Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="name_vanished_closure" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">#GClosure to invoke when @name is known
to not exist or %NULL.</doc>
          <type name="GObject.Closure" c:type="GClosure*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_type_can_be_executable" c:identifier="g_content_type_can_be_executable">
      <doc xml:space="preserve">Checks if a content type can be executable. Note that for instance
things like text files can be executables (i.e. scripts and batch files).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the file type corresponds to a type that
    can be executable, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a content type string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_type_equals" c:identifier="g_content_type_equals">
      <doc xml:space="preserve">Compares two content types for equality.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the two strings are identical or equivalent,
    %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type1" transfer-ownership="none">
          <doc xml:space="preserve">a content type string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="type2" transfer-ownership="none">
          <doc xml:space="preserve">a content type string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_type_from_mime_type" c:identifier="g_content_type_from_mime_type" version="2.18">
      <doc xml:space="preserve">Tries to find a content type based on the mime type name.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">Newly allocated string with content type or
    %NULL. Free with g_free()</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="mime_type" transfer-ownership="none">
          <doc xml:space="preserve">a mime type string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_type_get_description" c:identifier="g_content_type_get_description">
      <doc xml:space="preserve">Gets the human readable description of the content type.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a short description of the content type @type. Free the
    returned string with g_free()</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a content type string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_type_get_generic_icon_name" c:identifier="g_content_type_get_generic_icon_name" version="2.34">
      <doc xml:space="preserve">Gets the generic icon name for a content type.

See the
[shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
specification for more on the generic icon name.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">the registered generic icon name for the given @type,
    or %NULL if unknown. Free with g_free()</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a content type string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_type_get_icon" c:identifier="g_content_type_get_icon">
      <doc xml:space="preserve">Gets the icon for a content type.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">#GIcon corresponding to the content type. Free the returned
    object with g_object_unref()</doc>
        <type name="Icon" c:type="GIcon*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a content type string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_type_get_mime_type" c:identifier="g_content_type_get_mime_type">
      <doc xml:space="preserve">Gets the mime type for the content type, if one is registered.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">the registered mime type for the
    given @type, or %NULL if unknown; free with g_free().</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a content type string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_type_get_symbolic_icon" c:identifier="g_content_type_get_symbolic_icon" version="2.34">
      <doc xml:space="preserve">Gets the symbolic icon for a content type.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">symbolic #GIcon corresponding to the content type.
    Free the returned object with g_object_unref()</doc>
        <type name="Icon" c:type="GIcon*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a content type string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_type_guess" c:identifier="g_content_type_guess">
      <doc xml:space="preserve">Guesses the content type based on example data. If the function is
uncertain, @result_uncertain will be set to %TRUE. Either @filename
or @data may be %NULL, in which case the guess will be based solely
on the other argument.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a string indicating a guessed content type for the
    given data. Free with g_free()</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a string, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a stream of data, or %NULL</doc>
          <array length="2" zero-terminated="0" c:type="const guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="data_size" transfer-ownership="none">
          <doc xml:space="preserve">the size of @data</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="result_uncertain" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for the certainty
    of the result, or %NULL</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_type_guess_for_tree" c:identifier="g_content_type_guess_for_tree" version="2.18">
      <doc xml:space="preserve">Tries to guess the type of the tree with root @root, by
looking at the files it contains. The result is an array
of content types, with the best guess coming first.

The types returned all have the form x-content/foo, e.g.
x-content/audio-cdda (for audio CDs) or x-content/image-dcf
(for a camera memory card). See the
[shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
specification for more on x-content types.

This function is useful in the implementation of
g_mount_guess_content_type().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">an %NULL-terminated
    array of zero or more content types. Free with g_strfreev()</doc>
        <array c:type="gchar**">
          <type name="utf8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="root" transfer-ownership="none">
          <doc xml:space="preserve">the root of the tree to guess a type for</doc>
          <type name="File" c:type="GFile*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_type_is_a" c:identifier="g_content_type_is_a">
      <doc xml:space="preserve">Determines if @type is a subset of @supertype.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @type is a kind of @supertype,
    %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a content type string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="supertype" transfer-ownership="none">
          <doc xml:space="preserve">a content type string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_type_is_mime_type" c:identifier="g_content_type_is_mime_type" version="2.52">
      <doc xml:space="preserve">Determines if @type is a subset of @mime_type.
Convenience wrapper around g_content_type_is_a().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @type is a kind of @mime_type,
    %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a content type string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="mime_type" transfer-ownership="none">
          <doc xml:space="preserve">a mime type string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_type_is_unknown" c:identifier="g_content_type_is_unknown">
      <doc xml:space="preserve">Checks if the content type is the generic "unknown" type.
On UNIX this is the "application/octet-stream" mimetype,
while on win32 it is "*" and on OSX it is a dynamic type
or octet-stream.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the type is the unknown type.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a content type string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_types_get_registered" c:identifier="g_content_types_get_registered">
      <doc xml:space="preserve">Gets a list of strings containing all the registered content types
known to the system. The list and its data should be freed using
g_list_free_full (list, g_free).</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">list of the registered
    content types</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="utf8"/>
        </type>
      </return-value>
    </function>
    <function name="dbus_address_escape_value" c:identifier="g_dbus_address_escape_value" version="2.36">
      <doc xml:space="preserve">Escape @string so it can appear in a D-Bus address as the value
part of a key-value pair.

For instance, if @string is `/run/bus-for-:0`,
this function would return `/run/bus-for-%3A0`,
which could be used in a D-Bus address like
`unix:nonce-tcp:host=127.0.0.1,port=42,noncefile=/run/bus-for-%3A0`.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a copy of @string with all
    non-optionally-escaped bytes escaped</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">an unescaped string to be included in a D-Bus address
    as the value in a key-value pair</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_address_get_for_bus_sync" c:identifier="g_dbus_address_get_for_bus_sync" version="2.26" throws="1">
      <doc xml:space="preserve">Synchronously looks up the D-Bus address for the well-known message
bus instance specified by @bus_type. This may involve using various
platform specific mechanisms.

The returned address will be in the
[D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a valid D-Bus address string for @bus_type or %NULL if
    @error is set</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="bus_type" transfer-ownership="none">
          <doc xml:space="preserve">a #GBusType</doc>
          <type name="BusType" c:type="GBusType"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a #GCancellable or %NULL</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_address_get_stream" c:identifier="g_dbus_address_get_stream" version="2.26">
      <doc xml:space="preserve">Asynchronously connects to an endpoint specified by @address and
sets up the connection so it is in a state to run the client-side
of the D-Bus authentication conversation. @address must be in the
[D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).

When the operation is finished, @callback will be invoked. You can
then call g_dbus_address_get_stream_finish() to get the result of
the operation.

This is an asynchronous failable function. See
g_dbus_address_get_stream_sync() for the synchronous version.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="address" transfer-ownership="none">
          <doc xml:space="preserve">A valid D-Bus address.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">A #GCancellable or %NULL.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
          <doc xml:space="preserve">A #GAsyncReadyCallback to call when the request is satisfied.</doc>
          <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Data to pass to @callback.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_address_get_stream_finish" c:identifier="g_dbus_address_get_stream_finish" version="2.26" throws="1">
      <doc xml:space="preserve">Finishes an operation started with g_dbus_address_get_stream().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A #GIOStream or %NULL if @error is set.</doc>
        <type name="IOStream" c:type="GIOStream*"/>
      </return-value>
      <parameters>
        <parameter name="res" transfer-ownership="none">
          <doc xml:space="preserve">A #GAsyncResult obtained from the GAsyncReadyCallback passed to g_dbus_address_get_stream().</doc>
          <type name="AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
        <parameter name="out_guid" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">%NULL or return location to store the GUID extracted from @address, if any.</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_address_get_stream_sync" c:identifier="g_dbus_address_get_stream_sync" version="2.26" throws="1">
      <doc xml:space="preserve">Synchronously connects to an endpoint specified by @address and
sets up the connection so it is in a state to run the client-side
of the D-Bus authentication conversation. @address must be in the
[D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).

This is a synchronous failable function. See
g_dbus_address_get_stream() for the asynchronous version.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A #GIOStream or %NULL if @error is set.</doc>
        <type name="IOStream" c:type="GIOStream*"/>
      </return-value>
      <parameters>
        <parameter name="address" transfer-ownership="none">
          <doc xml:space="preserve">A valid D-Bus address.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="out_guid" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">%NULL or return location to store the GUID extracted from @address, if any.</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">A #GCancellable or %NULL.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_annotation_info_lookup" c:identifier="g_dbus_annotation_info_lookup" moved-to="DBusAnnotationInfo.lookup" version="2.26">
      <doc xml:space="preserve">Looks up the value of an annotation.

The cost of this function is O(n) in number of annotations.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The value or %NULL if not found. Do not free, it is owned by @annotations.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="annotations" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">A %NULL-terminated array of annotations or %NULL.</doc>
          <array c:type="GDBusAnnotationInfo**">
            <type name="DBusAnnotationInfo" c:type="GDBusAnnotationInfo*"/>
          </array>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">The name of the annotation to look up.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_error_encode_gerror" c:identifier="g_dbus_error_encode_gerror" moved-to="DBusError.encode_gerror" version="2.26">
      <doc xml:space="preserve">Creates a D-Bus error name to use for @error. If @error matches
a registered error (cf. g_dbus_error_register_error()), the corresponding
D-Bus error name will be returned.

Otherwise the a name of the form
`org.gtk.GDBus.UnmappedGError.Quark._ESCAPED_QUARK_NAME.Code_ERROR_CODE`
will be used. This allows other GDBus applications to map the error
on the wire back to a #GError using g_dbus_error_new_for_dbus_error().

This function is typically only used in object mappings to put a
#GError on the wire. Regular applications should not use it.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A D-Bus error name (never %NULL). Free with g_free().</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">A #GError.</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_error_get_remote_error" c:identifier="g_dbus_error_get_remote_error" moved-to="DBusError.get_remote_error" version="2.26">
      <doc xml:space="preserve">Gets the D-Bus error name used for @error, if any.

This function is guaranteed to return a D-Bus error name for all
#GErrors returned from functions handling remote method calls
(e.g. g_dbus_connection_call_finish()) unless
g_dbus_error_strip_remote_error() has been used on @error.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">an allocated string or %NULL if the D-Bus error name
    could not be found. Free with g_free().</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">a #GError</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_error_is_remote_error" c:identifier="g_dbus_error_is_remote_error" moved-to="DBusError.is_remote_error" version="2.26">
      <doc xml:space="preserve">Checks if @error represents an error received via D-Bus from a remote peer. If so,
use g_dbus_error_get_remote_error() to get the name of the error.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @error represents an error from a remote peer,
%FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">A #GError.</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_error_new_for_dbus_error" c:identifier="g_dbus_error_new_for_dbus_error" moved-to="DBusError.new_for_dbus_error" version="2.26">
      <doc xml:space="preserve">Creates a #GError based on the contents of @dbus_error_name and
@dbus_error_message.

Errors registered with g_dbus_error_register_error() will be looked
up using @dbus_error_name and if a match is found, the error domain
and code is used. Applications can use g_dbus_error_get_remote_error()
to recover @dbus_error_name.

If a match against a registered error is not found and the D-Bus
error name is in a form as returned by g_dbus_error_encode_gerror()
the error domain and code encoded in the name is used to
create the #GError. Also, @dbus_error_name is added to the error message
such that it can be recovered with g_dbus_error_get_remote_error().

Otherwise, a #GError with the error code %G_IO_ERROR_DBUS_ERROR
in the #G_IO_ERROR error domain is returned. Also, @dbus_error_name is
added to the error message such that it can be recovered with
g_dbus_error_get_remote_error().

In all three cases, @dbus_error_name can always be recovered from the
returned #GError using the g_dbus_error_get_remote_error() function
(unless g_dbus_error_strip_remote_error() hasn't been used on the returned error).

This function is typically only used in object mappings to prepare
#GError instances for applications. Regular applications should not use
it.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">An allocated #GError. Free with g_error_free().</doc>
        <type name="GLib.Error" c:type="GError*"/>
      </return-value>
      <parameters>
        <parameter name="dbus_error_name" transfer-ownership="none">
          <doc xml:space="preserve">D-Bus error name.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="dbus_error_message" transfer-ownership="none">
          <doc xml:space="preserve">D-Bus error message.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_error_quark" c:identifier="g_dbus_error_quark" moved-to="DBusError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="dbus_error_register_error" c:identifier="g_dbus_error_register_error" moved-to="DBusError.register_error" version="2.26">
      <doc xml:space="preserve">Creates an association to map between @dbus_error_name and
#GErrors specified by @error_domain and @error_code.

This is typically done in the routine that returns the #GQuark for
an error domain.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the association was created, %FALSE if it already
exists.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="error_domain" transfer-ownership="none">
          <doc xml:space="preserve">A #GQuark for a error domain.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="error_code" transfer-ownership="none">
          <doc xml:space="preserve">An error code.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="dbus_error_name" transfer-ownership="none">
          <doc xml:space="preserve">A D-Bus error name.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_error_register_error_domain" c:identifier="g_dbus_error_register_error_domain" moved-to="DBusError.register_error_domain" version="2.26">
      <doc xml:space="preserve">Helper function for associating a #GError error domain with D-Bus error names.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="error_domain_quark_name" transfer-ownership="none">
          <doc xml:space="preserve">The error domain name.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="quark_volatile" transfer-ownership="none">
          <doc xml:space="preserve">A pointer where to store the #GQuark.</doc>
          <type name="gsize" c:type="volatile gsize*"/>
        </parameter>
        <parameter name="entries" transfer-ownership="none">
          <doc xml:space="preserve">A pointer to @num_entries #GDBusErrorEntry struct items.</doc>
          <array length="3" zero-terminated="0" c:type="const GDBusErrorEntry*">
            <type name="DBusErrorEntry" c:type="GDBusErrorEntry"/>
          </array>
        </parameter>
        <parameter name="num_entries" transfer-ownership="none">
          <doc xml:space="preserve">Number of items to register.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_error_strip_remote_error" c:identifier="g_dbus_error_strip_remote_error" moved-to="DBusError.strip_remote_error" version="2.26">
      <doc xml:space="preserve">Looks for extra information in the error message used to recover
the D-Bus error name and strips it if found. If stripped, the
message field in @error will correspond exactly to what was
received on the wire.

This is typically used when presenting errors to the end user.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if information was stripped, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">A #GError.</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_error_unregister_error" c:identifier="g_dbus_error_unregister_error" moved-to="DBusError.unregister_error" version="2.26">
      <doc xml:space="preserve">Destroys an association previously set up with g_dbus_error_register_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the association was destroyed, %FALSE if it wasn't found.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="error_domain" transfer-ownership="none">
          <doc xml:space="preserve">A #GQuark for a error domain.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="error_code" transfer-ownership="none">
          <doc xml:space="preserve">An error code.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="dbus_error_name" transfer-ownership="none">
          <doc xml:space="preserve">A D-Bus error name.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_generate_guid" c:identifier="g_dbus_generate_guid" version="2.26">
      <doc xml:space="preserve">Generate a D-Bus GUID that can be used with
e.g. g_dbus_connection_new().

See the D-Bus specification regarding what strings are valid D-Bus
GUID (for example, D-Bus GUIDs are not RFC-4122 compliant).</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A valid D-Bus GUID. Free with g_free().</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
    </function>
    <function name="dbus_gvalue_to_gvariant" c:identifier="g_dbus_gvalue_to_gvariant" version="2.30">
      <doc xml:space="preserve">Converts a #GValue to a #GVariant of the type indicated by the @type
parameter.

The conversion is using the following rules:

- #G_TYPE_STRING: 's', 'o', 'g' or 'ay'
- #G_TYPE_STRV: 'as', 'ao' or 'aay'
- #G_TYPE_BOOLEAN: 'b'
- #G_TYPE_UCHAR: 'y'
- #G_TYPE_INT: 'i', 'n'
- #G_TYPE_UINT: 'u', 'q'
- #G_TYPE_INT64 'x'
- #G_TYPE_UINT64: 't'
- #G_TYPE_DOUBLE: 'd'
- #G_TYPE_VARIANT: Any #GVariantType

This can fail if e.g. @gvalue is of type #G_TYPE_STRING and @type
is ['i'][G-VARIANT-TYPE-INT32:CAPS]. It will also fail for any #GType
(including e.g. #G_TYPE_OBJECT and #G_TYPE_BOXED derived-types) not
in the table above.

Note that if @gvalue is of type #G_TYPE_VARIANT and its value is
%NULL, the empty #GVariant instance (never %NULL) for @type is
returned (e.g. 0 for scalar types, the empty string for string types,
'/' for object path types, the empty array for any array type and so on).

See the g_dbus_gvariant_to_gvalue() function for how to convert a
#GVariant to a #GValue.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A #GVariant (never floating) of #GVariantType @type holding
    the data from @gvalue or %NULL in case of failure. Free with
    g_variant_unref().</doc>
        <type name="GLib.Variant" c:type="GVariant*"/>
      </return-value>
      <parameters>
        <parameter name="gvalue" transfer-ownership="none">
          <doc xml:space="preserve">A #GValue to convert to a #GVariant</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">A #GVariantType</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_gvariant_to_gvalue" c:identifier="g_dbus_gvariant_to_gvalue" version="2.30">
      <doc xml:space="preserve">Converts a #GVariant to a #GValue. If @value is floating, it is consumed.

The rules specified in the g_dbus_gvalue_to_gvariant() function are
used - this function is essentially its reverse form. So, a #GVariant
containing any basic or string array type will be converted to a #GValue
containing a basic value or string array. Any other #GVariant (handle,
variant, tuple, dict entry) will be converted to a #GValue containing that
#GVariant.

The conversion never fails - a valid #GValue is always returned in
@out_gvalue.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">A #GVariant.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
        <parameter name="out_gvalue" direction="out" caller-allocates="1" transfer-ownership="none">
          <doc xml:space="preserve">Return location pointing to a zero-filled (uninitialized) #GValue.</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_is_address" c:identifier="g_dbus_is_address" version="2.26">
      <doc xml:space="preserve">Checks if @string is a
[D-Bus address](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).

This doesn't check if @string is actually supported by #GDBusServer
or #GDBusConnection - use g_dbus_is_supported_address() to do more
checks.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @string is a valid D-Bus address, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">A string.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_is_guid" c:identifier="g_dbus_is_guid" version="2.26">
      <doc xml:space="preserve">Checks if @string is a D-Bus GUID.

See the D-Bus specification regarding what strings are valid D-Bus
GUID (for example, D-Bus GUIDs are not RFC-4122 compliant).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @string is a guid, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">The string to check.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_is_interface_name" c:identifier="g_dbus_is_interface_name" version="2.26">
      <doc xml:space="preserve">Checks if @string is a valid D-Bus interface name.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if valid, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">The string to check.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_is_member_name" c:identifier="g_dbus_is_member_name" version="2.26">
      <doc xml:space="preserve">Checks if @string is a valid D-Bus member (e.g. signal or method) name.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if valid, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">The string to check.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_is_name" c:identifier="g_dbus_is_name" version="2.26">
      <doc xml:space="preserve">Checks if @string is a valid D-Bus bus name (either unique or well-known).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if valid, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">The string to check.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_is_supported_address" c:identifier="g_dbus_is_supported_address" version="2.26" throws="1">
      <doc xml:space="preserve">Like g_dbus_is_address() but also checks if the library supports the
transports in @string and that key/value pairs for each transport
are valid. See the specification of the
[D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @string is a valid D-Bus address that is
supported by this library, %FALSE if @error is set.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">A string.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_is_unique_name" c:identifier="g_dbus_is_unique_name" version="2.26">
      <doc xml:space="preserve">Checks if @string is a valid D-Bus unique bus name.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if valid, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">The string to check.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dtls_client_connection_new" c:identifier="g_dtls_client_connection_new" moved-to="DtlsClientConnection.new" version="2.48" throws="1">
      <doc xml:space="preserve">Creates a new #GDtlsClientConnection wrapping @base_socket which is
assumed to communicate with the server identified by @server_identity.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the new
  #GDtlsClientConnection, or %NULL on error</doc>
        <type name="DtlsClientConnection" c:type="GDatagramBased*"/>
      </return-value>
      <parameters>
        <parameter name="base_socket" transfer-ownership="none">
          <doc xml:space="preserve">the #GDatagramBased to wrap</doc>
          <type name="DatagramBased" c:type="GDatagramBased*"/>
        </parameter>
        <parameter name="server_identity" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the expected identity of the server</doc>
          <type name="SocketConnectable" c:type="GSocketConnectable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dtls_server_connection_new" c:identifier="g_dtls_server_connection_new" moved-to="DtlsServerConnection.new" version="2.48" throws="1">
      <doc xml:space="preserve">Creates a new #GDtlsServerConnection wrapping @base_socket.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the new
  #GDtlsServerConnection, or %NULL on error</doc>
        <type name="DtlsServerConnection" c:type="GDatagramBased*"/>
      </return-value>
      <parameters>
        <parameter name="base_socket" transfer-ownership="none">
          <doc xml:space="preserve">the #GDatagramBased to wrap</doc>
          <type name="DatagramBased" c:type="GDatagramBased*"/>
        </parameter>
        <parameter name="certificate" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the default server certificate, or %NULL</doc>
          <type name="TlsCertificate" c:type="GTlsCertificate*"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_new_for_commandline_arg" c:identifier="g_file_new_for_commandline_arg" moved-to="File.new_for_commandline_arg">
      <doc xml:space="preserve">Creates a #GFile with the given argument from the command line.
The value of @arg can be either a URI, an absolute path or a
relative path resolved relative to the current working directory.
This operation never fails, but the returned object might not
support any I/O operation if @arg points to a malformed path.

Note that on Windows, this function expects its argument to be in
UTF-8 -- not the system code page.  This means that you
should not use this function with string from argv as it is passed
to main().  g_win32_get_command_line() will return a UTF-8 version of
the commandline.  #GApplication also uses UTF-8 but
g_application_command_line_create_file_for_arg() may be more useful
for you there.  It is also always possible to use this function with
#GOptionContext arguments of type %G_OPTION_ARG_FILENAME.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new #GFile.
   Free the returned object with g_object_unref().</doc>
        <type name="File" c:type="GFile*"/>
      </return-value>
      <parameters>
        <parameter name="arg" transfer-ownership="none">
          <doc xml:space="preserve">a command line string</doc>
          <type name="filename" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_new_for_commandline_arg_and_cwd" c:identifier="g_file_new_for_commandline_arg_and_cwd" moved-to="File.new_for_commandline_arg_and_cwd" version="2.36">
      <doc xml:space="preserve">Creates a #GFile with the given argument from the command line.

This function is similar to g_file_new_for_commandline_arg() except
that it allows for passing the current working directory as an
argument instead of using the current working directory of the
process.

This is useful if the commandline argument was given in a context
other than the invocation of the current process.

See also g_application_command_line_create_file_for_arg().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new #GFile</doc>
        <type name="File" c:type="GFile*"/>
      </return-value>
      <parameters>
        <parameter name="arg" transfer-ownership="none">
          <doc xml:space="preserve">a command line string</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="cwd" transfer-ownership="none">
          <doc xml:space="preserve">the current working directory of the commandline</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_new_for_path" c:identifier="g_file_new_for_path" moved-to="File.new_for_path">
      <doc xml:space="preserve">Constructs a #GFile for a given path. This operation never
fails, but the returned object might not support any I/O
operation if @path is malformed.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new #GFile for the given @path.
  Free the returned object with g_object_unref().</doc>
        <type name="File" c:type="GFile*"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">a string containing a relative or absolute path.
    The string must be encoded in the glib filename encoding.</doc>
          <type name="filename" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_new_for_uri" c:identifier="g_file_new_for_uri" moved-to="File.new_for_uri">
      <doc xml:space="preserve">Constructs a #GFile for a given URI. This operation never
fails, but the returned object might not support any I/O
operation if @uri is malformed or if the uri type is
not supported.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new #GFile for the given @uri.
    Free the returned object with g_object_unref().</doc>
        <type name="File" c:type="GFile*"/>
      </return-value>
      <parameters>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:space="preserve">a UTF-8 string containing a URI</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_new_tmp" c:identifier="g_file_new_tmp" moved-to="File.new_tmp" version="2.32" throws="1">
      <doc xml:space="preserve">Opens a file in the preferred directory for temporary files (as
returned by g_get_tmp_dir()) and returns a #GFile and
#GFileIOStream pointing to it.

@tmpl should be a string in the GLib file name encoding
containing a sequence of six 'X' characters, and containing no
directory components. If it is %NULL, a default template is used.

Unlike the other #GFile constructors, this will return %NULL if
a temporary file could not be created.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new #GFile.
    Free the returned object with g_object_unref().</doc>
        <type name="File" c:type="GFile*"/>
      </return-value>
      <parameters>
        <parameter name="tmpl" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Template for the file
  name, as in g_file_open_tmp(), or %NULL for a default template</doc>
          <type name="filename" c:type="const char*"/>
        </parameter>
        <parameter name="iostream" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">on return, a #GFileIOStream for the created file</doc>
          <type name="FileIOStream" c:type="GFileIOStream**"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_parse_name" c:identifier="g_file_parse_name" moved-to="File.parse_name">
      <doc xml:space="preserve">Constructs a #GFile with the given @parse_name (i.e. something
given by g_file_get_parse_name()). This operation never fails,
but the returned object might not support any I/O operation if
the @parse_name cannot be parsed.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new #GFile.</doc>
        <type name="File" c:type="GFile*"/>
      </return-value>
      <parameters>
        <parameter name="parse_name" transfer-ownership="none">
          <doc xml:space="preserve">a file name or path to be parsed</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="icon_deserialize" c:identifier="g_icon_deserialize" moved-to="Icon.deserialize" version="2.38">
      <doc xml:space="preserve">Deserializes a #GIcon previously serialized using g_icon_serialize().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #GIcon, or %NULL when deserialization fails.</doc>
        <type name="Icon" c:type="GIcon*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a #GVariant created with g_icon_serialize()</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
      </parameters>
    </function>
    <function name="icon_hash" c:identifier="g_icon_hash" moved-to="Icon.hash">
      <doc xml:space="preserve">Gets a hash for an icon.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a #guint containing a hash for the @icon, suitable for
use in a #GHashTable or similar data structure.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="icon" transfer-ownership="none">
          <doc xml:space="preserve">#gconstpointer to an icon object.</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="icon_new_for_string" c:identifier="g_icon_new_for_string" moved-to="Icon.new_for_string" version="2.20" throws="1">
      <doc xml:space="preserve">Generate a #GIcon instance from @str. This function can fail if
@str is not valid - see g_icon_to_string() for discussion.

If your application or library provides one or more #GIcon
implementations you need to ensure that each #GType is registered
with the type system prior to calling g_icon_new_for_string().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">An object implementing the #GIcon
         interface or %NULL if @error is set.</doc>
        <type name="Icon" c:type="GIcon*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">A string obtained via g_icon_to_string().</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="initable_newv" c:identifier="g_initable_newv" moved-to="Initable.newv" version="2.22" deprecated="1" deprecated-version="2.54" throws="1">
      <doc xml:space="preserve">Helper function for constructing #GInitable object. This is
similar to g_object_newv() but also initializes the object
and returns %NULL, setting an error on failure.</doc>
      <doc-deprecated xml:space="preserve">Use g_object_new_with_properties() and
g_initable_init() instead. See #GParameter for more information.</doc-deprecated>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated
     #GObject, or %NULL on error</doc>
        <type name="GObject.Object" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="object_type" transfer-ownership="none">
          <doc xml:space="preserve">a #GType supporting #GInitable.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="n_parameters" transfer-ownership="none">
          <doc xml:space="preserve">the number of parameters in @parameters</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="parameters" transfer-ownership="none">
          <doc xml:space="preserve">the parameters to use to construct the object</doc>
          <array length="1" zero-terminated="0" c:type="GParameter*">
            <type name="GObject.Parameter" c:type="GParameter"/>
          </array>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="io_error_from_errno" c:identifier="g_io_error_from_errno">
      <doc xml:space="preserve">Converts errno.h error codes into GIO error codes. The fallback
value %G_IO_ERROR_FAILED is returned for error codes not currently
handled (but note that future GLib releases may return a more
specific value instead).

As %errno is global and may be modified by intermediate function
calls, you should save its value as soon as the call which sets it</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">#GIOErrorEnum value for the given errno.h error number.</doc>
        <type name="IOErrorEnum" c:type="GIOErrorEnum"/>
      </return-value>
      <parameters>
        <parameter name="err_no" transfer-ownership="none">
          <doc xml:space="preserve">Error number as defined in errno.h.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="io_error_quark" c:identifier="g_io_error_quark">
      <doc xml:space="preserve">Gets the GIO Error Quark.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a #GQuark.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="io_extension_point_implement" c:identifier="g_io_extension_point_implement" moved-to="IOExtensionPoint.implement">
      <doc xml:space="preserve">Registers @type as extension for the extension point with name
@extension_point_name.

If @type has already been registered as an extension for this
extension point, the existing #GIOExtension object is returned.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a #GIOExtension object for #GType</doc>
        <type name="IOExtension" c:type="GIOExtension*"/>
      </return-value>
      <parameters>
        <parameter name="extension_point_name" transfer-ownership="none">
          <doc xml:space="preserve">the name of the extension point</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">the #GType to register as extension</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="extension_name" transfer-ownership="none">
          <doc xml:space="preserve">the name for the extension</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="priority" transfer-ownership="none">
          <doc xml:space="preserve">the priority for the extension</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="io_extension_point_lookup" c:identifier="g_io_extension_point_lookup" moved-to="IOExtensionPoint.lookup">
      <doc xml:space="preserve">Looks up an existing extension point.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GIOExtensionPoint, or %NULL if there
   is no registered extension point with the given name.</doc>
        <type name="IOExtensionPoint" c:type="GIOExtensionPoint*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">the name of the extension point</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="io_extension_point_register" c:identifier="g_io_extension_point_register" moved-to="IOExtensionPoint.register">
      <doc xml:space="preserve">Registers an extension point.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the new #GIOExtensionPoint. This object is
   owned by GIO and should not be freed.</doc>
        <type name="IOExtensionPoint" c:type="GIOExtensionPoint*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">The name of the extension point</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="io_modules_load_all_in_directory" c:identifier="g_io_modules_load_all_in_directory">
      <doc xml:space="preserve">Loads all the modules in the specified directory.

If don't require all modules to be initialized (and thus registering
all gtypes) then you can use g_io_modules_scan_all_in_directory()
which allows delayed/lazy loading of modules.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a list of #GIOModules loaded
     from the directory,
     All the modules are loaded into memory, if you want to
     unload them (enabling on-demand loading) you must call
     g_type_module_unuse() on all the modules. Free the list
     with g_list_free().</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="IOModule"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="dirname" transfer-ownership="none">
          <doc xml:space="preserve">pathname for a directory containing modules
    to load.</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="io_modules_load_all_in_directory_with_scope" c:identifier="g_io_modules_load_all_in_directory_with_scope" version="2.30">
      <doc xml:space="preserve">Loads all the modules in the specified directory.

If don't require all modules to be initialized (and thus registering
all gtypes) then you can use g_io_modules_scan_all_in_directory()
which allows delayed/lazy loading of modules.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a list of #GIOModules loaded
     from the directory,
     All the modules are loaded into memory, if you want to
     unload them (enabling on-demand loading) you must call
     g_type_module_unuse() on all the modules. Free the list
     with g_list_free().</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="IOModule"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="dirname" transfer-ownership="none">
          <doc xml:space="preserve">pathname for a directory containing modules
    to load.</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="scope" transfer-ownership="none">
          <doc xml:space="preserve">a scope to use when scanning the modules.</doc>
          <type name="IOModuleScope" c:type="GIOModuleScope*"/>
        </parameter>
      </parameters>
    </function>
    <function name="io_modules_scan_all_in_directory" c:identifier="g_io_modules_scan_all_in_directory" version="2.24">
      <doc xml:space="preserve">Scans all the modules in the specified directory, ensuring that
any extension point implemented by a module is registered.

This may not actually load and initialize all the types in each
module, some modules may be lazily loaded and initialized when
an extension point it implementes is used with e.g.
g_io_extension_point_get_extensions() or
g_io_extension_point_get_extension_by_name().

If you need to guarantee that all types are loaded in all the modules,
use g_io_modules_load_all_in_directory().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dirname" transfer-ownership="none">
          <doc xml:space="preserve">pathname for a directory containing modules
    to scan.</doc>
          <type name="filename" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="io_modules_scan_all_in_directory_with_scope" c:identifier="g_io_modules_scan_all_in_directory_with_scope" version="2.30">
      <doc xml:space="preserve">Scans all the modules in the specified directory, ensuring that
any extension point implemented by a module is registered.

This may not actually load and initialize all the types in each
module, some modules may be lazily loaded and initialized when
an extension point it implementes is used with e.g.
g_io_extension_point_get_extensions() or
g_io_extension_point_get_extension_by_name().

If you need to guarantee that all types are loaded in all the modules,
use g_io_modules_load_all_in_directory().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dirname" transfer-ownership="none">
          <doc xml:space="preserve">pathname for a directory containing modules
    to scan.</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="scope" transfer-ownership="none">
          <doc xml:space="preserve">a scope to use when scanning the modules</doc>
          <type name="IOModuleScope" c:type="GIOModuleScope*"/>
        </parameter>
      </parameters>
    </function>
    <function name="io_scheduler_cancel_all_jobs" c:identifier="g_io_scheduler_cancel_all_jobs" deprecated="1">
      <doc xml:space="preserve">Cancels all cancellable I/O jobs.

A job is cancellable if a #GCancellable was passed into
g_io_scheduler_push_job().</doc>
      <doc-deprecated xml:space="preserve">You should never call this function, since you don't
know how other libraries in your program might be making use of
gioscheduler.</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="io_scheduler_push_job" c:identifier="g_io_scheduler_push_job" deprecated="1">
      <doc xml:space="preserve">Schedules the I/O job to run in another thread.

@notify will be called on @user_data after @job_func has returned,
regardless whether the job was cancelled or has run to completion.

If @cancellable is not %NULL, it can be used to cancel the I/O job
by calling g_cancellable_cancel() or by calling
g_io_scheduler_cancel_all_jobs().</doc>
      <doc-deprecated xml:space="preserve">use #GThreadPool or g_task_run_in_thread()</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="job_func" transfer-ownership="none" scope="notified" closure="1" destroy="2">
          <doc xml:space="preserve">a #GIOSchedulerJobFunc.</doc>
          <type name="IOSchedulerJobFunc" c:type="GIOSchedulerJobFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data to pass to @job_func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
          <doc xml:space="preserve">a #GDestroyNotify for @user_data, or %NULL</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
        <parameter name="io_priority" transfer-ownership="none">
          <doc xml:space="preserve">the [I/O priority][io-priority]
of the request.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="keyfile_settings_backend_new" c:identifier="g_keyfile_settings_backend_new">
      <doc xml:space="preserve">Creates a keyfile-backed #GSettingsBackend.

The filename of the keyfile to use is given by @filename.

All settings read to or written from the backend must fall under the
path given in @root_path (which must start and end with a slash and
not contain two consecutive slashes).  @root_path may be "/".

If @root_group is non-%NULL then it specifies the name of the keyfile
group used for keys that are written directly below @root_path.  For
example, if @root_path is "/apps/example/" and @root_group is
"toplevel", then settings the key "/apps/example/enabled" to a value
of %TRUE will cause the following to appear in the keyfile:

|[
  [toplevel]
  enabled=true
]|

If @root_group is %NULL then it is not permitted to store keys
directly below the @root_path.

For keys not stored directly below @root_path (ie: in a sub-path),
the name of the subpath (with the final slash stripped) is used as
the name of the keyfile group.  To continue the example, if
"/apps/example/profiles/default/font-size" were set to
12 then the following would appear in the keyfile:

|[
  [profiles/default]
  font-size=12
]|

The backend will refuse writes (and return writability as being
%FALSE) for keys outside of @root_path and, in the event that
@root_group is %NULL, also for keys directly under @root_path.
Writes will also be refused if the backend detects that it has the
inability to rewrite the keyfile (ie: the containing directory is not
writable).

There is no checking done for your key namespace clashing with the
syntax of the key file format.  For example, if you have '[' or ']'
characters in your path names or '=' in your key names you may be in
trouble.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a keyfile-backed #GSettingsBackend</doc>
        <type name="SettingsBackend" c:type="GSettingsBackend*"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">the filename of the keyfile</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="root_path" transfer-ownership="none">
          <doc xml:space="preserve">the path under which all settings keys appear</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="root_group" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the group name corresponding to
             @root_path, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="memory_settings_backend_new" c:identifier="g_memory_settings_backend_new" version="2.28">
      <doc xml:space="preserve">Creates a memory-backed #GSettingsBackend.

This backend allows changes to settings, but does not write them
to any backing storage, so the next time you run your application,
the memory backend will start out with the default values again.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created #GSettingsBackend</doc>
        <type name="SettingsBackend" c:type="GSettingsBackend*"/>
      </return-value>
    </function>
    <function name="network_monitor_get_default" c:identifier="g_network_monitor_get_default" moved-to="NetworkMonitor.get_default" version="2.32">
      <doc xml:space="preserve">Gets the default #GNetworkMonitor for the system.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a #GNetworkMonitor</doc>
        <type name="NetworkMonitor" c:type="GNetworkMonitor*"/>
      </return-value>
    </function>
    <function name="networking_init" c:identifier="g_networking_init" version="2.36">
      <doc xml:space="preserve">Initializes the platform networking libraries (eg, on Windows, this
calls WSAStartup()). GLib will call this itself if it is needed, so
you only need to call it if you directly call system networking
functions (without calling any GLib networking functions first).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="null_settings_backend_new" c:identifier="g_null_settings_backend_new" version="2.28">
      <doc xml:space="preserve">Creates a readonly #GSettingsBackend.

This backend does not allow changes to settings, so all settings
will always have their default values.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created #GSettingsBackend</doc>
        <type name="SettingsBackend" c:type="GSettingsBackend*"/>
      </return-value>
    </function>
    <function name="pollable_source_new" c:identifier="g_pollable_source_new" version="2.28">
      <doc xml:space="preserve">Utility method for #GPollableInputStream and #GPollableOutputStream
implementations. Creates a new #GSource that expects a callback of
type #GPollableSourceFunc. The new source does not actually do
anything on its own; use g_source_add_child_source() to add other
sources to it to cause it to trigger.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the new #GSource.</doc>
        <type name="GLib.Source" c:type="GSource*"/>
      </return-value>
      <parameters>
        <parameter name="pollable_stream" transfer-ownership="none">
          <doc xml:space="preserve">the stream associated with the new source</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pollable_source_new_full" c:identifier="g_pollable_source_new_full" version="2.34">
      <doc xml:space="preserve">Utility method for #GPollableInputStream and #GPollableOutputStream
implementations. Creates a new #GSource, as with
g_pollable_source_new(), but also attaching @child_source (with a
dummy callback), and @cancellable, if they are non-%NULL.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the new #GSource.</doc>
        <type name="GLib.Source" c:type="GSource*"/>
      </return-value>
      <parameters>
        <parameter name="pollable_stream" transfer-ownership="none">
          <doc xml:space="preserve">the stream associated with the
  new source</doc>
          <type name="GObject.Object" c:type="gpointer"/>
        </parameter>
        <parameter name="child_source" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">optional child source to attach</doc>
          <type name="GLib.Source" c:type="GSource*"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">optional #GCancellable to attach</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pollable_stream_read" c:identifier="g_pollable_stream_read" version="2.34" throws="1">
      <doc xml:space="preserve">Tries to read from @stream, as with g_input_stream_read() (if
@blocking is %TRUE) or g_pollable_input_stream_read_nonblocking()
(if @blocking is %FALSE). This can be used to more easily share
code between blocking and non-blocking implementations of a method.

If @blocking is %FALSE, then @stream must be a
#GPollableInputStream for which g_pollable_input_stream_can_poll()
returns %TRUE, or else the behavior is undefined. If @blocking is
%TRUE, then @stream does not need to be a #GPollableInputStream.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of bytes read, or -1 on error.</doc>
        <type name="gssize" c:type="gssize"/>
      </return-value>
      <parameters>
        <parameter name="stream" transfer-ownership="none">
          <doc xml:space="preserve">a #GInputStream</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">a buffer to
  read data into</doc>
          <array length="2" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes to read</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="blocking" transfer-ownership="none">
          <doc xml:space="preserve">whether to do blocking I/O</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pollable_stream_write" c:identifier="g_pollable_stream_write" version="2.34" throws="1">
      <doc xml:space="preserve">Tries to write to @stream, as with g_output_stream_write() (if
@blocking is %TRUE) or g_pollable_output_stream_write_nonblocking()
(if @blocking is %FALSE). This can be used to more easily share
code between blocking and non-blocking implementations of a method.

If @blocking is %FALSE, then @stream must be a
#GPollableOutputStream for which
g_pollable_output_stream_can_poll() returns %TRUE or else the
behavior is undefined. If @blocking is %TRUE, then @stream does not
need to be a #GPollableOutputStream.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of bytes written, or -1 on error.</doc>
        <type name="gssize" c:type="gssize"/>
      </return-value>
      <parameters>
        <parameter name="stream" transfer-ownership="none">
          <doc xml:space="preserve">a #GOutputStream.</doc>
          <type name="OutputStream" c:type="GOutputStream*"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">the buffer
  containing the data to write.</doc>
          <array length="2" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes to write</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="blocking" transfer-ownership="none">
          <doc xml:space="preserve">whether to do blocking I/O</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pollable_stream_write_all" c:identifier="g_pollable_stream_write_all" version="2.34" throws="1">
      <doc xml:space="preserve">Tries to write @count bytes to @stream, as with
g_output_stream_write_all(), but using g_pollable_stream_write()
rather than g_output_stream_write().

On a successful write of @count bytes, %TRUE is returned, and
@bytes_written is set to @count.

If there is an error during the operation (including
%G_IO_ERROR_WOULD_BLOCK in the non-blocking case), %FALSE is
returned and @error is set to indicate the error status,
@bytes_written is updated to contain the number of bytes written
into the stream before the error occurred.

As with g_pollable_stream_write(), if @blocking is %FALSE, then
@stream must be a #GPollableOutputStream for which
g_pollable_output_stream_can_poll() returns %TRUE or else the
behavior is undefined. If @blocking is %TRUE, then @stream does not
need to be a #GPollableOutputStream.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE if there was an error</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="stream" transfer-ownership="none">
          <doc xml:space="preserve">a #GOutputStream.</doc>
          <type name="OutputStream" c:type="GOutputStream*"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">the buffer
  containing the data to write.</doc>
          <array length="2" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes to write</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="blocking" transfer-ownership="none">
          <doc xml:space="preserve">whether to do blocking I/O</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">location to store the number of bytes that was
  written to the stream</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="proxy_get_default_for_protocol" c:identifier="g_proxy_get_default_for_protocol" moved-to="Proxy.get_default_for_protocol" version="2.26">
      <doc xml:space="preserve">Lookup "gio-proxy" extension point for a proxy implementation that supports
specified protocol.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">return a #GProxy or NULL if protocol
              is not supported.</doc>
        <type name="Proxy" c:type="GProxy*"/>
      </return-value>
      <parameters>
        <parameter name="protocol" transfer-ownership="none">
          <doc xml:space="preserve">the proxy protocol name (e.g. http, socks, etc)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="proxy_resolver_get_default" c:identifier="g_proxy_resolver_get_default" moved-to="ProxyResolver.get_default" version="2.26">
      <doc xml:space="preserve">Gets the default #GProxyResolver for the system.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the default #GProxyResolver.</doc>
        <type name="ProxyResolver" c:type="GProxyResolver*"/>
      </return-value>
    </function>
    <function name="resolver_error_quark" c:identifier="g_resolver_error_quark" moved-to="ResolverError.quark" version="2.22">
      <doc xml:space="preserve">Gets the #GResolver Error Quark.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a #GQuark.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="resource_error_quark" c:identifier="g_resource_error_quark" moved-to="ResourceError.quark" version="2.32">
      <doc xml:space="preserve">Gets the #GResource Error Quark.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a #GQuark</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="resource_load" c:identifier="g_resource_load" moved-to="Resource.load" version="2.32" throws="1">
      <doc xml:space="preserve">Loads a binary resource bundle and creates a #GResource representation of it, allowing
you to query it for data.

If you want to use this resource in the global resource namespace you need
to register it with g_resources_register().

If @filename is empty or the data in it is corrupt,
%G_RESOURCE_ERROR_INTERNAL will be returned. If @filename doesn&#x2019;t exist, or
there is an error in reading it, an error from g_mapped_file_new() will be
returned.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new #GResource, or %NULL on error</doc>
        <type name="Resource" c:type="GResource*"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">the path of a filename to load, in the GLib filename encoding</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="resources_enumerate_children" c:identifier="g_resources_enumerate_children" version="2.32" throws="1">
      <doc xml:space="preserve">Returns all the names of children at the specified @path in the set of
globally registered resources.
The return result is a %NULL terminated list of strings which should
be released with g_strfreev().

@lookup_flags controls the behaviour of the lookup.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">an array of constant strings</doc>
        <array c:type="char**">
          <type name="utf8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">A pathname inside the resource</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="lookup_flags" transfer-ownership="none">
          <doc xml:space="preserve">A #GResourceLookupFlags</doc>
          <type name="ResourceLookupFlags" c:type="GResourceLookupFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="resources_get_info" c:identifier="g_resources_get_info" version="2.32" throws="1">
      <doc xml:space="preserve">Looks for a file at the specified @path in the set of
globally registered resources and if found returns information about it.

@lookup_flags controls the behaviour of the lookup.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the file was found. %FALSE if there were errors</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">A pathname inside the resource</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="lookup_flags" transfer-ownership="none">
          <doc xml:space="preserve">A #GResourceLookupFlags</doc>
          <type name="ResourceLookupFlags" c:type="GResourceLookupFlags"/>
        </parameter>
        <parameter name="size" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">a location to place the length of the contents of the file,
   or %NULL if the length is not needed</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
        <parameter name="flags" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">a location to place the #GResourceFlags about the file,
   or %NULL if the flags are not needed</doc>
          <type name="guint32" c:type="guint32*"/>
        </parameter>
      </parameters>
    </function>
    <function name="resources_lookup_data" c:identifier="g_resources_lookup_data" version="2.32" throws="1">
      <doc xml:space="preserve">Looks for a file at the specified @path in the set of
globally registered resources and returns a #GBytes that
lets you directly access the data in memory.

The data is always followed by a zero byte, so you
can safely use the data as a C string. However, that byte
is not included in the size of the GBytes.

For uncompressed resource files this is a pointer directly into
the resource bundle, which is typically in some readonly data section
in the program binary. For compressed files we allocate memory on
the heap and automatically uncompress the data.

@lookup_flags controls the behaviour of the lookup.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">#GBytes or %NULL on error.
    Free the returned object with g_bytes_unref()</doc>
        <type name="GLib.Bytes" c:type="GBytes*"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">A pathname inside the resource</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="lookup_flags" transfer-ownership="none">
          <doc xml:space="preserve">A #GResourceLookupFlags</doc>
          <type name="ResourceLookupFlags" c:type="GResourceLookupFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="resources_open_stream" c:identifier="g_resources_open_stream" version="2.32" throws="1">
      <doc xml:space="preserve">Looks for a file at the specified @path in the set of
globally registered resources and returns a #GInputStream
that lets you read the data.

@lookup_flags controls the behaviour of the lookup.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">#GInputStream or %NULL on error.
    Free the returned object with g_object_unref()</doc>
        <type name="InputStream" c:type="GInputStream*"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">A pathname inside the resource</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="lookup_flags" transfer-ownership="none">
          <doc xml:space="preserve">A #GResourceLookupFlags</doc>
          <type name="ResourceLookupFlags" c:type="GResourceLookupFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="resources_register" c:identifier="g_resources_register" version="2.32">
      <doc xml:space="preserve">Registers the resource with the process-global set of resources.
Once a resource is registered the files in it can be accessed
with the global resource lookup functions like g_resources_lookup_data().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="resource" transfer-ownership="none">
          <doc xml:space="preserve">A #GResource</doc>
          <type name="Resource" c:type="GResource*"/>
        </parameter>
      </parameters>
    </function>
    <function name="resources_unregister" c:identifier="g_resources_unregister" version="2.32">
      <doc xml:space="preserve">Unregisters the resource from the process-global set of resources.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="resource" transfer-ownership="none">
          <doc xml:space="preserve">A #GResource</doc>
          <type name="Resource" c:type="GResource*"/>
        </parameter>
      </parameters>
    </function>
    <function name="settings_schema_source_get_default" c:identifier="g_settings_schema_source_get_default" moved-to="SettingsSchemaSource.get_default" version="2.32">
      <doc xml:space="preserve">Gets the default system schema source.

This function is not required for normal uses of #GSettings but it
may be useful to authors of plugin management systems or to those who
want to introspect the content of schemas.

If no schemas are installed, %NULL will be returned.

The returned source may actually consist of multiple schema sources
from different directories, depending on which directories were given
in `XDG_DATA_DIRS` and `GSETTINGS_SCHEMA_DIR`. For this reason, all
lookups performed against the default source should probably be done
recursively.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the default schema source</doc>
        <type name="SettingsSchemaSource" c:type="GSettingsSchemaSource*"/>
      </return-value>
    </function>
    <function name="simple_async_report_error_in_idle" c:identifier="g_simple_async_report_error_in_idle" introspectable="0" deprecated="1" deprecated-version="2.46">
      <doc xml:space="preserve">Reports an error in an asynchronous function in an idle function by
directly setting the contents of the #GAsyncResult with the given error
information.</doc>
      <doc-deprecated xml:space="preserve">Use g_task_report_error().</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a #GObject, or %NULL.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
          <doc xml:space="preserve">a #GAsyncReadyCallback.</doc>
          <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data passed to @callback.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">a #GQuark containing the error domain (usually #G_IO_ERROR).</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="code" transfer-ownership="none">
          <doc xml:space="preserve">a specific error code.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">a formatted error reporting string.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">a list of variables to fill in @format.</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="simple_async_report_gerror_in_idle" c:identifier="g_simple_async_report_gerror_in_idle" deprecated="1" deprecated-version="2.46">
      <doc xml:space="preserve">Reports an error in an idle function. Similar to
g_simple_async_report_error_in_idle(), but takes a #GError rather
than building a new one.</doc>
      <doc-deprecated xml:space="preserve">Use g_task_report_error().</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a #GObject, or %NULL</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
          <doc xml:space="preserve">a #GAsyncReadyCallback.</doc>
          <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data passed to @callback.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">the #GError to report</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
      </parameters>
    </function>
    <function name="simple_async_report_take_gerror_in_idle" c:identifier="g_simple_async_report_take_gerror_in_idle" version="2.28" introspectable="0" deprecated="1" deprecated-version="2.46">
      <doc xml:space="preserve">Reports an error in an idle function. Similar to
g_simple_async_report_gerror_in_idle(), but takes over the caller's
ownership of @error, so the caller does not have to free it any more.</doc>
      <doc-deprecated xml:space="preserve">Use g_task_report_error().</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a #GObject, or %NULL</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
          <doc xml:space="preserve">a #GAsyncReadyCallback.</doc>
          <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data passed to @callback.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">the #GError to report</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
      </parameters>
    </function>
    <function name="srv_target_list_sort" c:identifier="g_srv_target_list_sort" moved-to="SrvTarget.list_sort" version="2.22" introspectable="0">
      <doc xml:space="preserve">Sorts @targets in place according to the algorithm in RFC 2782.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the head of the sorted list.</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="targets" transfer-ownership="none">
          <doc xml:space="preserve">a #GList of #GSrvTarget</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="tls_backend_get_default" c:identifier="g_tls_backend_get_default" moved-to="TlsBackend.get_default" version="2.28">
      <doc xml:space="preserve">Gets the default #GTlsBackend for the system.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a #GTlsBackend</doc>
        <type name="TlsBackend" c:type="GTlsBackend*"/>
      </return-value>
    </function>
    <function name="tls_client_connection_new" c:identifier="g_tls_client_connection_new" moved-to="TlsClientConnection.new" version="2.28" throws="1">
      <doc xml:space="preserve">Creates a new #GTlsClientConnection wrapping @base_io_stream (which
must have pollable input and output streams) which is assumed to
communicate with the server identified by @server_identity.

See the documentation for #GTlsConnection:base-io-stream for restrictions
on when application code can run operations on the @base_io_stream after
this function has returned.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the new
#GTlsClientConnection, or %NULL on error</doc>
        <type name="TlsClientConnection" c:type="GIOStream*"/>
      </return-value>
      <parameters>
        <parameter name="base_io_stream" transfer-ownership="none">
          <doc xml:space="preserve">the #GIOStream to wrap</doc>
          <type name="IOStream" c:type="GIOStream*"/>
        </parameter>
        <parameter name="server_identity" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the expected identity of the server</doc>
          <type name="SocketConnectable" c:type="GSocketConnectable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tls_error_quark" c:identifier="g_tls_error_quark" moved-to="TlsError.quark" version="2.28">
      <doc xml:space="preserve">Gets the TLS error quark.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a #GQuark.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="tls_file_database_new" c:identifier="g_tls_file_database_new" moved-to="TlsFileDatabase.new" version="2.30" throws="1">
      <doc xml:space="preserve">Creates a new #GTlsFileDatabase which uses anchor certificate authorities
in @anchors to verify certificate chains.

The certificates in @anchors must be PEM encoded.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the new
#GTlsFileDatabase, or %NULL on error</doc>
        <type name="TlsFileDatabase" c:type="GTlsDatabase*"/>
      </return-value>
      <parameters>
        <parameter name="anchors" transfer-ownership="none">
          <doc xml:space="preserve">filename of anchor certificate authorities.</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tls_server_connection_new" c:identifier="g_tls_server_connection_new" moved-to="TlsServerConnection.new" version="2.28" throws="1">
      <doc xml:space="preserve">Creates a new #GTlsServerConnection wrapping @base_io_stream (which
must have pollable input and output streams).

See the documentation for #GTlsConnection:base-io-stream for restrictions
on when application code can run operations on the @base_io_stream after
this function has returned.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the new
#GTlsServerConnection, or %NULL on error</doc>
        <type name="TlsServerConnection" c:type="GIOStream*"/>
      </return-value>
      <parameters>
        <parameter name="base_io_stream" transfer-ownership="none">
          <doc xml:space="preserve">the #GIOStream to wrap</doc>
          <type name="IOStream" c:type="GIOStream*"/>
        </parameter>
        <parameter name="certificate" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the default server certificate, or %NULL</doc>
          <type name="TlsCertificate" c:type="GTlsCertificate*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_is_mount_path_system_internal" c:identifier="g_unix_is_mount_path_system_internal">
      <doc xml:space="preserve">Determines if @mount_path is considered an implementation of the
OS. This is primarily used for hiding mountable and mounted volumes
that only are used in the OS and has little to no relevance to the
casual user.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @mount_path is considered an implementation detail
    of the OS.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="mount_path" transfer-ownership="none">
          <doc xml:space="preserve">a mount path, e.g. `/media/disk` or `/usr`</doc>
          <type name="filename" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_is_system_device_path" c:identifier="g_unix_is_system_device_path" version="2.56">
      <doc xml:space="preserve">Determines if @device_path is considered a block device path which is only
used in implementation of the OS. This is primarily used for hiding
mounted volumes that are intended as APIs for programs to read, and system
administrators at a shell; rather than something that should, for example,
appear in a GUI. For example, the Linux `/proc` filesystem.

The list of device paths considered &#x2018;system&#x2019; ones may change over time.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @device_path is considered an implementation detail of
   the OS.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="device_path" transfer-ownership="none">
          <doc xml:space="preserve">a device path, e.g. `/dev/loop0` or `nfsd`</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_is_system_fs_type" c:identifier="g_unix_is_system_fs_type" version="2.56">
      <doc xml:space="preserve">Determines if @fs_type is considered a type of file system which is only
used in implementation of the OS. This is primarily used for hiding
mounted volumes that are intended as APIs for programs to read, and system
administrators at a shell; rather than something that should, for example,
appear in a GUI. For example, the Linux `/proc` filesystem.

The list of file system types considered &#x2018;system&#x2019; ones may change over time.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @fs_type is considered an implementation detail of the OS.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="fs_type" transfer-ownership="none">
          <doc xml:space="preserve">a file system type, e.g. `procfs` or `tmpfs`</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_at" c:identifier="g_unix_mount_at">
      <doc xml:space="preserve">Gets a #GUnixMountEntry for a given mount path. If @time_read
is set, it will be filled with a unix timestamp for checking
if the mounts have changed since with g_unix_mounts_changed_since().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #GUnixMountEntry.</doc>
        <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
      </return-value>
      <parameters>
        <parameter name="mount_path" transfer-ownership="none">
          <doc xml:space="preserve">path for a possible unix mount.</doc>
          <type name="filename" c:type="const char*"/>
        </parameter>
        <parameter name="time_read" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">guint64 to contain a timestamp.</doc>
          <type name="guint64" c:type="guint64*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_compare" c:identifier="g_unix_mount_compare">
      <doc xml:space="preserve">Compares two unix mounts.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">1, 0 or -1 if @mount1 is greater than, equal to,
or less than @mount2, respectively.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="mount1" transfer-ownership="none">
          <doc xml:space="preserve">first #GUnixMountEntry to compare.</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
        <parameter name="mount2" transfer-ownership="none">
          <doc xml:space="preserve">second #GUnixMountEntry to compare.</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_copy" c:identifier="g_unix_mount_copy" version="2.54">
      <doc xml:space="preserve">Makes a copy of @mount_entry.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new #GUnixMountEntry</doc>
        <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
      </return-value>
      <parameters>
        <parameter name="mount_entry" transfer-ownership="none">
          <doc xml:space="preserve">a #GUnixMountEntry.</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_for" c:identifier="g_unix_mount_for" version="2.52">
      <doc xml:space="preserve">Gets a #GUnixMountEntry for a given file path. If @time_read
is set, it will be filled with a unix timestamp for checking
if the mounts have changed since with g_unix_mounts_changed_since().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #GUnixMountEntry.</doc>
        <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
      </return-value>
      <parameters>
        <parameter name="file_path" transfer-ownership="none">
          <doc xml:space="preserve">file path on some unix mount.</doc>
          <type name="filename" c:type="const char*"/>
        </parameter>
        <parameter name="time_read" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">guint64 to contain a timestamp.</doc>
          <type name="guint64" c:type="guint64*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_free" c:identifier="g_unix_mount_free">
      <doc xml:space="preserve">Frees a unix mount.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="mount_entry" transfer-ownership="none">
          <doc xml:space="preserve">a #GUnixMountEntry.</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_get_device_path" c:identifier="g_unix_mount_get_device_path">
      <doc xml:space="preserve">Gets the device path for a unix mount.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a string containing the device path.</doc>
        <type name="filename" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="mount_entry" transfer-ownership="none">
          <doc xml:space="preserve">a #GUnixMount.</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_get_fs_type" c:identifier="g_unix_mount_get_fs_type">
      <doc xml:space="preserve">Gets the filesystem type for the unix mount.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a string containing the file system type.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="mount_entry" transfer-ownership="none">
          <doc xml:space="preserve">a #GUnixMount.</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_get_mount_path" c:identifier="g_unix_mount_get_mount_path">
      <doc xml:space="preserve">Gets the mount path for a unix mount.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the mount path for @mount_entry.</doc>
        <type name="filename" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="mount_entry" transfer-ownership="none">
          <doc xml:space="preserve">input #GUnixMountEntry to get the mount path for.</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_get_options" c:identifier="g_unix_mount_get_options" version="2.58">
      <doc xml:space="preserve">Gets a comma-separated list of mount options for the unix mount. For example,
`rw,relatime,seclabel,data=ordered`.

This is similar to g_unix_mount_point_get_options(), but it takes
a #GUnixMountEntry as an argument.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">a string containing the options, or %NULL if not
available.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="mount_entry" transfer-ownership="none">
          <doc xml:space="preserve">a #GUnixMountEntry.</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_guess_can_eject" c:identifier="g_unix_mount_guess_can_eject">
      <doc xml:space="preserve">Guesses whether a Unix mount can be ejected.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @mount_entry is deemed to be ejectable.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="mount_entry" transfer-ownership="none">
          <doc xml:space="preserve">a #GUnixMountEntry</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_guess_icon" c:identifier="g_unix_mount_guess_icon">
      <doc xml:space="preserve">Guesses the icon of a Unix mount.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #GIcon</doc>
        <type name="Icon" c:type="GIcon*"/>
      </return-value>
      <parameters>
        <parameter name="mount_entry" transfer-ownership="none">
          <doc xml:space="preserve">a #GUnixMountEntry</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_guess_name" c:identifier="g_unix_mount_guess_name">
      <doc xml:space="preserve">Guesses the name of a Unix mount.
The result is a translated string.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A newly allocated string that must
    be freed with g_free()</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="mount_entry" transfer-ownership="none">
          <doc xml:space="preserve">a #GUnixMountEntry</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_guess_should_display" c:identifier="g_unix_mount_guess_should_display">
      <doc xml:space="preserve">Guesses whether a Unix mount should be displayed in the UI.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @mount_entry is deemed to be displayable.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="mount_entry" transfer-ownership="none">
          <doc xml:space="preserve">a #GUnixMountEntry</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_guess_symbolic_icon" c:identifier="g_unix_mount_guess_symbolic_icon" version="2.34">
      <doc xml:space="preserve">Guesses the symbolic icon of a Unix mount.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #GIcon</doc>
        <type name="Icon" c:type="GIcon*"/>
      </return-value>
      <parameters>
        <parameter name="mount_entry" transfer-ownership="none">
          <doc xml:space="preserve">a #GUnixMountEntry</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_is_readonly" c:identifier="g_unix_mount_is_readonly">
      <doc xml:space="preserve">Checks if a unix mount is mounted read only.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @mount_entry is read only.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="mount_entry" transfer-ownership="none">
          <doc xml:space="preserve">a #GUnixMount.</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_is_system_internal" c:identifier="g_unix_mount_is_system_internal">
      <doc xml:space="preserve">Checks if a Unix mount is a system mount. This is the Boolean OR of
g_unix_is_system_fs_type(), g_unix_is_system_device_path() and
g_unix_is_mount_path_system_internal() on @mount_entry&#x2019;s properties.

The definition of what a &#x2018;system&#x2019; mount entry is may change over time as new
file system types and device paths are ignored.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the unix mount is for a system path.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="mount_entry" transfer-ownership="none">
          <doc xml:space="preserve">a #GUnixMount.</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_points_changed_since" c:identifier="g_unix_mount_points_changed_since">
      <doc xml:space="preserve">Checks if the unix mount points have changed since a given unix time.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the mount points have changed since @time.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="time" transfer-ownership="none">
          <doc xml:space="preserve">guint64 to contain a timestamp.</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_points_get" c:identifier="g_unix_mount_points_get">
      <doc xml:space="preserve">Gets a #GList of #GUnixMountPoint containing the unix mount points.
If @time_read is set, it will be filled with the mount timestamp,
allowing for checking if the mounts have changed with
g_unix_mount_points_changed_since().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">
    a #GList of the UNIX mountpoints.</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="UnixMountPoint"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="time_read" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">guint64 to contain a timestamp.</doc>
          <type name="guint64" c:type="guint64*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mounts_changed_since" c:identifier="g_unix_mounts_changed_since">
      <doc xml:space="preserve">Checks if the unix mounts have changed since a given unix time.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the mounts have changed since @time.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="time" transfer-ownership="none">
          <doc xml:space="preserve">guint64 to contain a timestamp.</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mounts_get" c:identifier="g_unix_mounts_get">
      <doc xml:space="preserve">Gets a #GList of #GUnixMountEntry containing the unix mounts.
If @time_read is set, it will be filled with the mount
timestamp, allowing for checking if the mounts have changed
with g_unix_mounts_changed_since().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">
    a #GList of the UNIX mounts.</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="UnixMountEntry"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="time_read" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">guint64 to contain a timestamp, or %NULL</doc>
          <type name="guint64" c:type="guint64*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
